diff --git a/lib/sbi/sbi_hart.c b/lib/sbi/sbi_hart.c
index 770fee0..fa87f0d 100644
--- a/lib/sbi/sbi_hart.c
+++ b/lib/sbi/sbi_hart.c
@@ -26,6 +26,7 @@
 
 extern void __sbi_expected_trap(void);
 extern void __sbi_expected_trap_hext(void);
+extern void ace_setup_this_hart();
 
 void (*sbi_hart_expected_trap)(void) = &__sbi_expected_trap;
 
@@ -369,7 +370,10 @@ static int sbi_hart_smepmp_configure(struct sbi_scratch *scratch,
 	pmp_disable(SBI_SMEPMP_RESV_ENTRY);
 
 	/* Program M-only regions when MML is not set. */
-	pmp_idx = 0;
+	// ACE start
+	// we need first two PMP entries to protect the confidential memory
+	pmp_idx = 2;
+	// ACE end
 	sbi_domain_for_each_memregion(dom, reg) {
 		/* Skip reserved entry */
 		if (pmp_idx == SBI_SMEPMP_RESV_ENTRY)
@@ -432,7 +436,10 @@ static int sbi_hart_oldpmp_configure(struct sbi_scratch *scratch,
 {
 	struct sbi_domain_memregion *reg;
 	struct sbi_domain *dom = sbi_domain_thishart_ptr();
-	unsigned int pmp_idx = 0;
+	// ACE start
+	// we need first two PMP entries to protect the confidential memory
+	unsigned int pmp_idx = 2;
+	// ACE end
 	unsigned int pmp_flags;
 	unsigned long pmp_addr;
 
@@ -523,6 +530,11 @@ int sbi_hart_pmp_configure(struct sbi_scratch *scratch)
 	if (!pmp_count)
 		return 0;
 
+	// ACE START
+	// we need 2 pmps to protect confidential memory region
+	pmp_count = pmp_count - 2;
+	// ACE END
+
 	pmp_log2gran = sbi_hart_pmp_log2gran(scratch);
 	pmp_bits = sbi_hart_pmp_addrbits(scratch) - 1;
 	pmp_addr_max = (1UL << pmp_bits) | ((1UL << pmp_bits) - 1);
@@ -534,6 +546,10 @@ int sbi_hart_pmp_configure(struct sbi_scratch *scratch)
 		rc = sbi_hart_oldpmp_configure(scratch, pmp_count,
 						pmp_log2gran, pmp_addr_max);
 
+	// ACE START
+	// temporal hack to reconfigure after OpenSBI does it.
+	ace_setup_this_hart();
+	// ACE END
 	/*
 	 * As per section 3.7.2 of privileged specification v1.12,
 	 * virtual address translations can be speculatively performed
