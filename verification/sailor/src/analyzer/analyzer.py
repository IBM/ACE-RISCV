# -------------- # -------------- # -------------- # -------------- # -------------- # -------------- # -------------- # -------------- # -------------- #
# ---------------------------- Author: Neelu S. Kalani (neelu.kalani@ibm.com/neelukalani7@gmail.com) --------------------------------------------------- #
# -------------- # -------------- # -------------- # -------------- # -------------- # -------------- # -------------- # -------------- # -------------- #
# ------------------------- This code uses the results of the SailScanner (generated by executing csr_analysis.py) ------------------------------------- #
# -------------- The results are put through a CSR-driven algorithm to generate the context switch code between two given privilege modes -------------- #
# -------------- # -------------- # -------------- # -------------- # -------------- # -------------- # -------------- # -------------- # -------------- #

import os;
import sys; 
#from lexer import *;
import csv; 
from riscv import *;

scanner_results_dir = "/scanner-results/";
analyzer_results_dir = "/analyzer-results/";
arch_scanner_results_dir = "";
arch_analyzer_results_dir = "";

arch_module = "";
arch_name = "";
results_dir = "";

SOURCE_MODE = "U";
TARGET_MODE = "S";

# -------------------------------------------------------- Input from the scanner for the analyzer------------------------------------------------------ #

instruction_CSR_footprint = {};

instruction_execution_access = [{}, {}, {}, {}, {}];

CSR_read_access = [{}, {}, {}, {}, {}];

CSR_write_access = [{}, {}, {}, {}, {}];

next_csr_list = ["ustatus", "uie", "utvec", "uscratch", "uepc", "ucause", "utval", "uip"];


# ----------------------------------------------- CSR-Driven Security Domain Switch Algorithm ---------------------------------------------------------- #

def switch_security_domain(source_mode, target_mode): 
   source_mode_id = SUPPORTED_MODES.index(source_mode);
   target_mode_id = SUPPORTED_MODES.index(target_mode);

   csr_swap_list = [];  
   csr_do_nothing_list = [];

   # The following is only for RISC-V 
   # if source_mode_id == 2 or target_mode_id == 2: 
   #    print("Error: Attempt to switch on the reserved mode!");
   #    exit(0);

   for csr in ctrl_reg_names: 
      csr_swap = False;
      source_affects = False;
      source_is_dependent = False;
      csr_name = "";
      if "[" in csr: 
         csr_name = csr.split("[")[0];
      else: 
         csr_name = csr;

      if csr_name not in CSR_write_access[source_mode_id].keys() or csr_name not in CSR_read_access[source_mode_id].keys():
         print("CSR Read/Write access information is missing for source mode: "+csr_name);
         continue;

      if csr_name not in CSR_write_access[target_mode_id].keys() or csr_name not in CSR_read_access[target_mode_id].keys():
         print("CSR Read/Write access information is missing for target mode: "+csr_name);
         continue;

      # We assume NExt extension to be disabled: so we will remove ustatus, uie, utvec, uscratch, uepc, ucause, utval, uip 
      if csr_name in next_csr_list:
         continue;

      if CSR_write_access[source_mode_id][csr_name] == "True": 
         # Source mode can directly write the CSR using CSR operation instructions. 
         source_affects = True;
      if source_affects == False: 
         # Source mode cannot directly write the CSR using CSR operation instructions.
         # But need to check if execution in Source mode can indirectly affect/modify the content of the CSR. 
         # E.g. Source mode can execute floating point instructions which will lead to mstatus.FS bits being set to dirty. If it is not cleared, then Target mode can read that and infer that the floating point unit was used. 
         for instr in instruction_CSR_footprint.keys():
            # TODO: Checking 'csr' itself in the list as there are some csr uses where the scanner doesn't detect if the use was a Read/Write. 
            # Until that is resolved in the scanner, we assume the use to be R+W.  
            if csr in instruction_CSR_footprint[instr] or csr+" Write" in instruction_CSR_footprint[instr] or csr+" R+W" in instruction_CSR_footprint[instr]: 
            #if csr+" Write" in instruction_CSR_footprint[instr] or csr+" R+W" in instruction_CSR_footprint[instr]: 
               if "TRUE" in instruction_execution_access[source_mode_id][instr] or "Default" in instruction_execution_access[source_mode_id][instr]: 
                  # Source mode can indirectly modify the content of the CSR during execution
                  if csr_name == "misa": 
                     print("Instr: "+instr+" affects "+csr);
                  source_affects = True; 
                  break; 
      if source_affects == False: 
         # We want to check if execution in Source mode is dependent on the content of the CSR.
         # That would mean this CSR could contain some sentisitive information about the security domain we are switching from.
         for instr in instruction_CSR_footprint.keys():
               # TODO: Checking 'csr' itself in the list as there are some csr uses where the scanner doesn't detect if the use was a Read/Write. 
               # Until that is resolved in the scanner, we assume the use to be R+W.  
               if csr in instruction_CSR_footprint[instr] or csr+" Read" in instruction_CSR_footprint[instr] or csr+" R+W" in instruction_CSR_footprint[instr] or csr_name in instruction_CSR_footprint[instr] or csr_name+" Read" in instruction_CSR_footprint[instr] or csr_name+" R+W" in instruction_CSR_footprint[instr]: 
                  if csr == "satp": 
                     print("Instr "+instr+" can read satp! Here is the instr_exec_acc for Source: "+instruction_execution_access[source_mode_id][instr]);
                  if "TRUE" in instruction_execution_access[source_mode_id][instr] or "Default" in instruction_execution_access[source_mode_id][instr]: 
                     source_is_dependent = True;
                     break; 

      #if csr_name == "scause": 
         #print("For scause: source is dependent on "+csr+": "+str(source_is_dependent)+" and source affects "+csr+": "+str(source_affects));

      # If source affects the value of the CSR directly or indirectly OR if execution in source mode is dependent on the content of CSR
      if source_affects == True or source_is_dependent == True: 
         if CSR_read_access[target_mode_id][csr_name] == "True": 
            # Target mode can directly read the CSR using CSR operation instructions.
            # Direct side channel 
            # Must swap and restore! 
            csr_swap_list.append(csr);
            csr_swap = True; 
            #if csr_name == "scause":
               #print("Target can read scause");
         # Need to do this for all subset/superset type of CSRs! 
         # TODO: Should only be done for specific fields though!!! 
         #elif csr_name == "mstatus" and CSR_read_access[target_mode_id]["sstatus"]:
         #   csr_swap_list.append(csr);
         #   csr_swap = True; 
         elif source_affects == True: 
            # Target mode cannot directly read the CSR using CSR operation instructions. 
            # But since Source mode can still write this CSR, we want to check if Target mode is dependent on the content of the CSR. 
            # E.g. Source mode can switch off the Floating point extension, and if Target mode tries to use it, an exception will occur - which becomes a side-channel for the Source mode to observe. 
            for instr in instruction_CSR_footprint.keys():
               # TODO: Checking 'csr' itself in the list as there are some csr uses where the scanner doesn't detect if the use was a Read/Write. 
               # Until that is resolved in the scanner, we assume the use to be R+W.  
               #if csr_name == "sedeleg" and instr == "LOAD": 
                  #print("Checking condition for sedeleg Read in LOAD's CSR footprint.");
                  #print(instruction_CSR_footprint[instr]);
               if csr in instruction_CSR_footprint[instr] or csr+" Read" in instruction_CSR_footprint[instr] or csr+" R+W" in instruction_CSR_footprint[instr] or csr_name in instruction_CSR_footprint[instr] or csr_name+" Read" in instruction_CSR_footprint[instr] or csr_name+" R+W" in instruction_CSR_footprint[instr]: 
                  #if csr_name == "sedeleg" and instr == "LOAD": 
                  #   print("Found sedeleg Read in LOAD's CSR footprint.");
                  if "TRUE" in instruction_execution_access[target_mode_id][instr] or "Default" in instruction_execution_access[target_mode_id][instr]: 
                    # if csr_name == "sedeleg" and instr == "LOAD": 
                    #    print("Found Target mode execution true for LOAD. (sedeleg Read)");
                    # if csr_name == "scause":
                    #    print("Target can be affected by scause");
                     csr_swap_list.append(csr);
                     csr_swap = True; 
                     break; 

      # If no need to swap then do nothing.
      # If source_affects_or_is_dependent == False, csr_swap will def be false, so we don't need an explicit check for that.
      if csr_swap == False:
         csr_do_nothing_list.append(csr);
         

   # A little post-processing 
   # For now we consider VS and XS to have the same action as FS (since we were not able to retrieve the ext_write_vcsr footprint in the analysis).
   # TODO: This should be fixed in Sailor Scanner. 
   if "mstatus[FS]" in csr_swap_list:
      if "mstatus[VS]" not in csr_swap_list: 
         csr_swap_list.append("mstatus[VS]");
         csr_do_nothing_list.remove("mstatus[VS]");
      if "mstatus[XS]" not in csr_swap_list: 
         csr_swap_list.append("mstatus[XS]");
         csr_do_nothing_list.remove("mstatus[XS]");

   if "sstatus[FS]" in csr_swap_list:
      if "sstatus[VS]" not in csr_swap_list: 
         csr_swap_list.append("sstatus[VS]");
         csr_do_nothing_list.remove("sstatus[VS]");
      if "sstatus[XS]" not in csr_swap_list: 
         csr_swap_list.append("sstatus[XS]");
         csr_do_nothing_list.remove("sstatus[XS]");

   # Next: We need to implement equivalence of mstatus and sstatus, sie and mie, sip and mip. 
   # TODO: Question: At what stage should this be? 

   for csr in csr_swap_list: 
      csr_name = "";
      if "[" in csr: 
         csr_name = csr.split("[")[0];
      else: 
         csr_name = csr;
   
      if csr_name == "mstatus" or csr_name == "mie" or csr_name == "mip": 
         smode_csr = "s" + csr[1:];
         if smode_csr in csr_do_nothing_list:
            csr_do_nothing_list.remove(smode_csr);
            csr_swap_list.append(smode_csr);  
      elif csr_name == "sstatus" or csr_name == "sie" or csr_name == "sip":  
         mmode_csr = "m" + csr[1:];
         if mmode_csr in csr_do_nothing_list:
            csr_do_nothing_list.remove(mmode_csr);
            csr_swap_list.append(mmode_csr);  
   

   print("For security domain switch from "+source_mode+"-mode to "+target_mode+"-mode:");
   print("\n***** Following CSRs are Security Sensitive: *****\n");
   #print(sorted(csr_swap_list));
   print(csr_swap_list);
   print("\n***** Following CSRs are NOT Security Sensitive: *****\n");
   #print(sorted(csr_do_nothing_list));
   print(csr_do_nothing_list);

   csv_output_file = open(arch_analyzer_results_dir+"switch-from-"+SOURCE_MODE+"-to-"+TARGET_MODE+".csv", "w", newline="");
   csv_writer = csv.writer(csv_output_file);

   csv_writer.writerow(["Security Sensitive","Not Security Sensitive"]);

   max_len = max(len(csr_swap_list),len(csr_do_nothing_list));

   for i in range(max_len): 
      row = [csr_swap_list[i] if i < len(csr_swap_list) else "", csr_do_nothing_list[i] if i < len(csr_do_nothing_list) else ""];
      csv_writer.writerow(row);

   csv_output_file.close();


def main(argv_arch, argv_results_dir):
   global arch_module;
   global arch_scanner_results_dir;
   global arch_analyzer_results_dir;
   global results_dir;
   global arch_name;
   global SOURCE_MODE;
   global TARGET_MODE;

   global instruction_CSR_footprint;
   global instruction_execution_access;
   global CSR_read_access;
   global CSR_write_access;


   #  if len(sys.argv) != 4: 
   #      print("Please provide architecture as command line argument.");
   #      exit(0);

   #  arch_module_name = "";
   #  if sys.argv[1] == "riscv64":
   #      arch_module_name = "riscv";
   #  elif sys.argv[1] == "riscv64-hext":
   #      arch_module_name = "riscv_h";
   #  elif sys.argv[1] == "arm":
   #      arch_module_name = "arm";

   #  try:
   #      arch_module = import_module(arch_module_name);
   #  except ImportError:
   #      print(f"Unsupported architecture: {sys.argv[1]}");
   #      exit(0);    
   
   results_dir = argv_results_dir;
   arch_name = argv_arch;
   arch_scanner_results_dir = results_dir + scanner_results_dir + argv_arch + "/";
   arch_analyzer_results_dir = results_dir + analyzer_results_dir + argv_arch + "/";

   os.popen('mkdir -p '+results_dir+'/analyzer-results');
   os.popen('mkdir -p '+results_dir+'/analyzer-results/'+arch_name);
   #  arch_scanner_results_dir = scanner_results_dir+"/"+arch_module_name+"/";
   #  arch_analyzer_results_dir = analyzer_results_dir+"/"+arch_module_name+"/";

   # if len(sys.argv) != 3: 
   #    print("Please provide source and target privilege modes for security domain switch as command line arguments. E.g. python3 security_domain_switch.py U S");
   #    exit(0); 

   # SOURCE_MODE = sys.argv[1];

   if SOURCE_MODE not in SUPPORTED_MODES: 
      print("We do not support analysis for this source mode! Following modes are supported: ");
      print(SUPPORTED_MODES);
      exit(0);

   # TARGET_MODE = sys.argv[2];

   if TARGET_MODE not in SUPPORTED_MODES: 
      print("We do not support analysis for this target mode! Following modes are supported: ");
      print(SUPPORTED_MODES);
      exit(0);

# ----------------------------------------------------- Populating input from the CSVs ----------------------------------------------------------------- #    

   with open(arch_scanner_results_dir+'csr-footprint-per-instruction.csv', mode ='r') as infile:
   #with open(arch_scanner_results_dir+'csr-footprint-per-instruction-plex-scanner.csv', mode='r') as infile:
      reader = csv.reader(infile)
      for row in reader:
         key = row[0];
         values = row[1:len(row)-1];
         while '' in values:
               values.remove('');
         while ' ' in values: 
               values.remove(' ');
         instruction_CSR_footprint[key] = values;

   print('file name: '+arch_scanner_results_dir+'priv-levels-instruction-execution-annotated.csv');

   with open(arch_scanner_results_dir+'priv-levels-instruction-execution-annotated.csv', mode='r') as infile:
      reader = csv.reader(infile)
      for row in reader:
         key = row[0];
         #Preprocessing of key.... 
         #key.replace(' ','');
         if key.count('(') > 1: 
               #print("Splitting 1...")
               key = key.split("(")[1].replace(" ","");
         else: 
               #print("Splitting 2...")
               key = key.split("(")[0].replace(" ","");

         if key == "Instruction" or key == "WFI" or key == "VSETVLI":   # TODO: Check why there's no CSR footprint for VSETVLI  
               continue;

         if key not in instruction_CSR_footprint.keys():
               print("key not in CSR_footprint.keys(): "+key);
               exit(0);

         print(key);        

         # This only works for RV64! 
         instruction_execution_access[0][key] = row[1];
         instruction_execution_access[1][key] = row[2];
         instruction_execution_access[3][key] = row[3];
         
         # TODO: This works for RV64 with H-ext! 
         # instruction_execution_access[0][key] = row[1];
         # instruction_execution_access[1][key] = row[2];
         # instruction_execution_access[2][key] = row[3];
         # instruction_execution_access[3][key] = row[4];
         # instruction_execution_access[4][key] = row[5];

   with open(arch_scanner_results_dir+'priv-levels-csr-access.csv', mode='r') as infile: 
      reader = csv.reader(infile)
      for row in reader:
         key = row[0];
         if key == "CSR":
               continue;

         # TODO: This works for RV64 with H-ext! 
         # CSR_read_access[0][key] = row[1];
         # CSR_write_access[0][key] = row[2];
         # CSR_read_access[1][key] = row[3];
         # CSR_write_access[1][key] = row[4];
         # CSR_read_access[2][key] = row[5];
         # CSR_write_access[2][key] = row[6];
         # CSR_read_access[3][key] = row[7];
         # CSR_write_access[3][key] = row[8];
         # CSR_read_access[4][key] = row[9];
         # CSR_write_access[4][key] = row[10];

         # This only works for RV64! 
         CSR_read_access[0][key] = row[1];
         CSR_write_access[0][key] = row[2];
         CSR_read_access[1][key] = row[3];
         CSR_write_access[1][key] = row[4];
         CSR_read_access[3][key] = row[5];
         CSR_write_access[3][key] = row[6];

   """ print(CSR_footprint);
   print(user_mode_access);
   print(supervisor_mode_access);
   print(machine_mode_access);

   print(user_csr_read_access);
   print(user_csr_write_access);
   print(supervisor_csr_read_access);
   print(supervisor_csr_write_access);
   print(machine_csr_read_access);
   print(machine_csr_write_access); """

   switch_security_domain(SOURCE_MODE, TARGET_MODE);


