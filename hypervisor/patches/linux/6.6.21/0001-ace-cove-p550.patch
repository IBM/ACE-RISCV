diff --git a/Documentation/devicetree/bindings/interrupt-controller/riscv,aplic.yaml b/Documentation/devicetree/bindings/interrupt-controller/riscv,aplic.yaml
new file mode 100644
index 000000000000..b7f20aad72c2
--- /dev/null
+++ b/Documentation/devicetree/bindings/interrupt-controller/riscv,aplic.yaml
@@ -0,0 +1,159 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/interrupt-controller/riscv,aplic.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: RISC-V Advanced Platform Level Interrupt Controller (APLIC)
+
+maintainers:
+  - Anup Patel <anup@brainfault.org>
+
+description:
+  The RISC-V advanced interrupt architecture (AIA) defines an advanced
+  platform level interrupt controller (APLIC) for handling wired interrupts
+  in a RISC-V platform. The RISC-V AIA specification can be found at
+  https://github.com/riscv/riscv-aia.
+
+  The RISC-V APLIC is implemented as hierarchical APLIC domains where all
+  interrupt sources connect to the root domain which can further delegate
+  interrupts to child domains. There is one device tree node for each APLIC
+  domain.
+
+allOf:
+  - $ref: /schemas/interrupt-controller.yaml#
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - riscv,qemu-aplic
+      - const: riscv,aplic
+
+  reg:
+    maxItems: 1
+
+  interrupt-controller: true
+
+  "#interrupt-cells":
+    const: 2
+
+  interrupts-extended:
+    minItems: 1
+    maxItems: 16384
+    description:
+      Given APLIC domain directly injects external interrupts to a set of
+      RISC-V HARTS (or CPUs). Each node pointed to should be a riscv,cpu-intc
+      node, which has a riscv node (i.e. RISC-V HART) as parent.
+
+  msi-parent:
+    description:
+      Given APLIC domain forwards wired interrupts as MSIs to a AIA incoming
+      message signaled interrupt controller (IMSIC). This property should be
+      considered only when the interrupts-extended property is absent.
+
+  riscv,num-sources:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 1
+    maximum: 1023
+    description:
+      Specifies how many wired interrupts are supported by this APLIC domain.
+
+  riscv,children:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    minItems: 1
+    maxItems: 1024
+    items:
+      maxItems: 1
+    description:
+      A list of child APLIC domains for the given APLIC domain. Each child
+      APLIC domain is assigned child index in increasing order with the
+      first child APLIC domain assigned child index 0. The APLIC domain
+      child index is used by firmware to delegate interrupts from the
+      given APLIC domain to a particular child APLIC domain.
+
+  riscv,delegate:
+    $ref: /schemas/types.yaml#/definitions/phandle-array
+    minItems: 1
+    maxItems: 1024
+    items:
+      items:
+        - description: child APLIC domain phandle
+        - description: first interrupt number (inclusive)
+        - description: last interrupt number (inclusive)
+    description:
+      A interrupt delegation list where each entry is a triple consisting
+      of child APLIC domain phandle, first interrupt number, and last
+      interrupt number. The firmware will configure interrupt delegation
+      registers based on interrupt delegation list.
+
+required:
+  - compatible
+  - reg
+  - interrupt-controller
+  - "#interrupt-cells"
+  - riscv,num-sources
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    // Example 1 (APLIC domains directly injecting interrupt to HARTs):
+
+    aplic0: interrupt-controller@c000000 {
+      compatible = "riscv,qemu-aplic", "riscv,aplic";
+      interrupts-extended = <&cpu1_intc 11>,
+                            <&cpu2_intc 11>,
+                            <&cpu3_intc 11>,
+                            <&cpu4_intc 11>;
+      reg = <0xc000000 0x4080>;
+      interrupt-controller;
+      #interrupt-cells = <2>;
+      riscv,num-sources = <63>;
+      riscv,children = <&aplic1>, <&aplic2>;
+      riscv,delegate = <&aplic1 1 63>;
+    };
+
+    aplic1: interrupt-controller@d000000 {
+      compatible = "riscv,qemu-aplic", "riscv,aplic";
+      interrupts-extended = <&cpu1_intc 9>,
+                            <&cpu2_intc 9>;
+      reg = <0xd000000 0x4080>;
+      interrupt-controller;
+      #interrupt-cells = <2>;
+      riscv,num-sources = <63>;
+    };
+
+    aplic2: interrupt-controller@e000000 {
+      compatible = "riscv,qemu-aplic", "riscv,aplic";
+      interrupts-extended = <&cpu3_intc 9>,
+                            <&cpu4_intc 9>;
+      reg = <0xe000000 0x4080>;
+      interrupt-controller;
+      #interrupt-cells = <2>;
+      riscv,num-sources = <63>;
+    };
+
+  - |
+    // Example 2 (APLIC domains forwarding interrupts as MSIs):
+
+    aplic3: interrupt-controller@c000000 {
+      compatible = "riscv,qemu-aplic", "riscv,aplic";
+      msi-parent = <&imsic_mlevel>;
+      reg = <0xc000000 0x4000>;
+      interrupt-controller;
+      #interrupt-cells = <2>;
+      riscv,num-sources = <63>;
+      riscv,children = <&aplic4>;
+      riscv,delegate = <&aplic4 1 63>;
+    };
+
+    aplic4: interrupt-controller@d000000 {
+      compatible = "riscv,qemu-aplic", "riscv,aplic";
+      msi-parent = <&imsic_slevel>;
+      reg = <0xd000000 0x4000>;
+      interrupt-controller;
+      #interrupt-cells = <2>;
+      riscv,num-sources = <63>;
+    };
+...
diff --git a/Documentation/devicetree/bindings/interrupt-controller/riscv,imsics.yaml b/Documentation/devicetree/bindings/interrupt-controller/riscv,imsics.yaml
new file mode 100644
index 000000000000..b9db03b6e95f
--- /dev/null
+++ b/Documentation/devicetree/bindings/interrupt-controller/riscv,imsics.yaml
@@ -0,0 +1,168 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/interrupt-controller/riscv,imsics.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: RISC-V Incoming MSI Controller (IMSIC)
+
+maintainers:
+  - Anup Patel <anup@brainfault.org>
+
+description: |
+  The RISC-V advanced interrupt architecture (AIA) defines a per-CPU incoming
+  MSI controller (IMSIC) for handling MSIs in a RISC-V platform. The RISC-V
+  AIA specification can be found at https://github.com/riscv/riscv-aia.
+
+  The IMSIC is a per-CPU (or per-HART) device with separate interrupt file
+  for each privilege level (machine or supervisor). The configuration of
+  a IMSIC interrupt file is done using AIA CSRs and it also has a 4KB MMIO
+  space to receive MSIs from devices. Each IMSIC interrupt file supports a
+  fixed number of interrupt identities (to distinguish MSIs from devices)
+  which is same for given privilege level across CPUs (or HARTs).
+
+  The device tree of a RISC-V platform will have one IMSIC device tree node
+  for each privilege level (machine or supervisor) which collectively describe
+  IMSIC interrupt files at that privilege level across CPUs (or HARTs).
+
+  The arrangement of IMSIC interrupt files in MMIO space of a RISC-V platform
+  follows a particular scheme defined by the RISC-V AIA specification. A IMSIC
+  group is a set of IMSIC interrupt files co-located in MMIO space and we can
+  have multiple IMSIC groups (i.e. clusters, sockets, chiplets, etc) in a
+  RISC-V platform. The MSI target address of a IMSIC interrupt file at given
+  privilege level (machine or supervisor) encodes group index, HART index,
+  and guest index (shown below).
+
+  XLEN-1           >=24                                 12    0
+  |                  |                                  |     |
+  -------------------------------------------------------------
+  |xxxxxx|Group Index|xxxxxxxxxxx|HART Index|Guest Index|  0  |
+  -------------------------------------------------------------
+
+allOf:
+  - $ref: /schemas/interrupt-controller.yaml#
+  - $ref: /schemas/interrupt-controller/msi-controller.yaml#
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - riscv,qemu-imsics
+      - const: riscv,imsics
+
+  reg:
+    minItems: 1
+    maxItems: 16384
+    description:
+      Base address of each IMSIC group.
+
+  interrupt-controller: true
+
+  "#interrupt-cells":
+    const: 0
+
+  msi-controller: true
+
+  interrupts-extended:
+    minItems: 1
+    maxItems: 16384
+    description:
+      This property represents the set of CPUs (or HARTs) for which given
+      device tree node describes the IMSIC interrupt files. Each node pointed
+      to should be a riscv,cpu-intc node, which has a riscv node (i.e. RISC-V
+      HART) as parent.
+
+  riscv,num-ids:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 63
+    maximum: 2047
+    description:
+      Number of interrupt identities supported by IMSIC interrupt file.
+
+  riscv,num-guest-ids:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 63
+    maximum: 2047
+    description:
+      Number of interrupt identities are supported by IMSIC guest interrupt
+      file. When not specified it is assumed to be same as specified by the
+      riscv,num-ids property.
+
+  riscv,guest-index-bits:
+    minimum: 0
+    maximum: 7
+    default: 0
+    description:
+      Number of guest index bits in the MSI target address. When not
+      specified it is assumed to be 0.
+
+  riscv,hart-index-bits:
+    minimum: 0
+    maximum: 15
+    description:
+      Number of HART index bits in the MSI target address. When not
+      specified it is estimated based on the interrupts-extended property.
+
+  riscv,group-index-bits:
+    minimum: 0
+    maximum: 7
+    default: 0
+    description:
+      Number of group index bits in the MSI target address. When not
+      specified it is assumed to be 0.
+
+  riscv,group-index-shift:
+    $ref: /schemas/types.yaml#/definitions/uint32
+    minimum: 0
+    maximum: 55
+    default: 24
+    description:
+      The least significant bit position of the group index bits in the
+      MSI target address. When not specified it is assumed to be 24.
+
+required:
+  - compatible
+  - reg
+  - interrupt-controller
+  - msi-controller
+  - interrupts-extended
+  - riscv,num-ids
+
+unevaluatedProperties: false
+
+examples:
+  - |
+    // Example 1 (Machine-level IMSIC files with just one group):
+
+    imsic_mlevel: interrupt-controller@24000000 {
+      compatible = "riscv,qemu-imsics", "riscv,imsics";
+      interrupts-extended = <&cpu1_intc 11>,
+                            <&cpu2_intc 11>,
+                            <&cpu3_intc 11>,
+                            <&cpu4_intc 11>;
+      reg = <0x28000000 0x4000>;
+      interrupt-controller;
+      #interrupt-cells = <0>;
+      msi-controller;
+      riscv,num-ids = <127>;
+    };
+
+  - |
+    // Example 2 (Supervisor-level IMSIC files with two groups):
+
+    imsic_slevel: interrupt-controller@28000000 {
+      compatible = "riscv,qemu-imsics", "riscv,imsics";
+      interrupts-extended = <&cpu1_intc 9>,
+                            <&cpu2_intc 9>,
+                            <&cpu3_intc 9>,
+                            <&cpu4_intc 9>;
+      reg = <0x28000000 0x2000>, /* Group0 IMSICs */
+            <0x29000000 0x2000>; /* Group1 IMSICs */
+      interrupt-controller;
+      #interrupt-cells = <0>;
+      msi-controller;
+      riscv,num-ids = <127>;
+      riscv,group-index-bits = <1>;
+      riscv,group-index-shift = <24>;
+    };
+...
diff --git a/arch/riscv/Kbuild b/arch/riscv/Kbuild
index d25ad1c19f88..1570cabe4141 100644
--- a/arch/riscv/Kbuild
+++ b/arch/riscv/Kbuild
@@ -1,5 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-only
 
+obj-$(CONFIG_RISCV_COVE_GUEST) += cove/
+
 obj-y += kernel/ mm/ net/
 obj-$(CONFIG_BUILTIN_DTB) += boot/dts/
 obj-y += errata/
diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
index c785a0200573..8b3e90cec091 100644
--- a/arch/riscv/Kconfig
+++ b/arch/riscv/Kconfig
@@ -14,7 +14,7 @@ config RISCV
 	def_bool y
 	select ACPI_GENERIC_GSI if ACPI
 	select ACPI_REDUCED_HARDWARE_ONLY if ACPI
-	select ARCH_DMA_DEFAULT_COHERENT
+	select ARCH_DMA_DEFAULT_COHERENT if !SOC_SIFIVE_EIC7700
 	select ARCH_ENABLE_HUGEPAGE_MIGRATION if HUGETLB_PAGE && MIGRATION
 	select ARCH_ENABLE_SPLIT_PMD_PTLOCK if PGTABLE_LEVELS > 2
 	select ARCH_ENABLE_THP_MIGRATION if TRANSPARENT_HUGEPAGE
@@ -36,9 +36,11 @@ config RISCV
 	select ARCH_HAS_STRICT_KERNEL_RWX if MMU && !XIP_KERNEL
 	select ARCH_HAS_STRICT_MODULE_RWX if MMU && !XIP_KERNEL
 	select ARCH_HAS_SYSCALL_WRAPPER
+	select ARCH_HAS_TEARDOWN_DMA_OPS if IOMMU_SUPPORT && SOC_SIFIVE_EIC7700
 	select ARCH_HAS_TICK_BROADCAST if GENERIC_CLOCKEVENTS_BROADCAST
 	select ARCH_HAS_UBSAN_SANITIZE_ALL
 	select ARCH_HAS_VDSO_DATA
+	select ARCH_KEEP_MEMBLOCK
 	select ARCH_OPTIONAL_KERNEL_RWX if ARCH_HAS_STRICT_KERNEL_RWX
 	select ARCH_OPTIONAL_KERNEL_RWX_DEFAULT
 	select ARCH_STACKWALK
@@ -64,6 +66,7 @@ config RISCV
 	select CLONE_BACKWARDS
 	select COMMON_CLK
 	select CPU_PM if CPU_IDLE || HIBERNATION
+	select DMA_DIRECT_REMAP if SOC_SIFIVE_EIC7700
 	select EDAC_SUPPORT
 	select FRAME_POINTER if PERF_EVENTS || (FUNCTION_TRACER && !DYNAMIC_FTRACE)
 	select GENERIC_ARCH_TOPOLOGY
@@ -141,6 +144,7 @@ config RISCV
 	select HAVE_STACKPROTECTOR
 	select HAVE_SYSCALL_TRACEPOINTS
 	select HOTPLUG_CORE_SYNC_DEAD if HOTPLUG_CPU
+	select IOMMU_DMA if IOMMU_SUPPORT && SOC_SIFIVE_EIC7700
 	select IRQ_DOMAIN
 	select IRQ_FORCED_THREADING
 	select KASAN_VMALLOC if KASAN
@@ -153,6 +157,8 @@ config RISCV
 	select PCI_DOMAINS_GENERIC if PCI
 	select PCI_MSI if PCI
 	select RISCV_ALTERNATIVE if !XIP_KERNEL
+	select RISCV_APLIC
+	select RISCV_IMSIC
 	select RISCV_INTC
 	select RISCV_TIMER if RISCV_SBI
 	select SIFIVE_PLIC
@@ -190,6 +196,11 @@ config ARCH_MMAP_RND_BITS_MAX
 config ARCH_MMAP_RND_COMPAT_BITS_MAX
 	default 17
 
+config RISCV_MEM_ENCRYPT
+	select ARCH_HAS_MEM_ENCRYPT
+	select ARCH_HAS_FORCE_DMA_UNENCRYPTED
+	def_bool n
+
 # set if we run in machine mode, cleared if we run in supervisor mode
 config RISCV_M_MODE
 	bool
@@ -268,12 +279,77 @@ config LOCKDEP_SUPPORT
 
 config RISCV_DMA_NONCOHERENT
 	bool
+	select ARCH_HAS_DMA_CLEAR_UNCACHED if SOC_SIFIVE_EIC7700
 	select ARCH_HAS_DMA_PREP_COHERENT
+	select ARCH_HAS_DMA_SET_UNCACHED if SOC_SIFIVE_EIC7700
 	select ARCH_HAS_SETUP_DMA_OPS
 	select ARCH_HAS_SYNC_DMA_FOR_CPU
 	select ARCH_HAS_SYNC_DMA_FOR_DEVICE
 	select DMA_BOUNCE_UNALIGNED_KMALLOC if SWIOTLB
 
+config RISCV_DIE0_CACHED_OFFSET
+	hex "DIE0 memory port addr of U84"
+	depends on RISCV && ARCH_HAS_DMA_SET_UNCACHED
+	default 0x80000000
+	help
+	  Access to DDR memory through U84 memory port is cached.
+
+config RISCV_DIE0_MEM_MAX_SIZE
+	hex "DIE0 memory size, default 32GB"
+	depends on RISCV && ARCH_HAS_DMA_SET_UNCACHED
+	default 0x800000000
+
+config RISCV_DIE0_UNCACHED_OFFSET
+	hex "DIE0 system port addr of U84"
+	depends on RISCV && ARCH_HAS_DMA_SET_UNCACHED
+	default 0xc000000000
+	help
+	  Access to DDR memory through U84 system port is uncached.
+	  Add this offset when allocating  memory from memory port(0x80000000~),
+	  then memremap to virtual address.
+
+config RISCV_DIE1_CACHED_OFFSET
+	hex "DIE1 memory port addr of U84"
+	depends on RISCV && ARCH_HAS_DMA_SET_UNCACHED
+	default 0x2000000000
+	help
+	  Access to DIE1 DDR memory through U84 memory port is cached.
+
+config RISCV_DIE1_MEM_MAX_SIZE
+	hex "DIE1 memory size, default 32GB"
+	depends on RISCV && ARCH_HAS_DMA_SET_UNCACHED
+	default 0x800000000
+
+config RISCV_DIE1_UNCACHED_OFFSET
+	hex "DIE1 system port addr of U84"
+	depends on RISCV && ARCH_HAS_DMA_SET_UNCACHED
+	default 0xe000000000
+	help
+	  Access to DIE1 DDR memory through U84 system port is uncached.
+	  Add this offset when allocating  memory from memory port(0x2000000000~),
+	  then memremap to virtual address.
+
+config RISCV_INTERLEAVE_CACHED_OFFSET
+	hex "memory port addr of interleave"
+	depends on RISCV && ARCH_HAS_DMA_SET_UNCACHED
+	default 0x4000000000
+	help
+	  Access to DDR memory through U84 memory port with interleave is cached.
+
+config RISCV_INTERLEAVE_MEM_MAX_SIZE
+	hex "Interleaving memory size, default 64GB"
+	depends on RISCV && ARCH_HAS_DMA_SET_UNCACHED
+	default 0x1000000000
+
+config RISCV_INTERLEAVE_UNCACHED_OFFSET
+	hex "system port addr of interleave"
+	depends on RISCV && ARCH_HAS_DMA_SET_UNCACHED
+	default 0x10000000000
+	help
+	  Access to DDR memory through U84 system port with interleave is uncached.
+	  Add this offset when allocating  memory from memory port(0x4000000000~),
+	  then memremap to virtual address.
+
 config RISCV_NONSTANDARD_CACHE_OPS
 	bool
 	help
@@ -328,7 +404,7 @@ config ARCH_RV64I
 	bool "RV64I"
 	select 64BIT
 	select ARCH_SUPPORTS_INT128 if CC_HAS_INT128
-	select SWIOTLB if MMU
+	select SWIOTLB if MMU && !SOC_SIFIVE_EIC7700
 
 endchoice
 
@@ -633,6 +709,42 @@ config THREAD_SIZE_ORDER
 	help
 	  Specify the Pages of thread stack size (from 4KB to 64KB), which also
 	  affects irq stack size, which is equal to thread stack size.
+menu "Confidential VM Extension(CoVE) Support"
+
+config RISCV_COVE_HOST
+	bool "Host(KVM) support for Confidential VM Extension(CoVE)"
+	depends on KVM
+	default n
+	help
+            Enable this if the platform supports confidential vm extension.
+	    That means the platform should be capable of running TEE VM (TVM)
+	    using KVM and TEE Security Manager (TSM).
+
+config RISCV_COVE_GUEST
+	bool "Guest Support for Confidential VM Extension(CoVE)"
+	default n
+	select SWIOTLB
+	select RISCV_MEM_ENCRYPT
+	select ARCH_HAS_CC_PLATFORM
+	help
+	  Enables support for running TVMs on platforms supporting CoVE.
+
+config RISCV_COVE_GUEST_EMBEDDED_TAP
+	bool "Guest Support for embedded TVM Attestation Payload (TAP)"
+	default n
+	select RISCV_COVE_GUEST
+	help
+	   Creates placeholder in the kernel image to embed TAP.
+
+config RISCV_COVE_GUEST_PROMOTE
+	bool "Automatic promotion of VM to TVM for Confidential VM Extension(CoVE)"
+	default n
+	select RISCV_COVE_GUEST
+	select RISCV_COVE_GUEST_EMBEDDED_TAP
+	help
+	  VM requests promotion to TVM during early boot on platforms supporting CoVE.
+
+endmenu # "Confidential VM Extension(CoVE) Support"
 
 endmenu # "Platform type"
 
diff --git a/arch/riscv/Kconfig.socs b/arch/riscv/Kconfig.socs
index 30fd6a512828..bad861ecdcd3 100644
--- a/arch/riscv/Kconfig.socs
+++ b/arch/riscv/Kconfig.socs
@@ -16,9 +16,16 @@ config ARCH_RENESAS
 config ARCH_SIFIVE
 	def_bool SOC_SIFIVE
 
+config SOC_SIFIVE_EIC7700
+	bool "SiFive eic7700 SoC"
+	select RISCV_NONSTANDARD_CACHE_OPS
+	help
+	  This enables support for SiFive EIC7700 platform hardware.
+
 config SOC_SIFIVE
 	bool "SiFive SoCs"
 	select ERRATA_SIFIVE if !XIP_KERNEL
+	select RISCV_DMA_NONCOHERENT if SOC_SIFIVE_EIC7700
 	help
 	  This enables support for SiFive SoC platform hardware.
 
diff --git a/arch/riscv/boot/dts/Makefile b/arch/riscv/boot/dts/Makefile
index f60a280abb15..a0889f1b1375 100644
--- a/arch/riscv/boot/dts/Makefile
+++ b/arch/riscv/boot/dts/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 subdir-y += allwinner
 subdir-y += canaan
+subdir-y += eswin
 subdir-y += microchip
 subdir-y += renesas
 subdir-y += sifive
diff --git a/arch/riscv/boot/dts/eswin/Makefile b/arch/riscv/boot/dts/eswin/Makefile
new file mode 100644
index 000000000000..f550122f0335
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_SOC_SIFIVE) += eic7700-hifive-premier-p550.dtb
+obj-$(CONFIG_BUILTIN_DTB) += $(addsuffix .o, $(dtb-y))
diff --git a/arch/riscv/boot/dts/eswin/eic7700-arch.dtsi b/arch/riscv/boot/dts/eswin/eic7700-arch.dtsi
new file mode 100644
index 000000000000..c0d9f396a50c
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/eic7700-arch.dtsi
@@ -0,0 +1,543 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Include file for Eswin EIC7700 SoC's cpu.
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+#include <dt-bindings/clock/eic7700-clock.h>
+
+#define UART0_INT	100
+#define UART1_INT	101
+#define UART2_INT	102
+#define UART3_INT	103
+#define UART4_INT	104
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+	compatible = "eic7700-dev";
+
+	L64: cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		timebase-frequency = <RTCCLK_FREQ>;
+		L17: cpu@0 {
+			clock-frequency = <0>;
+			compatible = "eswin,eic770x", "riscv";
+			d-cache-block-size = <64>;
+			d-cache-sets = <128>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <32>;
+			device_type = "cpu";
+			hardware-exec-breakpoint-count = <4>;
+			hwpf-distanceBits = <6>;
+			hwpf-hitCacheThrdBits = <5>;
+			hwpf-hitMSHRThrdBits = <4>;
+			hwpf-l2pfPoolSize = <10>;
+			hwpf-nIssQEnt = <6>;
+			hwpf-nPrefetchQueueEntries = <8>;
+			hwpf-nStreams = <16>;
+			hwpf-qFullnessThrdBits = <4>;
+			hwpf-windowBits = <6>;
+			i-cache-block-size = <64>;
+			i-cache-sets = <128>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <32>;
+			mmu-type = "riscv,sv48";
+			next-level-cache = <&L15>;
+			reg = <0x0>;
+			riscv,isa-base = "rv64i";
+			riscv,isa-extensions = "i", "m", "a", "f", "d", "c", "h", "zicsr", "zifencei", "zba", "zbb", "sscofpmf";
+			riscv,pmpgranularity = <4096>;
+			riscv,pmpregions = <8>;
+			sifive,buserror = <&L16>;
+			status = "okay";
+			timebase-frequency = <RTCCLK_FREQ>;
+			tlb-split;
+			clocks = <&d0_clock EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_0>;
+			operating-points-v2 = <&d0_cpu_opp_table>;
+			L14: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+			L13: pmu {
+				riscv,raw-event-to-mhpmcounters = <0x0 0x0 0xffffffff 0xff 0x78
+					0x0 0x1 0xffffffff 0xfffe07ff 0x78
+					0x0 0x2 0xffffffff 0xfffe00ff 0x78
+					0x0 0x3 0xfffffffc 0xff 0x78
+					0x0 0x4 0xffffffc0 0xff 0x78
+					0x0 0x5 0xffffffff 0xfffffdff 0x78
+					0x0 0x6 0xfffffe00 0x110204ff 0x78
+					0x0 0x7 0xffffffff 0xf00000ff 0x78
+					0x0 0x8 0xfffffe04 0xff 0x78
+					0x0 0x9 0xffffffff 0xffffc0ff 0x78
+					0x0 0xa 0xffffffff 0xf00000ff 0x78
+					0x0 0xb 0xffffffff 0xfffffcff 0x78
+					0x0 0xc 0xfffffff0 0xff 0x78
+					0x0 0xd 0xffffffff 0x800000ff 0x78
+					0x0 0xe 0xffffffff 0xf80000ff 0x78
+					0x0 0xf 0xfffffffc 0xff 0x78>;
+				riscv,event-to-mhpmcounters = <0x01 0x01 0x01 0x02 0x02 0x02 0x4 0x6 0x78 0x10009 0x10009 0x78 0x10019 0x10019 0x78 0x10021 0x10021 0x78>;
+				riscv,event-to-mhpmevent = <0x4 0x0 0x202 0x5 0x0 0x4000 0x6 0x0 0x2001 0x10009 0x0 0x102 0x10019 0x0 0x1002 0x10021 0x0 0x802>;
+				compatible = "riscv,pmu0", "riscv,pmu";
+				interrupts-extended = <&L14 13>;
+			};
+		};
+		L22: cpu@1 {
+			clock-frequency = <0>;
+			compatible = "eswin,eic770x", "riscv";
+			d-cache-block-size = <64>;
+			d-cache-sets = <128>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <32>;
+			device_type = "cpu";
+			hardware-exec-breakpoint-count = <4>;
+			hwpf-distanceBits = <6>;
+			hwpf-hitCacheThrdBits = <5>;
+			hwpf-hitMSHRThrdBits = <4>;
+			hwpf-l2pfPoolSize = <10>;
+			hwpf-nIssQEnt = <6>;
+			hwpf-nPrefetchQueueEntries = <8>;
+			hwpf-nStreams = <16>;
+			hwpf-qFullnessThrdBits = <4>;
+			hwpf-windowBits = <6>;
+			i-cache-block-size = <64>;
+			i-cache-sets = <128>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <32>;
+			mmu-type = "riscv,sv48";
+			next-level-cache = <&L20>;
+			reg = <0x1>;
+			riscv,isa-base = "rv64i";
+			riscv,isa-extensions = "i", "m", "a", "f", "d", "c", "h", "zicsr", "zifencei", "zba", "zbb", "sscofpmf";
+			riscv,pmpgranularity = <4096>;
+			riscv,pmpregions = <8>;
+			sifive,buserror = <&L21>;
+			status = "okay";
+			timebase-frequency = <RTCCLK_FREQ>;
+			tlb-split;
+			clocks = <&d0_clock EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_1>;
+			operating-points-v2 = <&d0_cpu_opp_table>;
+			L19: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+			L18: pmu {
+				riscv,raw-event-to-mhpmcounters = <0x0 0x0 0xffffffff 0xff 0x78
+					0x0 0x1 0xffffffff 0xfffe07ff 0x78
+					0x0 0x2 0xffffffff 0xfffe00ff 0x78
+					0x0 0x3 0xfffffffc 0xff 0x78
+					0x0 0x4 0xffffffc0 0xff 0x78
+					0x0 0x5 0xffffffff 0xfffffdff 0x78
+					0x0 0x6 0xfffffe00 0x110204ff 0x78
+					0x0 0x7 0xffffffff 0xf00000ff 0x78
+					0x0 0x8 0xfffffe04 0xff 0x78
+					0x0 0x9 0xffffffff 0xffffc0ff 0x78
+					0x0 0xa 0xffffffff 0xf00000ff 0x78
+					0x0 0xb 0xffffffff 0xfffffcff 0x78
+					0x0 0xc 0xfffffff0 0xff 0x78
+					0x0 0xd 0xffffffff 0x800000ff 0x78
+					0x0 0xe 0xffffffff 0xf80000ff 0x78
+					0x0 0xf 0xfffffffc 0xff 0x78>;
+				riscv,event-to-mhpmcounters = <0x01 0x01 0x01 0x02 0x02 0x02 0x4 0x6 0x78 0x10009 0x10009 0x78 0x10019 0x10019 0x78 0x10021 0x10021 0x78>;
+				riscv,event-to-mhpmevent = <0x4 0x0 0x202 0x5 0x0 0x4000 0x6 0x0 0x2001 0x10009 0x0 0x102 0x10019 0x0 0x1002 0x10021 0x0 0x802>;
+				compatible = "riscv,pmu0", "riscv,pmu";
+				interrupts-extended = <&L19 13>;
+			};
+		};
+		L27: cpu@2 {
+			clock-frequency = <0>;
+			compatible = "eswin,eic770x", "riscv";
+			d-cache-block-size = <64>;
+			d-cache-sets = <128>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <32>;
+			device_type = "cpu";
+			hardware-exec-breakpoint-count = <4>;
+			hwpf-distanceBits = <6>;
+			hwpf-hitCacheThrdBits = <5>;
+			hwpf-hitMSHRThrdBits = <4>;
+			hwpf-l2pfPoolSize = <10>;
+			hwpf-nIssQEnt = <6>;
+			hwpf-nPrefetchQueueEntries = <8>;
+			hwpf-nStreams = <16>;
+			hwpf-qFullnessThrdBits = <4>;
+			hwpf-windowBits = <6>;
+			i-cache-block-size = <64>;
+			i-cache-sets = <128>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <32>;
+			mmu-type = "riscv,sv48";
+			next-level-cache = <&L25>;
+			reg = <0x2>;
+			riscv,isa-base = "rv64i";
+			riscv,isa-extensions = "i", "m", "a", "f", "d", "c", "h", "zicsr", "zifencei", "zba", "zbb", "sscofpmf";
+			riscv,pmpgranularity = <4096>;
+			riscv,pmpregions = <8>;
+			sifive,buserror = <&L26>;
+			status = "okay";
+			timebase-frequency = <RTCCLK_FREQ>;
+			tlb-split;
+			clocks = <&d0_clock EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_2>;
+			operating-points-v2 = <&d0_cpu_opp_table>;
+			L24: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+			L23: pmu {
+				riscv,raw-event-to-mhpmcounters = <0x0 0x0 0xffffffff 0xff 0x78
+					0x0 0x1 0xffffffff 0xfffe07ff 0x78
+					0x0 0x2 0xffffffff 0xfffe00ff 0x78
+					0x0 0x3 0xfffffffc 0xff 0x78
+					0x0 0x4 0xffffffc0 0xff 0x78
+					0x0 0x5 0xffffffff 0xfffffdff 0x78
+					0x0 0x6 0xfffffe00 0x110204ff 0x78
+					0x0 0x7 0xffffffff 0xf00000ff 0x78
+					0x0 0x8 0xfffffe04 0xff 0x78
+					0x0 0x9 0xffffffff 0xffffc0ff 0x78
+					0x0 0xa 0xffffffff 0xf00000ff 0x78
+					0x0 0xb 0xffffffff 0xfffffcff 0x78
+					0x0 0xc 0xfffffff0 0xff 0x78
+					0x0 0xd 0xffffffff 0x800000ff 0x78
+					0x0 0xe 0xffffffff 0xf80000ff 0x78
+					0x0 0xf 0xfffffffc 0xff 0x78>;
+				riscv,event-to-mhpmcounters = <0x01 0x01 0x01 0x02 0x02 0x02 0x4 0x6 0x78 0x10009 0x10009 0x78 0x10019 0x10019 0x78 0x10021 0x10021 0x78>;
+				riscv,event-to-mhpmevent = <0x4 0x0 0x202 0x5 0x0 0x4000 0x6 0x0 0x2001 0x10009 0x0 0x102 0x10019 0x0 0x1002 0x10021 0x0 0x802>;
+				compatible = "riscv,pmu0", "riscv,pmu";
+				interrupts-extended = <&L24 13>;
+			};
+		};
+		L32: cpu@3 {
+			clock-frequency = <0>;
+			compatible = "eswin,eic770x", "riscv";
+			d-cache-block-size = <64>;
+			d-cache-sets = <128>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <32>;
+			device_type = "cpu";
+			hardware-exec-breakpoint-count = <4>;
+			hwpf-distanceBits = <6>;
+			hwpf-hitCacheThrdBits = <5>;
+			hwpf-hitMSHRThrdBits = <4>;
+			hwpf-l2pfPoolSize = <10>;
+			hwpf-nIssQEnt = <6>;
+			hwpf-nPrefetchQueueEntries = <8>;
+			hwpf-nStreams = <16>;
+			hwpf-qFullnessThrdBits = <4>;
+			hwpf-windowBits = <6>;
+			i-cache-block-size = <64>;
+			i-cache-sets = <128>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <32>;
+			mmu-type = "riscv,sv48";
+			next-level-cache = <&L30>;
+			reg = <0x3>;
+			riscv,isa-base = "rv64i";
+			riscv,isa-extensions = "i", "m", "a", "f", "d", "c", "h", "zicsr", "zifencei", "zba", "zbb", "sscofpmf";
+			riscv,pmpgranularity = <4096>;
+			riscv,pmpregions = <8>;
+			sifive,buserror = <&L31>;
+			status = "okay";
+			timebase-frequency = <RTCCLK_FREQ>;
+			tlb-split;
+			clocks = <&d0_clock EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_3>;
+			operating-points-v2 = <&d0_cpu_opp_table>;
+			L29: interrupt-controller {
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+			L28: pmu {
+				riscv,raw-event-to-mhpmcounters = <0x0 0x0 0xffffffff 0xff 0x78
+					0x0 0x1 0xffffffff 0xfffe07ff 0x78
+					0x0 0x2 0xffffffff 0xfffe00ff 0x78
+					0x0 0x3 0xfffffffc 0xff 0x78
+					0x0 0x4 0xffffffc0 0xff 0x78
+					0x0 0x5 0xffffffff 0xfffffdff 0x78
+					0x0 0x6 0xfffffe00 0x110204ff 0x78
+					0x0 0x7 0xffffffff 0xf00000ff 0x78
+					0x0 0x8 0xfffffe04 0xff 0x78
+					0x0 0x9 0xffffffff 0xffffc0ff 0x78
+					0x0 0xa 0xffffffff 0xf00000ff 0x78
+					0x0 0xb 0xffffffff 0xfffffcff 0x78
+					0x0 0xc 0xfffffff0 0xff 0x78
+					0x0 0xd 0xffffffff 0x800000ff 0x78
+					0x0 0xe 0xffffffff 0xf80000ff 0x78
+					0x0 0xf 0xfffffffc 0xff 0x78>;
+				riscv,event-to-mhpmcounters = <0x01 0x01 0x01 0x02 0x02 0x02 0x4 0x6 0x78 0x10009 0x10009 0x78 0x10019 0x10019 0x78 0x10021 0x10021 0x78>;
+				riscv,event-to-mhpmevent = <0x4 0x0 0x202 0x5 0x0 0x4000 0x6 0x0 0x2001 0x10009 0x0 0x102 0x10019 0x0 0x1002 0x10021 0x0 0x802>;
+				compatible = "riscv,pmu0", "riscv,pmu";
+				interrupts-extended = <&L29 13>;
+			};
+		};
+	};
+	L50: memory@80000000 {
+		compatible = "sifive,axi4-mem-port", "sifive,axi4-port", "sifive,mem-port";
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x7f 0x80000000>;
+		sifive,port-width-bytes = <32>;
+	};
+	SOC: soc {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "SiFive,FU800-soc", "fu800-soc", "sifive-soc", "simple-bus";
+		ranges;
+		L40: authentication-controller {
+			compatible = "sifive,authentication0";
+			sifive,auth-types = "fuse";
+		};
+		L51: axi4-sys-port@40000000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "sifive,axi4-sys-port", "sifive,axi4-port", "sifive,sys-port", "simple-external-bus", "simple-bus";
+			ranges = <0x40000000 0x0 0x40000000 0x40000000>;
+			sifive,port-width-bytes = <16>;
+		};
+		L52: axi4-sys-port@8000000000 {
+			#address-cells = <2>;
+			#size-cells = <2>;
+			compatible = "sifive,axi4-sys-port", "sifive,axi4-port", "sifive,sys-port", "simple-external-bus", "simple-bus";
+			ranges = <0x80 0x0 0x80 0x0 0x180 0x0>;
+			sifive,port-width-bytes = <16>;
+		};
+		L46: basic-bus-blocker@200000 {
+			compatible = "sifive,basic-bus-blocker1";
+			reg = <0x0 0x200000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L43: basic-bus-blocker@202000 {
+			compatible = "sifive,basic-bus-blocker1";
+			reg = <0x0 0x202000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L48: basic-bus-blocker@204000 {
+			compatible = "sifive,basic-bus-blocker1";
+			reg = <0x0 0x204000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L54: burst-bundler@10010000 {
+			compatible = "sifive,burst-bundler0";
+			reg = <0x0 0x10010000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L16: bus-error-unit@hart0 {
+			compatible = "sifive,buserror";
+			interrupt-parent = <&plic0>;
+			interrupts = <517>;
+			reg = <0x0 0x1700000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L21: bus-error-unit@hart1 {
+			compatible = "sifive,buserror";
+			interrupt-parent = <&plic0>;
+			interrupts = <518>;
+			reg = <0x0 0x1701000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L26: bus-error-unit@hart2 {
+			compatible = "sifive,buserror";
+			interrupt-parent = <&plic0>;
+			interrupts = <519>;
+			reg = <0x0 0x1702000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L31: bus-error-unit@hart3 {
+			compatible = "sifive,buserror";
+			interrupt-parent = <&plic0>;
+			interrupts = <520>;
+			reg = <0x0 0x1703000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L7: cache-controller@2010000 {
+			cache-block-size = <64>;
+			cache-level = <3>;
+			cache-sets = <4096>;
+			cache-size = <4194304>;
+			cache-unified;
+			compatible = "sifive,eic7700";
+			interrupt-parent = <&plic0>;
+			interrupts = <1>, <3>, <4>, <2>;
+			next-level-cache = <&L9 &L10 &L11 &L50>;
+			reg = <0x0 0x2010000 0x0 0x4000 0x0 0x8000000 0x0 0x400000>;
+			reg-names = "control", "sideband";
+			sifive,a-mshr-count = <60>;
+			sifive,bank-count = <4>;
+			sifive,ecc-granularity = <8>;
+			sifive,max-master-id = <13>;
+			sifive,perfmon-counters = <6>;
+			numa-node-id = <0>;
+		};
+
+		L34: debug-controller@0 {
+			compatible = "sifive,debug-100", "riscv,debug-100";
+			debug-attach = "jtag";
+			reg = <0x0 0x0 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L8: error-device@1000 {
+			compatible = "sifive,error0";
+			reg = <0x0 0x1000 0x0 0x3000 0x0 0x5000 0x0 0x13000 0x0 0x19000 0x0 0xe7000 0x0 0x114000 0x0 0xec000 0x0 0x201000 0x0 0x1000 0x0 0x203000 0x0 0x1000 0x0 0x205000 0x0 0x14fb000 0x0 0x1704000 0x0 0x8fc000 0x0 0x2014000 0x0 0x5fec000 0x0 0x8400000 0x0 0x3c00000 0x0 0x10000000 0x0 0x3000 0x0 0x10004000 0x0 0xc000 0x0 0x10011000 0x0 0x1f000 0x0 0x10034000 0x0 0x9fcc000 0x0 0x1a400000 0x0 0x5c00000>;
+		};
+		L9: error-device@10003000 {
+			compatible = "sifive,error0";
+			reg = <0x0 0x10003000 0x0 0x1000>;
+		};
+
+		plic0: interrupt-controller@c000000 {
+			#interrupt-cells = <1>;
+			compatible = "sifive,plic-1.0.0";
+			interrupt-controller;
+			interrupts-extended = <
+				&L14 0xffffffff &L14 9
+				&L19 0xffffffff &L19 9
+				&L24 0xffffffff &L24 9
+				&L29 0xffffffff &L29 9>;
+			reg = <0x0 0xc000000 0x0 0x4000000>;
+			reg-names = "control";
+			riscv,max-priority = <7>;
+			riscv,ndev = <520>;
+		};
+		L53: order-obliterator@10030000 {
+			compatible = "sifive,order-obliterator0";
+			interrupt-parent = <&plic0>;
+			interrupts = <516>;
+			reg = <0x0 0x10030000 0x0 0x4000>;
+			reg-names = "control";
+		};
+		L15: pl2@104000 {
+			cache-block-size = <64>;
+			cache-level = <2>;
+			cache-sets = <512>;
+			cache-size = <262144>;
+			cache-unified;
+			compatible = "sifive,pL2Cache0", "cache";
+			next-level-cache = <&L7>;
+			reg = <0x0 0x104000 0x0 0x4000>;
+			reg-names = "control";
+			sifive,ecc-granularity = <16>;
+			sifive,perfmon-counters = <6>;
+		};
+		L20: pl2@108000 {
+			cache-block-size = <64>;
+			cache-level = <2>;
+			cache-sets = <512>;
+			cache-size = <262144>;
+			cache-unified;
+			compatible = "sifive,pL2Cache0", "cache";
+			next-level-cache = <&L7>;
+			reg = <0x0 0x108000 0x0 0x4000>;
+			reg-names = "control";
+			sifive,ecc-granularity = <16>;
+			sifive,perfmon-counters = <6>;
+		};
+		L25: pl2@10c000 {
+			cache-block-size = <64>;
+			cache-level = <2>;
+			cache-sets = <512>;
+			cache-size = <262144>;
+			cache-unified;
+			compatible = "sifive,pL2Cache0", "cache";
+			next-level-cache = <&L7>;
+			reg = <0x0 0x10c000 0x0 0x4000>;
+			reg-names = "control";
+			sifive,ecc-granularity = <16>;
+			sifive,perfmon-counters = <6>;
+		};
+		L30: pl2@110000 {
+			cache-block-size = <64>;
+			cache-level = <2>;
+			cache-sets = <512>;
+			cache-size = <262144>;
+			cache-unified;
+			compatible = "sifive,pL2Cache0", "cache";
+			next-level-cache = <&L7>;
+			reg = <0x0 0x110000 0x0 0x4000>;
+			reg-names = "control";
+			sifive,ecc-granularity = <16>;
+			sifive,perfmon-counters = <6>;
+		};
+		L10: rom@1a000000 {
+			compatible = "ucbbar,cacheable-zero0";
+			reg = <0x0 0x1a000000 0x0 0x400000>;
+		};
+		L11: rom@3a000000 {
+			compatible = "ucbbar,cacheable-zero0";
+			reg = <0x0 0x3a000000 0x0 0x400000>;
+		};
+		L6: subsystem_pbus_clock {
+			#clock-cells = <0>;
+			clock-frequency = <10000000>;
+			clock-output-names = "subsystem_pbus_clock";
+			compatible = "fixed-clock";
+		};
+		L61: teststatus@4000 {
+			compatible = "sifive,test0";
+			reg = <0x0 0x4000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L45: tl-address-adjuster@20000000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "sifive,tl-inter-sys-port", "sifive,tl-port", "simple-external-bus", "simple-bus";
+			ranges = <0x20000000 0x0 0x20000000 0x1a000000 0x3a400000 0x0 0x3a400000 0x5c00000>;
+			sifive,port-width-bytes = <8>;
+		};
+		L42: tl-inter-mem-master-port@80000000 {
+			#address-cells = <2>;
+			#size-cells = <2>;
+			compatible = "sifive,tl-inter-mem-master-port", "sifive,tl-port", "sifive,inter-mem-master-port", "simple-external-bus", "simple-bus";
+			ranges = <0x0 0x80000000 0x0 0x80000000 0x7f 0x80000000>;
+			sifive,port-width-bytes = <32>;
+		};
+		L55: trace-encoder-0@100000 {
+			compatible = "sifive,trace0";
+			reg = <0x0 0x100000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L56: trace-encoder-1@101000 {
+			compatible = "sifive,trace0";
+			reg = <0x0 0x101000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L57: trace-encoder-2@102000 {
+			compatible = "sifive,trace0";
+			reg = <0x0 0x102000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L58: trace-encoder-3@103000 {
+			compatible = "sifive,trace0";
+			reg = <0x0 0x103000 0x0 0x1000>;
+			reg-names = "control";
+		};
+		L59: trace-funnel-0@18000 {
+			compatible = "sifive,trace0";
+			reg = <0x0 0x18000 0x0 0x1000>;
+			reg-names = "control";
+		};
+	};
+};
diff --git a/arch/riscv/boot/dts/eswin/eic7700-hifive-premier-p550.dts b/arch/riscv/boot/dts/eswin/eic7700-hifive-premier-p550.dts
new file mode 100644
index 000000000000..880ec234d084
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/eic7700-hifive-premier-p550.dts
@@ -0,0 +1,752 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree file for Eswin EIC7700 SoC.
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+/dts-v1/;
+
+#define RTCCLK_FREQ		1000000
+#define LSPCLK_FREQ		200000000
+
+/* Currently, not reserving any DDR for ECC capability. Also, ECC must be disabled in U-Boot
+ * If wanna enable ECC capability of DDR, should reserve highest zone of 1/8 all space for it
+ */
+#define MEMORY_SIZE_H		0x4
+#define MEMORY_SIZE_L		0x0
+#define CMA_SIZE		0x10000000
+
+#include "eic7700.dtsi"
+#include "hifive-premier-p550-pinctrl.dtsi"
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/gpio/gpio.h>
+
+/* Clock frequency (in Hz) of the PCB crystal for rtcclk */
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+	model = "SiFive HiFive Premier P550";
+	compatible = "sifive,hifive-premier-p550", "eswin,eic7700";
+
+	aliases {
+		serial0 = &d0_uart0;
+		ethernet0 = &d0_gmac0;
+		ethernet1 = &d0_gmac1;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	cpus {
+		timebase-frequency = <RTCCLK_FREQ>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0x0 CMA_SIZE>;
+			alignment = <0x0 0x1000>;
+			alloc-ranges = <0x0 0x80000000 MEMORY_SIZE_H MEMORY_SIZE_L>;
+			linux,cma-default;
+		};
+
+		npu0_reserved: sprammemory@59000000 {
+			no-map;
+			reg = <0x0 0x59000000 0x0 0x400000>;
+		};
+
+		lpcpu0_reserved: lpcpu@a0000000 {
+			no-map;
+			reg = <0x0 0xa0000000 0x0 0x100000>;
+		};
+
+		g2d_4GB_boundary_reserved_4k {
+			no-map;
+			reg = <0x0 0xfffff000 0x0 0x1000>;
+		};
+	};
+
+	soc {
+		reset_test@1e00e000 {
+			compatible	= "reset_test";
+			resets = <&d0_reset SCPU_RST_CTRL SW_SCPU_BUS_RSTN>,
+					 <&d0_reset SCPU_RST_CTRL SW_SCPU_CORE_RSTN>,
+					 <&d0_reset SCPU_RST_CTRL SW_SCPU_DBG_RSTN>;
+			reset-names = "bus", "core", "dbg";
+		};
+	};
+};
+
+&d0_clock {
+	status = "okay";
+};
+
+&d0_reset {
+	status = "okay";
+};
+
+&d0_pmu {
+	status = "okay";
+};
+
+&ddr0 {
+	status = "okay";
+};
+
+&ddr1 {
+	status = "okay";
+};
+
+&smmu0 {
+	status = "okay";
+};
+
+&smmu_pmu0 {
+	status = "disabled";
+};
+
+&d0_cfg_noc {
+	status = "okay";
+};
+
+&d0_llc_noc {
+	status = "okay";
+	stat,0 = "TracePort:ddr0_p0_req";
+	stat,1 = "TracePort:ddr1_p0_req";
+};
+
+&d0_sys_noc {
+	status = "okay";
+
+	stat,0 = "TracePort:ddr0_p1_req",
+		 "InitFlow:mcput_snoc_mp/I/0";
+
+	stat,1 = "TracePort:ddr0_p2_req",
+		 "InitFlow:dspt_snoc/I/0",
+		 "AddrBase:0x81000000", "AddrSize:0x30",
+		 "Opcode:RdWrLockUrg", "Status:ReqRsp", "Length:0x8000", "Urgency:0x0";
+
+	stat,2 = "TracePort:ddr1_p1_req",
+		 "Status:Req", "AddrSize:0x28";
+
+	stat,3 = "TracePort:ddr1_p2_req";
+
+	latency,0 = "TracePort:sysnoc_trans_probe_0", "AddrSize:0x0";
+	latency,1 = "TracePort:sysnoc_trans_probe_1","Mode:latency","AddrBase:0x82000000","AddrSize:0x28","Opcode:RdWr";
+
+	pending,0 = "TracePort:sysnoc_trans_probe_2", "AddrSize:0x3";
+};
+
+&d0_media_noc {
+	status = "okay";
+
+	stat,0 = "TracePort:ddr0_p3_req";
+	stat,1 = "TracePort:ddr1_p3_req";
+};
+
+&d0_realtime_noc {
+	status = "okay";
+
+	stat,0 = "TracePort:ddr0_p4_req";
+	stat,1 = "TracePort:ddr1_p4_req";
+};
+
+&d0_noc_wdt {
+	status = "okay";
+};
+
+&d0_ipc_scpu {
+	status = "okay";
+};
+
+&d0_lpcpu {
+	status = "disabled";
+};
+
+&pcie {
+	/* GPIO12 PCIE PRSNT input */
+	status = "okay";
+};
+
+&d0_npu{
+	status = "okay";
+};
+
+&d0_dsp_subsys {
+	status = "okay";
+};
+
+&d0_dsp0 {
+	status = "okay";
+};
+
+&d0_dsp1 {
+	status = "okay";
+};
+
+&d0_dsp2 {
+	status = "okay";
+};
+
+&d0_dsp3 {
+	status = "okay";
+};
+
+&gpu0 {
+	status = "okay";
+};
+
+&gc820 {
+	status = "okay";
+};
+
+&vdec0 {
+	status = "okay";
+};
+
+&venc0 {
+	status = "okay";
+};
+
+&video_output {
+	status = "okay";
+};
+
+&dc {
+	status = "okay";
+};
+
+&dc_test {
+    status = "disabled";
+};
+
+&virtual_display {
+    status = "okay";
+};
+
+&dsi_output {
+    status = "okay";
+};
+
+&dsi_controller {
+    status = "okay";
+};
+
+&dsi_panel {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio82_default &pinctrl_gpio85_default>;
+	backlight0-gpios = <&portc 18 GPIO_ACTIVE_HIGH>;
+	rst-gpios = <&portc 21 GPIO_ACTIVE_HIGH>;
+};
+
+&dw_hdmi {
+	status = "okay";
+	eswin-plat = <1>;
+	ports {
+		port@2 {
+			reg = <2>;
+			hdmi_in_i2s: endpoint@1 {
+				system-clock-frequency = <12288000>;
+				remote-endpoint = <&d0_i2s0_endpoint>;
+			};
+		};
+	};
+};
+
+&dw_hdmi_hdcp2 {
+    status = "okay";
+};
+
+&d0_i2s0 {
+	status = "okay";
+	d0_i2s0_port: port {
+		d0_i2s0_endpoint: endpoint {
+			remote-endpoint = <&hdmi_in_i2s>;
+			dai-format = "i2s";
+		};
+	};
+};
+
+&d0_i2s1 {
+	status = "okay";
+	d0_i2s1_port: port {
+		d0_i2s1_endpoint: endpoint {
+			remote-endpoint = <&d0_codec0_endpoint>;
+			dai-format = "i2s";
+		};
+	};
+};
+
+&d0_i2s2 {
+	/* connect WIFI module */
+	status = "disabled";
+};
+
+&d0_graphcard0 {
+	status = "okay";
+	dais = <&d0_i2s1_port>;
+};
+
+&d0_graphcard1 {
+	status = "okay";
+	dais = <&d0_i2s0_port>;
+};
+
+&d0_graphcard2 {
+	status = "disabled";
+};
+
+&isp_0 {
+	status = "disabled";
+};
+
+&isp_1 {
+	status = "disabled";
+};
+
+&dewarp {
+	status = "okay";
+};
+
+&mipi_dphy_rx {
+	status = "disabled";
+};
+
+&csi_dma0 {
+	status = "disabled";
+};
+
+&csi_dma1 {
+	status = "disabled";
+};
+
+&csi2_0 {
+	status = "disabled";
+};
+
+&csi2_1 {
+	status = "disabled";
+};
+
+&sdhci_emmc {
+	/* emmc */
+	status = "okay";
+	delay_code = <0x17>;
+	drive-impedance-ohm = <50>;
+	enable-cmd-pullup;
+	enable-data-pullup;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_emmc_led_control_default>;
+};
+
+&sdio0 {
+	/* sd card */
+	status = "okay";
+	delay_code = <0x29>;
+	drive-impedance-ohm = <33>;
+	enable-cmd-pullup;
+	enable-data-pullup;
+	no-sdio;
+	no-mmc;
+};
+
+&sdio1 {
+	/* wifi module */
+	status = "disabled";
+	delay_code = <0x29>;
+	drive-impedance-ohm = <33>;
+	enable-cmd-pullup;
+	enable-data-pullup;
+	non-removable;
+	no-sd;
+	no-mmc;
+};
+
+&d0_gmac0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio106_default>;
+	rst-gpios = <&portd 10 GPIO_ACTIVE_LOW>;
+	eswin,rgmiisel = <&pinctrl 0x290 0x3>;
+	eswin,led-cfgs = <0x6100 0xa40 0x420>;
+};
+
+&d0_gmac1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio111_default>;
+	rst-gpios = <&portd 15 GPIO_ACTIVE_LOW>;
+	eswin,rgmiisel = <&pinctrl 0x294 0x3>;
+	eswin,led-cfgs = <0x6100 0xa40 0x420>;
+};
+
+&d0_sata {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_sata_act_led_default>;
+};
+
+&d0_usbdrd3_0 {
+	status = "okay";
+};
+
+&d0_usbdrd_dwc3_0 {
+	status = "okay";
+	dr_mode = "host";
+	maximum-speed = "super-speed";
+};
+
+&d0_usbdrd3_1 {
+	status = "okay";
+};
+
+&d0_usbdrd_dwc3_1 {
+	status = "okay";
+	dr_mode = "host";
+	maximum-speed = "super-speed";
+	usb-hub {
+		gpio-hog;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio43_default>;
+		gpios = <&portb 11 GPIO_ACTIVE_HIGH>;
+		output-low;
+		line-name = "usb-hub-reset";
+	};
+};
+
+&d0_dmac0 {
+	status = "okay";
+};
+
+&d0_aon_dmac {
+	status = "okay";
+};
+
+&d0_uart0 {
+	/* debug */
+	status = "okay";
+};
+
+&d0_uart1 {
+	/* M.2 KEY E */
+	status = "okay";
+};
+
+&d0_uart2 {
+	/* connect MCU */
+	status = "okay";
+};
+
+&d0_uart3 {
+	/* pin header mux with GPIO 92,93 */
+	status = "disabled";
+};
+
+&d0_uart4 {
+	/* unused */
+	status = "disabled";
+};
+
+&ssi0 {
+	/* pin header mux with GPIO 35,36,37,38,39,40 */
+	status = "disabled";
+};
+
+&ssi1 {
+	/* unused */
+	status = "disabled";
+};
+
+&bootspi {
+	/* spi flash */
+	status = "okay";
+	num-cs = <1>;
+	cs-gpios = <&portd 0 GPIO_ACTIVE_LOW>;
+	spi-flash@0 {
+		compatible = "winbond,w25q128jw",
+					"jedec,spi-nor";
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		spi-max-frequency = <4800000>;
+		rx-sample-delay-ns = <10>;
+	};
+};
+
+&d0_mbox0 {
+	status = "okay";
+};
+
+&d0_mbox1 {
+	status = "okay";
+};
+
+&d0_mbox2 {
+	status = "okay";
+};
+
+&d0_mbox3 {
+	status = "okay";
+};
+
+&d0_mbox4 {
+	status = "okay";
+};
+
+&d0_mbox5 {
+	status = "okay";
+};
+
+&d0_mbox6 {
+	status = "okay";
+};
+
+&d0_mbox7 {
+	status = "okay";
+};
+
+&fan_control {
+	status = "okay";
+};
+
+&d0_i2c0 {
+	/* codec es8388 */
+	status = "okay";
+	d0_es8388_0: es8388-0@11 {
+		compatible = "eswin,es8388";
+		reg = <0x11>;
+		#sound-dai-cells = <0>;
+		eswin-plat = <2>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio0_default &pinctrl_gpio28_default>;
+		front-jack-gpios = <&porta 0 GPIO_ACTIVE_HIGH>;
+		back-jack-gpios = <&porta 28 GPIO_ACTIVE_HIGH>;
+		port {
+			d0_codec0_endpoint: endpoint {
+				system-clock-frequency = <12288000>;
+				remote-endpoint = <&d0_i2s1_endpoint>;
+			};
+		};
+	};
+};
+
+&d0_i2c1 {
+	/* pin header mux with GPIO 46,47 */
+	status = "disabled";
+};
+
+&d0_i2c2 {
+	/* mipi dsi touch ctrl con */
+	status = "disabled";
+};
+
+&d0_i2c3 {
+	/* FUSB303B cc logic */
+	status = "okay";
+	fusb303b@21 {
+		compatible = "fcs,fusb303b";
+		status = "okay";
+		reg = <0x21>;
+		eswin,syscfg = <&d0_sys_con 0x3C0 12>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio5_default>;
+		int-gpios = <&porta 5 GPIO_ACTIVE_HIGH>;
+		connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "host";
+		};
+	};
+};
+
+&d0_i2c4 {
+	/* unused */
+	status = "disabled";
+};
+
+&d0_i2c5 {
+	/* PCA9548 */
+	status = "okay";
+};
+
+&d0_i2c6 {
+	/* unused */
+	status = "disabled";
+};
+
+&d0_i2c7 {
+	/* unused */
+	status = "disabled";
+};
+
+&d0_i2c8 {
+	/* unused */
+	status = "disabled";
+};
+
+&d0_i2c9 {
+	/* unused */
+	status = "disabled";
+};
+
+&d0_aon_i2c0 {
+	/* AT24C02C EEPROM */
+	status = "okay";
+	eswin,syscfg = <&d0_sys_con 0x3C0 16>;
+	aon_eeprom@50 {
+		compatible = "atmel,24c02";
+		reg = <0x50>;
+	};
+};
+
+&d0_aon_i2c1 {
+	/* PCA9450 & SiC451 & INA226 & PAC1934 */
+	status = "okay";
+	eswin,syscfg = <&d0_sys_con 0x3C0 15>;
+	iic_hold_time = <0x40>;
+	pac1934:pac1934@10 {
+		compatible = "microchip,pac1934";
+		/*update all register data*/
+		update_time_ms = <1000>;
+		eswin,chan_label = "som vdd", "soc vdd", "cpu vdd", "ddr lpvdd";
+		label = "som_info";
+		/*The update number of times the energy accumulates*/
+		energy_acc_count = <0>;
+		shunt_resistors=<1 1 1 1>;
+		reg = <0x10>;
+	};
+
+	sys_power:ina226@44 {
+		compatible = "ti,ina226";
+		#io-channel-cells = <1>;
+		label = "sys_power";
+		reg = <0x44>;
+		shunt-resistor = <1000>;
+	};
+};
+
+&pwm0 {
+	/* fan */
+	status = "okay";
+};
+
+&pvt0 {
+	status = "okay";
+};
+
+&pvt1 {
+	status = "okay";
+};
+
+&wdt0 {
+	status = "okay";
+};
+
+&wdt1 {
+	status = "okay";
+};
+
+&wdt2 {
+	status = "okay";
+};
+
+&wdt3 {
+	status = "okay";
+};
+
+&die0_rtc {
+	status = "okay";
+};
+
+&timer0 {
+	status = "okay";
+};
+
+&timer1 {
+	status = "okay";
+};
+
+&timer2 {
+	status = "okay";
+};
+
+&timer3 {
+	status = "okay";
+};
+
+&pinctrl {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio6_default &pinctrl_gpio7_default &pinctrl_gpio8_default &pinctrl_gpio9_default
+			&pinctrl_gpio10_default &pinctrl_gpio17_default &pinctrl_gpio35_default &pinctrl_gpio36_default
+			&pinctrl_gpio37_default &pinctrl_gpio38_default &pinctrl_gpio39_default &pinctrl_gpio40_default
+			&pinctrl_gpio41_default &pinctrl_gpio46_default &pinctrl_gpio52_default
+			&pinctrl_gpio53_default &pinctrl_gpio64_default &pinctrl_gpio65_default &pinctrl_gpio66_default
+			&pinctrl_gpio67_default &pinctrl_gpio70_default &pinctrl_gpio73_default &pinctrl_gpio83_default
+			&pinctrl_gpio86_default &pinctrl_gpio87_default &pinctrl_gpio92_default &pinctrl_gpio93_default>;
+
+    /* pin header default function for GPIO
+       SPI1 (CS0,SCLK,MOSI,MISO,D2,D3): GPIO 35,36,37,38,39,40
+       I2C1 (SCL,SDA): GPIO 46,47
+       UART3(TX,RX): GPIO 92,93
+    */
+};
+
+/*
+GPIO USED ON CarrierBoard:
+	gpio0   : FP Audio Jack Sense(I), active low
+	gpio5   : TYPE C cc logic interrupt(I), active low
+	gpio11  : BT WAKE HOST(I), active low
+	gpio12  : PCIE present(I), active low
+	gpio14  : DSI FPC CON CTRL(J10&J11)
+	gpio15  : Wlan wake host(I), active low
+	gpio28  : RP audio jack sense(I), active low
+	gpio29  : EMMC active led ctrl(O)
+
+	gpio43  : USB3.2 Gen1 hub Resetn(O), active low
+	gpio71  : CSI fpc con ctrl(O)
+	gpio74  : CSI fpc con ctrl(O)
+	gpio77  : CSI fpc con ctrl(O)
+	gpio76  : HOST WAKE BT(O), active low
+	gpio79  : WLAN POWER ON(O), active high
+	gpio80  : CSI fpc con ctrl(O)
+	gpio82  : DSI FPC CON CTRL(J10)
+	gpio85  : DSI FPC CON CTRL(J11)
+	gpio84  : GPIO LED CTRL(O), active high
+
+ GPIO USED ON SOM:
+	gpio18  : HOST WAKE WLAN(O), active low
+	gpio19  : HOST WAKE BT(O), active low
+	gpio20  : WLAN WAKE HOST(I), active low
+	gpio21  : BT WAKE HOST(I), active low
+	gpio106 : gphy0 resern(O), active low
+	gpio111 : gphy1 resern(O), active low
+
+*/
+
+&gpio0 {
+	status = "okay";
+};
diff --git a/arch/riscv/boot/dts/eswin/eic7700-noc.dtsi b/arch/riscv/boot/dts/eswin/eic7700-noc.dtsi
new file mode 100644
index 000000000000..a4e143548832
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/eic7700-noc.dtsi
@@ -0,0 +1,2620 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Include file for Die0 NOC monitor of Eswin EIC770x family SoC.
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+d0_cfg_noc:d0_cfg_noc{
+	compatible = "eswin,eic7700-noc";
+	#address-cells = <2>;
+	#size-cells = <2>;
+	ranges;
+	reg = <0 0x52060000 0 0x4000>;
+
+	interrupts = <446>;
+	interrupt-names = "error";
+	interrupt-parent = <&plic0>;
+	errlogger,idx = <0 1 3 5>;
+
+	sideband_manager@52061000{
+		compatible = "eswin,win2xxx-noc-sideband-manager";
+		reg = <0 0x52061000 0 0x10>;
+		SenseIn0 =
+			<SBM_CLMM 	OFFSET0>,
+			<SBM_CNOC_AON 	OFFSET1>,
+			<SBM_CNOC_DDRT0_CTRL 	OFFSET2>,
+			<SBM_CNOC_DDRT0_PHY 	OFFSET3>,
+			<SBM_CNOC_DDRT1_CTRL 	OFFSET4>,
+			<SBM_CNOC_DDRT1_PHY 	OFFSET5>,
+			<SBM_CNOC_DSPT 	OFFSET6>,
+			<SBM_CNOC_GPU 	OFFSET7>,
+			<SBM_CNOC_HSP 	OFFSET8>,
+			<SBM_CNOC_LSP_APB2 	OFFSET9>,
+			<SBM_CNOC_LSP_APB3	OFFSET10>,
+			<SBM_CNOC_LSP_APB4 	OFFSET11>,
+			<SBM_CNOC_LSP_APB6 	OFFSET12>,
+			<SBM_CNOC_MCPUT_D2D 	OFFSET13>,
+			<SBM_CNOC_NPU 	OFFSET14>,
+			<SBM_CNOC_PCIET_P 	OFFSET15>,
+			<SBM_CNOC_PCIET_X 	OFFSET16>,
+			<SBM_CNOC_TCU 	OFFSET17>,
+			<SBM_CNOC_VC 	OFFSET18>,
+			<SBM_CNOC_VI 	OFFSET19>,
+			<SBM_CNOC_VO 	OFFSET20>;
+		bf-name =
+			"SBM_CLMM",
+			"SBM_CNOC_AON",
+			"SBM_CNOC_DDRT0_CTRL",
+			"SBM_CNOC_DDRT0_PHY ",
+			"SBM_CNOC_DDRT1_CTRL",
+			"SBM_CNOC_DDRT1_PHY",
+			"SBM_CNOC_DSPT",
+			"SBM_CNOC_GPU",
+			"SBM_CNOC_HSP",
+			"SBM_CNOC_LSP_APB2",
+			"SBM_CNOC_LSP_APB3",
+			"SBM_CNOC_LSP_APB4",
+			"SBM_CNOC_LSP_APB6",
+			"SBM_CNOC_MCPUT_D2D",
+			"SBM_CNOC_NPU",
+			"SBM_CNOC_PCIET_P",
+			"SBM_CNOC_PCIET_X",
+			"SBM_CNOC_TCU",
+			"SBM_CNOC_VC",
+			"SBM_CNOC_VI",
+			"SBM_CNOC_VO";
+	};
+	ErrorLogger0 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x14 32 >;
+		description = "Register 0 to log errors";
+		lock {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0 1>;
+			lut = "Not Locked", "Locked";
+		};
+		OpCode {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 1 4>;
+			lut = "RD: data read with incrementing address",
+				"RDW: data read with wrapping address",
+				"RDL: allocates monitor in the Target with incrementing address",
+				"RDX: exclusive read with incrementing address",
+				"WR: data write with incrementing address",
+				"WRW: data write with wrapping address",
+				"WRC: conditional write if matching monitor in Target is found",
+				"RSV: reserved",
+				"PRE: preamble packet of linked sequence (locked sequence)",
+				"URG: urgency packet used for QoS (status must be REQ)";
+		};
+		ErrCode {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 8 3 >;
+			lut = "SLV (error source: Target): error detected by the Slave without any information or no Error",
+				"DEC (error source: Initiator NIU): decode error",
+				"UNS (error source: Target NIU): unsupported access type",
+				"DISC (error source: Power Disconnect): disconnected Target or NoC domain",
+				"SEC (error source: Initiator NIU or Firewall): security error",
+				"HIDE (error source: Firewall): hidden security error. Will be reported as OK to the initiator",
+				"TMO (error source: Target NIU): time-out",
+				"RSV: reserved";
+
+		};
+		Len1 {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 16 12 >;
+		};
+		Format {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 31 1 >;
+			lut = "NTTP v3.0 (Invalid)", "NTTP v3.5 (Ok)";
+		};
+	};
+
+	ErrorLogger1 {
+		compatible = "eswin,eic7700,register", "eswin,eic7700,noc,filter,routeid";
+		offset,length = < 0x18 32>;
+		description = "Register 1 to log errors";
+		InitFlow {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 15 1 >;  /*bit 15 will aloways be 0, then we will always get "snoc_cnoc/I/0"*/
+			lut =
+				"snoc_cnoc/I/0";
+		};
+
+		TargetFlow {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 10 5 >;
+			lut =
+				"clmm/T/0",
+				"cnoc_aon/T/0",
+				"cnoc_ddrt0_ctrl/T/0",
+				"cnoc_ddrt0_phy/T/0",
+				"cnoc_ddrt1_ctrl/T/0",
+				"cnoc_ddrt1_phy/T/0",
+				"cnoc_dspt/T/0",
+				"cnoc_gpu/T/0",
+				"cnoc_hsp/T/0",
+				"cnoc_lsp_apb2/T/0",
+				"cnoc_lsp_apb3/T/0",
+				"cnoc_lsp_apb4/T/0",
+				"cnoc_lsp_apb6/T/0",
+				"cnoc_mcput_d2d/T/0",
+				"cnoc_npu/T/0",
+				"cnoc_pciet_p/T/0",
+				"cnoc_pciet_x/T/0",
+				"cnoc_service/T/0",
+				"cnoc_tcu/T/0",
+				"cnoc_vc/T/0",
+				"cnoc_vi/T/0",
+				"cnoc_vo/T/0",
+				"RESERVED",
+				"RESERVED",
+				"RESERVED",
+				"RESERVED",
+				"RESERVED",
+				"RESERVED",
+				"RESERVED",
+				"RESERVED",
+				"RESERVED",
+				"RESERVED";
+		};
+
+		TargetSubRange {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 8 2 >;
+		};
+
+		SeqId {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0 8 >;
+		};
+	};
+
+	ErrorLogger3 {
+		/* This register does not really include a bitfield or its bitfield is 32 bits and it provides an offset address */
+		/* To calculate the absolute address, you must use the initflow:targetflow:subrange from ErrorLogger1 register */
+		/* And use it as an index in the aperture table. Then you must add the value of this register to the value given */
+		/* by the table to get the absolute address. */
+		compatible = "eswin,eic7700,register";
+		offset,length = <0x20 32>;
+		description = "Register 3 to log errors";
+		aperture-link = <1>; /* link to ErrorLogger1 whose information are required to calculate real absolute address */
+		AbsoluteAddress {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 8 8 >;	/* bitfield initflow:targeflow:subrange from aperture-link register */
+			aperture-size= < 46 >;		/* Number of line in the aperture table below */
+			aperture-idx,aperture-base =	/* Aperture_idx is concatenation of initflow:targetflow:subrange bitfield from ErrorLogger1 */
+				/bits/ 64  <0x0 0x0    0x0  0x51600000>,
+				/bits/ 64  <0x0 0x0    0x1  0x71600000>,
+				/bits/ 64  <0x0 0x1    0x0  0x51800000>,
+				/bits/ 64  <0x0 0x1    0x1  0x71800000>,
+				/bits/ 64  <0x0 0x1    0x2  0x0       >,
+				/bits/ 64  <0x0 0x1    0x3  0x0       >,
+				/bits/ 64  <0x0 0x2    0x0  0x52300000>,
+				/bits/ 64  <0x0 0x2    0x1  0x72300000>,
+				/bits/ 64  <0x0 0x3    0x0  0x53000000>,
+				/bits/ 64  <0x0 0x3    0x1  0x73000000>,
+				/bits/ 64  <0x0 0x4    0x0  0x52380000>,
+				/bits/ 64  <0x0 0x4    0x1  0x72380000>,
+				/bits/ 64  <0x0 0x5    0x0  0x53800000>,
+				/bits/ 64  <0x0 0x5    0x1  0x73800000>,
+				/bits/ 64  <0x0 0x6    0x0  0x52200000>,
+				/bits/ 64  <0x0 0x6    0x1  0x72200000>,
+				/bits/ 64  <0x0 0x7    0x0  0x51400000>,
+				/bits/ 64  <0x0 0x7    0x1  0x71400000>,
+				/bits/ 64  <0x0 0x8    0x0  0x50400000>,
+				/bits/ 64  <0x0 0x8    0x1  0x70400000>,
+				/bits/ 64  <0x0 0x9    0x0  0x50800000>,
+				/bits/ 64  <0x0 0x9    0x1  0x70800000>,
+				/bits/ 64  <0x0 0xa    0x0  0x50900000>,
+				/bits/ 64  <0x0 0xa    0x1  0x70900000>,
+				/bits/ 64  <0x0 0xb    0x0  0x50a00000>,
+				/bits/ 64  <0x0 0xb    0x1  0x70a00000>,
+				/bits/ 64  <0x0 0xc    0x0  0x50b00000>,
+				/bits/ 64  <0x0 0xc    0x1  0x70b00000>,
+				/bits/ 64  <0x0 0xd    0x0  0x52100000>,
+				/bits/ 64  <0x0 0xd    0x1  0x72100000>,
+				/bits/ 64  <0x0 0xe    0x0  0x51c00000>,
+				/bits/ 64  <0x0 0xe    0x1  0x71c00000>,
+				/bits/ 64  <0x0 0xf    0x0  0x50000000>,
+				/bits/ 64  <0x0 0xf    0x1  0x70000000>,
+				/bits/ 64  <0x0 0x10   0x0  0x54000000>,
+				/bits/ 64  <0x0 0x10   0x1  0x74000000>,
+				/bits/ 64  <0x0 0x11   0x0  0x52060000>,
+				/bits/ 64  <0x0 0x11   0x1  0x72060000>,
+				/bits/ 64  <0x0 0x12   0x0  0x50c00000>,
+				/bits/ 64  <0x0 0x12   0x1  0x70c00000>,
+				/bits/ 64  <0x0 0x13   0x0  0x50100000>,
+				/bits/ 64  <0x0 0x13   0x1  0x70100000>,
+				/bits/ 64  <0x0 0x14   0x0  0x51000000>,
+				/bits/ 64  <0x0 0x14   0x1  0x71000000>,
+				/bits/ 64  <0x0 0x15   0x0  0x50200000>,
+				/bits/ 64  <0x0 0x15   0x1  0x70200000>;
+		};
+	};
+
+	ErrorLogger5 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x28 32>;
+		description = "Register 5 to log errors";
+
+		User_flag {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0x0 7 >;
+			lut =
+				"Cache_0",
+				"Cache_1",
+				"Cache_2",
+				"Cache_3",
+				"Prot_0",
+				"Prot_1",
+				"Prot_2";
+		};
+	};
+};
+
+d0_llc_noc:d0_llc_noc@52081400 {
+	compatible = "eswin,eic7700-noc";
+	#address-cells = <2>;
+	#size-cells = <2>;
+	ranges;
+	reg = <0 0x52081400 0 0x4000>;
+	interrupts = <441>;
+	interrupt-names = "error";
+	interrupt-parent = <&plic0>;
+	errlogger,idx = <0 1 3 4 5>;
+	sideband_manager@52082000 {
+		compatible = "eswin,win2xxx-noc-sideband-manager";
+		reg = <0 0x52082000 0 0x10>;
+		SenseIn0 =
+			<SBM_LNOC_NPU_LLC0 	OFFSET0>,
+			<SBM_LNOC_NPU_LLC1 	OFFSET1>,
+			<SBM_LNOC_DDRT0_P0 	OFFSET2>,
+			<SBM_LNOC_DDRT1_P0 	OFFSET3>;
+		bf-name =
+			"SBM_LNOC_NPU_LLC0",
+			"SBM_LNOC_NPU_LLC1",
+			"SBM_LNOC_DDRT0_P0",
+			"SBM_LNOC_DDRT1_P0";
+	};
+
+	llcnoc_packet_ddr0_p0_req_probe@52080000 {
+		compatible = "eswin,win2xxx-noc-packet-probe";
+		reg = <0 0x52080000 0 0x4000>;
+		clocks = <&d0_clock EIC7700_CLK_DDRT0_P0_ACLK>;
+		clock-names = "clk";
+		interrupts = <445>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <1>;
+		counter,nr = <2>;
+		portsel = "ddr0_p0_req";
+	};
+	llcnoc_packet_ddr1_p0_req_probe@52080800 {
+		compatible = "eswin,win2xxx-noc-packet-probe";
+		reg = <0 0x52080800 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_DDRT1_P0_ACLK>;
+		clock-names = "clk";
+		interrupts = <443>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <1>;
+		counter,nr = <2>;
+		portsel = "ddr1_p0_req";
+	};
+	llcnoc_trans_probe@52081000 {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		compatible = "eswin,win2xxx-noc-trans-probe";
+		reg = <0 0x52081000 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_NOC_NSP_CLK>;
+		clock-names = "clk";
+		interrupts = <441>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <2>;
+		counter,nr = <8>;
+		profiler,nr = <1>;
+		portsel = "npu_llc0", "npu_llc1";
+		llcnoc_trans_npu_llc0_filter@52081480 {
+			status = "disabled";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52081480 0 0x80>;
+		};
+		llcnoc_trans_npu_llc1_filter@52081500 {
+			status = "disabled";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52081500 0 0x80>;
+		};
+		llcnoc_trans_profiler@52081580 {
+			compatible = "eswin,win2xxx-noc-trans-profiler";
+			reg = <0 0x52081580 0 0x80>;
+		};
+	};
+	ErrorLogger0 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x14 32 >;
+		description = "Register 0 to log errors";
+		lock {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0 1 >;
+			lut = "Not Locked", "Locked";
+		};
+		OpCode {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 1 4 >;
+			lut = "RD: data read with incrementing address",
+				"RDW: data read with wrapping address",
+				"RDL: allocates monitor in the Target with incrementing address",
+				"RDX: exclusive read with incrementing address",
+				"WR: data write with incrementing address",
+				"WRW: data write with wrapping address",
+				"WRC: conditional write if matching monitor in Target is found",
+				"RSV: reserved",
+				"PRE: preamble packet of linked sequence (locked sequence)",
+				"URG: urgency packet used for QoS (status must be REQ)";
+		};
+		ErrCode {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 8 3 >;
+			lut = "SLV (error source: Target): error detected by the Slave without any information or no Error",
+				"DEC (error source: Initiator NIU): decode error",
+				"UNS (error source: Target NIU): unsupported access type",
+				"DISC (error source: Power Disconnect): disconnected Target or NoC domain",
+				"SEC (error source: Initiator NIU or Firewall): security error",
+				"HIDE (error source: Firewall): hidden security error. Will be reported as OK to the initiator",
+				"TMO (error source: Target NIU): time-out",
+				"RSV: reserved";
+
+		};
+		Len1 {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 16 12 >;
+		};
+		Format {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 31 1 >;
+			lut = "NTTP v3.0 (Invalid)", "NTTP v3.5 (Ok)";
+		};
+	};
+
+	ErrorLogger1 {
+		compatible = "eswin,eic7700,register", "eswin,eic7700,noc,filter,routeid";
+		offset,length = < 0x18 32>;
+		description = "Register 1 to log errors";
+		InitFlow {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 14 2 >;
+			lut =
+				"npu_lnoc_llc0/I/0",
+				"npu_lnoc_llc1/I/0",
+				"snoc_lnoc/I/0",
+				"RESERVED";
+		};
+
+		TargetFlow {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 12 2 >;
+			lut =
+				"lnoc_ddrt0_p0/T/0",
+				"lnoc_ddrt1_p0/T/0",
+				"lnoc_service/T/0",
+				"RESERVED";
+		};
+
+		TargetSubRange {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 8 4 >;
+		};
+
+		SeqId {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0 8 >;
+		};
+	};
+
+	ErrorLogger3 {
+		/* This register does not really include a bitfield or its bitfield is 32 bits and it provides an offset address */
+		/* To calculate the absolute address, you must use the initflow:targetflow:subrange from ErrorLogger1 register */
+		/* And use it as an index in the aperture table. Then you must add the value of this register to the value given */
+		/* by the table to get the absolute address. */
+		compatible = "eswin,eic7700,register";
+		offset,length = <0x20 32>;
+		description = "Register 3 to log errors";
+		aperture-link = <1>; /* link to ErrorLogger whose information are required to calculate real absolute address */
+		msb-link = <4>; /*indicate which ErrorLogger contains the msb addrs, -1 means no*/
+		AbsoluteAddress {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 8 8 >;		/* bitfield initflow:targeflow:subrange from aperture-link register */
+			aperture-size= < 53 >;		/* Number of line in the aperture table below */
+			aperture-idx,aperture-base =		/* Aperture_idx is concatenation of initflow:targetflow:subrange bitfield from ErrorLogger1 */
+				/bits/ 64  <0x0	0x0	0x0	0x80000000      >,
+				/bits/ 64  <0x0	0x0	0x1	0x100000000     >,
+				/bits/ 64  <0x0	0x0	0x2	0x200000000     >,
+				/bits/ 64  <0x0	0x0	0x3	0x400000000     >,
+				/bits/ 64  <0x0	0x0	0x4	0x800000000     >,
+				/bits/ 64  <0x0	0x0	0x5	0x2000000000    >,
+				/bits/ 64  <0x0	0x0	0x6	0xc000000000    >,
+				/bits/ 64  <0x0	0x0	0x7	0xe000000000    >,
+				/bits/ 64  <0x0	0x0	0x8	0x4000000000    >,
+				/bits/ 64  <0x0	0x0	0x9	0x4000000100    >,
+				/bits/ 64  <0x0	0x0	0xa	0x10000000000   >,
+				/bits/ 64  <0x0	0x0	0xb	0x10000000100   >,
+				/bits/ 64  <0x0	0x0	0xc	0x0             >,
+				/bits/ 64  <0x0	0x1	0x0	0x80000080      >,
+				/bits/ 64  <0x0	0x1	0x1	0x100000080     >,
+				/bits/ 64  <0x0	0x1	0x2	0x200000080     >,
+				/bits/ 64  <0x0	0x1	0x3	0x400000080     >,
+				/bits/ 64  <0x0	0x1	0x4	0x800000080     >,
+				/bits/ 64  <0x0	0x1	0x5	0x2000000080    >,
+				/bits/ 64  <0x0	0x1	0x6	0xc000000080    >,
+				/bits/ 64  <0x0	0x1	0x7	0xe000000080    >,
+				/bits/ 64  <0x0	0x1	0x8	0x4000000080    >,
+				/bits/ 64  <0x0	0x1	0x9	0x4000000180    >,
+				/bits/ 64  <0x0	0x1	0xa	0x10000000080   >,
+				/bits/ 64  <0x0	0x1	0xb	0x10000000180   >,
+				/bits/ 64  <0x1	0x0	0x0	0x80000000      >,
+				/bits/ 64  <0x1	0x0	0x1	0x100000000     >,
+				/bits/ 64  <0x1	0x0	0x2	0x200000000     >,
+				/bits/ 64  <0x1	0x0	0x3	0x400000000     >,
+				/bits/ 64  <0x1	0x0	0x4	0x800000000     >,
+				/bits/ 64  <0x1	0x0	0x5	0x2000000000    >,
+				/bits/ 64  <0x1	0x0	0x6	0xc000000000    >,
+				/bits/ 64  <0x1	0x0	0x7	0xe000000000    >,
+				/bits/ 64  <0x1	0x0	0x8	0x4000000000    >,
+				/bits/ 64  <0x1	0x0	0x9	0x4000000100    >,
+				/bits/ 64  <0x1	0x0	0xa	0x10000000000   >,
+				/bits/ 64  <0x1	0x0	0xb	0x10000000100   >,
+				/bits/ 64  <0x1	0x0	0xc	0x0             >,
+				/bits/ 64  <0x1	0x1	0x0	0x80000080      >,
+				/bits/ 64  <0x1	0x1	0x1	0x100000080     >,
+				/bits/ 64  <0x1	0x1	0x2	0x200000080     >,
+				/bits/ 64  <0x1	0x1	0x3	0x400000080     >,
+				/bits/ 64  <0x1	0x1	0x4	0x800000080     >,
+				/bits/ 64  <0x1	0x1	0x5	0x2000000080    >,
+				/bits/ 64  <0x1	0x1	0x6	0xc000000080    >,
+				/bits/ 64  <0x1	0x1	0x7	0xe000000080    >,
+				/bits/ 64  <0x1	0x1	0x8	0x4000000080    >,
+				/bits/ 64  <0x1	0x1	0x9	0x4000000180    >,
+				/bits/ 64  <0x1	0x1	0xa	0x10000000080   >,
+				/bits/ 64  <0x1	0x1	0xb	0x10000000180   >,
+				/bits/ 64  <0x2	0x2	0x0	0x52080000      >,
+				/bits/ 64  <0x2	0x2	0x1	0x72080000      >,
+				/bits/ 64  <0x2	0x2	0x2	0x0             >;
+		};
+	};
+
+	ErrorLogger4 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x24 32>;
+		description = "Register 4 to log errors";
+		addr_msb {
+			compatible = "eswin,eic7700,bitfield";
+			description = "Stores NTTP packet header field Addr (MSBs) of the logged error";
+			offset,length = < 0 9 >;
+		};
+	};
+
+	ErrorLogger5 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x28 32 >;
+		description = "Register 5 to log errors";
+
+		User_flag {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0x0 16 >;
+			lut =
+				"Cache_0",
+				"Cache_1",
+				"Cache_2",
+				"Cache_3",
+				"Prot_0",
+				"Prot_1",
+				"Prot_2",
+				"Qos_0",
+				"Qos_1",
+				"Qos_2",
+				"Qos_3",
+				"User_0",
+				"User_1",
+				"User_2",
+				"User_3",
+				"User_4";
+		};
+	};
+};
+
+d0_sys_noc:d0_sys_noc@52002C00 {
+	compatible = "eswin,eic7700-noc";
+	#address-cells = <2>;
+	#size-cells = <2>;
+	ranges;
+	reg = <0 0x52002C00 0 0x4000>;
+	interrupts = <431>;
+	interrupt-names = "error";
+	interrupt-parent = <&plic0>;
+	errlogger,idx = <0 1 3 4 5>;
+
+	eswin,qos-configs = "DSPT", "NPU", "SPISLV_TBU3";
+	eswin,DSPT-qos-base = <0x52002C80>;
+	eswin,DSPT-qos-settings = <
+		0x8 0x4        /* prio */
+		0xC 0x2        /* mode 0:fixed 1:limiter 2:bypass 3:regulator*/
+		/* a number of (1/256)th of Bytes/cycle.
+		   Ex:zebu zdfi design feature, dsp AXI Clk=1040MHz, BW=12.1875MB/s, register value = (9.375/1040)*256 = 0x03
+		*/
+		0x10 0x03    /* bandwidth. 12.1875MB/s */
+		/*
+		   Saturation(B) = ((Requried Bandwidth)*(Windows Time of Bandwidth Calculation))/16
+		   Ex:16 byte saturation for BW=12.1875MB/s means 1.313us window time.
+		   The desired value is number of saturation bytes divided by 16(ex,1 for 16byte B)
+		*/
+		0x14 0x1     /* saturation, 1.313us*/
+		0x18 0x1>;   /* QoSEn */
+
+	eswin,NPU-qos-base = <0x52002D00>;
+	eswin,NPU-qos-settings = <
+		0x8 0x4      /* prio */
+		0xC 0x2      /* mode */
+		0x10 0x18    /* bandwidth */
+		0x14 0x10    /* saturation */
+		0x18 0x1>;   /* QoSEn */
+
+	eswin,SPISLV_TBU3-qos-base = <0x52002D80>;
+	eswin,SPISLV_TBU3-qos-settings = <
+		0x8 0x4      /* prio */
+		0xC 0x2      /* mode */
+		0x10 0x18    /* bandwidth */
+		0x14 0x10    /* saturation */
+		0x18 0x1>;   /* QoSEn */
+	sideband_manager@52004000 {
+		compatible = "eswin,win2xxx-noc-sideband-manager";
+		reg = <0 0x52004000 0 0x10>;
+		SenseIn0 =
+			<SBM_AON_SNOC_SP0 	OFFSET0>,
+			<SBM_DSPT_SNOC 		OFFSET1>,
+			<SBM_JTAG_SNOC 		OFFSET2>,
+			<SBM_MCPUT_SNOC_D2D 	OFFSET3>,
+			<SBM_MCPUT_SNOC_MP 	OFFSET4>,
+			<SBM_MCPUT_SNOC_SP0 	OFFSET5>,
+			<SBM_MCPUT_SNOC_SP1 	OFFSET6>,
+			<SBM_NPU_SNOC_SP0 	OFFSET7>,
+			<SBM_NPU_SNOC_SP1 	OFFSET8>,
+			<SBM_PCIET_SNOC_P 	OFFSET9>,
+			<SBM_SPISLV_PCIET_SNOC	OFFSET10>,
+			<SBM_TBU4_SNOC 		OFFSET11>,
+			<SBM_TCU_SNOC 		OFFSET12>,
+			<SBM_SNOC_AON 		OFFSET13>,
+			<SBM_SNOC_DDR0_P1 	OFFSET14>,
+			<SBM_SNOC_DDR0_P2 	OFFSET15>,
+			<SBM_SNOC_DDR1_P1 	OFFSET16>,
+			<SBM_SNOC_DDR1_P2 	OFFSET17>,
+			<SBM_SNOC_DSPT 		OFFSET18>,
+			<SBM_SNOC_MCPUT_D2D 	OFFSET19>,
+			<SBM_SNOC_NPU 		OFFSET20>,
+			<SBM_SNOC_PCIET 	OFFSET21>;
+		bf-name =
+			"SBM_AON_SNOC_SP0",
+			"SBM_DSPT_SNOC",
+			"SBM_JTAG_SNOC",
+			"SBM_MCPUT_SNOC_D2D ",
+			"SBM_MCPUT_SNOC_MP",
+			"SBM_MCPUT_SNOC_SP0",
+			"SBM_MCPUT_SNOC_SP1",
+			"SBM_NPU_SNOC_SP0",
+			"SBM_NPU_SNOC_SP1",
+			"SBM_PCIET_SNOC_P",
+			"SBM_SPISLV_PCIET_SNOC",
+			"SBM_TBU4_SNOC",
+			"SBM_TCU_SNOC",
+			"SBM_SNOC_AON",
+			"SBM_SNOC_DDR0_P1",
+			"SBM_SNOC_DDR0_P2",
+			"SBM_SNOC_DDR1_P1",
+			"SBM_SNOC_DDR1_P2",
+			"SBM_SNOC_DSPT",
+			"SBM_SNOC_MCPUT_D2D",
+			"SBM_SNOC_NPU",
+			"SBM_SNOC_PCIET";
+	};
+	sysnoc_packet_ddr0_p1_req_probe@52000000 {
+		compatible = "eswin,win2xxx-noc-packet-probe";
+		reg = <0 0x52000000 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_DDRT0_P1_ACLK>;
+		clock-names = "clk";
+		interrupts = <439>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <1>;
+		counter,nr = <2>;
+		portsel = "ddr0_p1_req";
+	};
+	sysnoc_packet_ddr0_p2_req_probe@52000800 {
+		compatible = "eswin,win2xxx-noc-packet-probe";
+		reg = <0 0x52000800 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_DDRT0_P2_ACLK>;
+		clock-names = "clk";
+		interrupts = <437>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <1>;
+		counter,nr = <2>;
+		portsel = "ddr0_p2_req";
+	};
+	sysnoc_packet_ddr1_p1_req_probe@52001000 {
+		compatible = "eswin,win2xxx-noc-packet-probe";
+		reg = <0 0x52001000 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_DDRT1_P1_ACLK>;
+		clock-names = "clk";
+		interrupts = <435>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <1>;
+		counter,nr = <2>;
+		portsel = "ddr1_p1_req";
+	};
+	sysnoc_packet_ddr1_p2_req_probe@52001800 {
+		compatible = "eswin,win2xxx-noc-packet-probe";
+		reg = <0 0x52001800 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_DDRT1_P2_ACLK>;
+		clock-names = "clk";
+		interrupts = <433>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <1>;
+		counter,nr = <2>;
+		portsel = "ddr1_p2_req";
+	};
+	sysnoc_trans_probe_0@52002000 {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		compatible = "eswin,win2xxx-noc-trans-probe";
+		reg = <0 0x52002000 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_NOC_NSP_CLK>;
+		clock-names = "clk";
+		interrupts = <430>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <2>;
+		counter,nr = <8>;
+		profiler,nr = <1>;
+		portsel = "dspt_snoc", "npu_sp1";
+		sysnoc_trans_dspt_filter@52002E00 {
+			status = "disabled";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52002E00 0 0x80>;
+		};
+		sysnoc_trans_npu_sp1_filter@52002F80 {
+			status = "disabled";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52002F80 0 0x80>;
+		};
+		sysnoc_trans_profiler@52003180 {
+			compatible = "eswin,win2xxx-noc-trans-profiler";
+			reg = <0 0x52003180 0 0x80>;
+		};
+	};
+	sysnoc_trans_probe_1@52002400 {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		compatible = "eswin,win2xxx-noc-trans-probe";
+		reg = <0 0x52002400 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_NOC_NSP_CLK>;
+		clock-names = "clk";
+		interrupts = <429>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <3>;
+		counter,nr = <12>;
+		profiler,nr = <1>;
+		portsel = "mcput_mp", "mcput_sp1", "tcu";
+		sysnoc_trans_mcput_mp_filter@52002E80 {
+			status = "okay";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52002E80 0 0x80>;
+		};
+		sysnoc_trans_mcput_sp1_filter@52002F00 {
+			status = "okay";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52002F00 0 0x80>;
+		};
+		sysnoc_trans_tcu_filter@52003100 {
+			status = "okay";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52003100 0 0x80>;
+		};
+		sysnoc_trans_profiler@52003200 {
+			compatible = "eswin,win2xxx-noc-trans-profiler";
+			reg = <0 0x52003200 0 0x80>;
+		};
+	};
+	sysnoc_trans_probe_2@52002800 {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		compatible = "eswin,win2xxx-noc-trans-probe";
+		reg = <0 0x52002800 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_NOC_NSP_CLK>;
+		clock-names = "clk";
+		interrupts = <428>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <2>;
+		counter,nr = <8>;
+		profiler,nr = <1>;
+		portsel = "spislv_tbu3", "tbu4_snoc";
+		sysnoc_trans_spislv_tbu3_filter@52003000 {	/*pcie subsys*/
+			status = "disabled";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52003000 0 0x80>;
+		};
+		sysnoc_trans_tbu4_filter@52003080 {	/*aon subsys*/
+			status = "disabled";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52003080 0 0x80>;
+		};
+		sysnoc_trans_profiler@52003280 {
+			compatible = "eswin,win2xxx-noc-trans-profiler";
+			reg = <0 0x52003280 0 0x80>;
+		};
+	};
+	ErrorLogger0 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x14 32 >;
+		description = "Register 0 to log errors";
+		lock {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0 1>;
+			lut = "Not Locked", "Locked";
+		};
+		OpCode {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 1 4>;
+			lut = "RD: data read with incrementing address",
+				"RDW: data read with wrapping address",
+				"RDL: allocates monitor in the Target with incrementing address",
+				"RDX: exclusive read with incrementing address",
+				"WR: data write with incrementing address",
+				"WRW: data write with wrapping address",
+				"WRC: conditional write if matching monitor in Target is found",
+				"RSV: reserved",
+				"PRE: preamble packet of linked sequence (locked sequence)",
+				"URG: urgency packet used for QoS (status must be REQ)";
+		};
+		ErrCode {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 8 3 >;
+			lut = "SLV (error source: Target): error detected by the Slave without any information or no Error",
+				"DEC (error source: Initiator NIU): decode error",
+				"UNS (error source: Target NIU): unsupported access type",
+				"DISC (error source: Power Disconnect): disconnected Target or NoC domain",
+				"SEC (error source: Initiator NIU or Firewall): security error",
+				"HIDE (error source: Firewall): hidden security error. Will be reported as OK to the initiator",
+				"TMO (error source: Target NIU): time-out",
+				"RSV: reserved";
+
+		};
+		Len1 {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 16 12 >;
+		};
+		Format {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 31 1 >;
+			lut = "NTTP v3.0 (Invalid)", "NTTP v3.5 (Ok)";
+		};
+	};
+
+	ErrorLogger1 {
+		compatible = "eswin,eic7700,register", "eswin,eic7700,noc,filter,routeid";
+		offset,length = < 0x18 32>;
+		description = "Register 1 to log errors";
+		InitFlow {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 19 4 >;
+			lut =
+				"aon_snoc_sp0/I/0",
+				"dspt_snoc/I/0",
+				"jtag_snoc/I/0",
+				"mcput_snoc_d2d/I/0",
+				"mcput_snoc_mp/I/0",
+				"mcput_snoc_sp0/I/0",
+				"mcput_snoc_sp1/I/0",
+				"mnoc_snoc/I/0",
+				"npu_snoc_sp0/I/0",
+				"npu_snoc_sp1/I/0",
+				"pciet_snoc_p/I/0",
+				"rnoc_snoc/I/0",
+				"spislv_tbu3_snoc/I/0",
+				"tbu4_snoc/I/0",
+				"tcu_snoc/I/0",
+				"RESERVED0";
+		};
+
+		TargetFlow {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 15 4 >;
+			lut =
+				"snoc_aon/T/0",
+				"snoc_cnoc/T/0",
+				"snoc_ddrt0_p1/T/0",
+				"snoc_ddrt0_p2/T/0",
+				"snoc_ddrt1_p1/T/0",
+				"snoc_ddrt1_p2/T/0",
+				"snoc_dspt/T/0",
+				"snoc_lnoc/T/0",
+				"snoc_mcput_d2d/T/0",
+				"snoc_mnoc/T/0",
+				"snoc_npu/T/0",
+				"snoc_pciet/T/0",
+				"snoc_rnoc/T/0",
+				"snoc_service/T/0",
+				"RESERVED1",
+				"RESERVED2";
+		};
+
+		TargetSubRange {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 9 6 >;
+		};
+
+		SeqId {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0 9 >;
+		};
+	};
+
+	ErrorLogger3 {
+		/* This register does not really include a bitfield or its bitfield is 32 bits and it provides an offset address */
+		/* To calculate the absolute address, you must use the initflow:targetflow:subrange from ErrorLogger1 register */
+		/* And use it as an index in the aperture table. Then you must add the value of this register to the value given */
+		/* by the table to get the absolute address. */
+		compatible = "eswin,eic7700,register";
+		offset,length = <0x20 32>;
+		description = "Register 3 to log errors";
+		aperture-link = <1>; /* link to ErrorLogger whose information are required to calculate real absolute address */
+		msb-link = <4>; /*indicate which ErrorLogger contains the msb addrs, -1 means no*/
+		AbsoluteAddress {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 9 14 >;		/* bitfield initflow:targeflow:subrange from aperture-link register */
+			aperture-size= < 1181 >;		/* Number of line in the aperture table below */
+			aperture-idx,aperture-base =		/* Aperture_idx is concatenation of initflow:targetflow:subrange bitfield from ErrorLogger1 */
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0x0             0x52060000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0x1             0x72060000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0x2             0x52100000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0x3             0x52200000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0x4             0x52300000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0x5             0x72100000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0x6             0x72200000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0x7             0x72300000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0x8             0x53000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0x9             0x73000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0xa             0x50000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0xb             0x70000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0xc             0x54000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0xd             0x74000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0xe             0x0               >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0xf             0x0               >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_cnoc_T_O      0x10            0x0               >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_dspt_T_O      0x0             0x520e0000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_dspt_T_O      0x1             0x720e0000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_dspt_T_O      0x2             0x5b000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_dspt_T_O      0x3             0x7b000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_lnoc_T_O      0x0             0x52080000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_lnoc_T_O      0x1             0x72080000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x0             0x58400000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x1             0x78400000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x2             0x58800000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x3             0x78800000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x4             0x59000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x5             0x5a000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x6             0x5b000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x7             0x79000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x8             0x7a000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x9             0x7b000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0xa             0x50000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0xb             0x70000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0xc             0x40000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0xd             0x60000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mnoc_T_O      0x0             0x52020000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_mnoc_T_O      0x1             0x72020000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_npu_T_O       0x0             0x52080000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_npu_T_O       0x1             0x72080000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_npu_T_O       0x2             0x59000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_npu_T_O       0x3             0x5a000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_npu_T_O       0x4             0x79000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_npu_T_O       0x5             0x7a000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_pciet_T_O     0x0             0x40000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_pciet_T_O     0x1             0x60000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_rnoc_T_O      0x0             0x52040000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_rnoc_T_O      0x1             0x72040000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_service_T_O   0x0             0x52000000        >,
+				/bits/ 64  <aon_snoc_sp0_I_O     snoc_service_T_O   0x1             0x72000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0x0             0x520c0000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0x1             0x720c0000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0x2             0x58400000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0x3             0x78400000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0x4             0x14000400000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0x5             0x14008400000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0x6             0x58800000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0x7             0x78800000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0x8             0x14000800000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0x9             0x14008800000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0xa             0x5c000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0xb             0x7c000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0xc             0x14004000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_aon_T_O       0xd             0x1400c000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0x0             0x52060000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0x1             0x72060000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0x2             0x52100000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0x3             0x52200000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0x4             0x52300000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0x5             0x72100000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0x6             0x72200000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0x7             0x72300000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0x8             0x53000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0x9             0x73000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0xa             0x50000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0xb             0x70000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0xc             0x54000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0xd             0x74000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_cnoc_T_O      0xe             0x0               >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0x0             0x80000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0x1             0x100000000       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0x2             0x200000000       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0x3             0x400000000       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0x4             0x800000000       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0x5             0x2000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0x6             0xc000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0x7             0xe000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0x8             0x4000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0x9             0x4000000100      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0xa             0x10000000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt0_p2_T_O  0xb             0x10000000100     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0x0             0x80000080        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0x1             0x100000080       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0x2             0x200000080       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0x3             0x400000080       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0x4             0x800000080       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0x5             0x2000000080      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0x6             0xc000000080      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0x7             0xe000000080      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0x8             0x4000000080      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0x9             0x4000000180      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0xa             0x10000000080     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_ddrt1_p2_T_O  0xb             0x10000000180     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x0             0x58400000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x1             0x78400000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x2             0x14000400000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x3             0x14008400000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x4             0x58800000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x5             0x78800000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x6             0x14000800000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x7             0x14008800000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x8             0x59000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x9             0x5a000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0xa             0x5b000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0xb             0x79000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0xc             0x7a000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0xd             0x7b000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0xe             0x14001000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0xf             0x14002000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x10            0x14003000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x11            0x14009000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x12            0x1400a000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x13            0x1400b000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x14            0x50000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x15            0x70000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x16            0x40000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x17            0x60000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x18            0x80000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x19            0x100000000       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x1a            0x200000000       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x1b            0x400000000       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x1c            0x800000000       >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x1d            0x1800000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x1e            0x3800000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x1f            0xd800000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x20            0xf800000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x21            0x2000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x22            0x7000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x23            0x7000000100      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x24            0xc000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x25            0xe000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x26            0x13000000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x27            0x13000000100     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x28            0x4000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x29            0x4000000100      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x2a            0x8000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x2b            0xa000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x2c            0x10000000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_mcput_d2d_T_O 0x2d            0x10000000100     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x0             0x52080000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x1             0x72080000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x2             0x59000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x3             0x5a000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x4             0x79000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x5             0x7a000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x6             0x14001000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x7             0x14002000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x8             0x14009000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x9             0x1400a000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0xa             0x1800000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0xb             0x3800000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0xc             0xd800000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0xd             0xf800000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0xe             0x7000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0xf             0x7000000100      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x10            0x13000000000     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_npu_T_O       0x11            0x13000000100     >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_pciet_T_O     0x0             0x40000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_pciet_T_O     0x1             0x60000000        >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_pciet_T_O     0x2             0x8000000000      >,
+				/bits/ 64  <dspt_snoc_I_O        snoc_pciet_T_O     0x3             0xa000000000      >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0x0             0x52060000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0x1             0x72060000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0x2             0x52100000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0x3             0x52200000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0x4             0x52300000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0x5             0x72100000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0x6             0x72200000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0x7             0x72300000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0x8             0x53000000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0x9             0x73000000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0xa             0x50000000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0xb             0x70000000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0xc             0x54000000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0xd             0x74000000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0xe             0x0               >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0xf             0x0               >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_cnoc_T_O      0x10            0x0               >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_lnoc_T_O      0x0             0x52080000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_lnoc_T_O      0x1             0x72080000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_mnoc_T_O      0x0             0x52020000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_mnoc_T_O      0x1             0x72020000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_rnoc_T_O      0x0             0x52040000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_rnoc_T_O      0x1             0x72040000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_service_T_O   0x0             0x52000000        >,
+				/bits/ 64  <jtag_snoc_I_O        snoc_service_T_O   0x1             0x72000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0x0             0x520c0000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0x1             0x720c0000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0x2             0x58400000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0x3             0x78400000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0x4             0x14000400000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0x5             0x14008400000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0x6             0x58800000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0x7             0x78800000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0x8             0x14000800000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0x9             0x14008800000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0xa             0x5c000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0xb             0x7c000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0xc             0x14004000000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_aon_T_O       0xd             0x1400c000000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0x0             0x52060000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0x1             0x72060000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0x2             0x52100000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0x3             0x52200000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0x4             0x52300000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0x5             0x72100000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0x6             0x72200000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0x7             0x72300000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0x8             0x53000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0x9             0x73000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0xa             0x50000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0xb             0x70000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0xc             0x54000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0xd             0x74000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_cnoc_T_O      0xe             0x0               >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0x0             0x80000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0x1             0x100000000       >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0x2             0x200000000       >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0x3             0x400000000       >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0x4             0x800000000       >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0x5             0x2000000000      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0x6             0xc000000000      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0x7             0xe000000000      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0x8             0x4000000000      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0x9             0x4000000100      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0xa             0x10000000000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt0_p2_T_O  0xb             0x10000000100     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0x0             0x80000080        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0x1             0x100000080       >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0x2             0x200000080       >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0x3             0x400000080       >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0x4             0x800000080       >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0x5             0x2000000080      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0x6             0xc000000080      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0x7             0xe000000080      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0x8             0x4000000080      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0x9             0x4000000180      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0xa             0x10000000080     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_ddrt1_p2_T_O  0xb             0x10000000180     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_dspt_T_O      0x0             0x520e0000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_dspt_T_O      0x1             0x720e0000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_dspt_T_O      0x2             0x5b000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_dspt_T_O      0x3             0x7b000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_dspt_T_O      0x4             0x14003000000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_dspt_T_O      0x5             0x1400b000000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_lnoc_T_O      0x0             0x52080000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_lnoc_T_O      0x1             0x72080000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_mnoc_T_O      0x0             0x52020000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_mnoc_T_O      0x1             0x72020000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x0             0x52080000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x1             0x72080000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x2             0x59000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x3             0x5a000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x4             0x79000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x5             0x7a000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x6             0x14001000000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x7             0x14002000000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x8             0x14009000000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x9             0x1400a000000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0xa             0x1800000000      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0xb             0x3800000000      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0xc             0xd800000000      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0xd             0xf800000000      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0xe             0x7000000000      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0xf             0x7000000100      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x10            0x13000000000     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_npu_T_O       0x11            0x13000000100     >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_pciet_T_O     0x0             0x40000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_pciet_T_O     0x1             0x60000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_pciet_T_O     0x2             0x8000000000      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_pciet_T_O     0x3             0xa000000000      >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_rnoc_T_O      0x0             0x52040000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_rnoc_T_O      0x1             0x72040000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_service_T_O   0x0             0x52000000        >,
+				/bits/ 64  <mcput_snoc_d2d_I_O   snoc_service_T_O   0x1             0x72000000        >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt0_p1_T_O  0x0             0x80000000        >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt0_p1_T_O  0x1             0x100000000       >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt0_p1_T_O  0x2             0x200000000       >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt0_p1_T_O  0x3             0x400000000       >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt0_p1_T_O  0x4             0x800000000       >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt0_p1_T_O  0x5             0x2000000000      >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt0_p1_T_O  0x6             0x4000000000      >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt0_p1_T_O  0x7             0x4000000100      >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt1_p1_T_O  0x0             0x80000080        >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt1_p1_T_O  0x1             0x100000080       >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt1_p1_T_O  0x2             0x200000080       >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt1_p1_T_O  0x3             0x400000080       >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt1_p1_T_O  0x4             0x800000080       >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt1_p1_T_O  0x5             0x2000000080      >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt1_p1_T_O  0x6             0x4000000080      >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_ddrt1_p1_T_O  0x7             0x4000000180      >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0x0             0x52080000        >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0x1             0x72080000        >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0x2             0x59000000        >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0x3             0x5a000000        >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0x4             0x79000000        >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0x5             0x7a000000        >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0x6             0x1800000000      >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0x7             0x3800000000      >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0x8             0x7000000000      >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0x9             0x7000000100      >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0xa             0x0               >,
+				/bits/ 64  <mcput_snoc_mp_I_O    snoc_npu_T_O       0xb             0x0               >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_aon_T_O       0x0             0x520c0000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_aon_T_O       0x1             0x720c0000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_aon_T_O       0x2             0x58400000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_aon_T_O       0x3             0x78400000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_aon_T_O       0x4             0x58800000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_aon_T_O       0x5             0x78800000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_aon_T_O       0x6             0x5c000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_aon_T_O       0x7             0x7c000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0x0             0x52060000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0x1             0x72060000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0x2             0x52100000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0x3             0x52200000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0x4             0x52300000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0x5             0x72100000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0x6             0x72200000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0x7             0x72300000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0x8             0x53000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0x9             0x73000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0xa             0x50000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0xb             0x70000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0xc             0x54000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0xd             0x74000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_cnoc_T_O      0xe             0x0               >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_dspt_T_O      0x0             0x520e0000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_dspt_T_O      0x1             0x720e0000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_dspt_T_O      0x2             0x5b000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_dspt_T_O      0x3             0x7b000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_lnoc_T_O      0x0             0x52080000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_lnoc_T_O      0x1             0x72080000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0x0             0x58400000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0x1             0x78400000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0x2             0x58800000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0x3             0x78800000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0x4             0x59000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0x5             0x5a000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0x6             0x5b000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0x7             0x79000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0x8             0x7a000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0x9             0x7b000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0xa             0x50000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0xb             0x70000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0xc             0x40000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mcput_d2d_T_O 0xd             0x60000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mnoc_T_O      0x0             0x52020000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_mnoc_T_O      0x1             0x72020000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_npu_T_O       0x0             0x52080000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_npu_T_O       0x1             0x72080000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_npu_T_O       0x2             0x59000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_npu_T_O       0x3             0x5a000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_npu_T_O       0x4             0x79000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_npu_T_O       0x5             0x7a000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_pciet_T_O     0x0             0x40000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_pciet_T_O     0x1             0x60000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_rnoc_T_O      0x0             0x52040000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_rnoc_T_O      0x1             0x72040000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_service_T_O   0x0             0x52000000        >,
+				/bits/ 64  <mcput_snoc_sp0_I_O   snoc_service_T_O   0x1             0x72000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0x0             0x520c0000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0x1             0x720c0000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0x2             0x58400000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0x3             0x78400000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0x4             0x14000400000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0x5             0x14008400000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0x6             0x58800000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0x7             0x78800000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0x8             0x14000800000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0x9             0x14008800000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0xa             0x5c000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0xb             0x7c000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0xc             0x14004000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0xd             0x1400c000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0xe             0x0               >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_aon_T_O       0xf             0x0               >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0x0             0x80000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0x1             0x100000000       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0x2             0x200000000       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0x3             0x400000000       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0x4             0x800000000       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0x5             0x2000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0x6             0xc000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0x7             0xe000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0x8             0x4000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0x9             0x4000000100      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0xa             0x10000000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt0_p2_T_O  0xb             0x10000000100     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0x0             0x80000080        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0x1             0x100000080       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0x2             0x200000080       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0x3             0x400000080       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0x4             0x800000080       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0x5             0x2000000080      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0x6             0xc000000080      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0x7             0xe000000080      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0x8             0x4000000080      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0x9             0x4000000180      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0xa             0x10000000080     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_ddrt1_p2_T_O  0xb             0x10000000180     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_dspt_T_O      0x0             0x520e0000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_dspt_T_O      0x1             0x720e0000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_dspt_T_O      0x2             0x5b000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_dspt_T_O      0x3             0x7b000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_dspt_T_O      0x4             0x14003000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_dspt_T_O      0x5             0x1400b000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x0             0x58400000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x1             0x78400000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x2             0x14000400000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x3             0x14008400000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x4             0x58800000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x5             0x78800000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x6             0x14000800000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x7             0x14008800000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x8             0x59000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x9             0x5a000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0xa             0x5b000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0xb             0x79000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0xc             0x7a000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0xd             0x7b000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0xe             0x14001000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0xf             0x14002000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x10            0x14003000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x11            0x14009000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x12            0x1400a000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x13            0x1400b000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x14            0x50000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x15            0x70000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x16            0x40000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x17            0x60000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x18            0x80000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x19            0x100000000       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x1a            0x200000000       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x1b            0x400000000       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x1c            0x800000000       >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x1d            0x1800000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x1e            0x3800000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x1f            0xd800000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x20            0xf800000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x21            0x2000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x22            0x7000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x23            0x7000000100      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x24            0xc000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x25            0xe000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x26            0x13000000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x27            0x13000000100     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x28            0x4000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x29            0x4000000100      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x2a            0x8000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x2b            0xa000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x2c            0x10000000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_mcput_d2d_T_O 0x2d            0x10000000100     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x0             0x52080000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x1             0x72080000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x2             0x59000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x3             0x5a000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x4             0x79000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x5             0x7a000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x6             0x14001000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x7             0x14002000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x8             0x14009000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x9             0x1400a000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0xa             0x1800000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0xb             0x3800000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0xc             0xd800000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0xd             0xf800000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0xe             0x7000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0xf             0x7000000100      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x10            0x13000000000     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_npu_T_O       0x11            0x13000000100     >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_pciet_T_O     0x0             0x40000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_pciet_T_O     0x1             0x60000000        >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_pciet_T_O     0x2             0x8000000000      >,
+				/bits/ 64  <mcput_snoc_sp1_I_O   snoc_pciet_T_O     0x3             0xa000000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0x0             0x52060000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0x1             0x72060000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0x2             0x52100000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0x3             0x52200000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0x4             0x52300000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0x5             0x72100000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0x6             0x72200000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0x7             0x72300000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0x8             0x53000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0x9             0x73000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0xa             0x50000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0xb             0x70000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0xc             0x54000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0xd             0x74000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_cnoc_T_O      0xe             0x0               >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_dspt_T_O      0x0             0x520e0000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_dspt_T_O      0x1             0x720e0000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_dspt_T_O      0x2             0x5b000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_dspt_T_O      0x3             0x7b000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_dspt_T_O      0x4             0x14003000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_dspt_T_O      0x5             0x1400b000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x0             0x58400000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x1             0x78400000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x2             0x14000400000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x3             0x14008400000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x4             0x58800000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x5             0x78800000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x6             0x14000800000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x7             0x14008800000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x8             0x59000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x9             0x5a000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0xa             0x5b000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0xb             0x79000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0xc             0x7a000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0xd             0x7b000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0xe             0x14001000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0xf             0x14002000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x10            0x14003000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x11            0x14009000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x12            0x1400a000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x13            0x1400b000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x14            0x50000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x15            0x70000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x16            0x40000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x17            0x60000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x18            0x80000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x19            0x100000000       >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x1a            0x200000000       >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x1b            0x400000000       >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x1c            0x800000000       >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x1d            0x1800000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x1e            0x3800000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x1f            0xd800000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x20            0xf800000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x21            0x2000000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x22            0x7000000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x23            0x7000000100      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x24            0xc000000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x25            0xe000000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x26            0x13000000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x27            0x13000000100     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x28            0x4000000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x29            0x4000000100      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x2a            0x8000000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x2b            0xa000000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x2c            0x10000000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_mcput_d2d_T_O 0x2d            0x10000000100     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x0             0x52080000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x1             0x72080000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x2             0x59000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x3             0x5a000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x4             0x79000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x5             0x7a000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x6             0x14001000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x7             0x14002000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x8             0x14009000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x9             0x1400a000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0xa             0x1800000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0xb             0x3800000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0xc             0xd800000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0xd             0xf800000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0xe             0x7000000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0xf             0x7000000100      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x10            0x13000000000     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_npu_T_O       0x11            0x13000000100     >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_pciet_T_O     0x0             0x40000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_pciet_T_O     0x1             0x60000000        >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_pciet_T_O     0x2             0x8000000000      >,
+				/bits/ 64  <mnoc_snoc_I_O        snoc_pciet_T_O     0x3             0xa000000000      >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_aon_T_O       0x0             0x520c0000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_aon_T_O       0x1             0x720c0000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_aon_T_O       0x2             0x58400000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_aon_T_O       0x3             0x78400000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_aon_T_O       0x4             0x58800000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_aon_T_O       0x5             0x78800000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_aon_T_O       0x6             0x5c000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_aon_T_O       0x7             0x7c000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0x0             0x52060000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0x1             0x72060000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0x2             0x52100000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0x3             0x52200000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0x4             0x52300000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0x5             0x72100000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0x6             0x72200000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0x7             0x72300000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0x8             0x53000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0x9             0x73000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0xa             0x50000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0xb             0x70000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0xc             0x54000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0xd             0x74000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0xe             0x0               >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0xf             0x0               >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_cnoc_T_O      0x10            0x0               >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_dspt_T_O      0x0             0x520e0000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_dspt_T_O      0x1             0x720e0000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_dspt_T_O      0x2             0x5b000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_dspt_T_O      0x3             0x7b000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_lnoc_T_O      0x0             0x52080000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_lnoc_T_O      0x1             0x72080000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x0             0x58400000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x1             0x78400000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x2             0x58800000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x3             0x78800000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x4             0x59000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x5             0x5a000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x6             0x5b000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x7             0x79000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x8             0x7a000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0x9             0x7b000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0xa             0x50000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0xb             0x70000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0xc             0x40000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mcput_d2d_T_O 0xd             0x60000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mnoc_T_O      0x0             0x52020000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_mnoc_T_O      0x1             0x72020000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_pciet_T_O     0x0             0x40000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_pciet_T_O     0x1             0x60000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_rnoc_T_O      0x0             0x52040000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_rnoc_T_O      0x1             0x72040000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_service_T_O   0x0             0x52000000        >,
+				/bits/ 64  <npu_snoc_sp0_I_O     snoc_service_T_O   0x1             0x72000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0x0             0x520c0000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0x1             0x720c0000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0x2             0x58400000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0x3             0x78400000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0x4             0x14000400000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0x5             0x14008400000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0x6             0x58800000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0x7             0x78800000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0x8             0x14000800000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0x9             0x14008800000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0xa             0x5c000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0xb             0x7c000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0xc             0x14004000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0xd             0x1400c000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0xe             0x0               >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_aon_T_O       0xf             0x0               >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0x0             0x80000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0x1             0x100000000       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0x2             0x200000000       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0x3             0x400000000       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0x4             0x800000000       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0x5             0x2000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0x6             0xc000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0x7             0xe000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0x8             0x4000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0x9             0x4000000100      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0xa             0x10000000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt0_p2_T_O  0xb             0x10000000100     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0x0             0x80000080        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0x1             0x100000080       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0x2             0x200000080       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0x3             0x400000080       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0x4             0x800000080       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0x5             0x2000000080      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0x6             0xc000000080      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0x7             0xe000000080      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0x8             0x4000000080      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0x9             0x4000000180      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0xa             0x10000000080     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_ddrt1_p2_T_O  0xb             0x10000000180     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_dspt_T_O      0x0             0x520e0000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_dspt_T_O      0x1             0x720e0000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_dspt_T_O      0x2             0x5b000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_dspt_T_O      0x3             0x7b000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_dspt_T_O      0x4             0x14003000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_dspt_T_O      0x5             0x1400b000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x0             0x58400000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x1             0x78400000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x2             0x14000400000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x3             0x14008400000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x4             0x58800000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x5             0x78800000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x6             0x14000800000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x7             0x14008800000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x8             0x59000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x9             0x5a000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0xa             0x5b000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0xb             0x79000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0xc             0x7a000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0xd             0x7b000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0xe             0x14001000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0xf             0x14002000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x10            0x14003000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x11            0x14009000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x12            0x1400a000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x13            0x1400b000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x14            0x50000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x15            0x70000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x16            0x40000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x17            0x60000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x18            0x80000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x19            0x100000000       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x1a            0x200000000       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x1b            0x400000000       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x1c            0x800000000       >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x1d            0x1800000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x1e            0x3800000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x1f            0xd800000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x20            0xf800000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x21            0x2000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x22            0x7000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x23            0x7000000100      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x24            0xc000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x25            0xe000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x26            0x13000000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x27            0x13000000100     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x28            0x4000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x29            0x4000000100      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x2a            0x8000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x2b            0xa000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x2c            0x10000000000     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_mcput_d2d_T_O 0x2d            0x10000000100     >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_pciet_T_O     0x0             0x40000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_pciet_T_O     0x1             0x60000000        >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_pciet_T_O     0x2             0x8000000000      >,
+				/bits/ 64  <npu_snoc_sp1_I_O     snoc_pciet_T_O     0x3             0xa000000000      >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0x0             0x52060000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0x1             0x72060000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0x2             0x52100000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0x3             0x52200000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0x4             0x52300000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0x5             0x72100000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0x6             0x72200000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0x7             0x72300000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0x8             0x53000000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0x9             0x73000000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0xa             0x50000000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0xb             0x70000000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0xc             0x54000000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0xd             0x74000000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0xe             0x0               >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0xf             0x0               >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_cnoc_T_O      0x10            0x0               >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_lnoc_T_O      0x0             0x52080000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_lnoc_T_O      0x1             0x72080000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_mnoc_T_O      0x0             0x52020000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_mnoc_T_O      0x1             0x72020000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_rnoc_T_O      0x0             0x52040000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_rnoc_T_O      0x1             0x72040000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_service_T_O   0x0             0x52000000        >,
+				/bits/ 64  <pciet_snoc_p_I_O     snoc_service_T_O   0x1             0x72000000        >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x0             0x52080000        >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x1             0x72080000        >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x2             0x59000000        >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x3             0x5a000000        >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x4             0x79000000        >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x5             0x7a000000        >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x6             0x14001000000     >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x7             0x14002000000     >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x8             0x14009000000     >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x9             0x1400a000000     >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0xa             0x1800000000      >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0xb             0x3800000000      >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0xc             0xd800000000      >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0xd             0xf800000000      >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0xe             0x7000000000      >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0xf             0x7000000100      >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x10            0x13000000000     >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x11            0x13000000100     >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x12            0x0               >,
+				/bits/ 64  <rnoc_snoc_I_O        snoc_npu_T_O       0x13            0x0               >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0x0             0x520c0000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0x1             0x720c0000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0x2             0x58400000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0x3             0x78400000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0x4             0x14000400000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0x5             0x14008400000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0x6             0x58800000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0x7             0x78800000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0x8             0x14000800000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0x9             0x14008800000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0xa             0x5c000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0xb             0x7c000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0xc             0x14004000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_aon_T_O       0xd             0x1400c000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0x0             0x52060000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0x1             0x72060000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0x2             0x52100000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0x3             0x52200000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0x4             0x52300000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0x5             0x72100000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0x6             0x72200000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0x7             0x72300000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0x8             0x53000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0x9             0x73000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0xa             0x50000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0xb             0x70000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0xc             0x54000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0xd             0x74000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_cnoc_T_O      0xe             0x0               >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0x0             0x80000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0x1             0x100000000       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0x2             0x200000000       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0x3             0x400000000       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0x4             0x800000000       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0x5             0x2000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0x6             0xc000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0x7             0xe000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0x8             0x4000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0x9             0x4000000100      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0xa             0x10000000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt0_p2_T_O  0xb             0x10000000100     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0x0             0x80000080        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0x1             0x100000080       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0x2             0x200000080       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0x3             0x400000080       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0x4             0x800000080       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0x5             0x2000000080      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0x6             0xc000000080      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0x7             0xe000000080      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0x8             0x4000000080      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0x9             0x4000000180      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0xa             0x10000000080     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_ddrt1_p2_T_O  0xb             0x10000000180     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_dspt_T_O      0x0             0x520e0000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_dspt_T_O      0x1             0x720e0000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_dspt_T_O      0x2             0x5b000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_dspt_T_O      0x3             0x7b000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_dspt_T_O      0x4             0x14003000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_dspt_T_O      0x5             0x1400b000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_lnoc_T_O      0x0             0x52080000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_lnoc_T_O      0x1             0x72080000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x0             0x58400000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x1             0x78400000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x2             0x14000400000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x3             0x14008400000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x4             0x58800000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x5             0x78800000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x6             0x14000800000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x7             0x14008800000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x8             0x59000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x9             0x5a000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0xa             0x5b000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0xb             0x79000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0xc             0x7a000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0xd             0x7b000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0xe             0x14001000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0xf             0x14002000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x10            0x14003000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x11            0x14009000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x12            0x1400a000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x13            0x1400b000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x14            0x50000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x15            0x70000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x16            0x40000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x17            0x60000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x18            0x80000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x19            0x100000000       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x1a            0x200000000       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x1b            0x400000000       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x1c            0x800000000       >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x1d            0x1800000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x1e            0x3800000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x1f            0xd800000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x20            0xf800000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x21            0x2000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x22            0x7000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x23            0x7000000100      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x24            0xc000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x25            0xe000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x26            0x13000000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x27            0x13000000100     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x28            0x4000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x29            0x4000000100      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x2a            0x8000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x2b            0xa000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x2c            0x10000000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mcput_d2d_T_O 0x2d            0x10000000100     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mnoc_T_O      0x0             0x52020000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_mnoc_T_O      0x1             0x72020000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x0             0x52080000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x1             0x72080000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x2             0x59000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x3             0x5a000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x4             0x79000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x5             0x7a000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x6             0x14001000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x7             0x14002000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x8             0x14009000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x9             0x1400a000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0xa             0x1800000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0xb             0x3800000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0xc             0xd800000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0xd             0xf800000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0xe             0x7000000000      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0xf             0x7000000100      >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x10            0x13000000000     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_npu_T_O       0x11            0x13000000100     >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_rnoc_T_O      0x0             0x52040000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_rnoc_T_O      0x1             0x72040000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_service_T_O   0x0             0x52000000        >,
+				/bits/ 64  <spislv_tbu3_snoc_I_O snoc_service_T_O   0x1             0x72000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0x0             0x80000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0x1             0x100000000       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0x2             0x200000000       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0x3             0x400000000       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0x4             0x800000000       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0x5             0x2000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0x6             0xc000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0x7             0xe000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0x8             0x4000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0x9             0x4000000100      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0xa             0x10000000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt0_p2_T_O  0xb             0x10000000100     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0x0             0x80000080        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0x1             0x100000080       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0x2             0x200000080       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0x3             0x400000080       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0x4             0x800000080       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0x5             0x2000000080      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0x6             0xc000000080      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0x7             0xe000000080      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0x8             0x4000000080      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0x9             0x4000000180      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0xa             0x10000000080     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_ddrt1_p2_T_O  0xb             0x10000000180     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_dspt_T_O      0x0             0x520e0000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_dspt_T_O      0x1             0x720e0000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_dspt_T_O      0x2             0x5b000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_dspt_T_O      0x3             0x7b000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_dspt_T_O      0x4             0x14003000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_dspt_T_O      0x5             0x1400b000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x0             0x58400000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x1             0x78400000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x2             0x14000400000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x3             0x14008400000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x4             0x58800000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x5             0x78800000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x6             0x14000800000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x7             0x14008800000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x8             0x59000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x9             0x5a000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0xa             0x5b000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0xb             0x79000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0xc             0x7a000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0xd             0x7b000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0xe             0x14001000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0xf             0x14002000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x10            0x14003000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x11            0x14009000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x12            0x1400a000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x13            0x1400b000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x14            0x50000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x15            0x70000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x16            0x40000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x17            0x60000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x18            0x80000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x19            0x100000000       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x1a            0x200000000       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x1b            0x400000000       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x1c            0x800000000       >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x1d            0x1800000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x1e            0x3800000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x1f            0xd800000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x20            0xf800000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x21            0x2000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x22            0x7000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x23            0x7000000100      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x24            0xc000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x25            0xe000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x26            0x13000000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x27            0x13000000100     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x28            0x4000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x29            0x4000000100      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x2a            0x8000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x2b            0xa000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x2c            0x10000000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_mcput_d2d_T_O 0x2d            0x10000000100     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x0             0x52080000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x1             0x72080000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x2             0x59000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x3             0x5a000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x4             0x79000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x5             0x7a000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x6             0x14001000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x7             0x14002000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x8             0x14009000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x9             0x1400a000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0xa             0x1800000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0xb             0x3800000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0xc             0xd800000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0xd             0xf800000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0xe             0x7000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0xf             0x7000000100      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x10            0x13000000000     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x11            0x13000000100     >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x12            0x0               >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_npu_T_O       0x13            0x0               >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_pciet_T_O     0x0             0x40000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_pciet_T_O     0x1             0x60000000        >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_pciet_T_O     0x2             0x8000000000      >,
+				/bits/ 64  <tbu4_snoc_I_O        snoc_pciet_T_O     0x3             0xa000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0x0             0x80000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0x1             0x100000000       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0x2             0x200000000       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0x3             0x400000000       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0x4             0x800000000       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0x5             0x2000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0x6             0xc000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0x7             0xe000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0x8             0x4000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0x9             0x4000000100      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0xa             0x10000000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt0_p2_T_O  0xb             0x10000000100     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0x0             0x80000080        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0x1             0x100000080       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0x2             0x200000080       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0x3             0x400000080       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0x4             0x800000080       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0x5             0x2000000080      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0x6             0xc000000080      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0x7             0xe000000080      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0x8             0x4000000080      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0x9             0x4000000180      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0xa             0x10000000080     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_ddrt1_p2_T_O  0xb             0x10000000180     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_dspt_T_O      0x0             0x520e0000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_dspt_T_O      0x1             0x720e0000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_dspt_T_O      0x2             0x5b000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_dspt_T_O      0x3             0x7b000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_dspt_T_O      0x4             0x14003000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_dspt_T_O      0x5             0x1400b000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x0             0x58400000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x1             0x78400000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x2             0x14000400000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x3             0x14008400000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x4             0x58800000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x5             0x78800000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x6             0x14000800000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x7             0x14008800000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x8             0x59000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x9             0x5a000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0xa             0x5b000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0xb             0x79000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0xc             0x7a000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0xd             0x7b000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0xe             0x14001000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0xf             0x14002000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x10            0x14003000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x11            0x14009000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x12            0x1400a000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x13            0x1400b000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x14            0x50000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x15            0x70000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x16            0x40000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x17            0x60000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x18            0x80000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x19            0x100000000       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x1a            0x200000000       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x1b            0x400000000       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x1c            0x800000000       >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x1d            0x1800000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x1e            0x3800000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x1f            0xd800000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x20            0xf800000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x21            0x2000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x22            0x7000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x23            0x7000000100      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x24            0xc000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x25            0xe000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x26            0x13000000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x27            0x13000000100     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x28            0x4000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x29            0x4000000100      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x2a            0x8000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x2b            0xa000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x2c            0x10000000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_mcput_d2d_T_O 0x2d            0x10000000100     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x0             0x52080000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x1             0x72080000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x2             0x59000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x3             0x5a000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x4             0x79000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x5             0x7a000000        >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x6             0x14001000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x7             0x14002000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x8             0x14009000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x9             0x1400a000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0xa             0x1800000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0xb             0x3800000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0xc             0xd800000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0xd             0xf800000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0xe             0x7000000000      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0xf             0x7000000100      >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x10            0x13000000000     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x11            0x13000000100     >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x12            0x0               >,
+				/bits/ 64  <tcu_snoc_I_O         snoc_npu_T_O       0x13            0x0               >;
+			};
+	};
+
+	ErrorLogger4 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x24 32>;
+		description = "Register 4 to log errors";
+		addr_msb {
+			compatible = "eswin,eic7700,bitfield";
+			description = "Stores NTTP packet header field Addr (MSBs) of the logged error";
+			offset,length = < 0 9 >;
+		};
+	};
+
+	ErrorLogger5 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x28 32>;
+		description = "Register 5 to log errors";
+
+		User_flag {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0x0 18 >;
+			lut =
+				"Cache_0",
+				"Cache_1",
+				"Cache_2",
+				"Cache_3",
+				"Prot_0 ",
+				"Prot_1 ",
+				"Prot_2 ",
+				"User_0 ",
+				"User_1 ",
+				"User_2 ",
+				"User_3 ",
+				"User_4 ",
+				"User_5 ",
+				"User_6 ",
+				"qos0",
+				"qos1",
+				"qos2",
+				"qos3";
+		};
+	};
+};
+
+d0_media_noc:d0_media_noc@52021400 {
+	compatible = "eswin,eic7700-noc";
+	#address-cells = <2>;
+	#size-cells = <2>;
+	ranges;
+	reg = <0 0x52021400 0 0x4000>;
+	interrupts = <454>;
+	interrupt-names = "error";
+	interrupt-parent = <&plic0>;
+	errlogger,idx = <0 1 3 4 5>;
+	eswin,qos-configs = "GPU", "TBU2", "VC";
+	eswin,GPU-qos-base = <0x52021480>;
+	eswin,GPU-qos-settings = <
+		0x8 0x4        /* prio */
+		0xC 0x2        /* mode */
+		0x10 0x1E0    /* bandwidth*/
+		0x14 0x1     /* saturation*/
+		0x18 0x1>;   /* QoSEn */
+
+	eswin,TBU2-qos-base = <0x52021500>;
+	eswin,TBU2-qos-settings = <
+		0x8 0x4      /* prio */
+		0xC 0x2      /* mode */
+		0x10 0x18    /* bandwidth */
+		0x14 0x10    /* saturation */
+		0x18 0x1>;   /* QoSEn */
+
+	eswin,VC-qos-base = <0x52021580>;
+	eswin,VC-qos-settings = <
+		0x8 0x4      /* prio */
+		0xC 0x2      /* mode */
+		0x10 0x18    /* bandwidth */
+		0x14 0x10    /* saturation */
+		0x18 0x1>;   /* QoSEn */
+	sideband_manager@52022000 {
+		compatible = "eswin,win2xxx-noc-sideband-manager";
+		reg = <0 0x52022000 0 0x10>;
+		SenseIn0 =
+			<SBM_MNOC_GPU 	OFFSET0>,
+			<SBM_MNOC_TBU2 	OFFSET1>,
+			<SBM_MNOC_VC 	OFFSET2>,
+			<SBM_MNOC_DDRT0_P3 	OFFSET3>,
+			<SBM_MNOC_DDRT1_P3 	OFFSET4>;
+		bf-name =
+			"SBM_MNOC_GPU",
+			"SBM_MNOC_TBU2",
+			"SBM_MNOC_VC",
+			"SBM_MNOC_DDRT0_P3",
+			"SBM_MNOC_DDRT1_P3";
+	};
+
+	mnoc_packet_ddr0_p3_req_probe@52020000 {
+		compatible = "eswin,win2xxx-noc-packet-probe";
+		reg = <0 0x52020000 0 0x4000>;
+		clocks = <&d0_clock EIC7700_CLK_DDRT0_P3_ACLK>;
+		clock-names = "clk";
+		interrupts = <458>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <1>;
+		counter,nr = <2>;
+		portsel = "ddr0_p3_req";
+	};
+	mnoc_packet_ddr1_p3_req_probe@52020800 {
+		compatible = "eswin,win2xxx-noc-packet-probe";
+		reg = <0 0x52020800 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_DDRT1_P3_ACLK>;
+		clock-names = "clk";
+		interrupts = <456>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <1>;
+		counter,nr = <2>;
+		portsel = "ddr1_p3_req";
+	};
+	mnoc_trans_probe@52021000 {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		compatible = "eswin,win2xxx-noc-trans-probe";
+		reg = <0 0x52021000 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_NOC_NSP_CLK>;
+		clock-names = "clk";
+		interrupts = <453>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <3>;
+		counter,nr = <12>;
+		profiler,nr = <1>;
+		portsel = "gpu", "tbu2", "vc";
+		mnoc_trans_gpu_filter@52021600 {
+			status = "disabled";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52021600 0 0x80>;
+		};
+		mnoc_trans_tbu2_filter@52021680 {	/*hsp subsys*/
+			status = "disabled";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52021680 0 0x80>;
+		};
+		mnoc_trans_vc_filter@52021700 {
+			status = "disabled";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52021700 0 0x80>;
+		};
+		mnoc_trans_profiler@52021780 {
+			compatible = "eswin,win2xxx-noc-trans-profiler";
+			reg = <0 0x52021780 0 0x80>;
+		};
+	};
+	ErrorLogger0 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x14 32 >;
+		description = "Register 0 to log errors";
+		lock {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0 1 >;
+			lut = "Not Locked", "Locked";
+		};
+		OpCode {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 1 4 >;
+			lut = "RD: data read with incrementing address",
+				"RDW: data read with wrapping address",
+				"RDL: allocates monitor in the Target with incrementing address",
+				"RDX: exclusive read with incrementing address",
+				"WR: data write with incrementing address",
+				"WRW: data write with wrapping address",
+				"WRC: conditional write if matching monitor in Target is found",
+				"RSV: reserved",
+				"PRE: preamble packet of linked sequence (locked sequence)",
+				"URG: urgency packet used for QoS (status must be REQ)";
+		};
+		ErrCode {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 8 3 >;
+			lut = "SLV (error source: Target): error detected by the Slave without any information or no Error",
+				"DEC (error source: Initiator NIU): decode error",
+				"UNS (error source: Target NIU): unsupported access type",
+				"DISC (error source: Power Disconnect): disconnected Target or NoC domain",
+				"SEC (error source: Initiator NIU or Firewall): security error",
+				"HIDE (error source: Firewall): hidden security error. Will be reported as OK to the initiator",
+				"TMO (error source: Target NIU): time-out",
+				"RSV: reserved";
+
+		};
+		Len1 {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 16 12 >;
+		};
+		Format {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 31 1 >;
+			lut = "NTTP v3.0 (Invalid)", "NTTP v3.5 (Ok)";
+		};
+	};
+
+	ErrorLogger1 {
+		compatible = "eswin,eic7700,register", "eswin,eic7700,noc,filter,routeid";
+		offset,length = < 0x18 32>;
+		description = "Register 1 to log errors";
+		InitFlow {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 14 2 >;
+			lut =
+				"gpu_mnoc/I/0",
+				"snoc_mnoc/I/0",
+				"tbu2_mnoc/I/0",
+				"vc_mnoc/I/0";
+		};
+
+		TargetFlow {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 12 2 >;
+			lut =
+				"mnoc_ddrt0_p3/T/0",
+				"mnoc_ddrt1_p3/T/0",
+				"mnoc_service/T/0",
+				"mnoc_snoc/T/0";
+		};
+
+		TargetSubRange {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 9 3 >;
+		};
+
+		SeqId {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0 9 >;
+		};
+	};
+
+	ErrorLogger3 {
+		/* This register does not really include a bitfield or its bitfield is 32 bits and it provides an offset address */
+		/* To calculate the absolute address, you must use the initflow:targetflow:subrange from ErrorLogger1 register */
+		/* And use it as an index in the aperture table. Then you must add the value of this register to the value given */
+		/* by the table to get the absolute address. */
+		compatible = "eswin,eic7700,register";
+		offset,length = <0x20 32>;
+		description = "Register 3 to log errors";
+		aperture-link = <1>; /* link to ErrorLogger whose information are required to calculate real absolute address */
+		msb-link = <4>; /*indicate which ErrorLogger contains the msb addrs, -1 means no*/
+		AbsoluteAddress {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 9 7 >;		/* bitfield initflow:targeflow:subrange from aperture-link register */
+			aperture-size= < 55 >;			/* Number of line in the aperture table below */
+			aperture-idx,aperture-base =	/* Aperture_idx is concatenation of initflow:targetflow:subrange bitfield from ErrorLogger1 */
+					/bits/ 64  <0x0  0x0 0x0           0x80000000       >,
+					/bits/ 64  <0x0  0x0 0x1           0x100000000      >,
+					/bits/ 64  <0x0  0x0 0x2           0x200000000      >,
+					/bits/ 64  <0x0  0x0 0x3           0x400000000      >,
+					/bits/ 64  <0x0  0x0 0x4           0x800000000      >,
+					/bits/ 64  <0x0  0x0 0x5           0x2000000000     >,
+					/bits/ 64  <0x0  0x0 0x6           0x4000000000     >,
+					/bits/ 64  <0x0  0x0 0x7           0x4000000100     >,
+					/bits/ 64  <0x0  0x1 0x0           0x80000080       >,
+					/bits/ 64  <0x0  0x1 0x1           0x100000080      >,
+					/bits/ 64  <0x0  0x1 0x2           0x200000080      >,
+					/bits/ 64  <0x0  0x1 0x3           0x400000080      >,
+					/bits/ 64  <0x0  0x1 0x4           0x800000080      >,
+					/bits/ 64  <0x0  0x1 0x5           0x2000000080     >,
+					/bits/ 64  <0x0  0x1 0x6           0x4000000080     >,
+					/bits/ 64  <0x0  0x1 0x7           0x4000000180     >,
+					/bits/ 64  <0x0  0x3 0x0           0x0              >,
+					/bits/ 64  <0x1 0x2  0x0           0x52020000       >,
+					/bits/ 64  <0x1 0x2  0x1           0x72020000       >,
+					/bits/ 64  <0x1 0x2  0x2           0x0              >,
+					/bits/ 64  <0x1 0x2  0x3           0x0              >,
+					/bits/ 64  <0x2 0x0 0x0           0x80000000       >,
+					/bits/ 64  <0x2 0x0 0x1           0x100000000      >,
+					/bits/ 64  <0x2 0x0 0x2           0x200000000      >,
+					/bits/ 64  <0x2 0x0 0x3           0x400000000      >,
+					/bits/ 64  <0x2 0x0 0x4           0x800000000      >,
+					/bits/ 64  <0x2 0x0 0x5           0x2000000000     >,
+					/bits/ 64  <0x2 0x0 0x6           0x4000000000     >,
+					/bits/ 64  <0x2 0x0 0x7           0x4000000100     >,
+					/bits/ 64  <0x2 0x1 0x0           0x80000080       >,
+					/bits/ 64  <0x2 0x1 0x1           0x100000080      >,
+					/bits/ 64  <0x2 0x1 0x2           0x200000080      >,
+					/bits/ 64  <0x2 0x1 0x3           0x400000080      >,
+					/bits/ 64  <0x2 0x1 0x4           0x800000080      >,
+					/bits/ 64  <0x2 0x1 0x5           0x2000000080     >,
+					/bits/ 64  <0x2 0x1 0x6           0x4000000080     >,
+					/bits/ 64  <0x2 0x1 0x7           0x4000000180     >,
+					/bits/ 64  <0x2 0x3   0x0           0x0              >,
+					/bits/ 64  <0x3   0x0 0x0           0x80000000       >,
+					/bits/ 64  <0x3   0x0 0x1           0x100000000      >,
+					/bits/ 64  <0x3   0x0 0x2           0x200000000      >,
+					/bits/ 64  <0x3   0x0 0x3           0x400000000      >,
+					/bits/ 64  <0x3   0x0 0x4           0x800000000      >,
+					/bits/ 64  <0x3   0x0 0x5           0x2000000000     >,
+					/bits/ 64  <0x3   0x0 0x6           0x4000000000     >,
+					/bits/ 64  <0x3   0x0 0x7           0x4000000100     >,
+					/bits/ 64  <0x3   0x1 0x0           0x80000080       >,
+					/bits/ 64  <0x3   0x1 0x1           0x100000080      >,
+					/bits/ 64  <0x3   0x1 0x2           0x200000080      >,
+					/bits/ 64  <0x3   0x1 0x3           0x400000080      >,
+					/bits/ 64  <0x3   0x1 0x4           0x800000080      >,
+					/bits/ 64  <0x3   0x1 0x5           0x2000000080     >,
+					/bits/ 64  <0x3   0x1 0x6           0x4000000080     >,
+					/bits/ 64  <0x3   0x1 0x7           0x4000000180     >,
+					/bits/ 64  <0x3   0x3 0x0           0x0              >;
+		};
+	};
+
+	ErrorLogger4 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x24 32>;
+		description = "Register 4 to log errors";
+		addr_msb {
+			compatible = "eswin,eic7700,bitfield";
+			description = "Stores NTTP packet header field Addr (MSBs) of the logged error";
+			offset,length = < 0 9 >;
+		};
+	};
+
+	ErrorLogger5 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x28 32 >;
+		description = "Register 5 to log errors";
+
+		User_flag {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0x0 18 >;
+			lut =
+				"Cache_0",
+				"Cache_1",
+				"Cache_2",
+				"Cache_3",
+				"Prot_0 ",
+				"Prot_1 ",
+				"Prot_2 ",
+				"User_0 ",
+				"User_1 ",
+				"User_2 ",
+				"User_3 ",
+				"User_4 ",
+				"User_5 ",
+				"User_6 ",
+				"qos0",
+				"qos1",
+				"qos2",
+				"qos3";
+		};
+	};
+};
+
+d0_realtime_noc:d0_realtime_noc@52041400 {
+	compatible = "eswin,eic7700-noc";
+	#address-cells = <2>;
+	#size-cells = <2>;
+	ranges;
+	reg = <0 0x52041400 0 0x4000>;
+	interrupts = <448>;
+	interrupt-names = "error";
+	interrupt-parent = <&plic0>;
+	errlogger,idx = <0 1 3 4 5>;
+	eswin,qos-configs = "TBU0", "VO";
+	eswin,TBU0-qos-base = <0x52041480>;
+	eswin,TBU0-qos-settings = <
+		0x8 0x4        /* prio */
+		0xC 0x2        /* mode */
+		0x10 0x1E0    /* bandwidth */
+		0x14 0x1     /* saturation */
+		0x18 0x1>;   /* QoSEn */
+
+	eswin,VO-qos-base = <0x52041500>;
+	eswin,VO-qos-settings = <
+		0x8 0x4      /* prio */
+		0xC 0x2      /* mode */
+		0x10 0x18    /* bandwidth */
+		0x14 0x10    /* saturation */
+		0x18 0x1>;   /* QoSEn */
+	sideband_manager@52042000 {
+		compatible = "eswin,win2xxx-noc-sideband-manager";
+		reg = <0 0x52042000 0 0x10>;
+		SenseIn0 =
+			<SBM_RNOC_TBU0 	OFFSET0>,
+			<SBM_RNOC_VO 	OFFSET1>,
+			<SBM_RNOC_DDRT0_P4 	OFFSET2>,
+			<SBM_RNOC_DDRT1_P4 	OFFSET3>;
+		bf-name =
+			"SBM_RNOC_TBU0",
+			"SBM_RNOC_VO",
+			"SBM_RNOC_DDRT0_P4",
+			"SBM_RNOC_DDRT1_P4";
+	};
+
+	rnoc_packet_ddr0_p4_req_probe@52040000 {
+		compatible = "eswin,win2xxx-noc-packet-probe";
+		reg = <0 0x52040000 0 0x4000>;
+		clocks = <&d0_clock EIC7700_CLK_DDRT0_P4_ACLK>;
+		clock-names = "clk";
+		interrupts = <452>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <1>;
+		counter,nr = <2>;
+		portsel = "ddr0_p4_req";
+	};
+	rnoc_packet_ddr1_p4_req_probe@52040800 {
+		compatible = "eswin,win2xxx-noc-packet-probe";
+		reg = <0 0x52040800 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_DDRT1_P4_ACLK>;
+		clock-names = "clk";
+		interrupts = <450>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <1>;
+		counter,nr = <2>;
+		portsel = "ddr1_p4_req";
+	};
+	rnoc_trans_probe@52041000 {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		compatible = "eswin,win2xxx-noc-trans-probe";
+		reg = <0 0x52041000 0 0x4000>;
+		clocks =<&d0_clock EIC7700_CLK_NOC_NSP_CLK>;
+		clock-names = "clk";
+		interrupts = <447>;
+		interrupt-names = "stat";
+		interrupt-parent = <&plic0>;
+		filter,nr = <2>;
+		counter,nr = <8>;
+		profiler,nr = <1>;
+		portsel = "tbu0", "vo";
+		rnoc_trans_tbu0_filter@52041580 {	/*vi subsys*/
+			status = "disabled";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52041580 0 0x80>;
+		};
+		rnoc_trans_vo_filter@52041600 {
+			status = "disabled";
+			compatible = "eswin,win2xxx-noc-trans-filter";
+			reg = <0 0x52041600 0 0x80>;
+		};
+		rnoc_trans_profiler@52041680 {
+			compatible = "eswin,win2xxx-noc-trans-profiler";
+			reg = <0 0x52041680 0 0x80>;
+		};
+	};
+	ErrorLogger0 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x14 32 >;
+		description = "Register 0 to log errors";
+		lock {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0 1 >;
+			lut = "Not Locked", "Locked";
+		};
+		OpCode {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 1 4 >;
+			lut = "RD: data read with incrementing address",
+				"RDW: data read with wrapping address",
+				"RDL: allocates monitor in the Target with incrementing address",
+				"RDX: exclusive read with incrementing address",
+				"WR: data write with incrementing address",
+				"WRW: data write with wrapping address",
+				"WRC: conditional write if matching monitor in Target is found",
+				"RSV: reserved",
+				"PRE: preamble packet of linked sequence (locked sequence)",
+				"URG: urgency packet used for QoS (status must be REQ)";
+		};
+		ErrCode {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 8 3 >;
+			lut = "SLV (error source: Target): error detected by the Slave without any information or no Error",
+				"DEC (error source: Initiator NIU): decode error",
+				"UNS (error source: Target NIU): unsupported access type",
+				"DISC (error source: Power Disconnect): disconnected Target or NoC domain",
+				"SEC (error source: Initiator NIU or Firewall): security error",
+				"HIDE (error source: Firewall): hidden security error. Will be reported as OK to the initiator",
+				"TMO (error source: Target NIU): time-out",
+				"RSV: reserved";
+
+		};
+		Len1 {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 16 12 >;
+		};
+		Format {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 31 1 >;
+			lut = "NTTP v3.0 (Invalid)", "NTTP v3.5 (Ok)";
+		};
+	};
+
+	ErrorLogger1 {
+		compatible = "eswin,eic7700,register", "eswin,eic7700,noc,filter,routeid";
+		offset,length = < 0x18 32>;
+		description = "Register 1 to log errors";
+		InitFlow {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 14 2 >;
+			lut =
+				"snoc_rnoc/I/0",
+				"tbu0_rnoc/I/0",
+				"vo_rnoc/I/0",
+				"RESERVED0";
+		};
+
+		TargetFlow {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 12 2 >;
+			lut =
+				"rnoc_ddrt0_p4/T/0",
+				"rnoc_ddrt1_p4/T/0",
+				"rnoc_service/T/0",
+				"rnoc_snoc/T/0";
+		};
+
+		TargetSubRange {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 9 3 >;
+		};
+
+		SeqId {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0 9 >;
+		};
+	};
+
+	ErrorLogger3 {
+		/* This register does not really include a bitfield or its bitfield is 32 bits and it provides an offset address */
+		/* To calculate the absolute address, you must use the initflow:targetflow:subrange from ErrorLogger1 register */
+		/* And use it as an index in the aperture table. Then you must add the value of this register to the value given */
+		/* by the table to get the absolute address. */
+		compatible = "eswin,eic7700,register";
+		offset,length = <0x20 32>;
+		description = "Register 3 to log errors";
+		aperture-link = <1>; /* link to ErrorLogger whose information are required to calculate real absolute address */
+		msb-link = <4>; /*indicate which ErrorLogger contains the msb addrs, -1 means no*/
+		AbsoluteAddress {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 9 7 >;		/* bitfield initflow:targeflow:subrange from aperture-link register */
+			aperture-size= < 40 >;			/* Number of line in the aperture table below */
+			aperture-idx,aperture-base =	/* Aperture_idx is concatenation of initflow:targetflow:subrange bitfield from ErrorLogger1 */
+					/bits/ 64  <0x0 0x2 0x0          0x52040000       >,
+					/bits/ 64  <0x0 0x2 0x1          0x72040000       >,
+					/bits/ 64  <0x0 0x2 0x2          0x0              >,
+					/bits/ 64  <0x0 0x2 0x3          0x0              >,
+					/bits/ 64  <0x1 0x0 0x0          0x80000000       >,
+					/bits/ 64  <0x1 0x0 0x1          0x100000000      >,
+					/bits/ 64  <0x1 0x0 0x2          0x200000000      >,
+					/bits/ 64  <0x1 0x0 0x3          0x400000000      >,
+					/bits/ 64  <0x1 0x0 0x4          0x800000000      >,
+					/bits/ 64  <0x1 0x0 0x5          0x2000000000     >,
+					/bits/ 64  <0x1 0x1 0x0          0x80000080       >,
+					/bits/ 64  <0x1 0x1 0x1          0x100000080      >,
+					/bits/ 64  <0x1 0x1 0x2          0x200000080      >,
+					/bits/ 64  <0x1 0x1 0x3          0x400000080      >,
+					/bits/ 64  <0x1 0x1 0x4          0x800000080      >,
+					/bits/ 64  <0x1 0x1 0x5          0x2000000080     >,
+					/bits/ 64  <0x1 0x3 0x0          0x59000000       >,
+					/bits/ 64  <0x1 0x3 0x1          0x79000000       >,
+					/bits/ 64  <0x1 0x3 0x2          0x14001000000    >,
+					/bits/ 64  <0x1 0x3 0x3          0x14009000000    >,
+					/bits/ 64  <0x1 0x3 0x4          0x0              >,
+					/bits/ 64  <0x1 0x3 0x5          0x0              >,
+					/bits/ 64  <0x2 0x0 0x0          0x80000000       >,
+					/bits/ 64  <0x2 0x0 0x1          0x100000000      >,
+					/bits/ 64  <0x2 0x0 0x2          0x200000000      >,
+					/bits/ 64  <0x2 0x0 0x3          0x400000000      >,
+					/bits/ 64  <0x2 0x0 0x4          0x800000000      >,
+					/bits/ 64  <0x2 0x0 0x5          0x2000000000     >,
+					/bits/ 64  <0x2 0x1 0x0          0x80000080       >,
+					/bits/ 64  <0x2 0x1 0x1          0x100000080      >,
+					/bits/ 64  <0x2 0x1 0x2          0x200000080      >,
+					/bits/ 64  <0x2 0x1 0x3          0x400000080      >,
+					/bits/ 64  <0x2 0x1 0x4          0x800000080      >,
+					/bits/ 64  <0x2 0x1 0x5          0x2000000080     >,
+					/bits/ 64  <0x2 0x3 0x0          0x59000000       >,
+					/bits/ 64  <0x2 0x3 0x1          0x79000000       >,
+					/bits/ 64  <0x2 0x3 0x2          0x14001000000    >,
+					/bits/ 64  <0x2 0x3 0x3          0x14009000000    >,
+					/bits/ 64  <0x2 0x3 0x4          0x0              >,
+					/bits/ 64  <0x2 0x3 0x5          0x0              >;
+		};
+	};
+
+	ErrorLogger4 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x24 32>;
+		description = "Register 4 to log errors";
+		addr_msb {
+			compatible = "eswin,eic7700,bitfield";
+			description = "Stores NTTP packet header field Addr (MSBs) of the logged error";
+			offset,length = < 0 9 >;
+		};
+	};
+
+	ErrorLogger5 {
+		compatible = "eswin,eic7700,register";
+		offset,length = < 0x28 32 >;
+		description = "Register 5 to log errors";
+
+		User_flag {
+			compatible = "eswin,eic7700,bitfield";
+			offset,length = < 0x0 16 >;
+			lut =
+				 "Cache_0",
+				 "Cache_1",
+				 "Cache_2",
+				 "Cache_3",
+				 "Prot_0 ",
+				 "Prot_1 ",
+				 "Prot_2 ",
+				 "User_0 ",
+				 "User_1 ",
+				 "User_2 ",
+				 "User_3 ",
+				 "User_4 ",
+				 "qos0",
+				 "qos1",
+				 "qos2",
+				 "qos3";
+		};
+	};
+};
diff --git a/arch/riscv/boot/dts/eswin/eic7700.dtsi b/arch/riscv/boot/dts/eswin/eic7700.dtsi
new file mode 100644
index 000000000000..82b62135ebea
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/eic7700.dtsi
@@ -0,0 +1,2180 @@
+﻿// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Include file for Die0 System peripherals of Eswin EIC770x family SoC.
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+#include "eic7700-arch.dtsi"
+#include <dt-bindings/memory/eic7700-sid.h>
+#include <dt-bindings/mailbox/eswin-mailbox.h>
+#include <dt-bindings/reset/eic7700-syscrg.h>
+#include <dt-bindings/clock/eic7700-clock.h>
+#include <dt-bindings/interconnect/eic7700.h>
+
+/ {
+    compatible = "eswin,eic7700";
+	d0_cpu_opp_table: opp-table0 {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp-24000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_24M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-100000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_100M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-200000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_200M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-400000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_400M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-500000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_500M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-600000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_600M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-700000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_700M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-800000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_800M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-900000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_900M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-1000000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_1000M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-1200000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_1200M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-1300000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_1300M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+		opp-1400000000 {
+			opp-hz = /bits/ 64 <CLK_FREQ_1400M>;
+			opp-microvolt = <800000>;
+			clock-latency-ns = <70000>;
+		};
+	};
+};
+
+&SOC {
+		d0_uart0: serial@0x50900000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x50900000 0x0 0x10000>;
+			clock-frequency = <LSPCLK_FREQ>;
+			interrupt-parent = <&plic0>;
+			interrupts = <UART0_INT>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			numa-node-id = <0>;
+		};
+
+		d0_uart1: serial@0x50910000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x50910000 0x0 0x10000>;
+			clock-frequency = <LSPCLK_FREQ>;
+			interrupt-parent = <&plic0>;
+			interrupts = <UART1_INT>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			numa-node-id = <0>;
+		};
+
+		d0_uart2: serial@0x50920000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x50920000 0x0 0x10000>;
+			clock-frequency = <LSPCLK_FREQ>;
+			interrupt-parent = <&plic0>;
+			interrupts = <UART2_INT>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			numa-node-id = <0>;
+			status = "disabled";
+		};
+
+		d0_uart3: serial@0x50930000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x50930000 0x0 0x10000>;
+			clock-frequency = <LSPCLK_FREQ>;
+			interrupt-parent = <&plic0>;
+			interrupts = <UART3_INT>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			numa-node-id = <0>;
+			status = "disabled";
+		};
+
+		d0_uart4: serial@0x50940000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x0 0x50940000 0x0 0x10000>;
+			clock-frequency = <LSPCLK_FREQ>;
+			interrupt-parent = <&plic0>;
+			interrupts = <UART4_INT>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			numa-node-id = <0>;
+			status = "disabled";
+		};
+
+		d0_sys_con: scu_sys_con@0x51810000 {
+			compatible = "eswin,eic7700-scu-sys-con", "syscon", "simple-mfd";
+			#syscon-cells = <2>;
+			#size-cells = <2>;
+			reg = <0x0 0x51810000 0x0 0x8000>;
+			numa-node-id = <0>;
+			d0_noc_wdt:noc@51810324 {
+				compatible = "eswin,eic7700-noc-wdt";
+				interrupt-parent = <&plic0>;
+				interrupts = <392>, <393>, <394>, <395>,
+						<396>, <397>, <398>, <399>, <400>,
+						<401>, <402>, <403>, <404>, <405>,
+						<406>, <407>, <408>, <409>, <410>,
+						<411>, <412>, <413>, <414>, <415>,
+						<416>, <417>, <418>, <419>, <420>,
+						<421>, <422>, <423>, <424>, <425>,
+						<426>;
+				eswin,syscrg_csr = <&d0_sys_crg 0x100 0xffff>; //timeout paramerter
+				status = "disabled";
+			};
+		};
+
+		d0_sys_crg: sys-crg@51828000 {
+			compatible = "eswin,eic7700-sys-crg", "syscon", "simple-mfd";
+			reg = <0x000000 0x51828000 0x000000 0x80000>;
+			numa-node-id = <0>;
+			d0_reset: reset-controller {
+				compatible = "eswin,eic7700-reset";
+				#reset-cells = <2>;
+			};
+			d0_clock: clock-controller {
+				compatible = "eswin,eic7700-clock";
+				#clock-cells = <1>;
+			};
+		};
+
+		hfclk: hfclk {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <LSPCLK_FREQ>;
+			clock-output-names = "hfclk";
+		};
+
+		d0_hsp_sp_csr: hsp_sp_top_csr@0x50440000 {
+			compatible = "eswin,eic7700-hsp-sp-csr", "syscon";
+			#size-cells = <2>;
+			reg = <0x0 0x50440000 0x0 0x2000>;
+		};
+
+		smmu0: iommu@50c00000 {
+			compatible = "arm,smmu-v3";
+			reg = <0x0 0x50c00000 0x0 0x100000>;
+			eswin,syscfg = <&d0_sys_con 0x3fc>;
+			interrupt-parent = <&plic0>;
+			interrupts = <356>,
+				<360>,
+				<357>,
+				<358>;
+			interrupt-names = "eventq", "gerror", "priq", "cmdq-sync";
+			#iommu-cells = <1>;
+			resets = <&d0_reset TCU_RST_CTRL SW_TCU_AXI_RSTN>,
+				<&d0_reset TCU_RST_CTRL SW_TCU_CFG_RSTN>,
+				<&d0_reset TCU_RST_CTRL TBU_RSTN_0>,
+				<&d0_reset TCU_RST_CTRL TBU_RSTN_1>,
+				<&d0_reset TCU_RST_CTRL TBU_RSTN_2>,
+				<&d0_reset TCU_RST_CTRL TBU_RSTN_3>,
+				<&d0_reset TCU_RST_CTRL TBU_RSTN_4>,
+				<&d0_reset TCU_RST_CTRL TBU_RSTN_5>,
+				<&d0_reset TCU_RST_CTRL TBU_RSTN_6>,
+				<&d0_reset TCU_RST_CTRL TBU_RSTN_7>;
+			reset-names = "axi_rst", "cfg_rst", "tbu0_rst", "tbu1_rst", "tbu2_rst", "tbu3_rst",
+				"tbu4_rst", "tbu5_rst", "tbu6_rst", "tbu7_rst";
+			status = "disabled";
+			numa-node-id = <0>;
+		};
+
+		smmu_pmu0: pmu@50c02000 {
+			compatible = "arm,smmu-v3-pmcg";
+			reg = <0x0 0x50c02000 0x0 0x1000>,
+					<0x0 0x50c22000 0x0 0x1000>;
+			eswin,syscfg = <&d0_sys_con 0x3fc>;
+			interrupt-parent = <&plic0>;
+			interrupts = <363>;
+			status = "disabled";
+			numa-node-id = <0>;
+		};
+
+		d0_pmu: power-controller@51808000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "eswin,eic7700-pmu-controller";
+			reg = <0x0 0x51808000 0x0 0x8000>;
+			numa-node-id = <0>;
+			d0_pmu_pcie: eic7700-pmu-controller-port@0 {
+				compatible = "eswin,eic7700-pmu-controller-port";
+				reg_base = <0x0>;
+				power_status = <1>;
+				power_delay = <6 6 3 3>;
+				clock_delay = <4 2 2 2>;
+				reset_delay = <2 4 2 2>;
+				clamp_delay = <3 3 2 2>;
+				label = "D0_PCIE";
+				tbus = <EIC7700_TBUID_PCIE>;
+			};
+			d0_pmu_dsp1: eic7700-pmu-controller-port@40 {
+				compatible = "eswin,eic7700-pmu-controller-port";
+				reg_base = <0x40>;
+				power_status = <1>;
+				power_delay = <6 6 3 3>;
+				clock_delay = <4 2 2 2>;
+				reset_delay = <2 4 2 2>;
+				clamp_delay = <3 3 2 2>;
+				tbus = <EIC7700_TBUID_DSP1>;
+				label = "D0_DSP1";
+			};
+			d0_pmu_vi: eic7700-pmu-controller-port@80 {
+				compatible = "eswin,eic7700-pmu-controller-port";
+				reg_base = <0x80>;
+				power_status = <1>;
+				power_delay = <6 6 3 3>;
+				clock_delay = <4 2 2 2>;
+				reset_delay = <2 4 2 2>;
+				clamp_delay = <3 3 2 2>;
+				tbus = <EIC7700_TBUID_ISP>,<EIC7700_TBUID_DW>;
+				label = "D0_VI";
+			};
+			d0_pmu_vo: eic7700-pmu-controller-port@c0 {
+				compatible = "eswin,eic7700-pmu-controller-port";
+				reg_base = <0xc0>;
+				power_status = <1>;
+				power_delay = <6 6 3 3>;
+				clock_delay = <4 2 2 2>;
+				reset_delay = <2 4 2 2>;
+				clamp_delay = <3 3 2 2>;
+				label = "D0_VO";
+			};
+			d0_pmu_codec: eic7700-pmu-controller-port@140 {
+				compatible = "eswin,eic7700-pmu-controller-port";
+				reg_base = <0x140>;
+				power_status = <1>;
+				power_delay = <6 6 3 3>;
+				clock_delay = <4 2 2 2>;
+				reset_delay = <2 4 2 2>;
+				clamp_delay = <3 3 2 2>;
+				tbus = <EIC7700_TBUID_VDEC>, <EIC7700_TBUID_JDEC>,<EIC7700_TBUID_VENC>, <EIC7700_TBUID_JENC>;
+				label = "D0_CODEC";
+			};
+			d0_pmu_dsp2: eic7700-pmu-controller-port@200 {
+				compatible = "eswin,eic7700-pmu-controller-port";
+				reg_base = <0x200>;
+				power_status = <1>;
+				power_delay = <6 6 3 3>;
+				clock_delay = <4 2 2 2>;
+				reset_delay = <2 4 2 2>;
+				clamp_delay = <3 3 2 2>;
+				tbus = <EIC7700_TBUID_DSP2>;
+				label = "D0_DSP2";
+			};
+			d0_pmu_dsp3: eic7700-pmu-controller-port@240 {
+				compatible = "eswin,eic7700-pmu-controller-port";
+				reg_base = <0x240>;
+				power_status = <1>;
+				power_delay = <6 6 3 3>;
+				clock_delay = <4 2 2 2>;
+				reset_delay = <2 4 2 2>;
+				clamp_delay = <3 3 2 2>;
+				tbus = <EIC7700_TBUID_DSP3>;
+				label = "D0_DSP3";
+			};
+		};
+
+		d0_dmac0: dma-controller-hsp@0x50430000 {
+			compatible = "snps,axi-dma-1.01a";
+			reg = <0x0 0x50430000 0x0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <57>;
+			#dma-cells = <2>; // change dma-cells value <1> to <2>, to support peripheral selection dma-controller,See the parameter dmas for details;
+			clocks = <&d0_clock EIC7700_CLK_HSP_DMA0_CLK>;
+			clock-names = "core-clk";
+			resets = <&d0_reset HSPDMA_RST_CTRL SW_HSP_DMA0_RSTN>,
+				<&d0_reset HSPDMA_RST_CTRL SW_HSP_DMA_PRSTN>;
+			reset-names = "arst", "prst";
+			dma-channels = <12>;
+			snps,dma-masters = <1>;
+			snps,priority = <0 1 2 3 4 5 6 7 8 9 10 11>;
+			snps,data-width = <2>;
+			snps,block-size = <0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000>;
+			snps,axi-max-burst-len = <16>;
+			snps,max-msize = <64>;
+			iommus = <&smmu0 EIC7700_SID_DMA0>;
+			tbus = <EIC7700_TBUID_DMA0>;
+			eswin,hsp_sp_csr = <&d0_hsp_sp_csr 0x104c>;
+			eswin,syscfg = <&d0_sys_con DMA1_SID_REG_OFFSET 0x370>;
+			numa-node-id = <0>;
+		};
+
+		d0_aon_dmac: dma-controller-aon@0x518c0000 {
+			compatible = "snps,axi-dma-1.01a";
+			reg = <0x0 0x518c0000 0x0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <289>;
+			#dma-cells = <2>; // change dma-cells value <1> to <2>, to support peripheral selection dma-controller,See the parameter dmas for details;
+			clocks = <&d0_clock EIC7700_CLK_AONDMA_ACLK>;
+			clock-names = "core-clk";
+			resets = <&d0_reset DMA1_RST_CTRL SW_DMA1_ARSTN>,
+				<&d0_reset DMA1_RST_CTRL SW_DMA1_HRSTN>;
+			reset-names = "arst", "prst";
+			dma-channels = <16>;
+			snps,dma-masters = <2>;
+			snps,priority = <0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15>;
+			snps,data-width = <3>;
+			snps,block-size = <0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000 0x80000>;
+			snps,axi-max-burst-len = <32>;
+			snps,max-msize = <64>;
+			#size-cells = <2>;
+			#address-cells = <2>;
+			dma-ranges = <0x0 0x80000000 0x0 0x80000000 0x100 0x0>;
+			iommus = <&smmu0 EIC7700_SID_DMA1>;
+			tbus = <EIC7700_TBUID_DMA1>;
+			eswin,syscfg = <&d0_sys_con DMA1_SID_REG_OFFSET 0x370>;
+			numa-node-id = <0>;
+		};
+
+		d0_gmac0: ethernet@50400000 {
+			compatible = "eswin,eic7700-qos-eth";
+			reg = <0x0 0x50400000 0x0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupt-names = "macirq";
+			interrupts = <61>;
+			phy-mode = "rgmii";
+			numa-node-id = <0>;
+			id = <0>;
+			status = "disabled";
+			clocks = <&d0_clock EIC7700_CLK_HSP_ETH_APP_CLK>,
+					 <&d0_clock EIC7700_CLK_HSP_ETH_CSR_CLK>,
+					 <&d0_clock EIC7700_CLK_HSP_ETH0_CORE_CLK>;
+			clock-names = "app", "csr","tx";
+			resets = <&d0_reset HSPDMA_RST_CTRL SW_HSP_ETH0_ARSTN>;
+			reset-names = "ethrst";
+			tbus = <EIC7700_TBUID_ETH>;
+			eswin,hsp_sp_csr = <&d0_hsp_sp_csr 0x1030 0x100 0x108>;
+			eswin,syscrg_csr = <&d0_sys_crg 0x148 0x14c>;
+			snps,axi-config = <&d0_stmmac_axi_setup>;
+			d0_stmmac_axi_setup: stmmac-axi-config {
+				snps,blen = <0 0 0 0 16 8 4>;
+				snps,rd_osr_lmt = <2>;
+				snps,wr_osr_lmt = <2>;
+				snps,lpi_en = <0>;
+			};
+		};
+
+		d0_gmac1: ethernet@50410000 {
+			compatible = "eswin,eic7700-qos-eth";
+			reg = <0x0 0x50410000 0x0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupt-names = "macirq";
+			interrupts = <70>;
+			phy-mode = "rgmii";
+			numa-node-id = <0>;
+			id = <1>;
+			status = "disabled";
+			clocks = <&d0_clock EIC7700_CLK_HSP_ETH_APP_CLK>,
+					 <&d0_clock EIC7700_CLK_HSP_ETH_CSR_CLK>,
+					 <&d0_clock EIC7700_CLK_HSP_ETH1_CORE_CLK>;
+			clock-names = "app", "csr","tx";
+			resets = <&d0_reset HSPDMA_RST_CTRL SW_HSP_ETH1_ARSTN>;
+			reset-names = "ethrst";
+			tbus = <EIC7700_TBUID_ETH>;
+			eswin,hsp_sp_csr = <&d0_hsp_sp_csr 0x1034 0x200 0x208>;
+			eswin,syscrg_csr = <&d0_sys_crg 0x148 0x14c>;
+			snps,axi-config = <&d0_stmmac_axi_setup_gmac1>;
+			d0_stmmac_axi_setup_gmac1: stmmac-axi-config {
+				snps,blen = <0 0 0 0 16 8 4>;
+				snps,rd_osr_lmt = <2>;
+				snps,wr_osr_lmt = <2>;
+				snps,lpi_en = <0>;
+			};
+		};
+		noc {
+			compatible = "eswin,noc","simple-bus";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+			#include "eic7700-noc.dtsi"
+		};
+
+		d0_npu: eswin-npu@51c00000 {
+			compatible = "eswin,npu0";
+			reg = <0x0 0x51c00000 0x0 0x400000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <387 16>;
+			/*spram-region = <&npu0_reserved>;*/
+			#size-cells = <2>;
+			dma-ranges = <0x1 0x0 0x0 0xc0000000 0x1ff 0x0>;
+			iommus = <&smmu0 EIC7700_SID_NPU_DMA>;
+			tbus = <EIC7700_TBUID_NPU>;
+			dsp-avail-num = <1>;
+			spram-size = <0x400000>;
+			npu_mbox = <&d0_mbox2>;
+			resets = <&d0_reset NPU_RST_CTRL SW_NPU_E31CORE_RSTN>;
+			reset-names = "e31_core";
+			numa-node-id = <0>;
+		};
+
+		dev_llc_d0: llc@51c00000 {
+			compatible = "eswin,llc";
+			reg = <0x0 0x51c00000 0x0 0x400000>;
+			eswin,syscfg = <&d0_sys_con 0x324>;
+			eswin,syscrg_csr = <&d0_sys_crg>;
+			clocks = <&d0_clock EIC7700_CLK_NPU_ACLK>,
+				 <&d0_clock EIC7700_CLK_NPU_CFG_CLK>,
+				 <&d0_clock EIC7700_CLK_NPU_LLC_ACLK>,
+				 <&d0_clock EIC7700_CLK_NPU_CLK>,
+				 <&d0_clock EIC7700_MUX_U_NPU_CORE_3MUX1_GFREE>,
+				 <&d0_clock EIC7700_SPLL2_FOUT2>;
+			clock-names = "aclk", "cfg_clk", "llc_clk", "core_clk",
+					"mux_u_npu_core_3mux1_gfree", "fixed_rate_clk_spll2_fout2",
+					"fixed_rate_clk_spll1_fout1";
+			resets = <&d0_reset NPU_RST_CTRL SW_NPU_AXI_RSTN>,
+				<&d0_reset NPU_RST_CTRL SW_NPU_CFG_RSTN>,
+				<&d0_reset NPU_RST_CTRL SW_NPU_CORE_RSTN>,
+				<&d0_reset NPU_RST_CTRL SW_NPU_LLC_RSTN>;
+			reset-names = "axi", "cfg", "core", "llc";
+			numa-node-id = <0>;
+			spram-region = <&npu0_reserved>;
+		};
+
+		d0_dsp_subsys:dsp_subsys@52280400 {
+			#address-cells = <2>;
+			#size-cells = <2>;
+			reg = <0x0 0x52280400 0x0 0x10000>,
+					<0x0 0x51810000 0x0 0x8000>;
+			ranges;
+			compatible = "es-dsp-subsys", "simple-bus";
+			clocks = <&d0_clock EIC7700_CLK_DSPT_CFG_CLK>;
+			clock-names = "cfg_clk";
+			resets = <&d0_reset DSP_RST_CTRL SW_DSP_AXI_RSTN>,
+					<&d0_reset DSP_RST_CTRL SW_DSP_CFG_RSTN>,
+					<&d0_reset DSP_RST_CTRL SW_DSP_DIV4_RSTN>,
+					<&d0_reset DSP_RST_CTRL SW_DSP_DIV_RSTN_0>,
+					<&d0_reset DSP_RST_CTRL SW_DSP_DIV_RSTN_1>,
+					<&d0_reset DSP_RST_CTRL SW_DSP_DIV_RSTN_2>,
+					<&d0_reset DSP_RST_CTRL SW_DSP_DIV_RSTN_3>;
+			reset-names = "axi", "cfg", "div4", "div_0", "div_1", "div_2","div_3";
+			d0_dsp0:es_dsp@0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "eswin-dsp", "cdns,xrp-hw-eswin";
+				ranges = <0x28000000 0 0x5b000000 0x8000
+					0x28100000 0 0x5b100000 0x20000
+					0x28120000 0 0x5b120000 0x20000>;
+				clocks = <&d0_clock EIC7700_CLK_DSP_ACLK_0>;
+				clock-names = "aclk";
+				dsp_mbox = <&d0_mbox4>;
+				device-irq = <11
+					ESWIN_MAILBOX_DSP_0_TO_U84_REG_BASE
+					ESWIN_MAILBOX_WR_LOCK_BIT_DSP_0
+					ESWIN_MAILBOX_U84_TO_DSP_0_REG_BASE
+					ESWIN_MAIBOX_U84_IRQ_BIT
+					ESWIN_MAILBOX_U84_TO_NPU_0_REG_BASE>;
+
+				device-uart = <0x50900000>;
+				device-irq-mode = <1>;
+				host-irq-mode = <1>;
+				firmware-name = "eic7700_dsp_fw";
+				process-id = <0>;
+				dma-ranges = <0x30000000 0x0 0xc0000000 0xce000000>;
+				iommus = <&smmu0 EIC7700_SID_DSP_0>;
+				tbus = <EIC7700_TBUID_DSP0>;
+				numa-node-id = <0>;
+				aux-e31-dtim = <0x5a110000>;
+				dsp@0 {
+				};
+			};
+			d0_dsp1:es_dsp@1 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "eswin-dsp", "cdns,xrp-hw-eswin";
+				ranges = <0x28000000 0 0x5b008000 0x8000
+					0x28100000 0 0x5b140000 0x20000
+					0x28120000 0 0x5b160000 0x20000>;
+				clocks = <&d0_clock EIC7700_CLK_DSP_ACLK_1>;
+				clock-names = "aclk";
+				dsp_mbox = <&d0_mbox5>;
+				device-irq = <13
+					ESWIN_MAILBOX_DSP_1_TO_U84_REG_BASE
+					ESWIN_MAILBOX_WR_LOCK_BIT_DSP_1
+					ESWIN_MAILBOX_U84_TO_DSP_1_REG_BASE
+					ESWIN_MAIBOX_U84_IRQ_BIT
+					ESWIN_MAILBOX_U84_TO_NPU_0_REG_BASE>;
+				device-uart = <0x50900000>;
+				device-irq-mode = <1>;
+				host-irq-mode = <1>;
+				firmware-name = "eic7700_dsp_fw";
+				process-id = <1>;
+				dma-ranges = <0x30000000 0x0 0xc0000000 0xce000000>;
+				iommus = <&smmu0 EIC7700_SID_DSP_1>;
+				tbus = <EIC7700_TBUID_DSP1>;
+				numa-node-id = <0>;
+				aux-e31-dtim = <0x5a110000>;
+				dsp@0 {
+				};
+			};
+			d0_dsp2:es_dsp@2 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "eswin-dsp", "cdns,xrp-hw-eswin";
+				ranges = <0x28000000 0 0x5b010000 0x8000
+					0x28100000 0 0x5b180000 0x20000
+					0x28120000 0 0x5b1a0000 0x20000>;
+				clocks = <&d0_clock EIC7700_CLK_DSP_ACLK_2>;
+				clock-names = "aclk";
+				dsp_mbox = <&d0_mbox6>;
+				device-irq = <15
+					ESWIN_MAILBOX_DSP_2_TO_U84_REG_BASE
+					ESWIN_MAILBOX_WR_LOCK_BIT_DSP_2
+					ESWIN_MAILBOX_U84_TO_DSP_2_REG_BASE
+					ESWIN_MAIBOX_U84_IRQ_BIT
+					ESWIN_MAILBOX_U84_TO_NPU_0_REG_BASE>;
+				device-uart = <0x50900000>;
+				device-irq-mode = <1>;
+				host-irq-mode = <1>;
+				firmware-name = "eic7700_dsp_fw";
+				process-id = <2>;
+				dma-ranges = <0x30000000 0x0 0xc0000000 0xce000000>;
+				iommus = <&smmu0 EIC7700_SID_DSP_2>;
+				tbus = <EIC7700_TBUID_DSP2>;
+				numa-node-id = <0>;
+				aux-e31-dtim = <0x5a110000>;
+				dsp@0 {
+				};
+			};
+			d0_dsp3:es_dsp@3 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "eswin-dsp", "cdns,xrp-hw-eswin";
+				ranges = <0x28000000 0 0x5b018000 0x8000
+					0x28100000 0 0x5b1c0000 0x20000
+					0x28120000 0 0x5b1e0000 0x20000>;
+				clocks = <&d0_clock EIC7700_CLK_DSP_ACLK_3>;
+				clock-names = "aclk";
+				dsp_mbox = <&d0_mbox7>;
+				device-irq = <17
+					ESWIN_MAILBOX_DSP_3_TO_U84_REG_BASE
+					ESWIN_MAILBOX_WR_LOCK_BIT_DSP_3
+					ESWIN_MAILBOX_U84_TO_DSP_3_REG_BASE
+					ESWIN_MAIBOX_U84_IRQ_BIT
+					ESWIN_MAILBOX_U84_TO_NPU_0_REG_BASE>;
+				device-uart = <0x50900000>;
+				device-irq-mode = <1>;
+				host-irq-mode = <1>;
+				firmware-name = "eic7700_dsp_fw";
+				process-id = <3>;
+				dma-ranges = <0x30000000 0x0 0xc0000000 0xce000000>;
+				iommus = <&smmu0 EIC7700_SID_DSP_3>;
+				tbus = <EIC7700_TBUID_DSP3>;
+				numa-node-id = <0>;
+				aux-e31-dtim = <0x5a110000>;
+				dsp@0 {
+				};
+			};
+		};
+
+		gc820: g2d@50140000 {
+			compatible = "eswin,galcore_d0";
+			clocks = <&d0_clock EIC7700_CLK_VC_ACLK>,
+					<&d0_clock EIC7700_CLK_VC_CFG_CLK>,
+					<&d0_clock EIC7700_CLK_G2D_CFG_CLK>,
+					<&d0_clock EIC7700_CLK_CLK_G2D_ST2>,
+					<&d0_clock EIC7700_CLK_G2D_CLK>,
+					<&d0_clock EIC7700_CLK_G2D_ACLK>,
+					<&d0_clock EIC7700_CLK_VC_MON_PCLK>;
+			clock-names = "vc_aclk", "vc_cfg", "g2d_cfg", "g2d_st2", "g2d_clk", "g2d_aclk", "mon_pclk";
+			resets = <&d0_reset VC_RST_CTRL SW_VC_AXI_RSTN>,
+					<&d0_reset VC_RST_CTRL SW_VC_CFG_RSTN>,
+					<&d0_reset VC_RST_CTRL SW_VC_MONCFG_RSTN>,
+					<&d0_reset G2D_RST_CTRL SW_G2D_CORE_RSTN>,
+					<&d0_reset G2D_RST_CTRL SW_G2D_CFG_RSTN>,
+					<&d0_reset G2D_RST_CTRL SW_G2D_AXI_RSTN>;
+			reset-names = "axi", "cfg", "moncfg", "g2d_core", "g2d_cfg", "g2d_axi";
+			reg = <0 0x50140000 0 0x40000>, <0 0x50180000 0 0x40000>;
+			reg-names = "core_2d", "core_2d1";
+			fe-apb-offset = <0x800>;
+			interrupt-parent = <&plic0>;
+			interrupts = <49>, <50>;
+			interrupt-names = "core_2d", "core_2d1";
+			enable-mmu = <1>;
+			contiguous-size = <0xa00000>;
+			recovery = <0>;
+		};
+
+		gpu0: gpu@51400000 {
+			compatible = "img,gpu";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			reg = <0x0 0x51400000 0x0 0xFFFFF>;
+			clocks = <&d0_clock EIC7700_CLK_GPU_ACLK>,
+					<&d0_clock EIC7700_CLK_GPU_GRAY_CLK>,
+					<&d0_clock EIC7700_CLK_GPU_CFG_CLK>;
+			clock-names = "aclk", "gray_clk", "cfg_clk";
+			resets =<&d0_reset GPU_RST_CTRL SW_GPU_AXI_RSTN>,
+					<&d0_reset GPU_RST_CTRL SW_GPU_CFG_RSTN>,
+					<&d0_reset GPU_RST_CTRL SW_GPU_GRAY_RSTN>,
+					<&d0_reset GPU_RST_CTRL SW_GPU_JONES_RSTN>,
+					<&d0_reset GPU_RST_CTRL SW_GPU_SPU_RSTN>;
+			reset-names = "axi", "cfg", "gray", "jones","spu";
+			interrupt-parent = <&plic0>;
+			interrupts = <15>;
+		};
+
+		d0_sata: sata@0x50420000{
+			compatible = "snps,eswin-ahci";
+			reg = <0x0 0x50420000 0x0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupt-names = "intrq", "msi", "pme";
+			interrupts = <58>, <59>, <60>;
+			ports-implemented = <0x1>;
+			resets = <&d0_reset HSPDMA_RST_CTRL SW_SATA_ASIC0_RSTN>,
+					<&d0_reset HSPDMA_RST_CTRL SW_SATA_OOB_RSTN>,
+					<&d0_reset HSPDMA_RST_CTRL SW_SATA_PMALIVE_RSTN>,
+					<&d0_reset HSPDMA_RST_CTRL SW_SATA_RBC_RSTN>,
+					<&d0_reset HSPDMA_RST_CTRL SW_HSP_SATA_ARSTN>;
+			reset-names = "asic0", "oob", "pmalive", "rbc", "apb";
+			#size-cells = <2>;
+			iommus = <&smmu0 EIC7700_SID_SATA>;
+			tbus = <EIC7700_TBUID_SATA>;
+			dma-ranges = <0x0 0x0 0x0 0xc0000000 0x200 0x0>;
+			eswin,hsp_sp_csr = <&d0_hsp_sp_csr 0x1050>;
+			eswin,syscrg_csr = <&d0_sys_crg 0x41c>;
+			numa-node-id = <0>;
+		};
+
+		pcie: pcie@0x54000000 {
+			compatible = "eswin,eic7700-pcie";
+			clocks = <&d0_clock EIC7700_CLK_PCIET_ACLK>,
+				 <&d0_clock EIC7700_CLK_PCIET_CFG_CLK>,
+				 <&d0_clock EIC7700_CLK_PCIET_CR_CLK>,
+				 <&d0_clock EIC7700_CLK_PCIET_AUX_CLK>;
+			clock-names = "pcie_aclk", "pcie_cfg_clk", "pcie_cr_clk", "pcie_aux_clk";
+
+			reset-names = "pcie_cfg", "pcie_powerup", "pcie_pwren";
+			resets = <&d0_reset PCIE_RST_CTRL SW_PCIE_CFG_RSTN>,
+				 <&d0_reset PCIE_RST_CTRL SW_PCIE_POWERUP_RSTN>,
+				 <&d0_reset PCIE_RST_CTRL SW_PCIE_PERST_N>;
+
+			#address-cells = <3>;
+			#size-cells = <2>;
+			#interrupt-cells = <1>;
+			reg = <0x0 0x54000000 0x0 0x4000000>,	/* IP registers */
+			      <0x0 0x40000000 0x0 0x800000>,	/* Configuration space */
+			      <0x0 0x50000000 0x0 0x100000>;
+			reg-names = "dbi", "config", "mgmt";
+			device_type = "pci";
+			/* dma-coherent; */
+			bus-range = <0x0 0xff>;
+
+			ranges = <0x81000000  0x0 0x40800000  0x0 0x40800000 0x0 0x800000>,      /* I/O */
+				 <0x82000000  0x0 0x41000000  0x0 0x41000000 0x0 0xf000000>,    /* mem */
+				 <0xc3000000 0x80 0x00000000 0x80 0x00000000 0x02 0x00000000>;  /* mem prefetchable */
+
+			/* num-lanes = <0x4>; */
+			/**********************************
+			 	msi_ctrl_io[0~31] : 188~219
+			 	msi_ctrl_int : 220
+			**********************************/
+			interrupts = <220>;
+			interrupt-names = "msi";
+			interrupt-parent = <&plic0>;
+			iommus = <&smmu0 0xfe0000>;
+			iommu-map = <0x0 &smmu0 0xff0000 0xffffff>;
+			gen-x = <3>;
+			lane-x = <4>;
+			tbus = <EIC7700_TBUID_PCIE>;
+			status = "disabled";
+			numa-node-id = <0>;
+		};
+
+		ssi0: spi@50810000 {
+			compatible = "snps,eic7700-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x50810000 0x0 0x4000>;
+			spi-max-frequency = <4800000>;
+			clocks = <&d0_clock EIC7700_CLK_LSP_SSI0_PCLK>;
+			clock-names = "clk";
+			interrupt-parent = <&plic0>;
+			interrupts = <91>;
+			resets = <&d0_reset SSI_RST_CTRL SW_SSI_RST_N_0>;
+			reset-names = "spi";
+			eswin,spi_dma = <&d0_aon_dmac>;
+			dmas = <&d0_aon_dmac 38 3>, <&d0_aon_dmac 39 3>;
+			dma-names = "rx", "tx";
+			numa-node-id = <0>;
+			status = "disabled";
+		};
+
+		ssi1: spi@50814000 {
+			compatible = "snps,eic7700-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x50814000 0x0 0x4000>;
+			spi-max-frequency = <4800000>;
+			clocks = <&d0_clock EIC7700_CLK_LSP_SSI1_PCLK>;
+			clock-names = "clk";
+			interrupt-parent = <&plic0>;
+			interrupts = <92>;
+			resets = <&d0_reset SSI_RST_CTRL SW_SSI_RST_N_1>;
+			reset-names = "spi";
+			eswin,spi_dma = <&d0_aon_dmac>;
+			dmas = <&d0_aon_dmac 36 4>, <&d0_aon_dmac 37 4>;
+			dma-names = "rx", "tx";
+			numa-node-id = <0>;
+			status = "disabled";
+		};
+
+		bootspi: spi@51800000 {
+			compatible = "eswin,bootspi";
+			reg = <0x0 0x51800000 0x0 0x8000>,
+				<0x0 0x51828000 0x0 0x8000>,
+				<0x0 0x5c000000 0x0 0x8000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			clocks = <&d0_clock EIC7700_CLK_CLK_BOOTSPI_CFG>,
+					<&d0_clock EIC7700_CLK_CLK_BOOTSPI>;
+			clock-names = "cfg_clk", "clk";
+			resets = <&d0_reset BOOTSPI_RST_CTRL SW_BOOTSPI_RSTN>;
+			reset-names = "rst";
+			spi-max-frequency = <4800000>;
+			reg-io-width = <4>;
+			status = "disabled";
+		};
+
+		sdhci_emmc: mmc@50450000 {
+			compatible = "eswin,emmc-sdhci-5.1";
+			reg = <0x0 0x50450000 0x0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <79>;
+			assigned-clocks = <&d0_clock EIC7700_CLK_HSP_MSHC0_CORE_CLK>;
+			assigned-clock-rates = <200000000>;
+			clocks = <&d0_clock EIC7700_CLK_HSP_MSHC0_CORE_CLK>, <&d0_clock EIC7700_CLK_HSP_CFG_CLK>;
+			clock-names = "clk_xin", "clk_ahb";
+			clock-output-names = "emmc_cardclock";
+			#clock-cells = <0>;
+
+			resets = <&d0_reset HSPDMA_RST_CTRL SW_MSHC0_TXRX_RSTN>,
+				<&d0_reset HSPDMA_RST_CTRL SW_MSHC0_PHY_RSTN>,
+				<&d0_reset HSPDMA_RST_CTRL SW_HSP_EMMC_PRSTN>,
+				<&d0_reset HSPDMA_RST_CTRL SW_HSP_EMMC_ARSTN>;
+			reset-names = "txrx_rst", "phy_rst", "prstn", "arstn";
+
+			disable-cqe-dcmd;
+			bus-width = <8>;
+			non-removable;
+			/*mmc-ddr-1_8v;*/
+			mmc-hs400-1_8v;
+			max-frequency = <200000000>;
+			/* sdhci-caps-mask =  <0x0 0x3200000>; */
+			/* sdhci-caps-mask =  <0x2 0x3000000>; */
+			/* smmu */
+			#size-cells = <2>;
+			iommus = <&smmu0 EIC7700_SID_EMMC0>;
+			tbus = <EIC7700_TBUID_EMMC>;
+			dma-ranges = <0x0 0x00000000 0x0 0xc0000000 0x1 0x0>;
+			eswin,hsp_sp_csr = <&d0_hsp_sp_csr 0x1038>;
+			status = "disabled";
+			numa-node-id = <0>;
+		};
+
+		sdio0: mmc@0x50460000{
+			compatible = "eswin,sdhci-sdio";
+			reg = <0x0 0x50460000 0x0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <81>;
+			clocks =<&d0_clock EIC7700_CLK_HSP_MSHC1_CORE_CLK>,
+				<&d0_clock EIC7700_CLK_HSP_CFG_CLK>,
+				<&d0_clock EIC7700_SPLL2_FOUT3>,
+				<&d0_clock EIC7700_MUX_U_MSHCORE_ROOT_3MUX1_1>;
+			clock-names ="clk_xin","clk_ahb","clk_spll2_fout3","clk_mux1_1";
+			clock-output-names = "sdio0_cardclock";
+			#clock-cells = <0>;
+			resets = <&d0_reset HSPDMA_RST_CTRL SW_MSHC1_TXRX_RSTN>,
+				<&d0_reset HSPDMA_RST_CTRL SW_MSHC1_PHY_RSTN>,
+				<&d0_reset HSPDMA_RST_CTRL SW_HSP_SD0_PRSTN>,
+				<&d0_reset HSPDMA_RST_CTRL SW_HSP_SD0_ARSTN>;
+			reset-names = "txrx_rst","phy_rst","prstn","arstn";
+
+			core-clk-reg = <0x51828164>;
+			clock-frequency = <208000000>;
+			max-frequency = <208000000>;
+			#size-cells = <2>;
+			dma-ranges = <0x0 0x20000000 0x0 0xc0000000 0x0 0x40000000>;
+			iommus = <&smmu0 EIC7700_SID_SD0>;
+			tbus = <EIC7700_TBUID_SD>;
+			eswin,hsp_sp_csr = <&d0_hsp_sp_csr 0x103c>;
+			bus-width = <4>;
+			sdio-id = <0>;
+			numa-node-id = <0>;
+			status = "disabled";
+		};
+
+		sdio1: mmc@0x50470000{
+			compatible = "eswin,sdhci-sdio";
+			reg = <0x0 0x50470000 0x0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <83>;
+			clocks =<&d0_clock EIC7700_CLK_HSP_MSHC2_CORE_CLK>,
+				<&d0_clock EIC7700_CLK_HSP_CFG_CLK>,
+				<&d0_clock EIC7700_SPLL2_FOUT3>,
+				<&d0_clock EIC7700_MUX_U_MSHCORE_ROOT_3MUX1_1>;
+			clock-names ="clk_xin","clk_ahb","clk_spll2_fout3","clk_mux1_1";
+			clock-output-names = "sdio1_cardclock";
+			#clock-cells = <0>;
+			resets = <&d0_reset HSPDMA_RST_CTRL SW_MSHC2_TXRX_RSTN>,
+				<&d0_reset HSPDMA_RST_CTRL SW_MSHC2_PHY_RSTN>,
+				<&d0_reset HSPDMA_RST_CTRL SW_HSP_SD1_PRSTN>,
+				<&d0_reset HSPDMA_RST_CTRL SW_HSP_SD1_ARSTN>;
+			reset-names = "txrx_rst","phy_rst","prstn","arstn";
+
+			core-clk-reg = <0x51828168>;
+			clock-frequency = <208000000>;
+			max-frequency = <208000000>;
+			#size-cells = <2>;
+			dma-ranges = <0x0 0x20000000 0x0 0xc0000000 0x0 0x40000000>;
+			iommus = <&smmu0 EIC7700_SID_SD1>;
+			tbus = <EIC7700_TBUID_SD>;
+			eswin,hsp_sp_csr = <&d0_hsp_sp_csr 0x1040>;
+			bus-width = <4>;
+			sdio-id = <1>;
+			numa-node-id = <0>;
+			status = "disabled";
+		};
+
+		vdec0: video-decoder0@50100000 {
+			compatible = "eswin,video-decoder0";
+			clocks = <&d0_clock EIC7700_CLK_VC_ACLK>,
+					 <&d0_clock EIC7700_CLK_VC_CFG_CLK>,
+					 <&d0_clock EIC7700_CLK_VC_JD_CLK>,
+					 <&d0_clock EIC7700_CLK_VC_VD_CLK>,
+					 <&d0_clock EIC7700_MUX_U_VCACLK_ROOT_2MUX1_GFREE>,
+					 <&d0_clock EIC7700_SPLL0_FOUT1>,
+					 <&d0_clock EIC7700_SPLL2_FOUT1>,
+					 <&d0_clock EIC7700_CLK_VC_JD_PCLK>,
+					 <&d0_clock EIC7700_CLK_VC_VD_PCLK>,
+					 <&d0_clock EIC7700_CLK_VC_MON_PCLK>;
+			clock-names = "aclk", "cfg_clk", "jd_clk", "vd_clk", "vc_mux", "spll0_fout1", "spll2_fout1", "jd_pclk", "vd_pclk", "mon_pclk";
+			resets = <&d0_reset VC_RST_CTRL SW_VC_AXI_RSTN>,
+					 <&d0_reset VC_RST_CTRL SW_VC_CFG_RSTN>,
+					 <&d0_reset VC_RST_CTRL SW_VC_MONCFG_RSTN>,
+					 <&d0_reset JD_RST_CTRL SW_JD_CFG_RSTN>,
+					 <&d0_reset JD_RST_CTRL SW_JD_AXI_RSTN>,
+					 <&d0_reset VD_RST_CTRL SW_VD_CFG_RSTN>,
+					 <&d0_reset VD_RST_CTRL SW_VD_AXI_RSTN>;
+			reset-names = "axi", "cfg", "moncfg", "jd_cfg", "jd_axi", "vd_cfg", "vd_axi";
+			eswin,syscfg = <&d0_sys_con 0x0 0x4>;
+
+			vcmd-core = <0 0x6c>;
+			axife-core = <0x200 0x100>;
+			vdec-core = <0x800 0xc00>;
+			interrupt-parent = <&plic0>;
+			#size-cells = <2>;
+			dma-ranges = <0x0 0x0 0x0 0x80000000 0x200 0x0>;
+			//iommus = <&smmu0 EIC7700_SID_VDEC>;
+			vccsr-reg = <0x0 0x501c0000 0x0 0x1000>;
+			numa-node-id = <0>;
+			tbus = <EIC7700_TBUID_VDEC>, <EIC7700_TBUID_JDEC>;
+
+			vdec_0: vdec0@50100000 {
+				core-name = "video-dec0";
+				base-addr = <0x50100000>;
+				interrupts = <236>;
+			};
+
+			jdec_0: jdec0@50120000 {
+				core-name = "jpeg-dec0";
+				base-addr = <0x50120000>;
+				interrupts = <237>;
+			};
+		};
+
+		venc0: video-encoder@50110000 {
+			compatible = "eswin,video-encoder0";
+			clocks = <&d0_clock EIC7700_CLK_VC_ACLK>,
+					 <&d0_clock EIC7700_CLK_VC_CFG_CLK>,
+					 <&d0_clock EIC7700_CLK_VC_JE_CLK>,
+					 <&d0_clock EIC7700_CLK_VC_VE_CLK>,
+					 <&d0_clock EIC7700_MUX_U_VCACLK_ROOT_2MUX1_GFREE>,
+					 <&d0_clock EIC7700_SPLL0_FOUT1>,
+					 <&d0_clock EIC7700_SPLL2_FOUT1>,
+					 <&d0_clock EIC7700_CLK_VC_JE_PCLK>,
+					 <&d0_clock EIC7700_CLK_VC_VE_PCLK>,
+					 <&d0_clock EIC7700_CLK_VC_MON_PCLK>;
+			clock-names = "aclk", "cfg_clk", "je_clk", "ve_clk", "vc_mux", "spll0_fout1", "spll2_fout1", "je_pclk", "ve_pclk", "mon_pclk";
+			resets = <&d0_reset VC_RST_CTRL SW_VC_AXI_RSTN>,
+					 <&d0_reset VC_RST_CTRL SW_VC_CFG_RSTN>,
+					 <&d0_reset VC_RST_CTRL SW_VC_MONCFG_RSTN>,
+					 <&d0_reset JE_RST_CTRL SW_JE_CFG_RSTN>,
+					 <&d0_reset JE_RST_CTRL SW_JE_AXI_RSTN>,
+					 <&d0_reset VE_RST_CTRL SW_VE_CFG_RSTN>,
+					 <&d0_reset VE_RST_CTRL SW_VE_AXI_RSTN>;
+			reset-names = "axi", "cfg", "moncfg", "je_cfg", "je_axi", "ve_cfg", "ve_axi";
+			eswin,syscfg = <&d0_sys_con 0x0 0x4>;
+
+			vcmd-core = <0 0x6c>;
+			axife-core = <0x2000 0x7d0>;
+			venc-core = <0x1000 0x87c>;
+			interrupt-parent = <&plic0>;
+			#size-cells = <2>;
+			dma-ranges = <0x0 0x0 0x0 0x80000000 0x200 0x0>;
+			//iommus = <&smmu0 EIC7700_SID_VENC>;
+			vccsr-reg = <0x0 0x501c0000 0x0 0x1000>;
+			numa-node-id = <0>;
+			tbus = <EIC7700_TBUID_VENC>, <EIC7700_TBUID_JENC>;
+
+			venc_0: venc0@50110000 {
+				core-name = "video-enc0";
+				base-addr = <0x50110000>;
+				interrupts = <229>;
+			};
+
+			jenc_0: jenc0@50130000 {
+				core-name = "jpeg-enc0";
+				base-addr = <0x50130000>;
+				interrupts = <232>;
+			};
+		};
+
+		/*mailbox between u84 & scpu*/
+		d0_mbox0: mbox@50a00000 {
+			compatible = "eswin,eic7700-mailbox";
+			reg = <0 ESWIN_MAILBOX_U84_TO_SCPU_REG_BASE 0 0x10000>,
+				  <0 ESWIN_MAILBOX_SCPU_TO_U84_REG_BASE 0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <117>;
+			#mbox-cells = <1>;
+			clocks = <&d0_clock EIC7700_CLK_MAILBOX_0>,
+				<&d0_clock EIC7700_CLK_MAILBOX_1>;
+			clock-names = "pclk_mailbox_host", "pclk_mailbox_device";
+			resets = <&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_0>,
+				<&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_1>;
+			reset-names = "rst", "rst_device";
+			lock-bit = <ESWIN_MAILBOX_WR_LOCK_BIT_U84>;
+			irq-bit = <ESWIN_MAIBOX_SCPU_IRQ_BIT>;
+		};
+
+		/*mailbox between u84 & lpcpu*/
+		d0_mbox1: mbox@50a20000 {
+			compatible = "eswin,eic7700-mailbox";
+			reg = <0 ESWIN_MAILBOX_U84_TO_LPCPU_REG_BASE 0 0x10000>,
+				  <0 ESWIN_MAILBOX_LPCPU_TO_U84_REG_BASE 0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <119>;
+			#mbox-cells = <1>;
+			clocks = <&d0_clock EIC7700_CLK_MAILBOX_2>,
+				<&d0_clock EIC7700_CLK_MAILBOX_3>;
+			clock-names = "pclk_mailbox_host", "pclk_mailbox_device";
+			resets = <&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_2>,
+				<&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_3>;
+			reset-names = "rst", "rst_device";
+			lock-bit = <ESWIN_MAILBOX_WR_LOCK_BIT_U84>;
+			irq-bit  = <ESWIN_MAIBOX_LPCPU_IRQ_BIT>;
+		};
+
+		/*mailbox between u84 & npu_0*/
+		d0_mbox2: mbox@50a40000 {
+			compatible = "eswin,npu0-mailbox";
+			reg = <0 ESWIN_MAILBOX_U84_TO_NPU_0_REG_BASE 0 0x10000>,
+				  <0 ESWIN_MAILBOX_NPU_0_TO_U84_REG_BASE 0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <121>;
+			#mbox-cells = <1>;
+			clocks = <&d0_clock EIC7700_CLK_MAILBOX_4>,
+				<&d0_clock EIC7700_CLK_MAILBOX_5>;
+			clock-names = "pclk_mailbox_host", "pclk_mailbox_device";
+			resets = <&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_4>,
+				<&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_5>;
+			reset-names = "rst", "rst_device";
+			lock-bit = <ESWIN_MAILBOX_WR_LOCK_BIT_U84>;
+			irq-bit  = <ESWIN_MAIBOX_NPU_0_IRQ_BIT>;
+		};
+
+		/*mailbox between u84 & npu_1*/
+		d0_mbox3: mbox@50a60000 {
+			compatible = "eswin,eic7700-mailbox";
+			reg = <0 ESWIN_MAILBOX_U84_TO_NPU_1_REG_BASE 0 0x10000>,
+				  <0 ESWIN_MAILBOX_NP1_0_TO_U84_REG_BASE 0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <123>;
+			#mbox-cells = <1>;
+			clocks = <&d0_clock EIC7700_CLK_MAILBOX_6>,
+				<&d0_clock EIC7700_CLK_MAILBOX_7>;
+			clock-names = "pclk_mailbox_host", "pclk_mailbox_device";
+			resets = <&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_6>,
+				<&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_7>;
+			reset-names = "rst", "rst_device";
+			lock-bit = <ESWIN_MAILBOX_WR_LOCK_BIT_U84>;
+			irq-bit  = <ESWIN_MAIBOX_NPU_1_IRQ_BIT>;
+		};
+
+		/*mailbox between u84 & dsp_0*/
+		d0_mbox4: mbox@50a80000 {
+			compatible = "eswin,dsp0-mailbox";
+			reg = <0 ESWIN_MAILBOX_U84_TO_DSP_0_REG_BASE 0 0x10000>,
+				  <0 ESWIN_MAILBOX_DSP_0_TO_U84_REG_BASE 0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <125>;
+			#mbox-cells = <1>;
+			clocks = <&d0_clock EIC7700_CLK_MAILBOX_8>,
+				<&d0_clock EIC7700_CLK_MAILBOX_9>;
+			clock-names = "pclk_mailbox_host", "pclk_mailbox_device";
+			resets = <&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_8>,
+				<&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_9>;
+			reset-names = "rst", "rst_device";
+			lock-bit = <ESWIN_MAILBOX_WR_LOCK_BIT_U84>;
+			irq-bit  = <ESWIN_MAIBOX_DSP_0_IRQ_BIT>;
+		};
+
+		/*mailbox between u84 & dsp_1*/
+		d0_mbox5: mbox@50aa0000 {
+			compatible = "eswin,dsp1-mailbox";
+			reg = <0 ESWIN_MAILBOX_U84_TO_DSP_1_REG_BASE 0 0x10000>,
+				  <0 ESWIN_MAILBOX_DSP_1_TO_U84_REG_BASE 0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <127>;
+			#mbox-cells = <1>;
+			clocks = <&d0_clock EIC7700_CLK_MAILBOX_10>,
+				<&d0_clock EIC7700_CLK_MAILBOX_11>;
+			clock-names = "pclk_mailbox_host", "pclk_mailbox_device";
+			resets = <&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_10>,
+				<&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_11>;
+			reset-names = "rst", "rst_device";
+			lock-bit = <ESWIN_MAILBOX_WR_LOCK_BIT_U84>;
+			irq-bit  = <ESWIN_MAIBOX_DSP_1_IRQ_BIT>;
+		};
+
+		/*mailbox between u84 & dsp_2*/
+		d0_mbox6: mbox@50ac0000 {
+			compatible = "eswin,dsp2-mailbox";
+			reg = <0 ESWIN_MAILBOX_U84_TO_DSP_2_REG_BASE 0 0x10000>,
+				  <0 ESWIN_MAILBOX_DSP_2_TO_U84_REG_BASE 0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <129>;
+			#mbox-cells = <1>;
+			clocks = <&d0_clock EIC7700_CLK_MAILBOX_12>,
+				<&d0_clock EIC7700_CLK_MAILBOX_13>;
+			clock-names = "pclk_mailbox_host", "pclk_mailbox_device";
+			resets = <&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_12>,
+				<&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_13>;
+			reset-names = "rst", "rst_device";
+			lock-bit = <ESWIN_MAILBOX_WR_LOCK_BIT_U84>;
+			irq-bit  = <ESWIN_MAIBOX_DSP_2_IRQ_BIT>;
+		};
+
+		/*mailbox between u84 & dsp_3*/
+		d0_mbox7: mbox@50ae0000 {
+			compatible = "eswin,dsp3-mailbox";
+			reg = <0 ESWIN_MAILBOX_U84_TO_DSP_3_REG_BASE 0 0x10000>,
+				  <0 ESWIN_MAILBOX_DSP_3_TO_U84_REG_BASE 0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <131>;
+			#mbox-cells = <1>;
+			clocks = <&d0_clock EIC7700_CLK_MAILBOX_14>,
+				<&d0_clock EIC7700_CLK_MAILBOX_15>;
+			clock-names = "pclk_mailbox_host", "pclk_mailbox_device";
+			resets = <&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_14>,
+				<&d0_reset MBOX_RST_CTRL SW_MBOX_RST_N_15>;
+			reset-names = "rst", "rst_device";
+			lock-bit = <ESWIN_MAILBOX_WR_LOCK_BIT_U84>;
+			irq-bit  = <ESWIN_MAIBOX_DSP_3_IRQ_BIT>;
+		};
+
+		d0_ipc_scpu:ipc@0 {
+			compatible = "eswin,eic7700-ipc";
+			#size-cells = <2>;
+			dma-ranges = <0x0 0x80000000 0x0 0xc0000000 0x0 0x80000000>;
+			iommus = <&smmu0 EIC7700_SID_SCPU>;
+			tbus = <EIC7700_TBUID_SCPU>;
+			eswin,syscfg = <&d0_sys_con SCPU_SID_REG_OFFSET 0>,
+			               <&d0_sys_con CRYPT_SID_REG_OFFSET 0>;
+			mboxes = <&d0_mbox0 0>;
+			mbox-names = "u84_scpu";
+			numa-node-id = <0>;
+		};
+
+		d0_lpcpu:lpcpu@0 {
+			compatible = "eswin,eic7700-lpcpu";
+			fw-region = <&lpcpu0_reserved>;
+			clocks = <&d0_clock EIC7700_CLK_CLK_LPCPU_CORE>,
+					<&d0_clock EIC7700_CLK_CLK_LPCPU_BUS>;
+			clock-names = "core_clk", "bus_clk";
+
+			reset-names = "core_rst", "bus_rst", "dbg_rst";
+			resets = <&d0_reset LPCPU_RST_CTRL SW_LPCPU_CORE_RSTN>,
+					<&d0_reset LPCPU_RST_CTRL SW_LPCPU_BUS_RSTN>,
+					<&d0_reset LPCPU_RST_CTRL SW_LPCPU_DBG_RSTN>;
+			#size-cells = <2>;
+
+			dma-ranges = <0x0 0xb0000000 0x0 0xc0000000 0x0 0x50000000>;
+			iommus = <&smmu0 EIC7700_SID_LCPU>;
+			eswin,syscfg = <&d0_sys_con LCPU_SID_REG_OFFSET 0>;
+			tbus = <EIC7700_TBUID_LPCPU>;
+			mboxes = <&d0_mbox1 0>;
+			mbox-names = "u84_lpcpu";
+			numa-node-id = <0>;
+			status = "disabled";
+		};
+
+		pvt0: pvt@0x50b00000 {
+			compatible = "eswin,eswin-pvt";
+			clocks = <&d0_clock EIC7700_CLK_PVT_CLK_0>;
+			clock-names = "pvt_clk";
+			resets = <&d0_reset PVT_RST_CTRL SW_PVT_RST_N_0>;
+			reset-names = "pvt_rst";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x50b00000 0x0 0x10000>;
+			interrupts = <349>;
+			interrupt-parent = <&plic0>;
+			status = "disabled";
+		};
+		pvt1: pvt@0x52360000 {
+			compatible = "eswin,eswin-pvt";
+			clocks = <&d0_clock EIC7700_CLK_PVT_CLK_1>;
+			clock-names = "pvt_clk";
+			resets = <&d0_reset PVT_RST_CTRL SW_PVT_RST_N_1>;
+			reset-names = "pvt_rst";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x52360000 0x0 0x20000>;
+			interrupts = <350>;
+			interrupt-parent = <&plic0>;
+			status = "disabled";
+		};
+
+		fan_control: fan_control@50b50000 {
+			compatible = "eswin-fan-control";
+			reg = <0x0 0x50b50000 0x0 0x10000>;
+			clocks = <&d0_clock EIC7700_CLK_LSP_FAN_PCLK>;
+			clock-names = "pclk";
+			resets = <&d0_reset FAN_RST_CTRL SW_FAN_RST_N>;
+			reset-names = "fan_rst";
+			interrupt-parent = <&plic0>;
+			interrupt-names = "fanirq";
+			interrupts = <354>;
+			pulses-per-revolution = <2>;
+			pwm-minimum-period = <1000>;
+			pwms = <&pwm0 0 100000>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_fan_tach_default>;
+			status = "disabled";
+		};
+
+		d0_i2c0: i2c@50950000 {
+			compatible = "snps,designware-i2c";
+			clock-frequency = <100000>;
+			clocks = <&d0_clock EIC7700_CLK_LSP_I2C0_PCLK>;
+			clock-names = "pclk";
+			resets = <&d0_reset I2C_RST_CTRL SW_I2C_RST_N_0>;
+			reset-names = "rst";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x50950000 0x0 0x8000>;
+			interrupts = <105>;
+			interrupt-parent = <&plic0>;
+		};
+		d0_i2c1: i2c@50960000 {
+			compatible = "snps,designware-i2c";
+			clock-frequency = <100000>;
+			clocks = <&d0_clock EIC7700_CLK_LSP_I2C1_PCLK>;
+			clock-names = "pclk";
+			resets = <&d0_reset I2C_RST_CTRL SW_I2C_RST_N_1>;
+			reset-names = "rst";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x50960000 0x0 0x10000>;
+			interrupts = <106>;
+			interrupt-parent = <&plic0>;
+		};
+		d0_i2c2: i2c@50970000 {
+				compatible = "snps,designware-i2c";
+				clock-frequency = <100000>;
+				clocks = <&d0_clock EIC7700_CLK_LSP_I2C2_PCLK>;
+				clock-names = "pclk";
+				resets = <&d0_reset I2C_RST_CTRL SW_I2C_RST_N_2>;
+				reset-names = "rst";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0 0x50970000 0x0 0x8000>;
+				interrupts = <107>;
+				interrupt-parent = <&plic0>;
+		};
+		d0_i2c3: i2c@50980000 {
+				compatible = "snps,designware-i2c";
+				clock-frequency = <100000>;
+				clocks = <&d0_clock EIC7700_CLK_LSP_I2C3_PCLK>;
+				clock-names = "pclk";
+				resets = <&d0_reset I2C_RST_CTRL SW_I2C_RST_N_3>;
+				reset-names = "rst";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0 0x50980000 0x0 0x8000>;
+				interrupts = <108>;
+				interrupt-parent = <&plic0>;
+		};
+		d0_i2c4: i2c@50990000 {
+				compatible = "snps,designware-i2c";
+				clock-frequency = <100000>;
+				clocks = <&d0_clock EIC7700_CLK_LSP_I2C4_PCLK>;
+				clock-names = "pclk";
+				resets = <&d0_reset I2C_RST_CTRL SW_I2C_RST_N_4>;
+				reset-names = "rst";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0 0x50990000 0x0 0x8000>;
+				interrupts = <109>;
+				interrupt-parent = <&plic0>;
+		};
+		d0_i2c5: i2c@509a0000 {
+				compatible = "snps,designware-i2c";
+				clock-frequency = <100000>;
+				clocks = <&d0_clock EIC7700_CLK_LSP_I2C5_PCLK>;
+				clock-names = "pclk";
+				resets = <&d0_reset I2C_RST_CTRL SW_I2C_RST_N_5>;
+				reset-names = "rst";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0 0x509a0000 0x0 0x8000>;
+				interrupts = <110>;
+				interrupt-parent = <&plic0>;
+		};
+		d0_i2c6: i2c@509b0000 {
+				compatible = "snps,designware-i2c";
+				clock-frequency = <100000>;
+				clocks = <&d0_clock EIC7700_CLK_LSP_I2C6_PCLK>;
+				clock-names = "pclk";
+				resets = <&d0_reset I2C_RST_CTRL SW_I2C_RST_N_6>;
+				reset-names = "rst";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0 0x509b0000 0x0 0x8000>;
+				interrupts = <111>;
+				interrupt-parent = <&plic0>;
+		};
+		d0_i2c7: i2c@509c0000 {
+				compatible = "snps,designware-i2c";
+				clock-frequency = <100000>;
+				clocks = <&d0_clock EIC7700_CLK_LSP_I2C7_PCLK>;
+				clock-names = "pclk";
+				resets = <&d0_reset I2C_RST_CTRL SW_I2C_RST_N_7>;
+				reset-names = "rst";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0 0x509c0000 0x0 0x8000>;
+				interrupts = <112>;
+				interrupt-parent = <&plic0>;
+		};
+		d0_i2c8: i2c@509d0000 {
+				compatible = "snps,designware-i2c";
+				clock-frequency = <100000>;
+				clocks = <&d0_clock EIC7700_CLK_LSP_I2C8_PCLK>;
+				clock-names = "pclk";
+				resets = <&d0_reset I2C_RST_CTRL SW_I2C_RST_N_8>;
+				reset-names = "rst";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0 0x509d0000 0x0 0x8000>;
+				interrupts = <113>;
+				interrupt-parent = <&plic0>;
+		};
+		d0_i2c9: i2c@509e0000 {
+				compatible = "snps,designware-i2c";
+				clock-frequency = <100000>;
+				clocks = <&d0_clock EIC7700_CLK_LSP_I2C9_PCLK>;
+				clock-names = "pclk";
+				resets = <&d0_reset I2C_RST_CTRL SW_I2C_RST_N_9>;
+				reset-names = "rst";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0 0x509e0000 0x0 0x8000>;
+				interrupts = <114>;
+				interrupt-parent = <&plic0>;
+		};
+		d0_aon_i2c0: i2c@51830000 {
+				compatible = "snps,designware-i2c";
+				clock-frequency = <100000>;
+				clocks = <&d0_clock EIC7700_CLK_AON_I2C0_PCLK>;
+				clock-names = "pclk";
+				resets = <&d0_reset I2C0_RST_CTRL SW_I2C0_PRSTN>;
+				reset-names = "rst";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0 0x51830000 0x0 0x8000>;
+				interrupts = <290>;
+				interrupt-parent = <&plic0>;
+				eswin,i2c_dma = <&d0_aon_dmac>;
+				dma-names = "rx", "tx";
+				/*
+				* dmas : DMA specifiers
+				* &d0_aon_dmac : dma controller
+				* 41 : i2c0 aon dma handshake number
+				* 0xff : no need to select to dma controller
+				*/
+				dmas = <&d0_aon_dmac 41 0xff>, <&d0_aon_dmac 42 0xff>;
+		};
+		d0_aon_i2c1: i2c@51838000 {
+				compatible = "snps,designware-i2c";
+				clock-frequency = <100000>;
+				clocks = <&d0_clock EIC7700_CLK_AON_I2C1_PCLK>;
+				clock-names = "pclk";
+				resets = <&d0_reset I2C1_RST_CTRL SW_I2C1_PRSTN>;
+				reset-names = "rst";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				reg = <0x0 0x51838000 0x0 0x8000>;
+				interrupts = <291>;
+				interrupt-parent = <&plic0>;
+		};
+		pinctrl: pinctrl@0x51600080 {
+			compatible = "eswin,eic7700-pinctrl";
+			reg = <0x0 0x51600080 0x0 0x1FFF80>;
+			status = "disabled";
+		};
+
+		gpio0: gpio@51600000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "snps,dw-apb-gpio";
+			reg = <0x0 0x51600000 0x0 0x80>;
+
+			porta: gpio-port@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				ngpios = <32>;
+				reg = <0>;
+				interrupt-parent = <&plic0>;
+				interrupts = <303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318
+								319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334>;
+			};
+
+			portb: gpio-port@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				ngpios = <32>;
+				reg = <1>;
+			};
+
+			portc: gpio-port@2 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				ngpios = <32>;
+				reg = <2>;
+			};
+
+			portd: gpio-port@3 {
+				compatible = "snps,dw-apb-gpio-port";
+				gpio-controller;
+				#gpio-cells = <2>;
+				ngpios = <16>;
+				reg = <3>;
+			};
+		};
+
+		pwm0: pwm@0x50818000 {
+			compatible = "eswin,pwm-eswin";
+			#pwm-cells = <2>;
+			reg = <0x0 0x50818000 0x0 0x4000>;
+			clock-names = "pwm","pclk";
+			clocks = <&d0_clock EIC7700_CLK_LSP_TIMER_PCLK>;
+			clock-frequency = <200000000>;
+			resets = <&d0_reset TIMER_RST_CTRL SW_TIMER_RST_N>;
+			reset-names = "pwmrst";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_pwm0_default>;
+			status = "disabled";
+		};
+
+		wdt0: watchdog@0x50800000 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x50800000 0x0 0x4000>;
+			clocks =<&d0_clock EIC7700_CLK_LSP_WDT0_PCLK>;
+			clock-names = "pclk";
+			resets = <&d0_reset WDT_RST_CTRL SW_WDT_RST_N_0>;
+			reset-names = "rst";
+			interrupts = <87>;
+			interrupt-parent = <&plic0>;
+			status = "disabled";
+		};
+
+		wdt1: watchdog@0x50804000 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x50804000 0x0 0x4000>;
+			clocks =<&d0_clock EIC7700_CLK_LSP_WDT1_PCLK>;
+			clock-names = "pclk";
+			resets = <&d0_reset WDT_RST_CTRL SW_WDT_RST_N_1>;
+			reset-names = "rst";
+			interrupts = <88>;
+			interrupt-parent = <&plic0>;
+			status = "disabled";
+		};
+
+		wdt2: watchdog@0x50808000 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x50808000 0x0 0x4000>;
+			clocks =<&d0_clock EIC7700_CLK_LSP_WDT2_PCLK>;
+			clock-names = "pclk";
+			resets = <&d0_reset WDT_RST_CTRL SW_WDT_RST_N_2>;
+			reset-names = "rst";
+			interrupts = <89>;
+			interrupt-parent = <&plic0>;
+			status = "disabled";
+		};
+
+		wdt3: watchdog@0x5080c000 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x5080c000 0x0 0x4000>;
+			clocks =<&d0_clock EIC7700_CLK_LSP_WDT3_PCLK>;
+			clock-names = "pclk";
+			resets = <&d0_reset WDT_RST_CTRL SW_WDT_RST_N_3>;
+			reset-names = "rst";
+			interrupts = <90>;
+			interrupt-parent = <&plic0>;
+			status = "disabled";
+		};
+
+		timer0: timer@0x51840000 {
+			compatible = "eswin,eswin-timer";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			reg = <0x0 0x51840000 0x0 0x8000>;
+			perf_count = <7>;
+			interrupt-parent = <&plic0>;
+			interrupts = <345>;
+			clock-names = "pclk","timer_aclk";
+			clocks = <&d0_clock EIC7700_CLK_TIMER_PCLK_0>,
+					 <&d0_clock EIC7700_CLK_TIMER_CLK_0>;
+			resets = <&d0_reset TIMER0_RST_CTRL SW_TIMER0_RSTN_0>,
+				<&d0_reset TIMER0_RST_CTRL SW_TIMER0_RSTN_1>,
+				<&d0_reset TIMER0_RST_CTRL SW_TIMER0_RSTN_2>,
+				<&d0_reset TIMER0_RST_CTRL SW_TIMER0_RSTN_3>,
+				<&d0_reset TIMER0_RST_CTRL SW_TIMER0_RSTN_4>,
+				<&d0_reset TIMER0_RST_CTRL SW_TIMER0_RSTN_5>,
+				<&d0_reset TIMER0_RST_CTRL SW_TIMER0_RSTN_6>,
+				<&d0_reset TIMER0_RST_CTRL SW_TIMER0_RSTN_7>,
+				<&d0_reset TIMER0_RST_CTRL SW_TIMER0_PRSTN>;
+			reset-names = "trst0","trst1","trst2","trst3","trst4","trst5","trst6","trst7","prst";
+		};
+
+		timer1: timer@0x51848000 {
+			compatible = "eswin,eswin-timer";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			reg = <0x0 0x51848000 0x0 0x8000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <346>;
+			clock-names = "pclk","timer_aclk";
+			clocks = <&d0_clock EIC7700_CLK_TIMER_PCLK_1>,
+					 <&d0_clock EIC7700_CLK_TIMER_CLK_1>;
+			resets = <&d0_reset TIMER1_RST_CTRL SW_TIMER1_RSTN_0>,
+				<&d0_reset TIMER1_RST_CTRL SW_TIMER1_RSTN_1>,
+				<&d0_reset TIMER1_RST_CTRL SW_TIMER1_RSTN_2>,
+				<&d0_reset TIMER1_RST_CTRL SW_TIMER1_RSTN_3>,
+				<&d0_reset TIMER1_RST_CTRL SW_TIMER1_RSTN_4>,
+				<&d0_reset TIMER1_RST_CTRL SW_TIMER1_RSTN_5>,
+				<&d0_reset TIMER1_RST_CTRL SW_TIMER1_RSTN_6>,
+				<&d0_reset TIMER1_RST_CTRL SW_TIMER1_RSTN_7>,
+				<&d0_reset TIMER1_RST_CTRL SW_TIMER1_PRSTN>;
+			reset-names = "trst0","trst1","trst2","trst3","trst4","trst5","trst6","trst7","prst";
+		};
+
+		timer2: timer@0x51850000 {
+			compatible = "eswin,eswin-timer";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			reg = <0x0 0x51850000 0x0 0x8000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <347>;
+			clock-names = "pclk","timer_aclk";
+			clocks = <&d0_clock EIC7700_CLK_TIMER_PCLK_2>,
+					 <&d0_clock EIC7700_CLK_TIMER_CLK_2>;
+			resets = <&d0_reset TIMER2_RST_CTRL SW_TIMER2_RSTN_0>,
+			   <&d0_reset TIMER2_RST_CTRL SW_TIMER2_RSTN_1>,
+			   <&d0_reset TIMER2_RST_CTRL SW_TIMER2_RSTN_2>,
+			   <&d0_reset TIMER2_RST_CTRL SW_TIMER2_RSTN_3>,
+			   <&d0_reset TIMER2_RST_CTRL SW_TIMER2_RSTN_4>,
+			   <&d0_reset TIMER2_RST_CTRL SW_TIMER2_RSTN_5>,
+			   <&d0_reset TIMER2_RST_CTRL SW_TIMER2_RSTN_6>,
+			   <&d0_reset TIMER2_RST_CTRL SW_TIMER2_RSTN_7>,
+			   <&d0_reset TIMER2_RST_CTRL SW_TIMER2_PRSTN>;
+			reset-names = "trst0","trst1","trst2","trst3","trst4","trst5","trst6","trst7","prst";
+		};
+
+		timer3: timer@0x51858000 {
+			compatible = "eswin,eswin-timer";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			reg = <0x0 0x51858000 0x0 0x8000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <348>;
+			clock-names = "pclk","timer_aclk","timer3_clk8";
+			clocks = <&d0_clock EIC7700_CLK_TIMER_PCLK_3>,
+					 <&d0_clock EIC7700_CLK_TIMER_CLK_3>,
+					 <&d0_clock EIC7700_CLK_TIMER3_CLK8>;
+			resets = <&d0_reset TIMER3_RST_CTRL SW_TIMER3_RSTN_0>,
+				<&d0_reset TIMER3_RST_CTRL SW_TIMER3_RSTN_1>,
+				<&d0_reset TIMER3_RST_CTRL SW_TIMER3_RSTN_2>,
+				<&d0_reset TIMER3_RST_CTRL SW_TIMER3_RSTN_3>,
+				<&d0_reset TIMER3_RST_CTRL SW_TIMER3_RSTN_4>,
+				<&d0_reset TIMER3_RST_CTRL SW_TIMER3_RSTN_5>,
+				<&d0_reset TIMER3_RST_CTRL SW_TIMER3_RSTN_6>,
+				<&d0_reset TIMER3_RST_CTRL SW_TIMER3_RSTN_7>,
+				<&d0_reset TIMER3_RST_CTRL SW_TIMER3_PRSTN>;
+			reset-names = "trst0","trst1","trst2","trst3","trst4","trst5","trst6","trst7","prst";
+		};
+
+		die0_rtc: rtc@51818000 {
+			compatible = "eswin,eic7700-rtc";
+			reg = <0x0 0x51818000 0x0 0x400>;
+			eswin,syscfg = <&d0_sys_con 0x3c0>;
+			interrupt-parent = <&plic0>;
+			interrupts = <292>;
+			clocks = <&d0_clock EIC7700_CLK_CLK_RTC>;
+			clock-names = "rtcclk";
+			clock-frequency = <15625>;
+			resets = <&d0_reset RTC_RST_CTRL SW_RTC_RSTN>;
+			reset-names = "rtcrst";
+			status = "disabled";
+		};
+
+		d0_i2s0: i2s0@50200000 {
+			compatible = "snps,i2s";
+			clocks = <&d0_clock EIC7700_CLK_VO_I2S_MCLK>;
+			clock-names = "mclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#sound-dai-cells = <0x00000000>;
+			reg = <0x0 0x50200000 0x0 0x10000>;
+			dma-names = "rx", "tx";
+			dmas = <&d0_aon_dmac 4 0>, <&d0_aon_dmac 5 0>;
+			vo_mclk_sel,syscrg = <&d0_sys_crg 0x1bc>;
+			resets = <&d0_reset VO_I2SRST_CTRL SW_VO_I2S_RSTN>,
+				<&d0_reset VO_I2SRST_CTRL SW_VO_I2S_PRSTN>,
+				<&d0_reset VO_PHYRST_CTRL SW_VO_PRSTN>;
+			reset-names = "i2srst", "i2sprst", "voprst";
+		};
+
+		d0_i2s1: i2s1@50210000 {
+			compatible = "snps,i2s";
+			clocks = <&d0_clock EIC7700_CLK_VO_I2S_MCLK>;
+			clock-names = "mclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#sound-dai-cells = <0x00000000>;
+			reg = <0x0 0x50210000 0x0 0x10000>;
+			dma-names = "rx", "tx";
+			dmas = <&d0_aon_dmac 2 1>, <&d0_aon_dmac 3 1>;
+			vo_mclk_sel,syscrg = <&d0_sys_crg 0x1bc>;
+			resets = <&d0_reset VO_I2SRST_CTRL SW_VO_I2S_RSTN>,
+				<&d0_reset VO_I2SRST_CTRL SW_VO_I2S_PRSTN>,
+				<&d0_reset VO_PHYRST_CTRL SW_VO_PRSTN>;
+			reset-names = "i2srst", "i2sprst", "voprst";
+		};
+
+		d0_i2s2: i2s2@50220000 {
+			compatible = "snps,i2s";
+			clocks = <&d0_clock EIC7700_CLK_VO_I2S_MCLK>;
+			clock-names = "mclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			#sound-dai-cells = <0x00000000>;
+			reg = <0x0 0x50220000 0x0 0x10000>;
+			dma-names = "rx", "tx";
+			dmas = <&d0_aon_dmac 0 2>, <&d0_aon_dmac 1 2>;
+			vo_mclk_sel,syscrg = <&d0_sys_crg 0x1bc>;
+			resets = <&d0_reset VO_I2SRST_CTRL SW_VO_I2S_RSTN>,
+				<&d0_reset VO_I2SRST_CTRL SW_VO_I2S_PRSTN>,
+				<&d0_reset VO_PHYRST_CTRL SW_VO_PRSTN>;
+			reset-names = "i2srst", "i2sprst", "voprst";
+		};
+
+		d0_graphcard0: graphcard0 {
+			compatible = "audio-graph-card";
+		};
+
+		d0_graphcard1: graphcard1 {
+			compatible = "audio-graph-card";
+		};
+
+		d0_graphcard2: graphcard2 {
+			compatible = "audio-graph-card";
+		};
+
+		video_output: display-subsystem {
+			compatible = "eswin,display-subsystem";
+			ports = <&dc_out>;
+		};
+
+		dvb_widgets: dvb-subsystem {
+			compatible = "amlogic,dvb_widgets";
+			status = "disabled";
+		};
+
+		dc: display_control@502c0000 {
+			compatible = "eswin,dc";
+			reg = <0x0 0x502c0000 0x0 0x100>, <0x0 0x502c0180 0x0 0x700>, <0x0 0x502c1400 0x0 0x1400>;
+			interrupt-parent = <&plic0>;
+			interrupts = <238>;
+
+			clocks = <&d0_clock EIC7700_CLK_VO_CFG_CLK>,
+			         <&d0_clock EIC7700_CLK_VO_PIXEL_CLK>,
+			         <&d0_clock EIC7700_CLK_VO_ACLK>,
+			         <&d0_clock EIC7700_SPLL0_FOUT1>,
+			         <&d0_clock EIC7700_MUX_U_VO_ACLK_ROOT_2MUX1_GFREE>;
+			clock-names = "cfg_clk", "pix_clk", "axi_clk", "spll0_fout1", "vo_mux";
+			resets = <&d0_reset VO_RST_CTRL SW_VO_AXI_RSTN>,
+					 <&d0_reset VO_RST_CTRL SW_VO_CFG_RSTN>,
+					 <&d0_reset VO_RST_CTRL SW_VO_DC_RSTN>,
+					 <&d0_reset VO_RST_CTRL SW_VO_DC_PRSTN>;
+			reset-names = "vo_arst", "vo_prst", "dc_arst", "dc_prst";
+
+			dc_out: port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				dc_out_dpi0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&dsi_input0>;
+				};
+
+				dc_out_dpi1: endpoint@1 {
+					reg = <1>;
+					remote-endpoint = <&vd_input>;
+				};
+
+                dc_out_hdmi: endpoint@2 {
+                    reg = <2>;
+                    remote-endpoint = <&hdmi_in_dc>;
+                };
+			};
+		};
+
+		virtual_display: es_wb {
+			compatible = "eswin,virtual_display";
+			bpp = /bits/ 8 <8>;
+
+			port {
+				vd_input: endpoint {
+					remote-endpoint = <&dc_out_dpi1>;
+				};
+			};
+		};
+
+		dsi_output: dsi-output {
+			compatible = "eswin,dsi-encoder";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				/* input */
+				port@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+					dsi_input0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&dc_out_dpi0>;
+					};
+				};
+
+				/* output */
+				port@1 {
+					reg = <1>;
+					dsi_out:endpoint {
+						remote-endpoint = <&mipi_dsi_in>;
+					};
+				};
+			};
+		};
+
+		dsi_controller: mipi_dsi@50270000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "eswin,dw-mipi-dsi";
+			reg = <0x0 0x50270000 0x0 0x10000>;
+			clocks = <&d0_clock EIC7700_CLK_CLK_MIPI_TXESC>;
+			clock-names = "pclk";
+			resets = <&d0_reset VO_PHYRST_CTRL SW_VO_MIPI_PRSTN>;
+			reset-names ="phyrstn";
+			/*
+			phys = <&dphy>;
+			phy-names = "dphy";
+			*/
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					mipi_dsi_in: endpoint {
+						remote-endpoint = <&dsi_out>;
+					};
+				};
+
+				port@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					mipi_dsi_out: endpoint {
+						remote-endpoint = <&panel_in>;
+					};
+				};
+			};
+
+			dsi_panel:dsi_panel@0 {
+				compatible = "eswin,generic-panel";
+				reg = <0>;
+
+				port {
+					panel_in: endpoint {
+						remote-endpoint = <&mipi_dsi_out>;
+					};
+				};
+			};
+		};
+
+		dc_test: dctest@502c0000 {
+			compatible = "eswin,dc";
+			reg = <0x0 0x502c0000 0x0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <238>;
+		};
+
+		dw_hdmi: hdmi@502a0000 {
+			compatible = "eswin,eswin-dw-hdmi";
+			reg = <0x0 0x502a0000 0x0 0x20000>;
+			pinctrl-names = "default";
+			//pinctrl-0 = <&hdmi_i2c_xfer>;
+			interrupt-parent = <&plic0>;
+			interrupts = <274>;
+			clocks = <&d0_clock EIC7700_CLK_VO_CFG_CLK>, <&d0_clock EIC7700_CLK_VO_PIXEL_CLK>,
+				   <&d0_clock EIC7700_CLK_VO_CEC_CLK>, <&d0_clock EIC7700_CLK_VO_CR_CLK>;
+			clock-names = "iahb", "vpll", "cec", "isfr";
+			//power-domains = <&power EIC7700_PD_HDCP>;
+			reg-io-width = <4>;
+			ddc-i2c-scl-high-time-ns = <4708>;
+			ddc-i2c-scl-low-time-ns = <4916>;
+			#sound-dai-cells = <0>;
+			resets = <&d0_reset VO_PHYRST_CTRL SW_VO_HDMI_PRSTN>,
+					 <&d0_reset VO_PHYRST_CTRL SW_HDMI_PHYCTRL_RSTN>,
+					 <&d0_reset VO_PHYRST_CTRL SW_VO_HDMI_RSTN>;
+			reset-names = "prstn", "phyrstn", "rstn";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				port@0 {
+					reg = <0>;
+					hdmi_in_dc: endpoint@0 {
+						remote-endpoint = <&dc_out_hdmi>;
+					};
+				};
+			};
+		};
+
+		dw_hdmi_hdcp2: hdmi-hdcp2@50290000 {
+				compatible = "eswin,dw-hdmi-hdcp2";
+				reg = <0x0 0x50290000 0x0 0x10000>;
+				interrupt-parent = <&plic0>;
+				interrupts = <275>;
+				clocks = <&d0_clock EIC7700_CLK_VO_CFG_CLK>,
+					    <&d0_clock EIC7700_CLK_VO_HDMI_IESMCLK>;
+				clock-names ="pclk_hdcp2", "hdcp2_clk_hdmi";
+		};
+
+		d0_usbdrd3_0: usb0@50480000 {
+			compatible = "eswin,eic7700-dwc3";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			clocks =<&d0_clock EIC7700_GATE_HSP_USB0_SUSPEND_CLK>;
+			clock-names = "suspend";
+			eswin,hsp_sp_csr = <&d0_hsp_sp_csr 0x800 0x808 0x83c 0x840>;
+			resets = <&d0_reset HSPDMA_RST_CTRL SW_USB0_VAUX_RSTN>;
+			reset-names = "vaux";
+			ranges;
+			status = "disabled";
+			d0_usbdrd_dwc3_0: dwc3@50480000 {
+				compatible = "snps,dwc3";
+				reg = <0x0 0x50480000 0x0 0x10000>;
+				#address-cells = <2>;
+				#size-cells = <2>;
+				interrupt-parent = <&plic0>;
+				interrupts = <85>;
+				interrupt-names = "peripheral";
+				dr_mode = "peripheral";
+				phy_type = "utmi";
+				maximum-speed = "high-speed";
+				iommus = <&smmu0 EIC7700_SID_USB0>;
+				eswin,hsp_sp_csr = <&d0_hsp_sp_csr 0x1044>;
+				dma-ranges = <0x0 0x0 0x0 0xc0000000 0x200 0x0>;
+				snps,dis_enblslpm_quirk;
+				snps,dis-u2-freeclk-exists-quirk;
+				snps,dis_u2_susphy_quirk;
+				snps,dis-del-phy-power-chg-quirk;
+				snps,tx-ipgap-linecheck-dis-quirk;
+				snps,xhci-slow-suspend-quirk;
+				snps,xhci-trb-ent-quirk;
+				snps,usb3-warm-reset-on-resume-quirk;
+				status = "disabled";
+				numa-node-id = <0>;
+				tbus = <EIC7700_TBUID_USB>;
+			};
+		};
+
+		d0_usbdrd3_1: usb1@50490000  {
+			compatible = "eswin,eic7700-dwc3";
+			#address-cells = <2>;
+			#size-cells = <2>;
+			clocks =<&d0_clock EIC7700_GATE_HSP_USB1_SUSPEND_CLK>;
+			clock-names = "suspend";
+			eswin,hsp_sp_csr = <&d0_hsp_sp_csr 0x900 0x908 0x93c 0x940>;
+			resets = <&d0_reset HSPDMA_RST_CTRL SW_USB1_VAUX_RSTN>;
+			reset-names = "vaux";
+			ranges;
+			status = "disabled";
+			d0_usbdrd_dwc3_1: dwc3@50490000 {
+				compatible = "snps,dwc3";
+				reg = <0x0 0x50490000 0x0 0x10000>;
+				#address-cells = <2>;
+				#size-cells = <2>;
+				interrupt-parent = <&plic0>;
+				interrupts = <86>;
+				interrupt-names = "host";
+				dr_mode = "host";
+				phy_type = "utmi";
+				maximum-speed = "high-speed";
+				iommus = <&smmu0 EIC7700_SID_USB1>;
+				eswin,hsp_sp_csr = <&d0_hsp_sp_csr 0x1048>;
+				dma-ranges = <0x0 0x0 0x0 0xc0000000 0x200 0x0>;
+				snps,dis_enblslpm_quirk;
+				snps,dis-u2-freeclk-exists-quirk;
+				snps,dis_u2_susphy_quirk;
+				snps,dis-del-phy-power-chg-quirk;
+				snps,tx-ipgap-linecheck-dis-quirk;
+				snps,xhci-slow-suspend-quirk;
+				snps,xhci-trb-ent-quirk;
+				snps,usb3-warm-reset-on-resume-quirk;
+				status = "disabled";
+				numa-node-id = <0>;
+				tbus = <EIC7700_TBUID_USB>;
+			};
+		};
+
+		vi_top_csr: vi_common_top_csr@0x51030000 {
+			compatible = "esw,vi-common-csr", "syscon";
+			clocks = <&d0_clock EIC7700_CLK_VI_ACLK>,
+			         <&d0_clock EIC7700_CLK_VI_CFG_CLK>,
+			         <&d0_clock EIC7700_CLK_VI_DIG_ISP_CLK>,
+			         <&d0_clock EIC7700_CLK_VI_DVP_CLK>,
+			         <&d0_clock EIC7700_CLK_VI_PHY_CFG>,
+			         <&d0_clock EIC7700_CLK_VI_PHY_TXCLKESC>,
+			         <&d0_clock EIC7700_CLK_VI_SHUTTER_0>,
+			         <&d0_clock EIC7700_CLK_VI_SHUTTER_1>,
+			         <&d0_clock EIC7700_CLK_VI_SHUTTER_2>,
+			         <&d0_clock EIC7700_CLK_VI_SHUTTER_3>,
+			         <&d0_clock EIC7700_CLK_VI_SHUTTER_4>,
+			         <&d0_clock EIC7700_CLK_VI_SHUTTER_5>,
+			         <&d0_clock EIC7700_MUX_U_VI_ACLK_ROOT_2MUX1_GFREE>,
+			         <&d0_clock EIC7700_MUX_U_VI_DVP_ROOT_2MUX1_GFREE>,
+			         <&d0_clock EIC7700_MUX_U_VI_DIG_ISP_ROOT_2MUX1_GFREE>,
+			         <&d0_clock EIC7700_SPLL0_FOUT1>,
+			         <&d0_clock EIC7700_VPLL_FOUT1>;
+			clock-names = "aclk", "cfg_clk", "isp_aclk", "dvp_clk", "phy_cfg",
+			              "phy_escclk", "sht0", "sht1", "sht2", "sht3", "sht4",
+			              "sht5", "aclk_mux", "dvp_mux", "isp_mux", "spll0_fout1", "vpll_fout1";
+			resets = <&d0_reset VI_RST_CTRL SW_VI_AXI_RSTN>,
+			         <&d0_reset VI_RST_CTRL SW_VI_CFG_RSTN>,
+			         <&d0_reset ISP0_RST_CTRL SW_VI_ISP0_RSTN>,
+			         <&d0_reset ISP1_RST_CTRL SW_VI_ISP1_RSTN>,
+			         <&d0_reset DVP_RST_CTRL SW_VI_DVP_RSTN>,
+			         <&d0_reset SHUTTER_RST_CTRL SW_VI_SHUTTER_RSTN_0>,
+			         <&d0_reset SHUTTER_RST_CTRL SW_VI_SHUTTER_RSTN_1>,
+			         <&d0_reset SHUTTER_RST_CTRL SW_VI_SHUTTER_RSTN_2>,
+			         <&d0_reset SHUTTER_RST_CTRL SW_VI_SHUTTER_RSTN_3>,
+			         <&d0_reset SHUTTER_RST_CTRL SW_VI_SHUTTER_RSTN_4>,
+			         <&d0_reset SHUTTER_RST_CTRL SW_VI_SHUTTER_RSTN_5>;
+			reset-names = "axi", "cfg", "isp0", "isp1", "dvp", "sht0", "sht1", "sht2", "sht3", "sht4", "sht5";
+
+			id = <0>;
+			#size-cells = <2>;
+			reg = <0x0 0x51030000 0x0 0x10000>;
+		};
+
+		isp_0: isp@0x51000000 {
+			compatible = "esw,eic7700-isp";
+
+			reg = <0x0 0x51000000 0x0 0x10000>;
+			interrupts = <21 19 20>;
+			interrupt-parent = <&plic0>;
+			id = <0>;
+			#size-cells = <2>;
+			dma-ranges = <0x0 0x20000000 0x0 0x80000000 0x0 0x40000000>;
+			iommus = <&smmu0 EIC7700_SID_ISP0>;
+			tbus = <EIC7700_TBUID_ISP>;
+			eswin,vi_top_csr = <&vi_top_csr 0x1000>;
+			numa-node-id = <0>;
+		};
+
+		isp_1: isp@0x51010000 {
+			compatible = "esw,eic7700-isp";
+
+			reg = <0x0 0x51010000 0x0 0x10000>;
+			interrupts = <24 22 23>;
+			interrupt-parent = <&plic0>;
+			id = <1>;
+			#size-cells = <2>;
+			dma-ranges = <0x0 0x20000000 0x0 0x80000000 0x0 0x40000000>;
+			//iommus = <&smmu0 EIC7700_SID_ISP1>;
+			tbus = <EIC7700_TBUID_ISP>;
+			eswin,vi_top_csr = <&vi_top_csr 0x1004>;
+			numa-node-id = <0>;
+		};
+
+		dewarp: dewarp@51020000 {
+			compatible = "eswin,dewarp";
+			clocks = <&d0_clock EIC7700_CLK_VI_ACLK>,
+			         <&d0_clock EIC7700_CLK_VI_CFG_CLK>,
+			         <&d0_clock EIC7700_CLK_VI_DIG_DW_CLK>,
+			         <&d0_clock EIC7700_MUX_U_VI_ACLK_ROOT_2MUX1_GFREE>,
+			         <&d0_clock EIC7700_MUX_U_VI_DW_ROOT_2MUX1>,
+			         <&d0_clock EIC7700_SPLL0_FOUT1>,
+			         <&d0_clock EIC7700_VPLL_FOUT1>;
+			clock-names = "aclk", "cfg_clk", "dw_aclk", "aclk_mux", "dw_mux", "spll0_fout1", "vpll_fout1";
+			resets = <&d0_reset VI_RST_CTRL SW_VI_AXI_RSTN>,
+			         <&d0_reset VI_RST_CTRL SW_VI_CFG_RSTN>,
+			         <&d0_reset VI_RST_CTRL SW_VI_DWE_RSTN>;
+			reset-names = "axi", "cfg", "dwe";
+
+			interrupt-parent = <&plic0>;
+			interrupts = <26 25>;
+			#size-cells = <2>;
+			dma-ranges = <0x0 0x20000000 0x0 0x80000000 0x0 0x40000000>;
+			iommus = <&smmu0 EIC7700_SID_DW>;
+			tbus = <EIC7700_TBUID_DW>;
+			eswin,vi_top_csr = <&vi_top_csr 0x1008>;
+			reg = <0x0 0x51020000 0x0 0xc00>, <0x0 0x51020c00 0x0 0x120>;
+			numa-node-id = <0>;
+		};
+
+		mipi_dphy_rx: dphy@510c0000 {
+			compatible = "snps,dw-dphy-rx";
+			#phy-cells = <1>;
+			bus-width = <8>;
+			snps,dphy-frequency = <300000>;
+			snps,phy_type = <8>;
+			reg = <0x0 0x510c0000 0x0 0x20000>;
+			numa-node-id = <0>;
+		};
+
+		csi_dma0: csidma@0x52048000 {
+			compatible = "eswin,csi-video";
+			interrupt-parent = <&plic0>;
+			interrupts = <29>;
+			reg = <0x0 0x52048000 0x0 0x1000>;
+			numa-node-id = <0>;
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				csi_dmar_0: endpoint@0 {
+					reg = <0>;
+					bus-type = <4>;
+					remote-endpoint = <&csi2_dma_0_3>;
+				};
+			};
+		};
+
+		csi_dma1: csidma@0x52058000 {
+			compatible = "eswin,csi-video";
+			interrupt-parent = <&plic0>;
+			interrupts = <30>;
+			reg = <0x0 0x52058000 0x0 0x1000>;
+			numa-node-id = <0>;
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				csi_dmar_1: endpoint@0 {
+					reg = <0>;
+					bus-type = <4>;
+					remote-endpoint = <&csi2_dma_1_3>;
+				};
+			};
+		};
+
+		csi2_0: csi2@51050000 {
+			compatible = "snps,dw-csi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupt-parent = <&plic0>;
+			interrupts = <29>;
+			snps,output-type = <0>;
+			reg = <0x0 0x51050000 0x0 0x1000>;
+			/*phys = <&mipi_dphy_rx 1>;*/
+			numa-node-id = <0>;
+
+			/* MIPI CONFIG */
+			snps,en-ppi-width = <0>;/* 0: ppi8, 1: ppi16 */
+			snps,en-phy-mode = <0>;/* 0: D-PHY, 1: C-PHY */
+
+			ipi2_en = <0>;/* for virtual channel */
+			ipi2_vcid = <0>;/* virtual channel id */
+			ipi3_en = <0>;
+			ipi3_vcid = <0>;
+
+			#ifdef MIPI_CSI2_IMX290_ENBALE
+			port@1 {
+				reg = <1>;
+				csi2_0_1: endpoint {
+					bus-type = <4>;
+					clock-lanes = <0>;
+					#ifdef MIPI_CSI2_2LINE_ENABLE
+					data-lanes = <1 2>;
+					#else
+					data-lanes = <1 2 3 4>;
+					#endif
+					//remote-endpoint = <&imx290_csi2>;
+				};
+			};
+			#endif
+
+			port@2 {
+				reg = <2>;
+				csi2_dma_0_3: endpoint {
+					bus-type = <5>;
+					remote-endpoint = <&csi_dmar_0>;
+				};
+			};
+		};
+
+		csi2_1: csi2@51060000 {
+			compatible = "snps,dw-csi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupt-parent = <&plic0>;
+			interrupts = <30>;
+			snps,output-type = <0>;
+			reg = <0x0 0x51060000 0x0 0x1000>;
+			/*phys = <&mipi_dphy_rx 1>;*/
+			numa-node-id = <0>;
+
+			/* MIPI CONFIG */
+			snps,en-ppi-width = <0>;/* 0: ppi8, 1: ppi16 */
+			snps,en-phy-mode = <0>;/* 0: D-PHY, 1: C-PHY */
+
+			ipi2_en = <0>;/* for virtual channel */
+			ipi2_vcid = <0>;/* virtual channel id */
+			ipi3_en = <0>;
+			ipi3_vcid = <0>;
+
+			#ifdef MIPI_CSI2_IMX290_ENBALE
+			port@1 {
+				reg = <1>;
+				csi2_1_1: endpoint {
+					bus-type = <4>;
+					clock-lanes = <0>;
+					#ifdef MIPI_CSI2_2LINE_ENABLE
+					data-lanes = <1 2>;
+					#else
+					data-lanes = <1 2 3 4>;
+					#endif
+					//remote-endpoint = <&imx290_csi2>;
+				};
+			};
+			#endif
+
+			port@2 {
+				reg = <2>;
+				csi2_dma_1_3: endpoint {
+					bus-type = <5>;
+					remote-endpoint = <&csi_dmar_1>;
+				};
+			};
+		};
+
+		dc_test: dctest@502c0000 {
+			compatible = "eswin,dc";
+			reg = <0x0 0x502c0000 0x0 0x10000>;
+			interrupt-parent = <&plic0>;
+			interrupts = <238>;
+		};
+
+		ddr0: ddr-controller@0 {
+			compatible = "eswin,ddrc-1.20a";
+			interrupt-parent = <&plic0>;
+			interrupts = <10>;
+			interrupt-names = "ddr-ecc";
+			reg = <0x0 0x52300000 0x0 0x40000>;
+			ctrl-id = <0>;
+			status = "disabled";
+		};
+
+		ddr1: ddr-controller@1 {
+			compatible = "eswin,ddrc-1.20a";
+			interrupt-parent = <&plic0>;
+			interrupts = <299>;
+			interrupt-names = "ddr-ecc";
+			reg = <0x0 0x52380000 0x0 0x40000>;
+			ctrl-id = <1>;
+			status = "disabled";
+		};
+};
diff --git a/arch/riscv/boot/dts/eswin/hifive-premier-p550-pinctrl.dtsi b/arch/riscv/boot/dts/eswin/hifive-premier-p550-pinctrl.dtsi
new file mode 100644
index 000000000000..9b0e18db1d2b
--- /dev/null
+++ b/arch/riscv/boot/dts/eswin/hifive-premier-p550-pinctrl.dtsi
@@ -0,0 +1,1339 @@
+#include "eic7700.dtsi"
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+    #address-cells = <2>;
+    #size-cells = <2>;
+    soc {
+        pinctrl: pinctrl@0x51600080 {
+			compatible = "eswin,eic7700-pinctrl", "syscon";
+			reg = <0x0 0x51600080 0x0 0x1FFF80>;
+			status = "disabled";
+            //func0
+            pinctrl_sdio0_default: sdio0-default{
+				mux {
+					groups = "sdio0_group";
+					function = "sdio0_func";
+				};
+			};
+            pinctrl_sdio1_default: sdio1-default{
+				mux {
+					groups = "sdio1_group";
+					function = "sdio1_func";
+				};
+			};
+            pinctrl_por_sel_default: por_sel-default{
+				mux {
+					groups = "por_sel_group";
+					function = "por_sel_func";
+				};
+			};
+            pinctrl_jtag0_default: jtag0-default{
+				mux {
+					groups = "jtag0_group";
+					function = "jtag0_func";
+				};
+			};
+            pinctrl_jtag1_default: jtag1-default{
+				mux {
+					groups = "jtag1_group";
+					function = "jtag1_func";
+				};
+			};
+            pinctrl_jtag2_default: jtag2-default{
+				mux {
+					groups = "jtag2_group";
+					function = "jtag2_func";
+				};
+			};
+            pinctrl_pcie_default: pcie-default{
+				mux{
+					groups = "pcie_group";
+					function = "pcie_func";
+				};
+			};
+            pinctrl_hdmi_default: hdmi-default{
+				mux{
+					groups = "hdmi_group";
+					function = "hdmi_func";
+				};
+			};
+            pinctrl_rgmii0_default: rgmii0-default{
+				mux {
+					groups = "rgmii0_group";
+					function = "rgmii0_func";
+				};
+			};
+            pinctrl_rgmii1_default: rgmii1-default{
+				mux{
+					groups = "rgmii1_group";
+					function = "rgmii1_func";
+				};
+			};
+            pinctrl_spi0_default: spi0-default{
+				mux {
+					groups = "spi0_group";
+					function = "spi0_func";
+				};
+			};
+            pinctrl_spi1_default: spi1-default{
+				mux{
+					groups = "spi1_group";
+					function = "spi1_func";
+				};
+			};
+            pinctrl_spi3_default: spi3-default{
+				mux {
+					groups = "spi3_group";
+					function = "spi3_func";
+				};
+			};
+            pinctrl_por_time_sel0_default: por_time_sel0-default{
+				mux {
+					groups = "por_time_sel0_group";
+					function = "por_time_sel0_func";
+				};
+			};
+            pinctrl_por_time_sel1_default: por_time_sel1-default{
+				mux {
+					groups = "por_time_sel1_group";
+					function = "por_time_sel1_func";
+				};
+			};
+            pinctrl_i2s0_default: i2s0-default{
+				mux {
+					groups = "i2s0_group";
+					function = "i2s0_func";
+				};
+			};
+            pinctrl_i2s1_default: i2s1-default{
+				mux {
+					groups = "i2s1_group";
+					function = "i2s1_func";
+				};
+			};
+            pinctrl_i2s2_default: i2s2-default{
+				mux {
+					groups = "i2s2_group";
+					function = "i2s2_func";
+				};
+			};
+            pinctrl_usb0_pwren_default: usb0_pwren-default{
+				mux {
+					groups = "usb0_pwren_group";
+					function = "usb0_pwren_func";
+				};
+			};
+            pinctrl_usb1_pwren_default: usb1_pwren-default{
+				mux {
+					groups = "usb1_pwren_group";
+					function = "usb1_pwren_func";
+				};
+			};
+            pinctrl_i2c0_default: i2c0-default{
+				mux {
+					groups = "i2c0_group";
+					function = "i2c0_func";
+				};
+			};
+            pinctrl_i2c1_default: i2c1-default{
+				mux {
+					groups = "i2c1_group";
+					function = "i2c1_func";
+				};
+			};
+            pinctrl_i2c2_default: i2c2-default{
+				mux {
+					groups = "i2c2_group";
+					function = "i2c2_func";
+				};
+			};
+            pinctrl_i2c3_default: i2c3-default{
+				mux {
+					groups = "i2c3_group";
+					function = "i2c3_func";
+				};
+			};
+            pinctrl_i2c4_default: i2c4-default{
+				mux {
+					groups = "i2c4_group";
+					function = "i2c4_func";
+				};
+			};
+            pinctrl_i2c5_default: i2c5-default{
+				mux {
+					groups = "i2c5_group";
+					function = "i2c5_func";
+				};
+			};
+            pinctrl_i2c8_default: i2c8-default{
+				mux {
+					groups = "i2c8_group";
+					function = "i2c8_func";
+				};
+			};
+            pinctrl_i2c10_default: i2c10-default{
+				mux {
+					groups = "i2c10_group";
+					function = "i2c10_func";
+				};
+			};
+            pinctrl_i2c11_default: i2c11-default{
+				mux {
+					groups = "i2c11_group";
+					function = "i2c11_func";
+				};
+			};
+            pinctrl_uart0_default: uart0-default{
+				mux {
+					groups = "uart0_group";
+					function = "uart0_func";
+				};
+			};
+            pinctrl_uart1_default: uart1-default{
+				mux {
+					groups = "uart1_group";
+					function = "uart1_func";
+				};
+			};
+            pinctrl_uart2_default: uart2-default{
+				mux {
+					groups = "uart2_group";
+					function = "uart2_func";
+				};
+			};
+            pinctrl_pwm0_default: pwm0-default{
+                mux {
+                    groups = "pwm0_group";
+                    function = "pwm0_func";
+                };
+            };
+            pinctrl_fan_tach_default: fan_tach-default{
+				mux {
+					groups = "fan_tach_group";
+					function = "fan_tach_func";
+				};
+			};
+            pinctrl_mipi_csi0_default: mipi_csi0-default{
+				mux {
+					groups = "mipi_csi0_group";
+					function = "mipi_csi0_func";
+				};
+			};
+            pinctrl_mipi_csi1_default: mipi_csi1-default{
+				mux {
+					groups = "mipi_csi1_group";
+					function = "mipi_csi1_func";
+				};
+			};
+            pinctrl_mipi_csi2_default: mipi_csi2-default{
+				mux {
+					groups = "mipi_csi2_group";
+					function = "mipi_csi2_func";
+				};
+			};
+            pinctrl_mipi_csi3_default: mipi_csi3-default{
+				mux {
+					groups = "mipi_csi3_group";
+					function = "mipi_csi3_func";
+				};
+			};
+            pinctrl_mipi_csi4_default: mipi_csi4-default{
+				mux {
+					groups = "mipi_csi4_group";
+					function = "mipi_csi4_func";
+				};
+			};
+            pinctrl_mipi_csi5_default: mipi_csi5-default{
+				mux {
+					groups = "mipi_csi5_group";
+					function = "mipi_csi5_func";
+				};
+			};
+            pinctrl_s_mode_default: s_mode-default{
+				mux {
+					groups = "s_mode_group";
+					function = "s_mode_func";
+				};
+			};
+            pinctrl_pinmux_ddr_refclk_sel_default: pinmux_ddr_refclk_sel-default{
+				mux {
+					groups = "pinmux_ddr_refclk_sel_group";
+					function = "pinmux_ddr_refclk_sel_func";
+				};
+			};
+            pinctrl_boot_sel_default: boot_sel-default{
+				mux {
+					groups = "boot_sel_group";
+					function = "boot_sel_func";
+				};
+			};
+            pinctrl_lpddr_ref_clk_default: lpddr_ref_clk-default{
+				mux {
+					groups = "lpddr_ref_clk_group";
+					function = "lpddr_ref_clk_func";
+				};
+			};
+
+            //func1
+            pinctrl_spi2_default: spi2-default{
+				mux1 {
+					groups = "spi2_clk_group";
+					function = "spi2_clk_func";
+				};
+				conf1 {
+					groups = "spi2_clk_group";
+					input-enable = <1>;
+					bias-pull-up = <1>;
+					bias-pull-down = <0>;
+				};
+				mux2 {
+					groups = "spi2_d0_group";
+					function = "spi2_d0_func";
+				};
+				conf2 {
+					groups = "spi2_d0_group";
+					input-enable = <1>;
+					bias-pull-up = <1>;
+					bias-pull-down = <0>;
+				};
+				mux3 {
+					groups = "spi2_d1_d2_d3_group";
+					function = "spi2_d1_d2_d3_func";
+				};
+				conf3 {
+					groups = "spi2_d1_d2_d3_group";
+					input-enable = <1>;
+					bias-pull-up = <1>;
+					bias-pull-down = <0>;
+				};
+				mux4 {
+					groups = "spi2_cs_group";
+					function = "spi2_cs_func";
+				};
+			};
+
+            pinctrl_sata_act_led_default: sata_act_led-default{
+				mux {
+					groups = "sata_act_led_group";
+					function = "sata_act_led_func";
+				};
+				conf {
+					groups = "sata_act_led_group";
+					input-enable = <0>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_emmc_led_control_default: emmc_led_control-default{
+				mux {
+					groups = "emmc_led_control_group";
+					function = "emmc_led_control_func";
+				};
+				conf {
+					groups = "emmc_led_control_group";
+					input-enable = <0>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_sd0_led_control_default: sd0_led_control-default{
+				mux {
+					groups = "sd0_led_control_group";
+					function = "sd0_led_control_func";
+				};
+			};
+            pinctrl_sd1_led_control_default: sd1_led_control-default{
+				mux {
+					groups = "sd1_led_control_group";
+					function = "sd1_led_control_func";
+				};
+			};
+            pinctrl_i2c6_default: i2c6-default{
+				mux {
+					groups = "i2c6_group";
+					function = "i2c6_func";
+				};
+			};
+            pinctrl_i2c7_default: i2c7-default{
+				mux {
+					groups = "i2c7_group";
+					function = "i2c7_func";
+				};
+			};
+            pinctrl_i2c9_default: i2c9-default{
+				mux {
+					groups = "i2c9_group";
+					function = "i2c9_func";
+				};
+			};
+            pinctrl_pwm1_default: pwm1-default{
+				mux {
+					groups = "pwm1_group";
+					function = "pwm1_func";
+				};
+			};
+            pinctrl_pwm2_default: pwm2-default{
+				mux {
+					groups = "pwm2_group";
+					function = "pwm2_func";
+				};
+			};
+            pinctrl_mipi_csi_xtrig_default: mipi_csi_xtrig-default{
+				mux {
+					groups = "mipi_csi_xtrig_group";
+					function = "mipi_csi_xtrig_func";
+				};
+			};
+
+            //func3
+            pinctrl_uart3_default: uart3-default{
+				mux {
+					groups = "uart3_group";
+					function = "uart3_func";
+				};
+			};
+            pinctrl_uart4_default: uart4-default{
+				mux {
+					groups = "uart4_group";
+					function = "uart4_func";
+				};
+			};
+
+            //gpio
+            pinctrl_gpio0_default: gpio0-default{
+				mux {
+					groups = "gpio0_group";
+					function = "gpio0_func";
+				};
+				conf {
+					groups = "gpio0_group";
+					input-enable = <1>;
+					bias-pull-up = <1>;
+				};
+			};
+            pinctrl_gpio1_default: gpio1-default{
+				mux {
+					groups = "gpio1_group";
+					function = "gpio1_func";
+				};
+			};
+            pinctrl_gpio2_default: gpio2-default{
+				mux {
+					groups = "gpio2_group";
+					function = "gpio2_func";
+				};
+			};
+            pinctrl_gpio3_default: gpio3-default{
+				mux {
+					groups = "gpio3_group";
+					function = "gpio3_func";
+				};
+			};
+            pinctrl_gpio4_default: gpio4-default{
+				mux {
+					groups = "gpio4_group";
+					function = "gpio4_func";
+				};
+			};
+            pinctrl_gpio5_default: gpio5-default{
+				mux {
+					groups = "gpio5_group";
+					function = "gpio5_func";
+				};
+				conf {
+					groups = "gpio5_group";
+					input-enable = <1>;
+					bias-pull-up = <1>;
+				};
+			};
+            pinctrl_gpio6_default: gpio6-default{
+				mux {
+					groups = "gpio6_group";
+					function = "gpio6_func";
+				};
+				conf {
+					groups = "gpio6_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio7_default: gpio7-default{
+				mux {
+					groups = "gpio7_group";
+					function = "gpio7_func";
+				};
+				conf {
+					groups = "gpio7_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio8_default: gpio8-default{
+				mux {
+					groups = "gpio8_group";
+					function = "gpio8_func";
+				};
+				conf {
+					groups = "gpio8_group";
+					input-enable = <1>;
+					bias-pull-up = <1>;
+				};
+			};
+            pinctrl_gpio9_default: gpio9-default{
+				mux {
+					groups = "gpio9_group";
+					function = "gpio9_func";
+				};
+				conf {
+					groups = "gpio9_group";
+					input-enable = <1>;
+					bias-pull-up = <1>;
+				};
+			};
+            pinctrl_gpio10_default: gpio10-default{
+				mux {
+					groups = "gpio10_group";
+					function = "gpio10_func";
+				};
+				conf {
+					groups = "gpio10_group";
+					input-enable = <1>;
+					bias-pull-up = <1>;
+				};
+			};
+            pinctrl_gpio11_default: gpio11-default{
+				mux {
+					groups = "gpio11_group";
+					function = "gpio11_func";
+				};
+				conf {
+					groups = "gpio11_group";
+					input-enable = <1>;
+					bias-pull-up = <1>;
+				};
+			};
+            pinctrl_gpio12_default: gpio12-default{
+				mux {
+					groups = "gpio12_group";
+					function = "gpio12_func";
+				};
+			};
+            pinctrl_gpio13_default: gpio13-default{
+				mux {
+					groups = "gpio13_group";
+					function = "gpio13_func";
+				};
+			};
+            pinctrl_gpio14_default: gpio14-default{
+				mux {
+					groups = "gpio14_group";
+					function = "gpio14_func";
+				};
+			};
+            pinctrl_gpio15_default: gpio15-default{
+				mux {
+					groups = "gpio15_group";
+					function = "gpio15_func";
+				};
+			};
+            pinctrl_gpio16_default: gpio16-default{
+				mux {
+					groups = "gpio16_group";
+					function = "gpio16_func";
+				};
+				conf {
+					groups = "gpio16_group";
+					input-enable = <0>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio17_default: gpio17-default{
+				mux {
+					groups = "gpio17_group";
+					function = "gpio17_func";
+				};
+				conf {
+					groups = "gpio17_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio18_default: gpio18-default{
+				mux {
+					groups = "gpio18_group";
+					function = "gpio18_func";
+				};
+				conf {
+					groups = "gpio18_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio19_default: gpio19-default{
+				mux {
+					groups = "gpio19_group";
+					function = "gpio19_func";
+				};
+				conf {
+					groups = "gpio19_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio20_default: gpio20-default{
+				mux {
+					groups = "gpio20_group";
+					function = "gpio20_func";
+				};
+				conf {
+					groups = "gpio20_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio21_default: gpio21-default{
+				mux {
+					groups = "gpio21_group";
+					function = "gpio21_func";
+				};
+				conf {
+					groups = "gpio21_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio22_default: gpio22-default{
+				mux {
+					groups = "gpio22_group";
+					function = "gpio22_func";
+				};
+			};
+            pinctrl_gpio23_default: gpio23-default{
+				mux {
+					groups = "gpio23_group";
+					function = "gpio23_func";
+				};
+			};
+            pinctrl_gpio24_default: gpio24-default{
+				mux {
+					groups = "gpio24_group";
+					function = "gpio24_func";
+				};
+			};
+            pinctrl_gpio25_default: gpio25-default{
+				mux {
+					groups = "gpio25_group";
+					function = "gpio25_func";
+				};
+			};
+            pinctrl_gpio26_default: gpio26-default{
+				mux {
+					groups = "gpio26_group";
+					function = "gpio26_func";
+				};
+			};
+            pinctrl_gpio27_default: gpio27-default{
+				mux {
+					groups = "gpio27_group";
+					function = "gpio27_func";
+				};
+			};
+            pinctrl_gpio28_default: gpio28-default{
+				mux {
+					groups = "gpio28_group";
+					function = "gpio28_func";
+				};
+				conf {
+					groups = "gpio28_group";
+					input-enable = <1>;
+					bias-pull-up = <1>;
+				};
+			};
+            pinctrl_gpio29_default: gpio29-default{
+				mux {
+					groups = "gpio29_group";
+					function = "gpio29_func";
+				};
+			};
+            pinctrl_gpio30_default: gpio30-default{
+				mux {
+					groups = "gpio30_group";
+					function = "gpio30_func";
+				};
+			};
+            pinctrl_gpio31_default: gpio31-default{
+				mux {
+					groups = "gpio31_group";
+					function = "gpio31_func";
+				};
+			};
+            pinctrl_gpio32_default: gpio32-default{
+				mux {
+					groups = "gpio32_group";
+					function = "gpio32_func";
+				};
+			};
+            pinctrl_gpio33_default: gpio33-default{
+				mux {
+					groups = "gpio33_group";
+					function = "gpio33_func";
+				};
+			};
+            pinctrl_gpio34_default: gpio34-default{
+				mux {
+					groups = "gpio34_group";
+					function = "gpio34_func";
+				};
+			};
+            pinctrl_gpio35_default: gpio35-default{
+				mux {
+					groups = "gpio35_group";
+					function = "gpio35_func";
+				};
+				conf {
+					groups = "gpio35_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio36_default: gpio36-default{
+				mux {
+					groups = "gpio36_group";
+					function = "gpio36_func";
+				};
+				conf {
+					groups = "gpio36_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio37_default: gpio37-default{
+				mux {
+					groups = "gpio37_group";
+					function = "gpio37_func";
+				};
+				conf {
+					groups = "gpio37_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio38_default: gpio38-default{
+				mux {
+					groups = "gpio38_group";
+					function = "gpio38_func";
+				};
+				conf {
+					groups = "gpio38_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio39_default: gpio39-default{
+				mux {
+					groups = "gpio39_group";
+					function = "gpio39_func";
+				};
+				conf {
+					groups = "gpio39_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio40_default: gpio40-default{
+				mux {
+					groups = "gpio40_group";
+					function = "gpio40_func";
+				};
+				conf {
+					groups = "gpio40_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio41_default: gpio41-default{
+				mux {
+					groups = "gpio41_group";
+					function = "gpio41_func";
+				};
+			};
+            pinctrl_gpio42_default: gpio42-default{
+				mux {
+					groups = "gpio42_group";
+					function = "gpio42_func";
+				};
+				conf {
+					groups = "gpio42_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio43_default: gpio43-default{
+				mux {
+					groups = "gpio43_group";
+					function = "gpio43_func";
+				};
+			};
+            pinctrl_gpio44_default: gpio44-default{
+				mux {
+					groups = "gpio44_group";
+					function = "gpio44_func";
+				};
+			};
+            pinctrl_gpio45_default: gpio45-default{
+				mux {
+					groups = "gpio45_group";
+					function = "gpio45_func";
+				};
+			};
+            pinctrl_gpio46_default: gpio46-default{
+				mux {
+					groups = "gpio46_group";
+					function = "gpio46_func";
+				};
+				conf {
+					groups = "gpio46_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio47_default: gpio47-default{
+				mux {
+					groups = "gpio47_group";
+					function = "gpio47_func";
+				};
+				conf {
+					groups = "gpio47_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio48_default: gpio48-default{
+				mux {
+					groups = "gpio48_group";
+					function = "gpio48_func";
+				};
+			};
+            pinctrl_gpio49_default: gpio49-default{
+				mux {
+					groups = "gpio49_group";
+					function = "gpio49_func";
+				};
+			};
+            pinctrl_gpio50_default: gpio50-default{
+				mux {
+					groups = "gpio50_group";
+					function = "gpio50_func";
+				};
+			};
+            pinctrl_gpio51_default: gpio51-default{
+				mux {
+					groups = "gpio51_group";
+					function = "gpio51_func";
+				};
+			};
+            pinctrl_gpio52_default: gpio52-default{
+				mux {
+					groups = "gpio52_group";
+					function = "gpio52_func";
+				};
+				conf {
+					groups = "gpio52_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio53_default: gpio53-default{
+				mux {
+					groups = "gpio53_group";
+					function = "gpio53_func";
+				};
+				conf {
+					groups = "gpio53_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio54_default: gpio54-default{
+				mux {
+					groups = "gpio54_group";
+					function = "gpio54_func";
+				};
+			};
+            pinctrl_gpio55_default: gpio55-default{
+				mux {
+					groups = "gpio55_group";
+					function = "gpio55_func";
+				};
+			};
+            pinctrl_gpio56_default: gpio56-default{
+				mux {
+					groups = "gpio56_group";
+					function = "gpio56_func";
+				};
+			};
+            pinctrl_gpio57_default: gpio57-default{
+				mux {
+					groups = "gpio57_group";
+					function = "gpio57_func";
+				};
+			};
+            pinctrl_gpio58_default: gpio58-default{
+				mux {
+					groups = "gpio58_group";
+					function = "gpio58_func";
+				};
+			};
+            pinctrl_gpio59_default: gpio59-default{
+				mux {
+					groups = "gpio59_group";
+					function = "gpio59_func";
+				};
+			};
+            pinctrl_gpio60_default: gpio60-default{
+				mux {
+					groups = "gpio60_group";
+					function = "gpio60_func";
+				};
+			};
+            pinctrl_gpio61_default: gpio61-default{
+				mux {
+					groups = "gpio61_group";
+					function = "gpio61_func";
+				};
+			};
+            pinctrl_gpio62_default: gpio62-default{
+				mux {
+					groups = "gpio62_group";
+					function = "gpio62_func";
+				};
+			};
+            pinctrl_gpio63_default: gpio63-default{
+				mux {
+					groups = "gpio63_group";
+					function = "gpio63_func";
+				};
+			};
+            pinctrl_gpio64_default: gpio64-default{
+				mux {
+					groups = "gpio64_group";
+					function = "gpio64_func";
+				};
+				conf {
+					groups = "gpio64_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio65_default: gpio65-default{
+				mux {
+					groups = "gpio65_group";
+					function = "gpio65_func";
+				};
+				conf {
+					groups = "gpio65_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio66_default: gpio66-default{
+				mux {
+					groups = "gpio66_group";
+					function = "gpio66_func";
+				};
+				conf {
+					groups = "gpio66_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio67_default: gpio67-default{
+				mux {
+					groups = "gpio67_group";
+					function = "gpio67_func";
+				};
+				conf {
+					groups = "gpio67_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio68_default: gpio68-default{
+				mux {
+					groups = "gpio68_group";
+					function = "gpio68_func";
+				};
+			};
+            pinctrl_gpio69_default: gpio69-default{
+				mux {
+					groups = "gpio69_group";
+					function = "gpio69_func";
+				};
+			};
+            pinctrl_gpio70_default: gpio70-default{
+				mux {
+					groups = "gpio70_group";
+					function = "gpio70_func";
+				};
+			};
+            pinctrl_gpio71_default: gpio71-default{
+				mux {
+					groups = "gpio71_group";
+					function = "gpio71_func";
+				};
+			};
+            pinctrl_gpio72_default: gpio72-default{
+				mux {
+					groups = "gpio72_group";
+					function = "gpio72_func";
+				};
+			};
+            pinctrl_gpio73_default: gpio73-default{
+				mux {
+					groups = "gpio73_group";
+					function = "gpio73_func";
+				};
+			};
+            pinctrl_gpio74_default: gpio74-default{
+				mux {
+					groups = "gpio74_group";
+					function = "gpio74_func";
+				};
+			};
+            pinctrl_gpio75_default: gpio75-default{
+				mux {
+					groups = "gpio75_group";
+					function = "gpio75_func";
+				};
+			};
+            pinctrl_gpio76_default: gpio76-default{
+				mux {
+					groups = "gpio76_group";
+					function = "gpio76_func";
+				};
+			};
+            pinctrl_gpio77_default: gpio77-default{
+				mux {
+					groups = "gpio77_group";
+					function = "gpio77_func";
+				};
+			};
+            pinctrl_gpio78_default: gpio78-default{
+				mux {
+					groups = "gpio78_group";
+					function = "gpio78_func";
+				};
+			};
+            pinctrl_gpio79_default: gpio79-default{
+				mux {
+					groups = "gpio79_group";
+					function = "gpio79_func";
+				};
+			};
+            pinctrl_gpio80_default: gpio80-default{
+				mux {
+					groups = "gpio80_group";
+					function = "gpio80_func";
+				};
+			};
+            pinctrl_gpio81_default: gpio81-default{
+				mux {
+					groups = "gpio81_group";
+					function = "gpio81_func";
+				};
+			};
+            pinctrl_gpio82_default: gpio82-default{
+				mux {
+					groups = "gpio82_group";
+					function = "gpio82_func";
+				};
+			};
+            pinctrl_gpio83_default: gpio83-default{
+				mux {
+					groups = "gpio83_group";
+					function = "gpio83_func";
+				};
+			};
+            pinctrl_gpio84_default: gpio84-default{
+				mux {
+					groups = "gpio84_group";
+					function = "gpio84_func";
+				};
+			};
+            pinctrl_gpio85_default: gpio85-default{
+				mux {
+					groups = "gpio85_group";
+					function = "gpio85_func";
+				};
+			};
+            pinctrl_gpio86_default: gpio86-default{
+				mux {
+					groups = "gpio86_group";
+					function = "gpio86_func";
+				};
+			};
+            pinctrl_gpio87_default: gpio87-default{
+				mux {
+					groups = "gpio87_group";
+					function = "gpio87_func";
+				};
+			};
+            pinctrl_gpio88_default: gpio88-default{
+				mux {
+					groups = "gpio88_group";
+					function = "gpio88_func";
+				};
+			};
+            pinctrl_gpio89_default: gpio89-default{
+				mux {
+					groups = "gpio89_group";
+					function = "gpio89_func";
+				};
+			};
+            pinctrl_gpio90_default: gpio90-default{
+				mux {
+					groups = "gpio90_group";
+					function = "gpio90_func";
+				};
+			};
+            pinctrl_gpio91_default: gpio91-default{
+				mux {
+					groups = "gpio91_group";
+					function = "gpio91_func";
+				};
+			};
+            pinctrl_gpio92_default: gpio92-default{
+				mux {
+					groups = "gpio92_group";
+					function = "gpio92_func";
+				};
+				conf {
+					groups = "gpio92_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio93_default: gpio93-default{
+				mux {
+					groups = "gpio93_group";
+					function = "gpio93_func";
+				};
+				conf {
+					groups = "gpio93_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio94_default: gpio94-default{
+				mux {
+					groups = "gpio94_group";
+					function = "gpio94_func";
+				};
+				conf {
+					groups = "gpio94_group";
+					input-enable = <0>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio95_default: gpio95-default{
+				mux {
+					groups = "gpio95_group";
+					function = "gpio95_func";
+				};
+			};
+            pinctrl_gpio96_default: gpio96-default{
+				mux {
+					groups = "gpio96_group";
+					function = "gpio96_func";
+				};
+			};
+            pinctrl_gpio97_default: gpio97-default{
+				mux {
+					groups = "gpio97_group";
+					function = "gpio97_func";
+				};
+			};
+            pinctrl_gpio98_default: gpio98-default{
+				mux {
+					groups = "gpio98_group";
+					function = "gpio98_func";
+				};
+			};
+            pinctrl_gpio99_default: gpio99-default{
+				mux {
+					groups = "gpio99_group";
+					function = "gpio99_func";
+				};
+			};
+            pinctrl_gpio100_default: gpio100-default{
+				mux {
+					groups = "gpio100_group";
+					function = "gpio100_func";
+				};
+			};
+            pinctrl_gpio101_default: gpio101-default{
+				mux {
+					groups = "gpio101_group";
+					function = "gpio101_func";
+				};
+			};
+            pinctrl_gpio102_default: gpio102-default{
+				mux {
+					groups = "gpio102_group";
+					function = "gpio102_func";
+				};
+			};
+            pinctrl_gpio103_default: gpio103-default{
+				mux {
+					groups = "gpio103_group";
+					function = "gpio103_func";
+				};
+			};
+            pinctrl_gpio104_default: gpio104-default{
+				mux {
+					groups = "gpio104_group";
+					function = "gpio104_func";
+				};
+			};
+            pinctrl_gpio105_default: gpio105-default{
+				mux {
+					groups = "gpio105_group";
+					function = "gpio105_func";
+				};
+			};
+            pinctrl_gpio106_default: gpio106-default{
+				mux {
+					groups = "gpio106_group";
+					function = "gpio106_func";
+				};
+				conf {
+					groups = "gpio106_group";
+					input-enable = <0>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio107_default: gpio107-default{
+				mux {
+					groups = "gpio107_group";
+					function = "gpio107_func";
+				};
+				conf {
+					groups = "gpio107_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio108_default: gpio108-default{
+				mux {
+					groups = "gpio108_group";
+					function = "gpio108_func";
+				};
+				conf {
+					groups = "gpio108_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio109_default: gpio109-default{
+				mux {
+					groups = "gpio109_group";
+					function = "gpio109_func";
+				};
+				conf {
+					groups = "gpio109_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio110_default: gpio110-default{
+				mux {
+					groups = "gpio110_group";
+					function = "gpio110_func";
+				};
+				conf {
+					groups = "gpio110_group";
+					input-enable = <1>;
+					bias-pull-down = <1>;
+				};
+			};
+            pinctrl_gpio111_default: gpio111-default{
+				mux {
+					groups = "gpio111_group";
+					function = "gpio111_func";
+				};
+				conf {
+					groups = "gpio111_group";
+					input-enable = <0>;
+					bias-pull-up = <1>;
+				};
+			};
+
+            //func6
+            pinctrl_csi_mon_out_default: csi_mon_out-default{
+				mux {
+					groups = "csi_mon_out_group";
+					function = "csi_mon_out_func";
+				};
+			};
+            pinctrl_csi_ocla_clk_default: csi_ocla_clk-default{
+				mux {
+					groups = "csi_ocla_clk_group";
+					function = "csi_ocla_clk_func";
+				};
+			};
+            pinctrl_csi_mon_out_valid_default: csi_mon_out_valid-default{
+				mux {
+					groups = "csi_mon_out_valid_group";
+					function = "csi_mon_out_valid_func";
+				};
+			};
+            pinctrl_csi_parity_error_default: csi_parity_error-default{
+				mux {
+					groups = "csi_parity_error_group";
+					function = "csi_parity_error_func";
+				};
+			};
+            pinctrl_csi_dtb_out_default: csi_dtb_out-default{
+				mux {
+					groups = "csi_dtb_out_group";
+					function = "csi_dtb_out_func";
+				};
+			};
+            pinctrl_csi_phy_sel_default: csi_phy_sel-default{
+				mux {
+					groups = "csi_phy_sel_group";
+					function = "csi_phy_sel_func";
+				};
+			};
+            pinctrl_vc_g2d0_debug_out_default: vc_g2d0_debug_out-default{
+				mux {
+					groups = "vc_g2d0_debug_out_group";
+					function = "vc_g2d0_debug_out_func";
+				};
+			};
+            pinctrl_vc_g2d1_debug_out_default: vc_g2d1_debug_out-default{
+				mux {
+					groups = "vc_g2d1_debug_out_group";
+					function = "vc_g2d1_debug_out_func";
+				};
+			};
+            pinctrl_sata_mpll_clk_default: sata_mpll_clk-default{
+				mux {
+					groups = "sata_mpll_clk_group";
+					function = "sata_mpll_clk_func";
+				};
+			};
+            pinctrl_sata_ref_repeat_clk_m_default: sata_ref_repeat_clk_m-default{
+				mux {
+					groups = "sata_ref_repeat_clk_m_group";
+					function = "sata_ref_repeat_clk_m_func";
+				};
+			};
+            pinctrl_sata_ref_repeat_clk_p_default: sata_ref_repeat_clk_p-default{
+				mux {
+					groups = "sata_ref_repeat_clk_p_group";
+					function = "sata_ref_repeat_clk_p_func";
+				};
+			};
+		};
+    };
+};
diff --git a/arch/riscv/configs/defconfig b/arch/riscv/configs/defconfig
index ab86ec3b9eab..defda81697a2 100644
--- a/arch/riscv/configs/defconfig
+++ b/arch/riscv/configs/defconfig
@@ -103,7 +103,7 @@ CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
 CONFIG_BLK_DEV_LOOP=y
 CONFIG_VIRTIO_BLK=y
-CONFIG_BLK_DEV_NVME=m
+CONFIG_BLK_DEV_NVME=y
 CONFIG_BLK_DEV_SD=y
 CONFIG_BLK_DEV_SR=y
 CONFIG_SCSI_VIRTIO=y
@@ -132,6 +132,7 @@ CONFIG_SERIAL_8250_CONSOLE=y
 CONFIG_SERIAL_8250_DW=y
 CONFIG_SERIAL_OF_PLATFORM=y
 CONFIG_SERIAL_SH_SCI=y
+CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
 CONFIG_VIRTIO_CONSOLE=y
 CONFIG_HW_RANDOM=y
 CONFIG_HW_RANDOM_VIRTIO=y
diff --git a/arch/riscv/configs/hifive-premier-p550_defconfig b/arch/riscv/configs/hifive-premier-p550_defconfig
new file mode 100644
index 000000000000..11a739988123
--- /dev/null
+++ b/arch/riscv/configs/hifive-premier-p550_defconfig
@@ -0,0 +1,879 @@
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_PSI=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_CGROUPS=y
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_RDMA=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+CONFIG_CGROUP_MISC=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_EXPERT=y
+# CONFIG_SYSFS_SYSCALL is not set
+CONFIG_PERF_EVENTS=y
+CONFIG_SOC_SIFIVE_EIC7700=y
+CONFIG_SOC_SIFIVE=y
+CONFIG_SOC_VIRT=y
+CONFIG_SMP=y
+CONFIG_CMDLINE="clk_ignore_unused"
+CONFIG_CMDLINE_EXTEND=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_BLK_DEV_ZONED=y
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_CMA=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_PACKET_DIAG=m
+CONFIG_UNIX=y
+CONFIG_UNIX_DIAG=m
+CONFIG_TLS=m
+CONFIG_TLS_DEVICE=y
+CONFIG_XFRM_USER=m
+CONFIG_XFRM_INTERFACE=m
+CONFIG_XFRM_STATISTICS=y
+CONFIG_NET_KEY=m
+CONFIG_XDP_SOCKETS=y
+CONFIG_XDP_SOCKETS_DIAG=m
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_FIB_TRIE_STATS=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=m
+CONFIG_NET_IPGRE=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_NET_IPVTI=m
+CONFIG_NET_FOU_IP_TUNNELS=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_ESP_OFFLOAD=m
+CONFIG_INET_ESPINTCP=y
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_DIAG=m
+CONFIG_INET_UDP_DIAG=m
+CONFIG_INET_RAW_DIAG=m
+CONFIG_INET_DIAG_DESTROY=y
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_TCP_CONG_NV=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_TCP_CONG_LP=m
+CONFIG_TCP_CONG_VENO=m
+CONFIG_TCP_CONG_YEAH=m
+CONFIG_TCP_CONG_ILLINOIS=m
+CONFIG_TCP_CONG_DCTCP=m
+CONFIG_TCP_CONG_CDG=m
+CONFIG_TCP_CONG_BBR=m
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_ESP_OFFLOAD=m
+CONFIG_INET6_ESPINTCP=y
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_MIP6=m
+CONFIG_IPV6_ILA=m
+CONFIG_IPV6_VTI=m
+CONFIG_IPV6_SIT_6RD=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+CONFIG_IPV6_SEG6_LWTUNNEL=y
+CONFIG_IPV6_SEG6_HMAC=y
+CONFIG_IPV6_RPL_LWTUNNEL=y
+CONFIG_NETLABEL=y
+CONFIG_MPTCP=y
+CONFIG_NETWORK_PHY_TIMESTAMPING=y
+CONFIG_NETFILTER=y
+CONFIG_BRIDGE_NETFILTER=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_ZONES=y
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_TIMEOUT=y
+CONFIG_NF_CONNTRACK_TIMESTAMP=y
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_NF_CONNTRACK_SNMP=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NF_CT_NETLINK_TIMEOUT=m
+CONFIG_NF_CT_NETLINK_HELPER=m
+CONFIG_NETFILTER_NETLINK_GLUE_CT=y
+CONFIG_NF_TABLES=m
+CONFIG_NF_TABLES_INET=y
+CONFIG_NF_TABLES_NETDEV=y
+CONFIG_NFT_NUMGEN=m
+CONFIG_NFT_CT=m
+CONFIG_NFT_CONNLIMIT=m
+CONFIG_NFT_LOG=m
+CONFIG_NFT_LIMIT=m
+CONFIG_NFT_MASQ=m
+CONFIG_NFT_REDIR=m
+CONFIG_NFT_NAT=m
+CONFIG_NFT_TUNNEL=m
+CONFIG_NFT_QUEUE=m
+CONFIG_NFT_QUOTA=m
+CONFIG_NFT_REJECT=m
+CONFIG_NFT_COMPAT=m
+CONFIG_NFT_HASH=m
+CONFIG_NFT_XFRM=m
+CONFIG_NFT_SOCKET=m
+CONFIG_NFT_OSF=m
+CONFIG_NFT_TPROXY=m
+CONFIG_NFT_SYNPROXY=m
+CONFIG_NFT_DUP_NETDEV=m
+CONFIG_NFT_FWD_NETDEV=m
+CONFIG_NFT_REJECT_NETDEV=m
+CONFIG_NF_FLOW_TABLE_INET=m
+CONFIG_NF_FLOW_TABLE=m
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XTABLES_COMPAT=y
+CONFIG_NETFILTER_XT_TARGET_AUDIT=m
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HMARK=m
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_TEE=m
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_BPF=m
+CONFIG_NETFILTER_XT_MATCH_CGROUP=m
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLABEL=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_CPU=m
+CONFIG_NETFILTER_XT_MATCH_DEVGROUP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_IPCOMP=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_NFACCT=m
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_IP_SET=m
+CONFIG_IP_SET_BITMAP_IP=m
+CONFIG_IP_SET_BITMAP_IPMAC=m
+CONFIG_IP_SET_BITMAP_PORT=m
+CONFIG_IP_SET_HASH_IP=m
+CONFIG_IP_SET_HASH_IPMARK=m
+CONFIG_IP_SET_HASH_IPPORT=m
+CONFIG_IP_SET_HASH_IPPORTIP=m
+CONFIG_IP_SET_HASH_IPPORTNET=m
+CONFIG_IP_SET_HASH_IPMAC=m
+CONFIG_IP_SET_HASH_MAC=m
+CONFIG_IP_SET_HASH_NETPORTNET=m
+CONFIG_IP_SET_HASH_NET=m
+CONFIG_IP_SET_HASH_NETNET=m
+CONFIG_IP_SET_HASH_NETPORT=m
+CONFIG_IP_SET_HASH_NETIFACE=m
+CONFIG_IP_SET_LIST_SET=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_IPV6=y
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_IP_VS_PROTO_AH=y
+CONFIG_IP_VS_PROTO_SCTP=y
+CONFIG_IP_VS_RR=m
+CONFIG_IP_VS_WRR=m
+CONFIG_IP_VS_LC=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_VS_FO=m
+CONFIG_IP_VS_OVF=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_IP_VS_LBLCR=m
+CONFIG_IP_VS_DH=m
+CONFIG_IP_VS_SH=m
+CONFIG_IP_VS_MH=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_NQ=m
+CONFIG_IP_VS_TWOS=m
+CONFIG_IP_VS_FTP=m
+CONFIG_IP_VS_PE_SIP=m
+CONFIG_NFT_DUP_IPV4=m
+CONFIG_NFT_FIB_IPV4=m
+CONFIG_NF_TABLES_ARP=y
+CONFIG_NF_LOG_ARP=m
+CONFIG_NF_LOG_IPV4=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_RPFILTER=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_SYNPROXY=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP_NF_SECURITY=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_NFT_DUP_IPV6=m
+CONFIG_NFT_FIB_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RPFILTER=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_MATCH_SRH=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_TARGET_SYNPROXY=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+CONFIG_IP6_NF_SECURITY=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_IP6_NF_TARGET_NPT=m
+CONFIG_NF_TABLES_BRIDGE=m
+CONFIG_NFT_BRIDGE_META=m
+CONFIG_NFT_BRIDGE_REJECT=m
+CONFIG_NF_CONNTRACK_BRIDGE=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_IP_DCCP=y
+# CONFIG_IP_DCCP_CCID3 is not set
+CONFIG_SCTP_COOKIE_HMAC_SHA1=y
+CONFIG_RDS=m
+CONFIG_RDS_TCP=m
+CONFIG_TIPC=m
+CONFIG_ATM=m
+CONFIG_ATM_CLIP=m
+CONFIG_ATM_LANE=m
+CONFIG_ATM_MPOA=m
+CONFIG_ATM_BR2684=m
+CONFIG_L2TP=m
+CONFIG_L2TP_DEBUGFS=m
+CONFIG_L2TP_V3=y
+CONFIG_L2TP_IP=m
+CONFIG_L2TP_ETH=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_BRIDGE_MRP=y
+CONFIG_BRIDGE_CFM=y
+CONFIG_NET_DSA=m
+CONFIG_NET_DSA_TAG_NONE=m
+CONFIG_NET_DSA_TAG_AR9331=m
+CONFIG_NET_DSA_TAG_BRCM=m
+CONFIG_NET_DSA_TAG_BRCM_LEGACY=m
+CONFIG_NET_DSA_TAG_BRCM_PREPEND=m
+CONFIG_NET_DSA_TAG_HELLCREEK=m
+CONFIG_NET_DSA_TAG_GSWIP=m
+CONFIG_NET_DSA_TAG_DSA=m
+CONFIG_NET_DSA_TAG_EDSA=m
+CONFIG_NET_DSA_TAG_MTK=m
+CONFIG_NET_DSA_TAG_KSZ=m
+CONFIG_NET_DSA_TAG_OCELOT=m
+CONFIG_NET_DSA_TAG_OCELOT_8021Q=m
+CONFIG_NET_DSA_TAG_QCA=m
+CONFIG_NET_DSA_TAG_RTL4_A=m
+CONFIG_NET_DSA_TAG_RTL8_4=m
+CONFIG_NET_DSA_TAG_RZN1_A5PSW=m
+CONFIG_NET_DSA_TAG_LAN9303=m
+CONFIG_NET_DSA_TAG_SJA1105=m
+CONFIG_NET_DSA_TAG_TRAILER=m
+CONFIG_NET_DSA_TAG_XRS700X=m
+CONFIG_VLAN_8021Q=m
+CONFIG_VLAN_8021Q_GVRP=y
+CONFIG_VLAN_8021Q_MVRP=y
+CONFIG_LLC2=m
+CONFIG_ATALK=y
+CONFIG_X25=m
+CONFIG_LAPB=m
+CONFIG_PHONET=m
+CONFIG_6LOWPAN=m
+CONFIG_IEEE802154=m
+CONFIG_IEEE802154_6LOWPAN=m
+CONFIG_MAC802154=m
+CONFIG_NET_SCHED=y
+CONFIG_NET_CLS_CGROUP=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_DCB=y
+CONFIG_BATMAN_ADV=m
+# CONFIG_BATMAN_ADV_BATMAN_V is not set
+CONFIG_OPENVSWITCH=m
+CONFIG_VSOCKETS=m
+CONFIG_VIRTIO_VSOCKETS=m
+CONFIG_NETLINK_DIAG=m
+CONFIG_HSR=m
+CONFIG_QRTR=m
+CONFIG_QRTR_SMD=m
+CONFIG_QRTR_TUN=m
+CONFIG_NET_NCSI=y
+CONFIG_NCSI_OEM_CMD_GET_MAC=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_BPF_STREAM_PARSER=y
+CONFIG_NET_PKTGEN=m
+CONFIG_NET_DROP_MONITOR=m
+CONFIG_CFG80211=m
+CONFIG_NL80211_TESTMODE=y
+CONFIG_CFG80211_DEVELOPER_WARNINGS=y
+CONFIG_CFG80211_CERTIFICATION_ONUS=y
+CONFIG_CFG80211_REG_CELLULAR_HINTS=y
+CONFIG_CFG80211_REG_RELAX_NO_IR=y
+CONFIG_CFG80211_DEBUGFS=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=m
+CONFIG_MAC80211_MESH=y
+CONFIG_MAC80211_DEBUGFS=y
+CONFIG_MAC80211_MESSAGE_TRACING=y
+CONFIG_MAC80211_DEBUG_MENU=y
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCIEAER=y
+CONFIG_PCIEASPM_PERFORMANCE=y
+CONFIG_PCIE_PTM=y
+# CONFIG_PCI_QUIRKS is not set
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCIE_ESWIN=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_FW_LOADER_COMPRESS=y
+CONFIG_FW_LOADER_COMPRESS_ZSTD=y
+CONFIG_MTD=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=32768
+CONFIG_VIRTIO_BLK=y
+CONFIG_BLK_DEV_NVME=y
+CONFIG_NVME_MULTIPATH=y
+CONFIG_EEPROM_AT24=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+CONFIG_ATA=y
+CONFIG_SATA_AHCI=y
+CONFIG_AHCI_ESWIN=y
+CONFIG_MD=y
+CONFIG_MD_CLUSTER=m
+CONFIG_BCACHE=m
+CONFIG_BCACHE_ASYNC_REGISTRATION=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_UNSTRIPED=m
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=m
+CONFIG_DM_THIN_PROVISIONING=m
+CONFIG_DM_CACHE=m
+CONFIG_DM_WRITECACHE=m
+CONFIG_DM_EBS=m
+CONFIG_DM_ERA=m
+CONFIG_DM_CLONE=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_LOG_USERSPACE=m
+CONFIG_DM_RAID=m
+CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_QL=m
+CONFIG_DM_MULTIPATH_ST=m
+CONFIG_DM_MULTIPATH_HST=m
+CONFIG_DM_MULTIPATH_IOA=m
+CONFIG_DM_DELAY=m
+CONFIG_DM_INIT=y
+CONFIG_DM_UEVENT=y
+CONFIG_DM_FLAKEY=m
+CONFIG_DM_VERITY=m
+CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG=y
+CONFIG_DM_VERITY_VERIFY_ROOTHASH_SIG_SECONDARY_KEYRING=y
+CONFIG_DM_SWITCH=m
+CONFIG_DM_LOG_WRITES=m
+CONFIG_DM_INTEGRITY=m
+CONFIG_DM_ZONED=m
+CONFIG_TARGET_CORE=m
+CONFIG_TCM_IBLOCK=m
+CONFIG_TCM_FILEIO=m
+CONFIG_TCM_PSCSI=m
+CONFIG_LOOPBACK_TARGET=m
+CONFIG_ISCSI_TARGET=m
+CONFIG_REMOTE_TARGET=m
+CONFIG_FUSION=y
+CONFIG_FUSION_SPI=m
+CONFIG_FUSION_SAS=m
+CONFIG_FUSION_CTL=m
+CONFIG_FUSION_LOGGING=y
+CONFIG_NETDEVICES=y
+CONFIG_BONDING=m
+CONFIG_DUMMY=m
+CONFIG_WIREGUARD=m
+CONFIG_EQUALIZER=m
+CONFIG_NET_FC=y
+CONFIG_IFB=m
+CONFIG_NET_TEAM=m
+CONFIG_NET_TEAM_MODE_BROADCAST=m
+CONFIG_NET_TEAM_MODE_ROUNDROBIN=m
+CONFIG_NET_TEAM_MODE_RANDOM=m
+CONFIG_NET_TEAM_MODE_ACTIVEBACKUP=m
+CONFIG_NET_TEAM_MODE_LOADBALANCE=m
+CONFIG_MACVLAN=m
+CONFIG_MACVTAP=m
+CONFIG_IPVLAN=m
+CONFIG_IPVTAP=m
+CONFIG_VXLAN=m
+CONFIG_GENEVE=m
+CONFIG_BAREUDP=m
+CONFIG_GTP=m
+CONFIG_MACSEC=m
+CONFIG_NETCONSOLE=m
+CONFIG_NETCONSOLE_DYNAMIC=y
+CONFIG_TUN=y
+CONFIG_VETH=m
+CONFIG_VIRTIO_NET=y
+CONFIG_NLMON=m
+CONFIG_NET_VRF=m
+CONFIG_ATM_DUMMY=m
+CONFIG_ATM_TCP=m
+CONFIG_ATM_LANAI=m
+CONFIG_ATM_ENI=m
+CONFIG_ATM_NICSTAR=m
+CONFIG_ATM_IDT77252=m
+CONFIG_ATM_IA=m
+CONFIG_ATM_FORE200E=m
+CONFIG_ATM_HE=m
+CONFIG_ATM_HE_USE_SUNI=y
+CONFIG_ATM_SOLOS=m
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ASIX is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CADENCE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_NET_VENDOR_ENGLEDER is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_LITEX is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+# CONFIG_NET_VENDOR_MICROSOFT is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+CONFIG_STMMAC_ETH=y
+# CONFIG_DWMAC_GENERIC is not set
+CONFIG_DWMAC_EIC7700=y
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_VERTEXCOM is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_NET_VENDOR_XILINX is not set
+CONFIG_RTW88=m
+CONFIG_RTW88_8822BU=m
+CONFIG_RTW88_8822CS=m
+CONFIG_RTW88_DEBUG=y
+CONFIG_RTW88_DEBUGFS=y
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_LEGACY_PTYS is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
+CONFIG_VIRTIO_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_VIRTIO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_DESIGNWARE_SLAVE=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_I2C_SLAVE_EEPROM=y
+CONFIG_SPI=y
+CONFIG_SPI_DESIGNWARE=y
+CONFIG_SPI_DW_DMA=y
+CONFIG_SPI_DW_MMIO=y
+CONFIG_SPI_ESWIN_BOOTSPI=y
+# CONFIG_PTP_1588_CLOCK is not set
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_EIC7700=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_SENSORS_ESWIN_FAN_CONTROL=y
+CONFIG_SENSORS_ESWIN_PVT=y
+CONFIG_SENSORS_PAC1934=y
+CONFIG_PMBUS=y
+CONFIG_SENSORS_INA2XX=y
+CONFIG_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_REGULATOR=y
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_DRM=y
+CONFIG_DRM_DEBUG_MM=y
+CONFIG_DRM_I2C_NXP_TDA9950=y
+CONFIG_DRM_RADEON=m
+CONFIG_DRM_RADEON_USERPTR=y
+CONFIG_DRM_AMDGPU=m
+CONFIG_DRM_AST=y
+CONFIG_DRM_DISPLAY_CONNECTOR=y
+CONFIG_DRM_SIMPLE_BRIDGE=y
+CONFIG_DRM_TOSHIBA_TC358768=m
+CONFIG_DRM_LEGACY=y
+CONFIG_FB=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_HDA_INTEL=m
+CONFIG_SND_HDA_CODEC_HDMI=m
+CONFIG_SND_SOC=y
+CONFIG_SND_ESWIN_DW_I2S=y
+CONFIG_ESWIN_SND_SOC_CODECS=y
+CONFIG_ESWIN_SND_ES8388_CODEC=y
+CONFIG_SND_AUDIO_GRAPH_CARD=y
+CONFIG_USB_ULPI_BUS=y
+CONFIG_USB_CONN_GPIO=y
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+# CONFIG_USB_DEFAULT_PERSIST is not set
+CONFIG_USB_MON=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_DBGCAP=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_ACM=y
+CONFIG_USB_WDM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_UAS=y
+CONFIG_USB_DWC3=y
+CONFIG_USB_DWC3_ULPI=y
+CONFIG_USB_DWC2=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_CP210X=y
+CONFIG_USB_SERIAL_FTDI_SIO=y
+CONFIG_USB_SERIAL_KEYSPAN=y
+CONFIG_USB_SERIAL_PL2303=y
+CONFIG_USB_SERIAL_OTI6858=y
+CONFIG_USB_SERIAL_QUALCOMM=y
+CONFIG_USB_SERIAL_OPTION=y
+CONFIG_USB_TEST=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_NCM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_G_NCM=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_TYPEC=y
+CONFIG_TYPEC_TCPM=y
+CONFIG_TYPEC_TCPCI=y
+CONFIG_TYPEC_FUSB303B=y
+CONFIG_MMC=y
+CONFIG_MMC_TEST=y
+CONFIG_MMC_DEBUG=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_ESWIN=y
+CONFIG_MMC_SDHCI_OF_SDIO_ESWIN=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_EDAC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_ESWIN=y
+CONFIG_RTC_DRV_PCF8563=y
+CONFIG_DMADEVICES=y
+CONFIG_DW_AXI_DMAC=y
+CONFIG_DMATEST=y
+CONFIG_DMABUF_HEAPS=y
+CONFIG_DMABUF_HEAPS_SYSTEM=y
+CONFIG_DMABUF_HEAPS_CMA=y
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_INPUT=y
+CONFIG_VIRTIO_MMIO=y
+CONFIG_STAGING=y
+CONFIG_COMMON_CLK_EIC7700=y
+CONFIG_MAILBOX=y
+CONFIG_IOMMU_ESWIN=y
+CONFIG_ARM_SMMU_V3=y
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_SIFIVE_CCACHE=y
+CONFIG_EXTCON=y
+CONFIG_EXTCON_USB_GPIO=y
+CONFIG_MEMORY=y
+CONFIG_PWM=y
+CONFIG_PWM_ESWIN=y
+CONFIG_RESET_ESWIN_EIC7700=y
+CONFIG_DAX=y
+CONFIG_INTERCONNECT=y
+CONFIG_VALIDATE_FS_PARSER=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_REISERFS_FS=m
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+CONFIG_JFS_SECURITY=y
+CONFIG_JFS_STATISTICS=y
+CONFIG_XFS_FS=m
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+CONFIG_XFS_RT=y
+CONFIG_GFS2_FS=m
+CONFIG_OCFS2_FS=m
+CONFIG_BTRFS_FS=m
+CONFIG_BTRFS_FS_POSIX_ACL=y
+CONFIG_NILFS2_FS=m
+CONFIG_F2FS_FS=m
+CONFIG_F2FS_FS_SECURITY=y
+CONFIG_F2FS_FS_COMPRESSION=y
+# CONFIG_F2FS_IOSTAT is not set
+CONFIG_F2FS_UNFAIR_RWSEM=y
+CONFIG_EXPORTFS_BLOCK_OPS=y
+CONFIG_FS_ENCRYPTION=y
+CONFIG_FS_VERITY=y
+CONFIG_FS_VERITY_BUILTIN_SIGNATURES=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_QFMT_V1=m
+CONFIG_QFMT_V2=m
+CONFIG_AUTOFS_FS=y
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_VIRTIO_FS=m
+CONFIG_OVERLAY_FS=m
+CONFIG_OVERLAY_FS_XINO_AUTO=y
+CONFIG_FSCACHE=y
+CONFIG_FSCACHE_STATS=y
+CONFIG_CACHEFILES=m
+CONFIG_CACHEFILES_ERROR_INJECTION=y
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+CONFIG_UDF_FS=m
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_EXFAT_FS=m
+CONFIG_NTFS_FS=m
+CONFIG_NTFS3_FS=m
+CONFIG_NTFS3_LZX_XPRESS=y
+CONFIG_NTFS3_FS_POSIX_ACL=y
+CONFIG_PROC_KCORE=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_INODE64=y
+CONFIG_TMPFS_QUOTA=y
+CONFIG_HUGETLBFS=y
+CONFIG_EFIVAR_FS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_CHOICE_DECOMP_BY_MOUNT=y
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_LZ4=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_ZSTD=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_DLM=m
+CONFIG_UNICODE=y
+CONFIG_SECURITY=y
+CONFIG_SECURITY_SELINUX=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_SECURITY_APPARMOR=y
+CONFIG_SECURITY_SAFESETID=y
+CONFIG_DEFAULT_SECURITY_APPARMOR=y
+CONFIG_LSM="landlock,lockdown,yama,integrity,apparmor"
+CONFIG_CRYPTO_AES=m
+CONFIG_CRYPTO_CBC=m
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_XTS is not set
+CONFIG_CRYPTO_AEGIS128=m
+CONFIG_CRYPTO_CHACHA20POLY1305=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_DEV_VIRTIO=y
+CONFIG_SYSTEM_EXTRA_CERTIFICATE=y
+CONFIG_SECONDARY_TRUSTED_KEYRING=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+CONFIG_DMA_CMA=y
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=15
+CONFIG_CONSOLE_LOGLEVEL_QUIET=15
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=7
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT=y
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x01b6
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_PAGEALLOC=y
+CONFIG_SCHED_STACK_END_CHECK=y
+CONFIG_DEBUG_VM=y
+CONFIG_DEBUG_VM_PGFLAGS=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_DEBUG_PER_CPU_MAPS=y
+CONFIG_SOFTLOCKUP_DETECTOR=y
+CONFIG_WQ_WATCHDOG=y
+CONFIG_DEBUG_TIMEKEEPING=y
+CONFIG_DEBUG_RT_MUTEXES=y
+CONFIG_DEBUG_SPINLOCK=y
+CONFIG_DEBUG_MUTEXES=y
+CONFIG_DEBUG_RWSEMS=y
+CONFIG_DEBUG_ATOMIC_SLEEP=y
+CONFIG_DEBUG_LIST=y
+CONFIG_DEBUG_PLIST=y
+CONFIG_DEBUG_SG=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_EQS_DEBUG=y
+# CONFIG_RUNTIME_TESTING_MENU is not set
+CONFIG_MEMTEST=y
diff --git a/arch/riscv/configs/rv32_defconfig b/arch/riscv/configs/rv32_defconfig
index 89b601e253a6..5721af39afd1 100644
--- a/arch/riscv/configs/rv32_defconfig
+++ b/arch/riscv/configs/rv32_defconfig
@@ -66,6 +66,7 @@ CONFIG_INPUT_MOUSEDEV=y
 CONFIG_SERIAL_8250=y
 CONFIG_SERIAL_8250_CONSOLE=y
 CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SERIAL_EARLYCON_RISCV_SBI=y
 CONFIG_VIRTIO_CONSOLE=y
 CONFIG_HW_RANDOM=y
 CONFIG_HW_RANDOM_VIRTIO=y
diff --git a/arch/riscv/cove/Makefile b/arch/riscv/cove/Makefile
new file mode 100644
index 000000000000..a95043ba80ee
--- /dev/null
+++ b/arch/riscv/cove/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_RISCV_COVE_GUEST)	+= core.o cove_guest_sbi.o
diff --git a/arch/riscv/cove/core.c b/arch/riscv/cove/core.c
new file mode 100644
index 000000000000..582feb1c6c8d
--- /dev/null
+++ b/arch/riscv/cove/core.c
@@ -0,0 +1,40 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Confidential Computing Platform Capability checks
+ *
+ * Copyright (c) 2023 Rivos Inc.
+ *
+ * Authors:
+ *     Rajnesh Kanwal <rkanwal@rivosinc.com>
+ */
+
+#include <linux/export.h>
+#include <linux/cc_platform.h>
+#include <asm/sbi.h>
+#include <asm/cove.h>
+
+static bool is_tvm;
+
+bool is_cove_guest(void)
+{
+	return is_tvm;
+}
+EXPORT_SYMBOL_GPL(is_cove_guest);
+
+bool cc_platform_has(enum cc_attr attr)
+{
+	switch (attr) {
+	case CC_ATTR_GUEST_MEM_ENCRYPT:
+	case CC_ATTR_MEM_ENCRYPT:
+		return is_cove_guest();
+	default:
+		return false;
+	}
+}
+EXPORT_SYMBOL_GPL(cc_platform_has);
+
+void riscv_cove_sbi_init(void)
+{
+	if (sbi_probe_extension(SBI_EXT_COVG) > 0)
+		is_tvm = true;
+}
diff --git a/arch/riscv/cove/cove_guest_sbi.c b/arch/riscv/cove/cove_guest_sbi.c
new file mode 100644
index 000000000000..af22d5e7663e
--- /dev/null
+++ b/arch/riscv/cove/cove_guest_sbi.c
@@ -0,0 +1,109 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * COVG SBI extensions related helper functions.
+ *
+ * Copyright (c) 2023 Rivos Inc.
+ *
+ * Authors:
+ *     Rajnesh Kanwal <rkanwal@rivosinc.com>
+ */
+
+#include <linux/errno.h>
+#include <asm/sbi.h>
+#include <asm/covg_sbi.h>
+
+int sbi_covg_add_mmio_region(unsigned long addr, unsigned long len)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVG, SBI_EXT_COVG_ADD_MMIO_REGION, addr, len,
+			0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covg_remove_mmio_region(unsigned long addr, unsigned long len)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVG, SBI_EXT_COVG_REMOVE_MMIO_REGION, addr,
+			len, 0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covg_share_memory(unsigned long addr, unsigned long len)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVG, SBI_EXT_COVG_SHARE_MEMORY, addr, len, 0,
+			0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covg_unshare_memory(unsigned long addr, unsigned long len)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVG, SBI_EXT_COVG_UNSHARE_MEMORY, addr, len, 0,
+			0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covg_allow_external_interrupt(unsigned long id)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVG, SBI_EXT_COVG_ALLOW_EXT_INTERRUPT, id, 0,
+			0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covg_allow_all_external_interrupt(void)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVG, SBI_EXT_COVG_ALLOW_EXT_INTERRUPT, -1, 0,
+			0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covg_deny_external_interrupt(unsigned long id)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVG, SBI_EXT_COVG_DENY_EXT_INTERRUPT, id, 0, 0,
+			0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covg_deny_all_external_interrupt(void)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVG, SBI_EXT_COVG_DENY_EXT_INTERRUPT, -1, 0, 0,
+			0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
diff --git a/arch/riscv/include/asm/barrier.h b/arch/riscv/include/asm/barrier.h
index 110752594228..ca07d68c70a2 100644
--- a/arch/riscv/include/asm/barrier.h
+++ b/arch/riscv/include/asm/barrier.h
@@ -71,6 +71,8 @@ do {									\
  */
 #define smp_mb__after_spinlock()	RISCV_FENCE(iorw,iorw)
 
+#define wfe()   do { } while (0)
+
 #include <asm-generic/barrier.h>
 
 #endif /* __ASSEMBLY__ */
diff --git a/arch/riscv/include/asm/cove.h b/arch/riscv/include/asm/cove.h
new file mode 100644
index 000000000000..c4d609d64150
--- /dev/null
+++ b/arch/riscv/include/asm/cove.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * TVM helper functions
+ *
+ * Copyright (c) 2023 Rivos Inc.
+ *
+ * Authors:
+ *     Rajnesh Kanwal <rkanwal@rivosinc.com>
+ */
+
+#ifndef __RISCV_COVE_H__
+#define __RISCV_COVE_H__
+
+#ifdef CONFIG_RISCV_COVE_GUEST
+void riscv_cove_sbi_init(void);
+bool is_cove_guest(void);
+#else /* CONFIG_RISCV_COVE_GUEST */
+static inline bool is_cove_guest(void)
+{
+	return false;
+}
+static inline void riscv_cove_sbi_init(void)
+{
+}
+#endif /* CONFIG_RISCV_COVE_GUEST */
+
+#endif /* __RISCV_COVE_H__ */
diff --git a/arch/riscv/include/asm/covg_sbi.h b/arch/riscv/include/asm/covg_sbi.h
new file mode 100644
index 000000000000..31283de6cfa0
--- /dev/null
+++ b/arch/riscv/include/asm/covg_sbi.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * COVG SBI extension related header file.
+ *
+ * Copyright (c) 2023 Rivos Inc.
+ *
+ * Authors:
+ *     Rajnesh Kanwal <rkanwal@rivosinc.com>
+ */
+
+#ifndef __RISCV_COVG_SBI_H__
+#define __RISCV_COVG_SBI_H__
+
+#ifdef CONFIG_RISCV_COVE_GUEST
+
+int sbi_covg_add_mmio_region(unsigned long addr, unsigned long len);
+int sbi_covg_remove_mmio_region(unsigned long addr, unsigned long len);
+int sbi_covg_share_memory(unsigned long addr, unsigned long len);
+int sbi_covg_unshare_memory(unsigned long addr, unsigned long len);
+int sbi_covg_allow_external_interrupt(unsigned long id);
+int sbi_covg_allow_all_external_interrupt(void);
+int sbi_covg_deny_external_interrupt(unsigned long id);
+int sbi_covg_deny_all_external_interrupt(void);
+
+#else
+
+static inline int sbi_covg_add_mmio_region(unsigned long addr, unsigned long len) { return 0; }
+static inline int sbi_covg_remove_mmio_region(unsigned long addr, unsigned long len) { return 0; }
+static inline int sbi_covg_share_memory(unsigned long addr, unsigned long len) { return 0; }
+static inline int sbi_covg_unshare_memory(unsigned long addr, unsigned long len) { return 0; }
+static inline int sbi_covg_allow_external_interrupt(unsigned long id) { return 0; }
+static inline int sbi_covg_allow_all_external_interrupt(void) { return 0; }
+static inline int sbi_covg_deny_external_interrupt(unsigned long id) { return 0; }
+static inline int sbi_covg_deny_all_external_interrupt(void) { return 0; }
+
+#endif
+
+#endif /* __RISCV_COVG_SBI_H__ */
diff --git a/arch/riscv/include/asm/csr.h b/arch/riscv/include/asm/csr.h
index 777cb8299551..3ccea533233c 100644
--- a/arch/riscv/include/asm/csr.h
+++ b/arch/riscv/include/asm/csr.h
@@ -107,6 +107,8 @@
 #define EXC_VIRTUAL_INST_FAULT		22
 #define EXC_STORE_GUEST_PAGE_FAULT	23
 
+#define EXC_CUSTOM_KVM_COVE_RUN_FAIL	48
+
 /* PMP configuration */
 #define PMP_R			0x01
 #define PMP_W			0x02
diff --git a/arch/riscv/include/asm/io.h b/arch/riscv/include/asm/io.h
index 42497d487a17..d1f0453c6580 100644
--- a/arch/riscv/include/asm/io.h
+++ b/arch/riscv/include/asm/io.h
@@ -51,6 +51,7 @@
 #define __io_par(v)	__asm__ __volatile__ ("fence i,ior" : : : "memory");
 #define __io_pbw()	__asm__ __volatile__ ("fence iow,o" : : : "memory");
 #define __io_paw()	__asm__ __volatile__ ("fence o,io"  : : : "memory");
+#define __iomb()    mb()
 
 /*
  * Accesses from a single hart to a single I/O address must be ordered.  This
diff --git a/arch/riscv/include/asm/kvm_cove.h b/arch/riscv/include/asm/kvm_cove.h
new file mode 100644
index 000000000000..f05c9a7191bc
--- /dev/null
+++ b/arch/riscv/include/asm/kvm_cove.h
@@ -0,0 +1,245 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * COVE related header file.
+ *
+ * Copyright (c) 2023 RivosInc
+ *
+ * Authors:
+ *     Atish Patra <atishp@rivosinc.com>
+ */
+
+#ifndef __KVM_RISCV_COVE_H
+#define __KVM_RISCV_COVE_H
+
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/kvm_host.h>
+#include <linux/kvm.h>
+#include <linux/list.h>
+#include <asm/csr.h>
+#include <asm/sbi.h>
+
+#define KVM_COVE_TSM_CAP_PROMOTE_TVM         0x0
+#define KVM_COVE_TSM_CAP_ATTESTATION_LOCAL   0x1
+#define KVM_COVE_TSM_CAP_ATTESTATION_REMOTE  0x2
+#define KVM_COVE_TSM_CAP_AIA                 0x3
+#define KVM_COVE_TSM_CAP_MRIF                0x4
+#define KVM_COVE_TSM_CAP_MEMORY_ALLOCATION   0x5
+
+#define KVM_COVE_PAGE_SIZE_4K	(1UL << 12)
+#define KVM_COVE_PAGE_SIZE_2MB	(1UL << 21)
+#define KVM_COVE_PAGE_SIZE_1GB	(1UL << 30)
+#define KVM_COVE_PAGE_SIZE_512GB (1UL << 39)
+
+#define bytes_to_pages(n) ((n + PAGE_SIZE - 1) >> PAGE_SHIFT)
+
+/* Allocate 2MB(i.e. 512 pages) for the page table pool */
+#define KVM_COVE_PGTABLE_SIZE_MAX ((1UL << 10) * PAGE_SIZE)
+
+#define get_order_num_pages(n) (get_order(n << PAGE_SHIFT))
+
+#define get_gpr_index(goffset) \
+	((goffset - KVM_ARCH_GUEST_ZERO) / (__riscv_xlen / 8))
+
+/* Describe a confidential or shared memory region */
+struct kvm_riscv_cove_mem_region {
+	unsigned long hva;
+	unsigned long gpa;
+	unsigned long npages;
+};
+
+/* Page management structure for the host */
+struct kvm_riscv_cove_page {
+	struct list_head link;
+
+	/* Pointer to page allocated */
+	struct page *page;
+
+	/* number of pages allocated for page */
+	unsigned long npages;
+
+	/* Described the page type */
+	unsigned long ptype;
+
+	/* set if the page is mapped in guest physical address */
+	bool is_mapped;
+
+	/* The below two fileds are only valid if is_mapped is true */
+	/* host virtual address for the mapping */
+	unsigned long hva;
+	/* guest physical address for the mapping */
+	unsigned long gpa;
+};
+
+struct imsic_cove_state {
+	bool bind_required;
+	bool bound;
+	int vsfile_hgei;
+};
+
+struct kvm_cove_tvm_vcpu_context {
+	struct kvm_vcpu *vcpu;
+	/* Pages storing each vcpu state of the TVM in TSM */
+	struct kvm_riscv_cove_page vcpu_state;
+
+	/* Per VCPU imsic state */
+	struct imsic_cove_state imsic;
+};
+
+struct kvm_cove_tvm_context {
+	struct kvm *kvm;
+
+	/* TODO: This is not really a VMID as TSM returns the page owner ID instead of VMID */
+	unsigned long tvm_guest_id;
+
+	/* Address of TVM Attestation Payload (TAP) */
+	unsigned long cove_tap_addr;
+
+	/* Pages where TVM page table is stored */
+	struct kvm_riscv_cove_page pgtable;
+
+	/* Pages storing the TVM state in TSM */
+	struct kvm_riscv_cove_page tvm_state;
+
+	/* Keep track of zero pages */
+	struct list_head zero_pages;
+
+	/* Pages where TVM image is measured & loaded */
+	struct list_head measured_pages;
+
+	/* keep track of shared pages */
+	struct list_head shared_pages;
+
+	/* keep track of pending reclaim confidential pages */
+	struct list_head reclaim_pending_pages;
+
+	struct kvm_riscv_cove_mem_region shared_region;
+	struct kvm_riscv_cove_mem_region confidential_region;
+
+	/* spinlock to protect the tvm fence sequence */
+	spinlock_t tvm_fence_lock;
+
+	/* Track TVM state */
+	bool finalized_done;
+};
+
+static inline bool is_cove_vm(struct kvm *kvm)
+{
+	return kvm->arch.vm_type == KVM_VM_TYPE_RISCV_COVE_MULTI_STEP_INIT || \
+	       kvm->arch.vm_type == KVM_VM_TYPE_RISCV_COVE_SINGLE_STEP_INIT;
+}
+
+static inline bool is_cove_vcpu(struct kvm_vcpu *vcpu)
+{
+	return is_cove_vm(vcpu->kvm);
+}
+
+static inline bool is_cove_vm_initializing(struct kvm *kvm)
+{
+	return is_cove_vm(kvm) && !kvm->arch.tvmc->finalized_done;
+}
+
+static inline bool is_cove_vm_multi_step_initializing(struct kvm *kvm)
+{
+	return kvm->arch.vm_type == KVM_VM_TYPE_RISCV_COVE_MULTI_STEP_INIT && \
+	       !kvm->arch.tvmc->finalized_done;
+}
+
+static inline bool is_cove_vm_single_step_initializing(struct kvm *kvm)
+{
+	return kvm->arch.vm_type == KVM_VM_TYPE_RISCV_COVE_SINGLE_STEP_INIT && \
+	       !kvm->arch.tvmc->finalized_done;
+}
+
+static inline bool is_cove_vm_finalized(struct kvm *kvm)
+{
+	return is_cove_vm(kvm) && kvm->arch.tvmc->finalized_done;
+}
+
+#ifdef CONFIG_RISCV_COVE_HOST
+
+bool kvm_riscv_cove_enabled(void);
+bool kvm_riscv_cove_capability(unsigned long cap);
+int kvm_riscv_cove_init(void);
+
+/* TVM related functions */
+void kvm_riscv_cove_vm_destroy(struct kvm *kvm);
+int kvm_riscv_cove_vm_single_step_init(struct kvm *kvm);
+int kvm_riscv_cove_vm_multi_step_init(struct kvm *kvm);
+
+/* TVM VCPU related functions */
+void kvm_riscv_cove_vcpu_destroy(struct kvm_vcpu *vcpu);
+int kvm_riscv_cove_vcpu_init(struct kvm_vcpu *vcpu);
+void kvm_riscv_cove_vcpu_load(struct kvm_vcpu *vcpu);
+void kvm_riscv_cove_vcpu_put(struct kvm_vcpu *vcpu);
+void kvm_riscv_cove_gstage_preload(struct kvm_vcpu *vcpu);
+void kvm_riscv_cove_vcpu_switchto(struct kvm_vcpu *vcpu, struct kvm_cpu_trap *trap);
+int kvm_riscv_cove_vcpu_sbi_ecall(struct kvm_vcpu *vcpu, struct kvm_run *run);
+
+int kvm_riscv_cove_vm_measure_pages(struct kvm *kvm, struct kvm_riscv_cove_measure_region *mr);
+int kvm_riscv_cove_vm_add_memreg(struct kvm *kvm, unsigned long gpa, unsigned long size);
+int kvm_riscv_cove_handle_pagefault(struct kvm_vcpu *vcpu, gpa_t gpa,
+				    unsigned long hva);
+/* Fence related function */
+int kvm_riscv_cove_tvm_fence(struct kvm_vcpu *vcpu);
+
+/* AIA related CoVE functions */
+int kvm_riscv_cove_aia_init(struct kvm *kvm);
+int kvm_riscv_cove_vcpu_inject_interrupt(struct kvm_vcpu *vcpu, unsigned long iid);
+int kvm_riscv_cove_vcpu_imsic_unbind(struct kvm_vcpu *vcpu, int old_cpu);
+int kvm_riscv_cove_vcpu_imsic_bind(struct kvm_vcpu *vcpu, unsigned long imsic_mask);
+int kvm_riscv_cove_vcpu_imsic_rebind(struct kvm_vcpu *vcpu, int old_pcpu);
+int kvm_riscv_cove_aia_claim_imsic(struct kvm_vcpu *vcpu, phys_addr_t imsic_pa);
+int kvm_riscv_cove_aia_convert_imsic(struct kvm_vcpu *vcpu, phys_addr_t imsic_pa);
+int kvm_riscv_cove_vcpu_imsic_addr(struct kvm_vcpu *vcpu);
+#else
+static inline bool kvm_riscv_cove_enabled(void) {return false; };
+static inline bool kvm_riscv_cove_capability(unsigned long cap) { return false; };
+static inline int kvm_riscv_cove_init(void) { return -1; }
+static inline void kvm_riscv_cove_hardware_disable(void) {}
+static inline int kvm_riscv_cove_hardware_enable(void) {return 0; }
+
+/* TVM related functions */
+static inline void kvm_riscv_cove_vm_destroy(struct kvm *kvm) {}
+static inline int kvm_riscv_cove_vm_single_step_init(struct kvm *kvm) { return -1; }
+static inline int kvm_riscv_cove_vm_multi_step_init(struct kvm *kvm) { return -1; }
+
+/* TVM VCPU related functions */
+static inline void kvm_riscv_cove_vcpu_destroy(struct kvm_vcpu *vcpu) {}
+static inline int kvm_riscv_cove_vcpu_init(struct kvm_vcpu *vcpu) {return -1; }
+static inline void kvm_riscv_cove_vcpu_load(struct kvm_vcpu *vcpu) {}
+static inline void kvm_riscv_cove_vcpu_put(struct kvm_vcpu *vcpu) {}
+static inline void kvm_riscv_cove_gstage_preload(struct kvm_vcpu *vcpu) {}
+static inline void kvm_riscv_cove_vcpu_switchto(struct kvm_vcpu *vcpu, struct kvm_cpu_trap *trap) {}
+static inline int kvm_riscv_cove_vcpu_sbi_ecall(struct kvm_vcpu *vcpu, struct kvm_run *run)
+{
+	return -1;
+}
+static inline int kvm_riscv_cove_vm_add_memreg(struct kvm *kvm, unsigned long gpa,
+					       unsigned long size) {return -1; }
+static inline int kvm_riscv_cove_vm_measure_pages(struct kvm *kvm,
+						  struct kvm_riscv_cove_measure_region *mr)
+{
+	return -1;
+}
+static inline int kvm_riscv_cove_handle_pagefault(struct kvm_vcpu *vcpu,
+						  gpa_t gpa, unsigned long hva) { return -1; }
+
+/* TVM interrupt managenet via AIA functions */
+static inline int kvm_riscv_cove_aia_init(struct kvm *kvm) { return -1; }
+static inline int kvm_riscv_cove_vcpu_inject_interrupt(struct kvm_vcpu *vcpu,
+						       unsigned long iid) { return -1; }
+static inline int kvm_riscv_cove_vcpu_imsic_unbind(struct kvm_vcpu *vcpu,
+						   int old_cpu) { return -1; }
+static inline int kvm_riscv_cove_vcpu_imsic_bind(struct kvm_vcpu *vcpu,
+						 unsigned long imsic_mask) { return -1; }
+static inline int kvm_riscv_cove_aia_claim_imsic(struct kvm_vcpu *vcpu,
+						 phys_addr_t imsic_pa) { return -1; }
+static inline int kvm_riscv_cove_aia_convert_imsic(struct kvm_vcpu *vcpu,
+						 phys_addr_t imsic_pa) { return -1; }
+static inline int kvm_riscv_cove_vcpu_imsic_addr(struct kvm_vcpu *vcpu) { return -1; }
+static inline int kvm_riscv_cove_vcpu_imsic_rebind(struct kvm_vcpu *vcpu,
+						   int old_pcpu) { return -1; }
+#endif /* CONFIG_RISCV_COVE_HOST */
+
+#endif /* __KVM_RISCV_COVE_H */
diff --git a/arch/riscv/include/asm/kvm_cove_sbi.h b/arch/riscv/include/asm/kvm_cove_sbi.h
new file mode 100644
index 000000000000..c14366f2916a
--- /dev/null
+++ b/arch/riscv/include/asm/kvm_cove_sbi.h
@@ -0,0 +1,103 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * COVE SBI extension related header file.
+ *
+ * Copyright (c) 2023 RivosInc
+ *
+ * Authors:
+ *     Atish Patra <atishp@rivosinc.com>
+ */
+
+#ifndef __KVM_COVE_SBI_H
+#define __KVM_COVE_SBI_H
+
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/kvm_host.h>
+#include <asm/csr.h>
+#include <asm/sbi.h>
+
+#include <asm/asm-offsets.h>
+
+/**
+ * CoVE SBI extensions defines the NACL scratch memory.
+ * uint64_t gprs[32]
+ * uint64_t reserved[224]
+ */
+#define get_scratch_gpr_offset(goffset) (goffset - KVM_ARCH_GUEST_ZERO)
+
+#define nacl_shmem_gpr_write_cove(__s, __g, __o) \
+	nacl_shmem_scratch_write_long(__s, get_scratch_gpr_offset(__g), __o)
+
+#define nacl_shmem_gpr_read_cove(__s, __g) \
+	nacl_shmem_scratch_read_long(__s, get_scratch_gpr_offset(__g))
+
+/* Functions related to CoVE Host Interface (COVH) Extension */
+int sbi_covh_tsm_get_info(struct sbi_cove_tsm_info *tinfo_addr);
+int sbi_covh_tvm_initiate_fence(unsigned long tvmid);
+int sbi_covh_tsm_initiate_fence(void);
+int sbi_covh_tsm_local_fence(void);
+int sbi_covh_tsm_create_tvm(struct sbi_cove_tvm_create_params *tparam, unsigned long *tvmid);
+int sbi_covh_tsm_finalize_tvm(unsigned long tvmid, unsigned long sepc, unsigned long entry_arg);
+int sbi_covh_tsm_destroy_tvm(unsigned long tvmid);
+int sbi_covh_add_memory_region(unsigned long tvmid, unsigned long tgpadr, unsigned long rlen);
+
+int sbi_covh_tsm_reclaim_pages(unsigned long phys_addr, unsigned long npages);
+int sbi_covh_tsm_convert_pages(unsigned long phys_addr, unsigned long npages);
+int sbi_covh_tsm_reclaim_page(unsigned long page_addr_phys);
+int sbi_covh_add_pgt_pages(unsigned long tvmid, unsigned long page_addr_phys, unsigned long npages);
+
+int sbi_covh_add_measured_pages(unsigned long tvmid, unsigned long src_addr,
+				unsigned long dest_addr, enum sbi_cove_page_type ptype,
+				unsigned long npages, unsigned long tgpa);
+int sbi_covh_add_zero_pages(unsigned long tvmid, unsigned long page_addr_phys,
+			    enum sbi_cove_page_type ptype, unsigned long npages,
+			    unsigned long tvm_base_page_addr);
+
+int sbi_covh_create_tvm_vcpu(unsigned long tvmid, unsigned long tvm_vcpuid,
+			     unsigned long vpus_page_addr);
+
+int sbi_covh_run_tvm_vcpu(unsigned long tvmid, unsigned long tvm_vcpuid);
+
+int sbi_covh_add_shared_pages(unsigned long tvmid, unsigned long page_addr_phys,
+			      enum sbi_cove_page_type ptype,
+			      unsigned long npages,
+			      unsigned long tvm_base_page_addr);
+int sbi_covh_tvm_invalidate_pages(unsigned long tvmid,
+			     unsigned long tvm_base_page_addr,
+			     unsigned long len);
+int sbi_covh_tvm_validate_pages(unsigned long tvmid,
+			       unsigned long tvm_base_page_addr,
+			       unsigned long len);
+int sbi_covh_tvm_promote_page(unsigned long tvmid,
+			      unsigned long tvm_base_page_addr,
+			      enum sbi_cove_page_type ptype);
+int sbi_covh_tvm_demote_page(unsigned long tvmid,
+			     unsigned long tvm_base_page_addr,
+			     enum sbi_cove_page_type ptype);
+int sbi_covh_tvm_remove_pages(unsigned long tvmid,
+			      unsigned long tvm_base_page_addr,
+			      unsigned long len);
+int sbi_covh_tsm_promote_to_tvm(unsigned long fdt_address, unsigned long tap_addr,
+				unsigned long sepc, unsigned long *tvmid);
+
+/* Functions related to CoVE Interrupt Management(COVI) Extension */
+int sbi_covi_tvm_aia_init(unsigned long tvm_gid, struct sbi_cove_tvm_aia_params *tvm_aia_params);
+int sbi_covi_set_vcpu_imsic_addr(unsigned long tvm_gid, unsigned long vcpu_id,
+				 unsigned long imsic_addr);
+int sbi_covi_convert_imsic(unsigned long imsic_addr);
+int sbi_covi_reclaim_imsic(unsigned long imsic_addr);
+int sbi_covi_bind_vcpu_imsic(unsigned long tvm_gid, unsigned long vcpu_id,
+			     unsigned long imsic_mask);
+int sbi_covi_unbind_vcpu_imsic_begin(unsigned long tvm_gid, unsigned long vcpu_id);
+int sbi_covi_unbind_vcpu_imsic_end(unsigned long tvm_gid, unsigned long vcpu_id);
+int sbi_covi_inject_external_interrupt(unsigned long tvm_gid, unsigned long vcpu_id,
+					unsigned long interrupt_id);
+int sbi_covi_rebind_vcpu_imsic_begin(unsigned long tvm_gid, unsigned long vcpu_id,
+				      unsigned long imsic_mask);
+int sbi_covi_rebind_vcpu_imsic_clone(unsigned long tvm_gid, unsigned long vcpu_id);
+int sbi_covi_rebind_vcpu_imsic_end(unsigned long tvm_gid, unsigned long vcpu_id);
+
+
+
+#endif
diff --git a/arch/riscv/include/asm/kvm_host.h b/arch/riscv/include/asm/kvm_host.h
index 1ebf20dfbaa6..24ed8ae80c45 100644
--- a/arch/riscv/include/asm/kvm_host.h
+++ b/arch/riscv/include/asm/kvm_host.h
@@ -89,6 +89,8 @@ struct kvm_vmid {
 };
 
 struct kvm_arch {
+	unsigned long vm_type;
+
 	/* G-stage vmid */
 	struct kvm_vmid vmid;
 
@@ -101,6 +103,9 @@ struct kvm_arch {
 
 	/* AIA Guest/VM context */
 	struct kvm_aia aia;
+
+	/* COVE guest/VM context */
+	struct kvm_cove_tvm_context *tvmc;
 };
 
 struct kvm_cpu_trap {
@@ -244,6 +249,8 @@ struct kvm_vcpu_arch {
 
 	/* Performance monitoring context */
 	struct kvm_pmu pmu_context;
+
+	struct kvm_cove_tvm_vcpu_context *tc;
 };
 
 static inline void kvm_arch_sync_events(struct kvm *kvm) {}
@@ -315,11 +322,12 @@ void kvm_riscv_gstage_update_hgatp(struct kvm_vcpu *vcpu);
 void __init kvm_riscv_gstage_mode_detect(void);
 unsigned long __init kvm_riscv_gstage_mode(void);
 int kvm_riscv_gstage_gpa_bits(void);
+unsigned long kvm_riscv_gstage_pgd_size(void);
 
 void __init kvm_riscv_gstage_vmid_detect(void);
 unsigned long kvm_riscv_gstage_vmid_bits(void);
 int kvm_riscv_gstage_vmid_init(struct kvm *kvm);
-bool kvm_riscv_gstage_vmid_ver_changed(struct kvm_vmid *vmid);
+bool kvm_riscv_gstage_vmid_ver_changed(struct kvm *kvm);
 void kvm_riscv_gstage_vmid_update(struct kvm_vcpu *vcpu);
 
 int kvm_riscv_setup_default_irq_routing(struct kvm *kvm, u32 lines);
diff --git a/arch/riscv/include/asm/kvm_nacl.h b/arch/riscv/include/asm/kvm_nacl.h
new file mode 100644
index 000000000000..49bf06750e94
--- /dev/null
+++ b/arch/riscv/include/asm/kvm_nacl.h
@@ -0,0 +1,239 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) 2022 Ventana Micro Systems Inc.
+ */
+
+#ifndef __KVM_NACL_H
+#define __KVM_NACL_H
+
+#include <linux/jump_label.h>
+#include <linux/percpu.h>
+#include <asm/byteorder.h>
+#include <asm/csr.h>
+#include <asm/sbi.h>
+
+struct kvm_vcpu_arch;
+
+DECLARE_STATIC_KEY_FALSE(kvm_riscv_nacl_available);
+#define kvm_riscv_nacl_available() \
+	static_branch_unlikely(&kvm_riscv_nacl_available)
+
+DECLARE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_csr_available);
+#define kvm_riscv_nacl_sync_csr_available() \
+	static_branch_unlikely(&kvm_riscv_nacl_sync_csr_available)
+
+DECLARE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_hfence_available);
+#define kvm_riscv_nacl_sync_hfence_available() \
+	static_branch_unlikely(&kvm_riscv_nacl_sync_hfence_available)
+
+DECLARE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_sret_available);
+#define kvm_riscv_nacl_sync_sret_available() \
+	static_branch_unlikely(&kvm_riscv_nacl_sync_sret_available)
+
+DECLARE_STATIC_KEY_FALSE(kvm_riscv_nacl_autoswap_csr_available);
+#define kvm_riscv_nacl_autoswap_csr_available() \
+	static_branch_unlikely(&kvm_riscv_nacl_autoswap_csr_available)
+
+struct kvm_riscv_nacl {
+	void *shmem;
+	phys_addr_t shmem_phys;
+};
+DECLARE_PER_CPU(struct kvm_riscv_nacl, kvm_riscv_nacl);
+
+void __kvm_riscv_nacl_hfence(void *shmem,
+			     unsigned long control,
+			     unsigned long page_num,
+			     unsigned long page_count);
+
+void __kvm_riscv_nacl_switch_to(struct kvm_vcpu_arch *vcpu_arch,
+				unsigned long sbi_ext_id,
+				unsigned long sbi_func_id);
+
+int kvm_riscv_nacl_enable(void);
+
+void kvm_riscv_nacl_disable(void);
+
+void kvm_riscv_nacl_exit(void);
+
+int kvm_riscv_nacl_init(void);
+
+#ifdef CONFIG_32BIT
+#define lelong_to_cpu(__x)	le32_to_cpu(__x)
+#define cpu_to_lelong(__x)	cpu_to_le32(__x)
+#else
+#define lelong_to_cpu(__x)	le64_to_cpu(__x)
+#define cpu_to_lelong(__x)	cpu_to_le64(__x)
+#endif
+
+#define nacl_shmem()						\
+	this_cpu_ptr(&kvm_riscv_nacl)->shmem
+#define nacl_shmem_fast()					\
+	(kvm_riscv_nacl_available() ? nacl_shmem() : NULL)
+
+#define nacl_shmem_scratch_read_long(__s, __o)			\
+({								\
+	unsigned long *__p = (__s) +				\
+			     SBI_NACL_SHMEM_SCRATCH_OFFSET +	\
+			     (__o);				\
+	lelong_to_cpu(*__p);					\
+})
+
+#define nacl_shmem_scratch_write_long(__s, __o, __v)		\
+do {								\
+	unsigned long *__p = (__s) +				\
+			     SBI_NACL_SHMEM_SCRATCH_OFFSET +	\
+			     (__o);				\
+	*__p = cpu_to_lelong(__v);				\
+} while (0)
+
+#define nacl_shmem_scratch_write_longs(__s, __o, __a, __c)	\
+do {								\
+	unsigned int __i;					\
+	unsigned long *__p = (__s) +				\
+			     SBI_NACL_SHMEM_SCRATCH_OFFSET +	\
+			     (__o);				\
+	for (__i = 0; __i < (__c); __i++)			\
+		__p[__i] = cpu_to_lelong((__a)[__i]);		\
+} while (0)
+
+#define nacl_shmem_sync_hfence(__e)				\
+do {								\
+	sbi_ecall(SBI_EXT_NACL, SBI_EXT_NACL_SYNC_HFENCE,	\
+		  (__e), 0, 0, 0, 0, 0);			\
+} while (0)
+
+#define nacl_hfence_mkctrl(__t, __o, __v, __a)			\
+({								\
+	unsigned long __c = SBI_NACL_SHMEM_HFENCE_CTRL_PEND;	\
+	__c |= ((__t) & SBI_NACL_SHMEM_HFENCE_CTRL_TYPE_MASK)	\
+		<< SBI_NACL_SHMEM_HFENCE_CTRL_TYPE_SHIFT;	\
+	__c |= (((__o) - SBI_NACL_SHMEM_HFENCE_ORDER_BASE) &	\
+		SBI_NACL_SHMEM_HFENCE_CTRL_ORDER_MASK)	\
+		<< SBI_NACL_SHMEM_HFENCE_CTRL_ORDER_SHIFT;	\
+	__c |= ((__v) & SBI_NACL_SHMEM_HFENCE_CTRL_VMID_MASK)	\
+		<< SBI_NACL_SHMEM_HFENCE_CTRL_VMID_SHIFT;	\
+	__c |= ((__a) & SBI_NACL_SHMEM_HFENCE_CTRL_ASID_MASK);	\
+	__c;							\
+})
+
+#define nacl_hfence_mkpnum(__o, __addr)				\
+	((__addr) >> (__o))
+
+#define nacl_hfence_mkpcount(__o, __size)			\
+	((__size) >> (__o))
+
+#define nacl_shmem_hfence_gvma(__s, __gpa, __gpsz, __o)		\
+__kvm_riscv_nacl_hfence(__s,					\
+	nacl_hfence_mkctrl(SBI_NACL_SHMEM_HFENCE_TYPE_GVMA,	\
+			   __o, 0, 0),				\
+	nacl_hfence_mkpnum(__o, __gpa),				\
+	nacl_hfence_mkpcount(__o, __gpsz))
+
+#define nacl_shmem_hfence_gvma_all(__s)				\
+__kvm_riscv_nacl_hfence(__s,					\
+	nacl_hfence_mkctrl(SBI_NACL_SHMEM_HFENCE_TYPE_GVMA_ALL,	\
+			   0, 0, 0), 0, 0)
+
+#define nacl_shmem_hfence_gvma_vmid(__s, __v, __gpa, __gpsz, __o)\
+__kvm_riscv_nacl_hfence(__s,					\
+	nacl_hfence_mkctrl(SBI_NACL_SHMEM_HFENCE_TYPE_GVMA_VMID,\
+			   __o, __v, 0),			\
+	nacl_hfence_mkpnum(__o, __gpa),				\
+	nacl_hfence_mkpcount(__o, __gpsz))
+
+#define nacl_shmem_hfence_gvma_vmid_all(__s, __v)		\
+__kvm_riscv_nacl_hfence(__s,					\
+	nacl_hfence_mkctrl(SBI_NACL_SHMEM_HFENCE_TYPE_GVMA_VMID_ALL,\
+			   0, __v, 0), 0, 0)
+
+#define nacl_shmem_hfence_vvma(__s, __v, __gva, __gvsz, __o)	\
+__kvm_riscv_nacl_hfence(__s,					\
+	nacl_hfence_mkctrl(SBI_NACL_SHMEM_HFENCE_TYPE_VVMA,	\
+			   __o, __v, 0),			\
+	nacl_hfence_mkpnum(__o, __gva),				\
+	nacl_hfence_mkpcount(__o, __gvsz))
+
+#define nacl_shmem_hfence_vvma_all(__s, __v)			\
+__kvm_riscv_nacl_hfence(__s,					\
+	nacl_hfence_mkctrl(SBI_NACL_SHMEM_HFENCE_TYPE_VVMA_ALL,	\
+			   0, __v, 0), 0, 0)
+
+#define nacl_shmem_hfence_vvma_asid(__s, __v, __a, __gva, __gvsz, __o)\
+__kvm_riscv_nacl_hfence(__s,					\
+	nacl_hfence_mkctrl(SBI_NACL_SHMEM_HFENCE_TYPE_VVMA_ASID,\
+			   __o, __v, __a),			\
+	nacl_hfence_mkpnum(__o, __gva),				\
+	nacl_hfence_mkpcount(__o, __gvsz))
+
+#define nacl_shmem_hfence_vvma_asid_all(__s, __v, __a)		\
+__kvm_riscv_nacl_hfence(__s,					\
+	nacl_hfence_mkctrl(SBI_NACL_SHMEM_HFENCE_TYPE_VVMA_ASID_ALL,\
+			   0, __v, __a), 0, 0)
+
+#define nacl_shmem_csr_read(__s, __c)				\
+({								\
+	unsigned long *__a = (__s) + SBI_NACL_SHMEM_CSR_OFFSET;	\
+	lelong_to_cpu(__a[SBI_NACL_SHMEM_CSR_INDEX(__c)]);	\
+})
+
+#define nacl_shmem_csr_write(__s, __c, __v)			\
+do {								\
+	unsigned int __i = SBI_NACL_SHMEM_CSR_INDEX(__c);	\
+	unsigned long *__a = (__s) + SBI_NACL_SHMEM_CSR_OFFSET;	\
+	u8 *__b = (__s) + SBI_NACL_SHMEM_DBITMAP_OFFSET;	\
+	__a[__i] = cpu_to_lelong(__v);				\
+	__b[__i >> 3] |= 1U << (__i & 0x7);			\
+} while (0)
+
+#define nacl_shmem_csr_swap(__s, __c, __v)			\
+({								\
+	unsigned int __i = SBI_NACL_SHMEM_CSR_INDEX(__c);	\
+	unsigned long *__a = (__s) + SBI_NACL_SHMEM_CSR_OFFSET;	\
+	u8 *__b = (__s) + SBI_NACL_SHMEM_DBITMAP_OFFSET;	\
+	unsigned long __r = lelong_to_cpu(__a[__i]);		\
+	__a[__i] = cpu_to_lelong(__v);				\
+	__b[__i >> 3] |= 1U << (__i & 0x7);			\
+	__r;							\
+})
+
+#define nacl_shmem_sync_csr(__c)				\
+do {								\
+	sbi_ecall(SBI_EXT_NACL, SBI_EXT_NACL_SYNC_CSR,		\
+		  (__c), 0, 0, 0, 0, 0);			\
+} while (0)
+
+#define nacl_csr_read(__c)					\
+({								\
+	unsigned long __r;					\
+	if (kvm_riscv_nacl_available())				\
+		__r = nacl_shmem_csr_read(nacl_shmem(), __c);	\
+	else							\
+		__r = csr_read(__c);				\
+	__r;							\
+})
+
+#define nacl_csr_write(__c, __v)				\
+do {								\
+	if (kvm_riscv_nacl_sync_csr_available())		\
+		nacl_shmem_csr_write(nacl_shmem(), __c, __v);	\
+	else							\
+		csr_write(__c, __v);				\
+} while (0)
+
+#define nacl_csr_swap(__c, __v)					\
+({								\
+	unsigned long __r;					\
+	if (kvm_riscv_nacl_sync_csr_available())		\
+		__r = nacl_shmem_csr_swap(nacl_shmem(), __c, __v);\
+	else							\
+		__r = csr_swap(__c, __v);			\
+	__r;							\
+})
+
+#define nacl_sync_csr(__c)					\
+do {								\
+	if (kvm_riscv_nacl_sync_csr_available())		\
+		nacl_shmem_sync_csr(__c);			\
+} while (0)
+
+#endif
diff --git a/arch/riscv/include/asm/kvm_vcpu_sbi.h b/arch/riscv/include/asm/kvm_vcpu_sbi.h
index cdcf0ff07be7..a272dada7abc 100644
--- a/arch/riscv/include/asm/kvm_vcpu_sbi.h
+++ b/arch/riscv/include/asm/kvm_vcpu_sbi.h
@@ -69,8 +69,13 @@ extern const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_ipi;
 extern const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_rfence;
 extern const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_srst;
 extern const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_hsm;
+extern const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_dbcn;
 extern const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_experimental;
 extern const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_vendor;
+#ifdef CONFIG_RISCV_COVE_HOST
+extern const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_covg;
+extern const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_covh;
+#endif
 
 #ifdef CONFIG_RISCV_PMU_SBI
 extern const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_pmu;
diff --git a/arch/riscv/include/asm/mem_encrypt.h b/arch/riscv/include/asm/mem_encrypt.h
new file mode 100644
index 000000000000..0dc3fe8adfb6
--- /dev/null
+++ b/arch/riscv/include/asm/mem_encrypt.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * RISCV Memory Encryption Support.
+ *
+ * Copyright (c) 2023 Rivos Inc.
+ *
+ * Authors:
+ *     Rajnesh Kanwal <rkanwal@rivosinc.com>
+ */
+
+#ifndef __RISCV_MEM_ENCRYPT_H__
+#define __RISCV_MEM_ENCRYPT_H__
+
+#include <linux/init.h>
+
+struct device;
+
+bool force_dma_unencrypted(struct device *dev);
+
+/* Architecture __weak replacement functions */
+void __init mem_encrypt_init(void);
+
+int set_memory_encrypted(unsigned long addr, int numpages);
+int set_memory_decrypted(unsigned long addr, int numpages);
+
+#endif /* __RISCV_MEM_ENCRYPT_H__ */
diff --git a/arch/riscv/include/asm/pgtable-bits.h b/arch/riscv/include/asm/pgtable-bits.h
index f896708e8331..0a8abaf664f2 100644
--- a/arch/riscv/include/asm/pgtable-bits.h
+++ b/arch/riscv/include/asm/pgtable-bits.h
@@ -17,6 +17,7 @@
 #define _PAGE_ACCESSED  (1 << 6)    /* Set by hardware on any access */
 #define _PAGE_DIRTY     (1 << 7)    /* Set by hardware on any write */
 #define _PAGE_SOFT      (1 << 8)    /* Reserved for software */
+#define _PAGE_UNCACHE   (1 << 9)    /* Map to uncached system port */
 
 #define _PAGE_SPECIAL   _PAGE_SOFT
 #define _PAGE_TABLE     _PAGE_PRESENT
diff --git a/arch/riscv/include/asm/pgtable.h b/arch/riscv/include/asm/pgtable.h
index c00bd5377db9..77a739ab0e80 100644
--- a/arch/riscv/include/asm/pgtable.h
+++ b/arch/riscv/include/asm/pgtable.h
@@ -84,7 +84,7 @@
  * Define vmemmap for pfn_to_page & page_to_pfn calls. Needed if kernel
  * is configured with CONFIG_SPARSEMEM_VMEMMAP enabled.
  */
-#define vmemmap		((struct page *)VMEMMAP_START - (phys_ram_base >> PAGE_SHIFT))
+#define vmemmap		((struct page *)VMEMMAP_START)
 
 #define PCI_IO_SIZE      SZ_16M
 #define PCI_IO_END       VMEMMAP_START
@@ -208,6 +208,54 @@ extern struct pt_alloc_ops pt_ops __initdata;
 #define _PAGE_IOREMAP	((_PAGE_KERNEL & ~_PAGE_MTMASK) | _PAGE_IO)
 #define PAGE_KERNEL_IO		__pgprot(_PAGE_IOREMAP)
 
+#if defined(CONFIG_SOC_SIFIVE_EIC7700)
+#define pgprot_noncached(prot)      __pgprot(pgprot_val(prot) | _PAGE_UNCACHE)
+#define pgprot_writecombine(prot)   pgprot_noncached(prot)
+#define pgprot_dmacoherent(prot)    pgprot_noncached(prot)
+
+/* DIE0 */
+#define DIE0_MEM_PORT_PFN_START                     (CONFIG_RISCV_DIE0_CACHED_OFFSET >> PAGE_SHIFT)
+#define DIE0_MEM_PORT_PFN_END                       ((CONFIG_RISCV_DIE0_CACHED_OFFSET + CONFIG_RISCV_DIE0_MEM_MAX_SIZE) >> PAGE_SHIFT)
+
+#define DIE0_SYS_PORT_PFN_START                     (CONFIG_RISCV_DIE0_UNCACHED_OFFSET >> PAGE_SHIFT)
+#define DIE0_MEM_TO_SYS_PFN_ADDRESS(a)              (DIE0_SYS_PORT_PFN_START + ((u64)(a) - DIE0_MEM_PORT_PFN_START))
+#define DIE0_SYS_TO_MEM_PFN_ADDRESS(a)              (DIE0_MEM_PORT_PFN_START + ((u64)(a) - DIE0_SYS_PORT_PFN_START))
+#define DIE0_SYS_PORT_PFN_END                       ((CONFIG_RISCV_DIE0_UNCACHED_OFFSET + CONFIG_RISCV_DIE0_MEM_MAX_SIZE) >> PAGE_SHIFT)
+
+/* DIE1 */
+#define DIE1_MEM_PORT_PFN_START                     (CONFIG_RISCV_DIE1_CACHED_OFFSET >> PAGE_SHIFT)
+#define DIE1_MEM_PORT_PFN_END                       ((CONFIG_RISCV_DIE1_CACHED_OFFSET + CONFIG_RISCV_DIE1_MEM_MAX_SIZE) >> PAGE_SHIFT)
+
+#define DIE1_SYS_PORT_PFN_START                     (CONFIG_RISCV_DIE1_UNCACHED_OFFSET >> PAGE_SHIFT)
+#define DIE1_MEM_TO_SYS_PFN_ADDRESS(a)              (DIE1_SYS_PORT_PFN_START + ((u64)(a) - DIE1_MEM_PORT_PFN_START))
+#define DIE1_SYS_TO_MEM_PFN_ADDRESS(a)              (DIE1_MEM_PORT_PFN_START + ((u64)(a) - DIE1_SYS_PORT_PFN_START))
+#define DIE1_SYS_PORT_PFN_END                       ((CONFIG_RISCV_DIE1_UNCACHED_OFFSET + CONFIG_RISCV_DIE1_MEM_MAX_SIZE) >> PAGE_SHIFT)
+
+/* interleave */
+#define INTERLEAVE_MEM_PORT_PFN_START               (CONFIG_RISCV_INTERLEAVE_CACHED_OFFSET >> PAGE_SHIFT)
+#define INTERLEAVE_MEM_PORT_PFN_END                 ((CONFIG_RISCV_INTERLEAVE_CACHED_OFFSET + CONFIG_RISCV_INTERLEAVE_MEM_MAX_SIZE) >> PAGE_SHIFT)
+
+#define INTERLEAVE_SYS_PORT_PFN_START               (CONFIG_RISCV_INTERLEAVE_UNCACHED_OFFSET >> PAGE_SHIFT)
+#define INTERLEAVE_MEM_TO_SYS_PFN_ADDRESS(a)        (INTERLEAVE_SYS_PORT_PFN_START + ((u64)(a) - INTERLEAVE_MEM_PORT_PFN_START))
+#define INTERLEAVE_SYS_TO_MEM_PFN_ADDRESS(a)        (INTERLEAVE_MEM_PORT_PFN_START + ((u64)(a) - INTERLEAVE_SYS_PORT_PFN_START))
+#define INTERLEAVE_SYS_PORT_PFN_END                 ((CONFIG_RISCV_INTERLEAVE_UNCACHED_OFFSET + CONFIG_RISCV_INTERLEAVE_MEM_MAX_SIZE) >> PAGE_SHIFT)
+
+/* pha conversion between mem port and sys port */
+#define convert_pfn_from_mem_to_sys_port(pfn) \
+	((pfn < DIE0_MEM_PORT_PFN_END)?DIE0_MEM_TO_SYS_PFN_ADDRESS(pfn): \
+	((pfn >= DIE1_MEM_PORT_PFN_START && pfn < DIE1_MEM_PORT_PFN_END)?DIE1_MEM_TO_SYS_PFN_ADDRESS(pfn): \
+	 ((pfn >= INTERLEAVE_MEM_PORT_PFN_START && pfn < INTERLEAVE_MEM_PORT_PFN_END) ? INTERLEAVE_MEM_TO_SYS_PFN_ADDRESS(pfn) : (pfn))))
+
+#define convert_pfn_from_sys_to_mem_port(pfn) \
+	((pfn < DIE0_SYS_PORT_PFN_END)?DIE0_SYS_TO_MEM_PFN_ADDRESS(pfn): \
+	((pfn >= DIE1_SYS_PORT_PFN_START && pfn < DIE1_SYS_PORT_PFN_END)?DIE1_SYS_TO_MEM_PFN_ADDRESS(pfn): \
+	((pfn >= INTERLEAVE_SYS_PORT_PFN_START && pfn < INTERLEAVE_SYS_PORT_PFN_END) ? INTERLEAVE_SYS_TO_MEM_PFN_ADDRESS(pfn) : (pfn))))
+
+#define convert_pha_from_mem_to_sys_port(pha) \
+	(convert_pfn_from_mem_to_sys_port(pha >> PAGE_SHIFT) << PAGE_SHIFT)
+
+#endif
+
 extern pgd_t swapper_pg_dir[];
 extern pgd_t trampoline_pg_dir[];
 extern pgd_t early_pg_dir[];
@@ -327,6 +375,15 @@ static inline unsigned long pte_pfn(pte_t pte)
 {
 	unsigned long res  = __page_val_to_pfn(pte_val(pte));
 
+#if defined(CONFIG_SOC_SIFIVE_EIC7700)
+	unsigned long pfn_new;
+	if (unlikely(pte_val(pte) & _PAGE_UNCACHE))
+	{
+	    pr_debug("pte_pfn:pfn_sys 0x%lx to pfn_mport 0x%lx\n", (pte_val(pte) >> _PAGE_PFN_SHIFT), pfn_new);
+	    return convert_pfn_from_sys_to_mem_port(pte_val(pte) >> _PAGE_PFN_SHIFT);
+	}
+#endif
+
 	if (has_svnapot() && pte_napot(pte))
 		res = res & (res - 1UL);
 
@@ -340,6 +397,17 @@ static inline pte_t pfn_pte(unsigned long pfn, pgprot_t prot)
 {
 	unsigned long prot_val = pgprot_val(prot);
 
+#if defined(CONFIG_SOC_SIFIVE_EIC7700)
+	unsigned long pfn_new;
+
+	if (unlikely(_PAGE_UNCACHE == (pgprot_val(prot) & _PAGE_UNCACHE)))
+	{
+	    pfn_new = convert_pfn_from_mem_to_sys_port(pfn);
+	    pr_debug("pfn_pte:pfn_mport 0x%lx to pfn_sysport 0x%lx\n", pfn, pfn_new);
+	    return __pte((pfn_new << _PAGE_PFN_SHIFT) | pgprot_val(prot));
+	}
+#endif
+
 	ALT_THEAD_PMA(prot_val);
 
 	return __pte((pfn << _PAGE_PFN_SHIFT) | prot_val);
@@ -438,10 +506,6 @@ static inline pte_t pte_mkhuge(pte_t pte)
 	return pte;
 }
 
-#define pte_leaf_size(pte)	(pte_napot(pte) ?				\
-					napot_cont_size(napot_cont_order(pte)) :\
-					PAGE_SIZE)
-
 #ifdef CONFIG_NUMA_BALANCING
 /*
  * See the comment in include/asm-generic/pgtable.h
@@ -611,6 +675,7 @@ static inline int ptep_clear_flush_young(struct vm_area_struct *vma,
 	return ptep_test_and_clear_young(vma, address, ptep);
 }
 
+#if !defined(CONFIG_SOC_SIFIVE_EIC7700)
 #define pgprot_noncached pgprot_noncached
 static inline pgprot_t pgprot_noncached(pgprot_t _prot)
 {
@@ -632,6 +697,7 @@ static inline pgprot_t pgprot_writecombine(pgprot_t _prot)
 
 	return __pgprot(prot);
 }
+#endif
 
 /*
  * THP functions
@@ -884,7 +950,7 @@ static inline pte_t pte_swp_clear_exclusive(pte_t pte)
 #define TASK_SIZE_MIN	(PGDIR_SIZE_L3 * PTRS_PER_PGD / 2)
 
 #ifdef CONFIG_COMPAT
-#define TASK_SIZE_32	(_AC(0x80000000, UL))
+#define TASK_SIZE_32	(_AC(0x80000000, UL) - PAGE_SIZE)
 #define TASK_SIZE	(test_thread_flag(TIF_32BIT) ? \
 			 TASK_SIZE_32 : TASK_SIZE_64)
 #else
diff --git a/arch/riscv/include/asm/sbi.h b/arch/riscv/include/asm/sbi.h
index b79d0228144f..9b5108e26f92 100644
--- a/arch/riscv/include/asm/sbi.h
+++ b/arch/riscv/include/asm/sbi.h
@@ -30,6 +30,11 @@ enum sbi_ext_id {
 	SBI_EXT_HSM = 0x48534D,
 	SBI_EXT_SRST = 0x53525354,
 	SBI_EXT_PMU = 0x504D55,
+	SBI_EXT_DBCN = 0x4442434E,
+	SBI_EXT_NACL = 0x4E41434C,
+	SBI_EXT_COVH = 0x434F5648,
+	SBI_EXT_COVI = 0x434F5649,
+	SBI_EXT_COVG = 0x434F5647,
 
 	/* Experimentals extensions must lie within this range */
 	SBI_EXT_EXPERIMENTAL_START = 0x08000000,
@@ -236,6 +241,227 @@ enum sbi_pmu_ctr_type {
 /* Flags defined for counter stop function */
 #define SBI_PMU_STOP_FLAG_RESET (1 << 0)
 
+enum sbi_ext_dbcn_fid {
+	SBI_EXT_DBCN_CONSOLE_WRITE = 0,
+	SBI_EXT_DBCN_CONSOLE_READ = 1,
+	SBI_EXT_DBCN_CONSOLE_WRITE_BYTE = 2,
+};
+
+enum sbi_ext_nacl_fid {
+	SBI_EXT_NACL_PROBE_FEATURE = 0x0,
+	SBI_EXT_NACL_SETUP_SHMEM = 0x1,
+	SBI_EXT_NACL_SYNC_CSR = 0x2,
+	SBI_EXT_NACL_SYNC_HFENCE = 0x3,
+	SBI_EXT_NACL_SYNC_SRET = 0x4,
+};
+
+enum sbi_ext_nacl_feature {
+	SBI_NACL_FEAT_SYNC_CSR = 0x0,
+	SBI_NACL_FEAT_SYNC_HFENCE = 0x1,
+	SBI_NACL_FEAT_SYNC_SRET = 0x2,
+	SBI_NACL_FEAT_AUTOSWAP_CSR = 0x3,
+};
+
+#define SBI_NACL_SHMEM_ADDR_SHIFT	12
+#define SBI_NACL_SHMEM_SCRATCH_OFFSET	0x0000
+#define SBI_NACL_SHMEM_SCRATCH_SIZE	0x1000
+#define SBI_NACL_SHMEM_SRET_OFFSET	0x0000
+#define SBI_NACL_SHMEM_SRET_SIZE	0x0200
+#define SBI_NACL_SHMEM_AUTOSWAP_OFFSET	(SBI_NACL_SHMEM_SRET_OFFSET + \
+					 SBI_NACL_SHMEM_SRET_SIZE)
+#define SBI_NACL_SHMEM_AUTOSWAP_SIZE	0x0080
+#define SBI_NACL_SHMEM_UNUSED_OFFSET	(SBI_NACL_SHMEM_AUTOSWAP_OFFSET + \
+					 SBI_NACL_SHMEM_AUTOSWAP_SIZE)
+#define SBI_NACL_SHMEM_UNUSED_SIZE	0x0580
+#define SBI_NACL_SHMEM_HFENCE_OFFSET	(SBI_NACL_SHMEM_UNUSED_OFFSET + \
+					 SBI_NACL_SHMEM_UNUSED_SIZE)
+#define SBI_NACL_SHMEM_HFENCE_SIZE	0x0780
+#define SBI_NACL_SHMEM_DBITMAP_OFFSET	(SBI_NACL_SHMEM_HFENCE_OFFSET + \
+					 SBI_NACL_SHMEM_HFENCE_SIZE)
+#define SBI_NACL_SHMEM_DBITMAP_SIZE	0x0080
+#define SBI_NACL_SHMEM_CSR_OFFSET	(SBI_NACL_SHMEM_DBITMAP_OFFSET + \
+					 SBI_NACL_SHMEM_DBITMAP_SIZE)
+#define SBI_NACL_SHMEM_CSR_SIZE		((__riscv_xlen / 8) * 1024)
+#define SBI_NACL_SHMEM_SIZE		(SBI_NACL_SHMEM_CSR_OFFSET + \
+					 SBI_NACL_SHMEM_CSR_SIZE)
+
+#define SBI_NACL_SHMEM_CSR_INDEX(__csr_num)	\
+		((((__csr_num) & 0xc00) >> 2) | ((__csr_num) & 0xff))
+
+#define SBI_NACL_SHMEM_HFENCE_ENTRY_SZ		((__riscv_xlen / 8) * 4)
+#define SBI_NACL_SHMEM_HFENCE_ENTRY_MAX		\
+		(SBI_NACL_SHMEM_HFENCE_SIZE /	\
+		 SBI_NACL_SHMEM_HFENCE_ENTRY_SZ)
+#define SBI_NACL_SHMEM_HFENCE_ENTRY(__num)	\
+		(SBI_NACL_SHMEM_HFENCE_OFFSET +	\
+		 (__num) * SBI_NACL_SHMEM_HFENCE_ENTRY_SZ)
+#define SBI_NACL_SHMEM_HFENCE_ENTRY_CTRL(__num)	\
+		SBI_NACL_SHMEM_HFENCE_ENTRY(__num)
+#define SBI_NACL_SHMEM_HFENCE_ENTRY_PNUM(__num)\
+		(SBI_NACL_SHMEM_HFENCE_ENTRY(__num) + (__riscv_xlen / 8))
+#define SBI_NACL_SHMEM_HFENCE_ENTRY_PCOUNT(__num)\
+		(SBI_NACL_SHMEM_HFENCE_ENTRY(__num) + \
+		 ((__riscv_xlen / 8) * 3))
+
+#if __riscv_xlen == 32
+#define SBI_NACL_SHMEM_HFENCE_CTRL_ASID_BITS	9
+#define SBI_NACL_SHMEM_HFENCE_CTRL_VMID_BITS	7
+#else
+#define SBI_NACL_SHMEM_HFENCE_CTRL_ASID_BITS	16
+#define SBI_NACL_SHMEM_HFENCE_CTRL_VMID_BITS	14
+#endif
+#define SBI_NACL_SHMEM_HFENCE_CTRL_VMID_SHIFT	\
+				SBI_NACL_SHMEM_HFENCE_CTRL_ASID_BITS
+#define SBI_NACL_SHMEM_HFENCE_CTRL_ASID_MASK	\
+		((1UL << SBI_NACL_SHMEM_HFENCE_CTRL_ASID_BITS) - 1)
+#define SBI_NACL_SHMEM_HFENCE_CTRL_VMID_MASK	\
+		((1UL << SBI_NACL_SHMEM_HFENCE_CTRL_VMID_BITS) - 1)
+
+#define SBI_NACL_SHMEM_HFENCE_CTRL_ORDER_BITS	7
+#define SBI_NACL_SHMEM_HFENCE_CTRL_ORDER_SHIFT	(__riscv_xlen - 16)
+#define SBI_NACL_SHMEM_HFENCE_CTRL_ORDER_MASK	\
+		((1UL << SBI_NACL_SHMEM_HFENCE_CTRL_ORDER_BITS) - 1)
+#define SBI_NACL_SHMEM_HFENCE_ORDER_BASE	12
+
+#define SBI_NACL_SHMEM_HFENCE_CTRL_TYPE_BITS	4
+#define SBI_NACL_SHMEM_HFENCE_CTRL_TYPE_SHIFT	(__riscv_xlen - 8)
+#define SBI_NACL_SHMEM_HFENCE_CTRL_TYPE_MASK	\
+		((1UL << SBI_NACL_SHMEM_HFENCE_CTRL_TYPE_BITS) - 1)
+
+#define SBI_NACL_SHMEM_HFENCE_TYPE_GVMA		0x0
+#define SBI_NACL_SHMEM_HFENCE_TYPE_GVMA_ALL	0x1
+#define SBI_NACL_SHMEM_HFENCE_TYPE_GVMA_VMID	0x2
+#define SBI_NACL_SHMEM_HFENCE_TYPE_GVMA_VMID_ALL 0x3
+#define SBI_NACL_SHMEM_HFENCE_TYPE_VVMA		0x4
+#define SBI_NACL_SHMEM_HFENCE_TYPE_VVMA_ALL	0x5
+#define SBI_NACL_SHMEM_HFENCE_TYPE_VVMA_ASID	0x6
+#define SBI_NACL_SHMEM_HFENCE_TYPE_VVMA_ASID_ALL 0x7
+
+#define SBI_NACL_SHMEM_HFENCE_CTRL_PEND_BITS	1
+#define SBI_NACL_SHMEM_HFENCE_CTRL_PEND_SHIFT	(__riscv_xlen - 1)
+#define SBI_NACL_SHMEM_HFENCE_CTRL_PEND_MASK	\
+		((1UL << SBI_NACL_SHMEM_HFENCE_CTRL_PEND_BITS) - 1)
+#define SBI_NACL_SHMEM_HFENCE_CTRL_PEND		\
+		(SBI_NACL_SHMEM_HFENCE_CTRL_PEND_MASK << \
+		 SBI_NACL_SHMEM_HFENCE_CTRL_PEND_SHIFT)
+
+#define SBI_NACL_SHMEM_AUTOSWAP_FLAG_HSTATUS	(1 << 0)
+#define SBI_NACL_SHMEM_AUTOSWAP_HSTATUS		((__riscv_xlen / 8) * 1)
+
+#define SBI_NACL_SHMEM_SRET_X(__i)		((__riscv_xlen / 8) * (__i))
+#define SBI_NACL_SHMEM_SRET_X_LAST		31
+
+/* SBI COVH extension data structures */
+enum sbi_ext_covh_fid {
+	SBI_EXT_COVH_TSM_GET_INFO = 0,
+	SBI_EXT_COVH_TSM_CONVERT_PAGES,
+	SBI_EXT_COVH_TSM_RECLAIM_PAGES,
+	SBI_EXT_COVH_TSM_INITIATE_FENCE,
+	SBI_EXT_COVH_TSM_LOCAL_FENCE,
+	SBI_EXT_COVH_CREATE_TVM,
+	SBI_EXT_COVH_FINALIZE_TVM,
+	SBI_EXT_COVH_PROMOTE_TO_TVM,
+	SBI_EXT_COVH_DESTROY_TVM,
+	SBI_EXT_COVH_TVM_ADD_MEMORY_REGION,
+	SBI_EXT_COVH_TVM_ADD_PGT_PAGES,
+	SBI_EXT_COVH_TVM_ADD_MEASURED_PAGES,
+	SBI_EXT_COVH_TVM_ADD_ZERO_PAGES,
+	SBI_EXT_COVH_TVM_ADD_SHARED_PAGES,
+	SBI_EXT_COVH_TVM_CREATE_VCPU,
+	SBI_EXT_COVH_TVM_VCPU_RUN,
+	SBI_EXT_COVH_TVM_INITIATE_FENCE,
+	SBI_EXT_COVH_TVM_INVALIDATE_PAGES,
+	SBI_EXT_COVH_TVM_VALIDATE_PAGES,
+	SBI_EXT_COVH_TVM_PROMOTE_PAGE,
+	SBI_EXT_COVH_TVM_DEMOTE_PAGE,
+	SBI_EXT_COVH_TVM_REMOVE_PAGES,
+};
+
+enum sbi_ext_covi_fid {
+	SBI_EXT_COVI_TVM_AIA_INIT,
+	SBI_EXT_COVI_TVM_CPU_SET_IMSIC_ADDR,
+	SBI_EXT_COVI_TVM_CONVERT_IMSIC,
+	SBI_EXT_COVI_TVM_RECLAIM_IMSIC,
+	SBI_EXT_COVI_TVM_CPU_BIND_IMSIC,
+	SBI_EXT_COVI_TVM_CPU_UNBIND_IMSIC_BEGIN,
+	SBI_EXT_COVI_TVM_CPU_UNBIND_IMSIC_END,
+	SBI_EXT_COVI_TVM_CPU_INJECT_EXT_INTERRUPT,
+	SBI_EXT_COVI_TVM_REBIND_IMSIC_BEGIN,
+	SBI_EXT_COVI_TVM_REBIND_IMSIC_CLONE,
+	SBI_EXT_COVI_TVM_REBIND_IMSIC_END,
+};
+
+enum sbi_cove_page_type {
+	SBI_COVE_PAGE_4K,
+	SBI_COVE_PAGE_2MB,
+	SBI_COVE_PAGE_1GB,
+	SBI_COVE_PAGE_512GB,
+};
+
+enum sbi_cove_tsm_state {
+	/* TSM has not been loaded yet */
+	TSM_NOT_LOADED,
+	/* TSM has been loaded but not initialized yet */
+	TSM_LOADED,
+	/* TSM has been initialized and ready to run */
+	TSM_READY,
+};
+
+struct sbi_cove_tsm_info {
+	/* Current state of the TSM */
+	enum sbi_cove_tsm_state tstate;
+
+	/* TSM implementation identifier */
+	uint32_t impl_id;
+
+	/* Version of the loaded TSM */
+	uint32_t version;
+
+	/* Capabilities of the TSM */
+	unsigned long capabilities;
+
+	/* Number of 4K pages required per TVM */
+	unsigned long tvm_pages_needed;
+
+	/* Maximum VCPUs supported per TVM */
+	unsigned long tvm_max_vcpus;
+
+	/* Number of 4K pages each vcpu per TVM */
+	unsigned long tvcpu_pages_needed;
+};
+
+struct sbi_cove_tvm_create_params {
+	/* Root page directory for TVM's page table management */
+	unsigned long tvm_page_directory_addr;
+	/* Confidential memory address used to store TVM state information. Must be page aligned */
+	unsigned long tvm_state_addr;
+};
+
+struct sbi_cove_tvm_aia_params {
+	/* The base address is the address of the IMSIC with group ID, hart ID, and guest ID of 0 */
+	uint64_t imsic_base_addr;
+	/* The number of group index bits in an IMSIC address */
+	uint32_t group_index_bits;
+	/* The location of the group index in an IMSIC address. Must be >= 24i. */
+	uint32_t group_index_shift;
+	/* The number of hart index bits in an IMSIC address */
+	uint32_t hart_index_bits;
+	/* The number of guest index bits in an IMSIC address. Must be >= log2(guests/hart + 1) */
+	uint32_t guest_index_bits;
+	/* The number of guest interrupt files to be implemented per vCPU */
+	uint32_t guests_per_hart;
+};
+
+/* SBI COVG extension data structures */
+enum sbi_ext_covg_fid {
+	SBI_EXT_COVG_ADD_MMIO_REGION,
+	SBI_EXT_COVG_REMOVE_MMIO_REGION,
+	SBI_EXT_COVG_SHARE_MEMORY,
+	SBI_EXT_COVG_UNSHARE_MEMORY,
+	SBI_EXT_COVG_ALLOW_EXT_INTERRUPT,
+	SBI_EXT_COVG_DENY_EXT_INTERRUPT,
+};
+
 #define SBI_SPEC_VERSION_DEFAULT	0x1
 #define SBI_SPEC_VERSION_MAJOR_SHIFT	24
 #define SBI_SPEC_VERSION_MAJOR_MASK	0x7f
@@ -322,6 +548,11 @@ static inline unsigned long sbi_mk_version(unsigned long major,
 }
 
 int sbi_err_map_linux_errno(int err);
+
+extern bool sbi_debug_console_available;
+int sbi_debug_console_write(const char *bytes, unsigned int num_bytes);
+int sbi_debug_console_read(char *bytes, unsigned int num_bytes);
+
 #else /* CONFIG_RISCV_SBI */
 static inline int sbi_remote_fence_i(const struct cpumask *cpu_mask) { return -1; }
 static inline void sbi_init(void) {}
diff --git a/arch/riscv/include/uapi/asm/kvm.h b/arch/riscv/include/uapi/asm/kvm.h
index 992c5e407104..4e9fed8d791b 100644
--- a/arch/riscv/include/uapi/asm/kvm.h
+++ b/arch/riscv/include/uapi/asm/kvm.h
@@ -101,6 +101,29 @@ struct kvm_riscv_timer {
 	__u64 state;
 };
 
+/* Memory region details of a CoVE guest that is measured at boot time */
+enum KVM_RISCV_COVE_REGION {
+	KVM_RISCV_COVE_REGION_FIRMWARE = 0,
+	KVM_RISCV_COVE_REGION_KERNEL,
+	KVM_RISCV_COVE_REGION_FDT,
+	KVM_RISCV_COVE_REGION_INITRD,
+	KVM_RISCV_COVE_REGION_COVE_TAP,
+};
+
+struct kvm_riscv_cove_measure_region {
+	/* Address of the user space where the VM code/data resides */
+	unsigned long userspace_addr;
+
+	/* The guest physical address where VM code/data should be mapped */
+	unsigned long gpa;
+
+	/* Size of the region */
+	unsigned long size;
+
+	/* Type of the region */
+	enum KVM_RISCV_COVE_REGION type;
+};
+
 /*
  * ISA extension IDs specific to KVM. This is not the same as the host ISA
  * extension IDs as that is internal to the host and should not be exposed
@@ -148,6 +171,9 @@ enum KVM_RISCV_SBI_EXT_ID {
 	KVM_RISCV_SBI_EXT_PMU,
 	KVM_RISCV_SBI_EXT_EXPERIMENTAL,
 	KVM_RISCV_SBI_EXT_VENDOR,
+	KVM_RISCV_SBI_EXT_DBCN,
+	KVM_RISCV_SBI_EXT_COVG,
+	KVM_RISCV_SBI_EXT_COVH,
 	KVM_RISCV_SBI_EXT_MAX,
 };
 
@@ -300,6 +326,10 @@ enum KVM_RISCV_SBI_EXT_ID {
 /* One single KVM irqchip, ie. the AIA */
 #define KVM_NR_IRQCHIPS			1
 
+/* run->fail_entry.hardware_entry_failure_reason codes. */
+#define KVM_EXIT_FAIL_ENTRY_IMSIC_FILE_UNAVAILABLE (1ULL << 0)
+#define KVM_EXIT_FAIL_ENTRY_COVE_RUN_VCPU          (1ULL << 1)
+
 #endif
 
 #endif /* __LINUX_KVM_RISCV_H */
diff --git a/arch/riscv/kernel/Makefile b/arch/riscv/kernel/Makefile
index 03968c06258c..7a1afa40c69e 100644
--- a/arch/riscv/kernel/Makefile
+++ b/arch/riscv/kernel/Makefile
@@ -59,6 +59,7 @@ obj-y	+= stacktrace.o
 obj-y	+= cacheinfo.o
 obj-y	+= patch.o
 obj-y	+= probes/
+obj-y	+= bus_error.o
 obj-$(CONFIG_MMU) += vdso.o vdso/
 
 obj-$(CONFIG_RISCV_M_MODE)	+= traps_misaligned.o
diff --git a/arch/riscv/kernel/bus_error.c b/arch/riscv/kernel/bus_error.c
new file mode 100644
index 000000000000..67ea83094fed
--- /dev/null
+++ b/arch/riscv/kernel/bus_error.c
@@ -0,0 +1,132 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * BUS error monitor of core driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: Yu Ning <ningyu@eswincomputing.com>
+ */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/interrupt.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+/**
+ * @brief Bus error unit register map
+ * 0x00 : cause of error event
+ * 0x08 : physical address of error event
+ * 0x10 : event enable mask
+ * 0x18 : platform-level interrupt enable mask
+ * 0x20 : accrued event mask
+ * 0x28 : hart-local interrupt enable mask
+ */
+
+struct bus_error_device {
+	struct device *dev;
+	void __iomem *control;
+	int plic_irq;
+};
+
+static irqreturn_t bus_error_handle(int irq, void *dev_id)
+{
+	struct bus_error_device *bus_err = dev_id;
+	void __iomem *base = bus_err->control;
+
+	printk(KERN_ERR "bus error of cause event: %d, accrued: 0x%x, physical address: 0x%llx\n",
+		readl(base),readl(base+0x20),readq(base+0x8));
+
+	/* clean interrupt */
+	writel(0,base);
+	writel(0,base+0x20);
+
+	return IRQ_HANDLED;
+}
+
+static const struct of_device_id eswin_bus_error_of_match[] = {
+	{.compatible = "sifive,buserror", },
+	{ /* sentinel */ }
+};
+
+static int  bus_error_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = pdev->dev.of_node;
+	struct bus_error_device *bus_err_dev;
+	int ret;
+	struct resource *res;
+
+	bus_err_dev = devm_kcalloc(dev, 1,
+		sizeof(struct bus_error_device), GFP_KERNEL);
+	if (!bus_err_dev)
+		return -ENOMEM;
+
+	bus_err_dev->dev = dev;
+	dev_set_drvdata(dev, bus_err_dev);
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Error while get mem resource\n");
+		return -ENODEV;
+	}
+	bus_err_dev->control = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR_OR_NULL(bus_err_dev->control)) {
+		dev_err(dev, "Fail to get resource %s from 0x%llx!\n",
+			node->name, res->start);
+		ret = -EINVAL;
+		goto free_bus_err_dev;
+	}
+	bus_err_dev->plic_irq = platform_get_irq(pdev, 0);
+	ret = devm_request_irq(dev, bus_err_dev->plic_irq, bus_error_handle,
+				IRQF_SHARED, dev_name(dev), bus_err_dev);
+	if (ret) {
+		dev_err(dev, "Fail to request irq %d \n",
+				(int)bus_err_dev->plic_irq);
+		return ret;
+	}
+
+	/* clean any interrupt before */
+	writel(0,bus_err_dev->control);
+	writel(0,bus_err_dev->control+0x20);
+
+	/* enable interrupt */
+	writel(0xee2,bus_err_dev->control+0x18);
+	writel(0xee2,bus_err_dev->control+0x10);
+	dev_dbg(dev, "Bus-err unit init OK\n");
+	return 0;
+
+free_bus_err_dev:
+	return ret;
+
+}
+
+static struct platform_driver bus_error_driver = {
+	.probe = bus_error_probe,
+	.driver = {
+		.name = "buserror",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(eswin_bus_error_of_match),},
+};
+
+static int __init init_bus_error_unit(void)
+{
+	return platform_driver_register(&bus_error_driver);
+}
+
+subsys_initcall(init_bus_error_unit);
diff --git a/arch/riscv/kernel/head.S b/arch/riscv/kernel/head.S
index 0097c145385f..39c2aa088141 100644
--- a/arch/riscv/kernel/head.S
+++ b/arch/riscv/kernel/head.S
@@ -199,6 +199,24 @@ ENTRY(_start_kernel)
 	csrw CSR_IE, zero
 	csrw CSR_IP, zero
 
+#if defined(CONFIG_RISCV_COVE_GUEST_PROMOTE) && !defined(CONFIG_RISCV_M_MODE)
+	mv s0, a0
+	mv s1, a1
+	/* Request hypervisor to promote to TVM */
+	li a7, 0x434F5648        /* SBI_EXT_COVH */
+	li a6, 0x7               /* SBI_EXT_COVH_PROMOTE_TO_TVM */
+	mv a0, a1                /* DTB physical address */
+#ifdef CONFIG_RISCV_COVE_GUEST_EMBEDDED_TAP
+	la a1, __cove_tap_start	 /* TAP physical address */
+#else
+	li a1, 0
+#endif /* CONFIG_RISCV_COVE_GUEST_EMBEDDED_TAP */
+	ecall
+	/* Attestation reflects the result of promotion, so ignore it */
+	mv a0, s0
+	mv a1, s1
+#endif /* CONFIG_RISCV_COVE_GUEST_PROMOTE */
+
 #ifdef CONFIG_RISCV_M_MODE
 	/* flush the instruction cache */
 	fence.i
diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index 9cc0a7669271..d21e4863355b 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -14,6 +14,8 @@
 #include <asm/smp.h>
 #include <asm/softirq_stack.h>
 #include <asm/stacktrace.h>
+#include <asm/covg_sbi.h>
+#include <asm/cove.h>
 
 static struct fwnode_handle *(*__get_intc_node)(void);
 
@@ -106,9 +108,20 @@ int arch_show_interrupts(struct seq_file *p, int prec)
 
 void __init init_IRQ(void)
 {
+	// ACE potential problem
 	init_irq_stacks();
+	int ret;
+
 	irqchip_init();
 	if (!handle_arch_irq)
 		panic("No interrupt controller found.");
 	sbi_ipi_init();
+
+	if (is_cove_guest()) {
+		/* FIXME: For now just allow all interrupts. */
+		ret = sbi_covg_allow_all_external_interrupt();
+
+		if (ret)
+			pr_err("Failed to allow external interrupts.\n");
+	}
 }
diff --git a/arch/riscv/kernel/sbi.c b/arch/riscv/kernel/sbi.c
index 5a62ed1da453..e66e0999a800 100644
--- a/arch/riscv/kernel/sbi.c
+++ b/arch/riscv/kernel/sbi.c
@@ -7,6 +7,7 @@
 
 #include <linux/bits.h>
 #include <linux/init.h>
+#include <linux/mm.h>
 #include <linux/pm.h>
 #include <linux/reboot.h>
 #include <asm/sbi.h>
@@ -571,6 +572,66 @@ long sbi_get_mimpid(void)
 }
 EXPORT_SYMBOL_GPL(sbi_get_mimpid);
 
+bool sbi_debug_console_available;
+
+int sbi_debug_console_write(const char *bytes, unsigned int num_bytes)
+{
+	phys_addr_t base_addr;
+	struct sbiret ret;
+
+	if (!sbi_debug_console_available)
+		return -EOPNOTSUPP;
+
+	if (is_vmalloc_addr(bytes))
+		base_addr = page_to_phys(vmalloc_to_page(bytes)) +
+			    offset_in_page(bytes);
+	else
+		base_addr = __pa(bytes);
+	if (PAGE_SIZE < (offset_in_page(bytes) + num_bytes))
+		num_bytes = PAGE_SIZE - offset_in_page(bytes);
+
+	if (IS_ENABLED(CONFIG_32BIT))
+		ret = sbi_ecall(SBI_EXT_DBCN, SBI_EXT_DBCN_CONSOLE_WRITE,
+				num_bytes, lower_32_bits(base_addr),
+				upper_32_bits(base_addr), 0, 0, 0);
+	else
+		ret = sbi_ecall(SBI_EXT_DBCN, SBI_EXT_DBCN_CONSOLE_WRITE,
+				num_bytes, base_addr, 0, 0, 0, 0);
+
+	if (ret.error == SBI_ERR_FAILURE)
+		return -EIO;
+	return ret.error ? sbi_err_map_linux_errno(ret.error) : ret.value;
+}
+
+int sbi_debug_console_read(char *bytes, unsigned int num_bytes)
+{
+	phys_addr_t base_addr;
+	struct sbiret ret;
+
+	if (!sbi_debug_console_available)
+		return -EOPNOTSUPP;
+
+	if (is_vmalloc_addr(bytes))
+		base_addr = page_to_phys(vmalloc_to_page(bytes)) +
+			    offset_in_page(bytes);
+	else
+		base_addr = __pa(bytes);
+	if (PAGE_SIZE < (offset_in_page(bytes) + num_bytes))
+		num_bytes = PAGE_SIZE - offset_in_page(bytes);
+
+	if (IS_ENABLED(CONFIG_32BIT))
+		ret = sbi_ecall(SBI_EXT_DBCN, SBI_EXT_DBCN_CONSOLE_READ,
+				num_bytes, lower_32_bits(base_addr),
+				upper_32_bits(base_addr), 0, 0, 0);
+	else
+		ret = sbi_ecall(SBI_EXT_DBCN, SBI_EXT_DBCN_CONSOLE_READ,
+				num_bytes, base_addr, 0, 0, 0, 0);
+
+	if (ret.error == SBI_ERR_FAILURE)
+		return -EIO;
+	return ret.error ? sbi_err_map_linux_errno(ret.error) : ret.value;
+}
+
 void __init sbi_init(void)
 {
 	int ret;
@@ -612,6 +673,11 @@ void __init sbi_init(void)
 			sbi_srst_reboot_nb.priority = 192;
 			register_restart_handler(&sbi_srst_reboot_nb);
 		}
+		if ((sbi_spec_version >= sbi_mk_version(2, 0)) &&
+		    (sbi_probe_extension(SBI_EXT_DBCN) > 0)) {
+			pr_info("SBI DBCN extension detected\n");
+			sbi_debug_console_available = true;
+		}
 	} else {
 		__sbi_set_timer = __sbi_set_timer_v01;
 		__sbi_send_ipi	= __sbi_send_ipi_v01;
diff --git a/arch/riscv/kernel/setup.c b/arch/riscv/kernel/setup.c
index aac853ae4eb7..532c69c0ec89 100644
--- a/arch/riscv/kernel/setup.c
+++ b/arch/riscv/kernel/setup.c
@@ -37,6 +37,7 @@
 #include <asm/thread_info.h>
 #include <asm/kasan.h>
 #include <asm/efi.h>
+#include <asm/cove.h>
 
 #include "head.h"
 
@@ -268,6 +269,7 @@ void __init setup_arch(char **cmdline_p)
 
 	early_ioremap_setup();
 	sbi_init();
+	riscv_cove_sbi_init();
 	jump_label_init();
 	parse_early_param();
 
diff --git a/arch/riscv/kernel/vmlinux.lds.S b/arch/riscv/kernel/vmlinux.lds.S
index 002ca58dd998..4939f247ea8d 100644
--- a/arch/riscv/kernel/vmlinux.lds.S
+++ b/arch/riscv/kernel/vmlinux.lds.S
@@ -119,6 +119,18 @@ SECTIONS
 	}
 	__init_end = .;
 
+#ifdef CONFIG_RISCV_COVE_GUEST_EMBEDDED_TAP
+	. = ALIGN(4096);
+	.cove_tvm_attestation_payload : {
+		__cove_tap_start =  .;
+		LONG(0xace0ace0)
+		SHORT(0x0FFA)
+		FILL(0x00)
+		. += 4090;
+		__cove_tap_end =  .;
+	}
+#endif
+
 	/* Start of data section */
 	_sdata = .;
 	RO_DATA(SECTION_ALIGN)
diff --git a/arch/riscv/kvm/Makefile b/arch/riscv/kvm/Makefile
index 4c2067fc59fc..0076b50cfdec 100644
--- a/arch/riscv/kvm/Makefile
+++ b/arch/riscv/kvm/Makefile
@@ -14,6 +14,7 @@ kvm-y += vm.o
 kvm-y += vmid.o
 kvm-y += tlb.o
 kvm-y += mmu.o
+kvm-y += nacl.o
 kvm-y += vcpu.o
 kvm-y += vcpu_exit.o
 kvm-y += vcpu_fp.o
@@ -32,3 +33,4 @@ kvm-y += aia.o
 kvm-y += aia_device.o
 kvm-y += aia_aplic.o
 kvm-y += aia_imsic.o
+kvm-$(CONFIG_RISCV_COVE_HOST) += cove_sbi.o cove.o vcpu_sbi_covg.o vcpu_sbi_covh.o
diff --git a/arch/riscv/kvm/aia.c b/arch/riscv/kvm/aia.c
index 74bb27440527..6bebf5ee9ff0 100644
--- a/arch/riscv/kvm/aia.c
+++ b/arch/riscv/kvm/aia.c
@@ -16,10 +16,13 @@
 #include <linux/spinlock.h>
 #include <asm/hwcap.h>
 #include <asm/kvm_aia_imsic.h>
+#include <asm/kvm_cove.h>
 
 struct aia_hgei_control {
 	raw_spinlock_t lock;
 	unsigned long free_bitmap;
+	/* Tracks if a hgei is converted to confidential mode */
+	unsigned long nconf_bitmap;
 	struct kvm_vcpu *owners[BITS_PER_LONG];
 };
 static DEFINE_PER_CPU(struct aia_hgei_control, aia_hgei);
@@ -137,7 +140,7 @@ void kvm_riscv_vcpu_aia_load(struct kvm_vcpu *vcpu, int cpu)
 {
 	struct kvm_vcpu_aia_csr *csr = &vcpu->arch.aia_context.guest_csr;
 
-	if (!kvm_riscv_aia_available())
+	if (!kvm_riscv_aia_available() || is_cove_vcpu(vcpu))
 		return;
 
 	csr_write(CSR_VSISELECT, csr->vsiselect);
@@ -155,7 +158,7 @@ void kvm_riscv_vcpu_aia_put(struct kvm_vcpu *vcpu)
 {
 	struct kvm_vcpu_aia_csr *csr = &vcpu->arch.aia_context.guest_csr;
 
-	if (!kvm_riscv_aia_available())
+	if (!kvm_riscv_aia_available() || is_cove_vcpu(vcpu))
 		return;
 
 	csr->vsiselect = csr_read(CSR_VSISELECT);
@@ -376,6 +379,10 @@ int kvm_riscv_vcpu_aia_rmw_ireg(struct kvm_vcpu *vcpu, unsigned int csr_num,
 	if (!kvm_riscv_aia_available())
 		return KVM_INSN_ILLEGAL_TRAP;
 
+	/* TVMs do not support AIA emulation */
+	if (is_cove_vcpu(vcpu))
+		return KVM_INSN_EXIT_TO_USER_SPACE;
+
 	/* First try to emulate in kernel space */
 	isel = csr_read(CSR_VSISELECT) & ISELECT_MASK;
 	if (isel >= ISELECT_IPRIO0 && isel <= ISELECT_IPRIO15)
@@ -392,30 +399,98 @@ int kvm_riscv_vcpu_aia_rmw_ireg(struct kvm_vcpu *vcpu, unsigned int csr_num,
 int kvm_riscv_aia_alloc_hgei(int cpu, struct kvm_vcpu *owner,
 			     void __iomem **hgei_va, phys_addr_t *hgei_pa)
 {
-	int ret = -ENOENT;
-	unsigned long flags;
+	int ret = -ENOENT, rc;
+	bool reclaim_needed = false;
+	unsigned long flags, tmp_bitmap;
+	const struct imsic_local_config *lc;
 	struct aia_hgei_control *hgctrl = per_cpu_ptr(&aia_hgei, cpu);
-
-	if (!kvm_riscv_aia_available() || !hgctrl)
-		return -ENODEV;
-
-	raw_spin_lock_irqsave(&hgctrl->lock, flags);
-
-	if (hgctrl->free_bitmap) {
-		ret = __ffs(hgctrl->free_bitmap);
-		hgctrl->free_bitmap &= ~BIT(ret);
-		hgctrl->owners[ret] = owner;
-	}
-
-	raw_spin_unlock_irqrestore(&hgctrl->lock, flags);
-
-	/* TODO: To be updated later by AIA IMSIC HW guest file support */
-	if (hgei_va)
-		*hgei_va = NULL;
-	if (hgei_pa)
-		*hgei_pa = 0;
-
-	return ret;
+	phys_addr_t imsic_hgei_pa;
+
+	printk("ACE merge problem");
+	return -ENODEV;
+
+// 	if (!kvm_riscv_aia_available() || !hgctrl)
+// 		return -ENODEV;
+
+// 	lc = imsic_get_local_config(cpu);
+// 	raw_spin_lock_irqsave(&hgctrl->lock, flags);
+
+// 	if (!hgctrl->free_bitmap) {
+// 		raw_spin_unlock_irqrestore(&hgctrl->lock, flags);
+// 		goto done;
+// 	}
+
+// 	if (!is_cove_vcpu(owner)) {
+// 		/* Find a free one that is not converted */
+// 		tmp_bitmap = hgctrl->free_bitmap & hgctrl->nconf_bitmap;
+// 		if (tmp_bitmap > 0)
+// 			ret = __ffs(tmp_bitmap);
+// 		else {
+// 			/* All free ones have been converted in the past. Reclaim one now */
+// 			ret = __ffs(hgctrl->free_bitmap);
+// 			reclaim_needed = true;
+// 		}
+// 	} else {
+// 		/* First try to find a free one that is already converted */
+// 		tmp_bitmap = hgctrl->free_bitmap & !hgctrl->nconf_bitmap;
+// 		if (tmp_bitmap > 0)
+// 			ret = __ffs(tmp_bitmap);
+// 		else
+// 			ret = __ffs(hgctrl->free_bitmap);
+// 	}
+
+// 	hgctrl->free_bitmap &= ~BIT(ret);
+// 	hgctrl->owners[ret] = owner;
+// 	raw_spin_unlock_irqrestore(&hgctrl->lock, flags);
+
+// 	if (lc && ret > 0) {
+// 		if (hgei_va)
+// 			*hgei_va = lc->msi_va + (ret * IMSIC_MMIO_PAGE_SZ);
+// 		imsic_hgei_pa = lc->msi_pa + (ret * IMSIC_MMIO_PAGE_SZ);
+
+// 		if (reclaim_needed) {
+// 			rc = kvm_riscv_cove_aia_claim_imsic(owner, imsic_hgei_pa);
+// 			if (rc) {
+// 				kvm_err("Reclaim of imsic pa %pa failed for vcpu %d pcpu %d ret %d\n",
+// 					&imsic_hgei_pa, owner->vcpu_idx, smp_processor_id(), ret);
+// 				kvm_riscv_aia_free_hgei(cpu, ret);
+// 				return rc;
+// 			}
+// 		}
+
+// 		/*
+// 		 * Clear the free_bitmap here instead in case relcaim was necessary.
+// 		 * Do it here instead of above because it we should only set the nconf
+// 		 * bitmap after the claim is successful.
+// 		 */
+// 		raw_spin_lock_irqsave(&hgctrl->lock, flags);
+// 		if (reclaim_needed)
+// 			set_bit(ret, &hgctrl->nconf_bitmap);
+// 		raw_spin_unlock_irqrestore(&hgctrl->lock, flags);
+
+// 		if (is_cove_vcpu(owner) && test_bit(ret, &hgctrl->nconf_bitmap)) {
+// 			/*
+// 			 * Convert the address to confidential mode.
+// 			 * This may need to send IPIs to issue global fence. Hence,
+// 			 * enable interrupts temporarily for irq processing
+// 			 */
+// 			rc = kvm_riscv_cove_aia_convert_imsic(owner, imsic_hgei_pa);
+
+// 			if (rc) {
+// 				kvm_riscv_aia_free_hgei(cpu, ret);
+// 				ret = rc;
+// 			} else {
+// 				raw_spin_lock_irqsave(&hgctrl->lock, flags);
+// 				clear_bit(ret, &hgctrl->nconf_bitmap);
+// 				raw_spin_unlock_irqrestore(&hgctrl->lock, flags);
+// 			}
+// 		}
+// 	}
+
+// 	if (hgei_pa)
+// 		*hgei_pa = imsic_hgei_pa;
+// done:
+// 	return ret;
 }
 
 void kvm_riscv_aia_free_hgei(int cpu, int hgei)
@@ -492,6 +567,8 @@ static int aia_hgei_init(void)
 			hgctrl->free_bitmap &= ~BIT(0);
 		} else
 			hgctrl->free_bitmap = 0;
+		/* By default all vsfiles are to be used for non-confidential mode */
+		hgctrl->nconf_bitmap = hgctrl->free_bitmap;
 	}
 
 	/* Find INTC irq domain */
@@ -531,6 +608,9 @@ void kvm_riscv_aia_enable(void)
 	if (!kvm_riscv_aia_available())
 		return;
 
+	if (unlikely(kvm_riscv_cove_enabled()))
+		goto enable_gext;
+
 	aia_set_hvictl(false);
 	csr_write(CSR_HVIPRIO1, 0x0);
 	csr_write(CSR_HVIPRIO2, 0x0);
@@ -541,6 +621,7 @@ void kvm_riscv_aia_enable(void)
 	csr_write(CSR_HVIPRIO2H, 0x0);
 #endif
 
+enable_gext:
 	/* Enable per-CPU SGEI interrupt */
 	enable_percpu_irq(hgei_parent_irq,
 			  irq_get_trigger_type(hgei_parent_irq));
@@ -562,7 +643,9 @@ void kvm_riscv_aia_disable(void)
 	csr_clear(CSR_HIE, BIT(IRQ_S_GEXT));
 	disable_percpu_irq(hgei_parent_irq);
 
-	aia_set_hvictl(false);
+	/* The host is not allowed modify hvictl for TVMs */
+	if (!unlikely(kvm_riscv_cove_enabled()))
+		aia_set_hvictl(false);
 
 	raw_spin_lock_irqsave(&hgctrl->lock, flags);
 
@@ -601,8 +684,9 @@ int kvm_riscv_aia_init(void)
 {
 	int rc;
 
-	if (!riscv_isa_extension_available(NULL, SxAIA))
-		return -ENODEV;
+	return -ENODEV;
+	// if (!riscv_isa_extension_available(NULL, SxAIA))
+	// 	return -ENODEV;
 
 	/* Figure-out number of bits in HGEIE */
 	csr_write(CSR_HGEIE, -1UL);
diff --git a/arch/riscv/kvm/aia_device.c b/arch/riscv/kvm/aia_device.c
index 0eb689351b7d..17a49b4637f6 100644
--- a/arch/riscv/kvm/aia_device.c
+++ b/arch/riscv/kvm/aia_device.c
@@ -11,6 +11,7 @@
 #include <linux/kvm_host.h>
 #include <linux/uaccess.h>
 #include <asm/kvm_aia_imsic.h>
+#include <asm/kvm_cove.h>
 
 static void unlock_vcpus(struct kvm *kvm, int vcpu_lock_idx)
 {
@@ -102,7 +103,11 @@ static int aia_config(struct kvm *kvm, unsigned long type,
 				break;
 			default:
 				return -EINVAL;
-			}
+			};
+			/* TVM must have a physical vs file */
+			if (is_cove_vm(kvm) && *nr != KVM_DEV_RISCV_AIA_MODE_HWACCEL)
+				return -EINVAL;
+
 			aia->mode = *nr;
 		} else
 			*nr = aia->mode;
@@ -265,18 +270,23 @@ static int aia_init(struct kvm *kvm)
 	if (kvm->created_vcpus != atomic_read(&kvm->online_vcpus))
 		return -EBUSY;
 
-	/* Number of sources should be less than or equals number of IDs */
-	if (aia->nr_ids < aia->nr_sources)
-		return -EINVAL;
-
-	/* APLIC base is required for non-zero number of sources */
-	if (aia->nr_sources && aia->aplic_addr == KVM_RISCV_AIA_UNDEF_ADDR)
-		return -EINVAL;
+	if (!is_cove_vm(kvm)) {
+		/* Number of sources should be less than or equals number of IDs */
+		if (aia->nr_ids < aia->nr_sources)
+			return -EINVAL;
+		/* APLIC base is required for non-zero number of sources only for non TVMs*/
+		if (aia->nr_sources && aia->aplic_addr == KVM_RISCV_AIA_UNDEF_ADDR)
+			return -EINVAL;
 
-	/* Initialize APLIC */
-	ret = kvm_riscv_aia_aplic_init(kvm);
-	if (ret)
-		return ret;
+		/* Initialize APLIC */
+		ret = kvm_riscv_aia_aplic_init(kvm);
+		if (ret)
+			return ret;
+	} else {
+		ret = kvm_riscv_cove_aia_init(kvm);
+		if (ret)
+			return ret;
+	}
 
 	/* Iterate over each VCPU */
 	kvm_for_each_vcpu(idx, vcpu, kvm) {
@@ -651,8 +661,14 @@ void kvm_riscv_aia_init_vm(struct kvm *kvm)
 	 */
 
 	/* Initialize default values in AIA global context */
-	aia->mode = (kvm_riscv_aia_nr_hgei) ?
-		KVM_DEV_RISCV_AIA_MODE_AUTO : KVM_DEV_RISCV_AIA_MODE_EMUL;
+	if (is_cove_vm(kvm)) {
+		if (!kvm_riscv_aia_nr_hgei)
+			return;
+		aia->mode = KVM_DEV_RISCV_AIA_MODE_HWACCEL;
+	} else {
+		aia->mode = (kvm_riscv_aia_nr_hgei) ?
+			KVM_DEV_RISCV_AIA_MODE_AUTO : KVM_DEV_RISCV_AIA_MODE_EMUL;
+	}
 	aia->nr_ids = kvm_riscv_aia_max_ids - 1;
 	aia->nr_sources = 0;
 	aia->nr_group_bits = 0;
diff --git a/arch/riscv/kvm/aia_imsic.c b/arch/riscv/kvm/aia_imsic.c
index e808723a85f1..4bf1b217e7a0 100644
--- a/arch/riscv/kvm/aia_imsic.c
+++ b/arch/riscv/kvm/aia_imsic.c
@@ -16,6 +16,7 @@
 #include <kvm/iodev.h>
 #include <asm/csr.h>
 #include <asm/kvm_aia_imsic.h>
+#include <asm/kvm_cove.h>
 
 #define IMSIC_MAX_EIX	(IMSIC_MAX_ID / BITS_PER_TYPE(u64))
 
@@ -585,7 +586,7 @@ static void imsic_vsfile_local_update(int vsfile_hgei, u32 nr_eix,
 	csr_write(CSR_VSISELECT, old_vsiselect);
 }
 
-static void imsic_vsfile_cleanup(struct imsic *imsic)
+static void imsic_vsfile_cleanup(struct kvm_vcpu *vcpu, struct imsic *imsic)
 {
 	int old_vsfile_hgei, old_vsfile_cpu;
 	unsigned long flags;
@@ -606,8 +607,12 @@ static void imsic_vsfile_cleanup(struct imsic *imsic)
 
 	memset(imsic->swfile, 0, sizeof(*imsic->swfile));
 
-	if (old_vsfile_cpu >= 0)
+	if (old_vsfile_cpu >= 0) {
+		if (is_cove_vcpu(vcpu))
+			kvm_riscv_cove_vcpu_imsic_unbind(vcpu, old_vsfile_cpu);
+
 		kvm_riscv_aia_free_hgei(old_vsfile_cpu, old_vsfile_hgei);
+	}
 }
 
 static void imsic_swfile_extirq_update(struct kvm_vcpu *vcpu)
@@ -701,27 +706,30 @@ void kvm_riscv_vcpu_aia_imsic_release(struct kvm_vcpu *vcpu)
 	 * the old IMSIC VS-file so we first re-direct all interrupt
 	 * producers.
 	 */
+	if (!is_cove_vcpu(vcpu)) {
+		/* Purge the G-stage mapping */
+		kvm_riscv_gstage_iounmap(vcpu->kvm,
+					 vcpu->arch.aia_context.imsic_addr,
+					 IMSIC_MMIO_PAGE_SZ);
 
-	/* Purge the G-stage mapping */
-	kvm_riscv_gstage_iounmap(vcpu->kvm,
-				 vcpu->arch.aia_context.imsic_addr,
-				 IMSIC_MMIO_PAGE_SZ);
-
-	/* TODO: Purge the IOMMU mapping ??? */
+		/* TODO: Purge the IOMMU mapping ??? */
 
-	/*
-	 * At this point, all interrupt producers have been re-directed
-	 * to somewhere else so we move register state from the old IMSIC
-	 * VS-file to the IMSIC SW-file.
-	 */
+		/*
+		 * At this point, all interrupt producers have been re-directed
+		 * to somewhere else so we move register state from the old IMSIC
+		 * VS-file to the IMSIC SW-file.
+		 */
 
-	/* Read and clear register state from old IMSIC VS-file */
-	memset(&tmrif, 0, sizeof(tmrif));
-	imsic_vsfile_read(old_vsfile_hgei, old_vsfile_cpu, imsic->nr_hw_eix,
-			  true, &tmrif);
+		/* Read and clear register state from old IMSIC VS-file */
+		memset(&tmrif, 0, sizeof(tmrif));
+		imsic_vsfile_read(old_vsfile_hgei, old_vsfile_cpu, imsic->nr_hw_eix,
+				  true, &tmrif);
 
-	/* Update register state in IMSIC SW-file */
-	imsic_swfile_update(vcpu, &tmrif);
+		/* Update register state in IMSIC SW-file */
+		imsic_swfile_update(vcpu, &tmrif);
+	} else {
+		kvm_riscv_cove_vcpu_imsic_unbind(vcpu, old_vsfile_cpu);
+	}
 
 	/* Free-up old IMSIC VS-file */
 	kvm_riscv_aia_free_hgei(old_vsfile_cpu, old_vsfile_hgei);
@@ -760,7 +768,7 @@ int kvm_riscv_vcpu_aia_imsic_update(struct kvm_vcpu *vcpu)
 		/* For HW acceleration mode, we can't continue */
 		if (kvm->arch.aia.mode == KVM_DEV_RISCV_AIA_MODE_HWACCEL) {
 			run->fail_entry.hardware_entry_failure_reason =
-								CSR_HSTATUS;
+					KVM_EXIT_FAIL_ENTRY_IMSIC_FILE_UNAVAILABLE;
 			run->fail_entry.cpu = vcpu->cpu;
 			run->exit_reason = KVM_EXIT_FAIL_ENTRY;
 			return 0;
@@ -775,22 +783,24 @@ int kvm_riscv_vcpu_aia_imsic_update(struct kvm_vcpu *vcpu)
 	}
 	new_vsfile_hgei = ret;
 
-	/*
-	 * At this point, all interrupt producers are still using
-	 * to the old IMSIC VS-file so we first move all interrupt
-	 * producers to the new IMSIC VS-file.
-	 */
-
-	/* Zero-out new IMSIC VS-file */
-	imsic_vsfile_local_clear(new_vsfile_hgei, imsic->nr_hw_eix);
-
-	/* Update G-stage mapping for the new IMSIC VS-file */
-	ret = kvm_riscv_gstage_ioremap(kvm, vcpu->arch.aia_context.imsic_addr,
-				       new_vsfile_pa, IMSIC_MMIO_PAGE_SZ,
-				       true, true);
-	if (ret)
-		goto fail_free_vsfile_hgei;
-
+	/* TSM only maintains the gstage mapping. Skip vsfile updates & ioremap */
+	if (!is_cove_vcpu(vcpu)) {
+		/*
+		 * At this point, all interrupt producers are still using
+		 * to the old IMSIC VS-file so we first move all interrupt
+		 * producers to the new IMSIC VS-file.
+		 */
+
+		/* Zero-out new IMSIC VS-file */
+		imsic_vsfile_local_clear(new_vsfile_hgei, imsic->nr_hw_eix);
+
+		/* Update G-stage mapping for the new IMSIC VS-file */
+		ret = kvm_riscv_gstage_ioremap(kvm, vcpu->arch.aia_context.imsic_addr,
+					       new_vsfile_pa, IMSIC_MMIO_PAGE_SZ,
+					       true, true);
+		if (ret)
+			goto fail_free_vsfile_hgei;
+	}
 	/* TODO: Update the IOMMU mapping ??? */
 
 	/* Update new IMSIC VS-file details in IMSIC context */
@@ -801,12 +811,32 @@ int kvm_riscv_vcpu_aia_imsic_update(struct kvm_vcpu *vcpu)
 	imsic->vsfile_pa = new_vsfile_pa;
 	write_unlock_irqrestore(&imsic->vsfile_lock, flags);
 
+	/* Now bind the new vsfile for the TVMs */
+	if (is_cove_vcpu(vcpu) && vcpu->arch.tc) {
+		vcpu->arch.tc->imsic.vsfile_hgei = new_vsfile_hgei;
+		if (old_vsfile_cpu >= 0) {
+			if (vcpu->arch.tc->imsic.bound) {
+				ret = kvm_riscv_cove_vcpu_imsic_rebind(vcpu, old_vsfile_cpu);
+				if (ret) {
+					kvm_err("imsic rebind failed for vcpu %d ret %d\n",
+						 vcpu->vcpu_idx, ret);
+					goto fail_free_vsfile_hgei;
+				}
+			}
+			kvm_riscv_aia_free_hgei(old_vsfile_cpu, old_vsfile_hgei);
+		} else {
+			/* Bind if it is not a migration case */
+			vcpu->arch.tc->imsic.bind_required = true;
+		}
+		/* Skip the oldvsfile and swfile update process as it is managed by TSM */
+		goto done;
+	}
+
 	/*
 	 * At this point, all interrupt producers have been moved
 	 * to the new IMSIC VS-file so we move register state from
 	 * the old IMSIC VS/SW-file to the new IMSIC VS-file.
 	 */
-
 	memset(&tmrif, 0, sizeof(tmrif));
 	if (old_vsfile_cpu >= 0) {
 		/* Read and clear register state from old IMSIC VS-file */
@@ -959,6 +989,7 @@ int kvm_riscv_vcpu_aia_imsic_inject(struct kvm_vcpu *vcpu,
 	unsigned long flags;
 	struct imsic_mrif_eix *eix;
 	struct imsic *imsic = vcpu->arch.aia_context.imsic_state;
+	int ret;
 
 	/* We only emulate one IMSIC MMIO page for each Guest VCPU */
 	if (!imsic || !iid || guest_index ||
@@ -973,7 +1004,14 @@ int kvm_riscv_vcpu_aia_imsic_inject(struct kvm_vcpu *vcpu,
 	read_lock_irqsave(&imsic->vsfile_lock, flags);
 
 	if (imsic->vsfile_cpu >= 0) {
-		writel(iid, imsic->vsfile_va + IMSIC_MMIO_SETIPNUM_LE);
+		/* TSM can only inject the external interrupt if it is allowed by the guest */
+		if (is_cove_vcpu(vcpu)) {
+			ret = kvm_riscv_cove_vcpu_inject_interrupt(vcpu, iid);
+			if (ret)
+				kvm_err("External interrupt %d injection failed\n", iid);
+		} else {
+			writel(iid, imsic->vsfile_va + IMSIC_MMIO_SETIPNUM_LE);
+		}
 		kvm_vcpu_kick(vcpu);
 	} else {
 		eix = &imsic->swfile->eix[iid / BITS_PER_TYPE(u64)];
@@ -1053,6 +1091,17 @@ int kvm_riscv_vcpu_aia_imsic_init(struct kvm_vcpu *vcpu)
 	imsic->swfile_pa = page_to_phys(swfile_page);
 	spin_lock_init(&imsic->swfile_extirq_lock);
 
+	/* No need to setup iodev ops for TVMs. Swfile will also not be used for
+	 * TVMs. However, allocate it for now as to avoid different path during
+	 * free.
+	 */
+	if (is_cove_vcpu(vcpu)) {
+		ret = kvm_riscv_cove_vcpu_imsic_addr(vcpu);
+		if (ret)
+			goto fail_free_swfile;
+		return 0;
+	}
+
 	/* Setup IO device */
 	kvm_iodevice_init(&imsic->iodev, &imsic_iodoev_ops);
 	mutex_lock(&kvm->slots_lock);
@@ -1083,7 +1132,7 @@ void kvm_riscv_vcpu_aia_imsic_cleanup(struct kvm_vcpu *vcpu)
 	if (!imsic)
 		return;
 
-	imsic_vsfile_cleanup(imsic);
+	imsic_vsfile_cleanup(vcpu, imsic);
 
 	mutex_lock(&kvm->slots_lock);
 	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &imsic->iodev);
diff --git a/arch/riscv/kvm/cove.c b/arch/riscv/kvm/cove.c
new file mode 100644
index 000000000000..e21c15cc3f91
--- /dev/null
+++ b/arch/riscv/kvm/cove.c
@@ -0,0 +1,1084 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * COVE related helper functions.
+ *
+ * Copyright (c) 2023 RivosInc
+ *
+ * Authors:
+ *     Atish Patra <atishp@rivosinc.com>
+ */
+
+#include <linux/cpumask.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/kvm_host.h>
+#include <linux/smp.h>
+#include <asm/csr.h>
+#include <asm/sbi.h>
+#include <asm/kvm_nacl.h>
+#include <asm/kvm_cove.h>
+#include <asm/kvm_cove_sbi.h>
+#include <asm/asm-offsets.h>
+
+static struct sbi_cove_tsm_info tinfo;
+struct sbi_cove_tvm_create_params params;
+
+/* We need a global lock as initiate fence can be invoked once per host */
+static DEFINE_SPINLOCK(cove_fence_lock);
+
+static bool riscv_cove_enabled;
+
+static inline bool cove_is_within_region(unsigned long addr1, unsigned long size1,
+				       unsigned long addr2, unsigned long size2)
+{
+	return ((addr1 <= addr2) && ((addr1 + size1) >= (addr2 + size2)));
+}
+
+static void kvm_cove_local_fence(void *info)
+{
+	int rc;
+
+	rc = sbi_covh_tsm_local_fence();
+
+	if (rc)
+		kvm_err("local fence for TSM failed %d on cpu %d\n", rc, smp_processor_id());
+}
+
+static void cove_delete_shared_pinned_page_list(struct kvm *kvm,
+						struct list_head *tpages)
+{
+	struct kvm_riscv_cove_page *tpage, *temp;
+
+	list_for_each_entry_safe(tpage, temp, tpages, link) {
+		unpin_user_pages_dirty_lock(&tpage->page, 1, true);
+		list_del(&tpage->link);
+		kfree(tpage);
+	}
+}
+
+static void cove_delete_page_list(struct kvm *kvm, struct list_head *tpages, bool unpin)
+{
+	struct kvm_riscv_cove_page *tpage, *temp;
+	int rc;
+
+	list_for_each_entry_safe(tpage, temp, tpages, link) {
+		rc = sbi_covh_tsm_reclaim_pages(page_to_phys(tpage->page), tpage->npages);
+		if (rc)
+			kvm_err("Reclaiming page %llx failed\n", page_to_phys(tpage->page));
+		if (unpin)
+			unpin_user_pages_dirty_lock(&tpage->page, 1, true);
+		list_del(&tpage->link);
+		kfree(tpage);
+	}
+}
+
+static int kvm_riscv_cove_fence(void)
+{
+	int rc;
+
+	spin_lock(&cove_fence_lock);
+
+	rc = sbi_covh_tsm_initiate_fence();
+	if (rc) {
+		kvm_err("initiate fence for tsm failed %d\n", rc);
+		goto done;
+	}
+
+	/* initiate local fence on each online hart */
+	on_each_cpu(kvm_cove_local_fence, NULL, 1);
+done:
+	spin_unlock(&cove_fence_lock);
+	return rc;
+}
+
+int kvm_riscv_cove_tvm_fence(struct kvm_vcpu *vcpu)
+{
+	struct kvm *kvm = vcpu->kvm;
+	struct kvm_cove_tvm_context *tvmc = kvm->arch.tvmc;
+	DECLARE_BITMAP(vcpu_mask, KVM_MAX_VCPUS);
+	unsigned long i;
+	struct kvm_vcpu *temp_vcpu;
+	int ret;
+
+	if (!tvmc)
+		return -EINVAL;
+
+	spin_lock(&tvmc->tvm_fence_lock);
+	ret = sbi_covh_tvm_initiate_fence(tvmc->tvm_guest_id);
+	if (ret) {
+		spin_unlock(&tvmc->tvm_fence_lock);
+		return ret;
+	}
+
+	bitmap_clear(vcpu_mask, 0, KVM_MAX_VCPUS);
+	kvm_for_each_vcpu(i, temp_vcpu, kvm) {
+		if (temp_vcpu != vcpu)
+			bitmap_set(vcpu_mask, i, 1);
+	}
+
+	/*
+	 * The host just needs to make sure that the running vcpus exit the
+	 * guest mode and traps into TSM so that it can issue hfence.
+	 */
+	kvm_make_vcpus_request_mask(kvm, KVM_REQ_OUTSIDE_GUEST_MODE, vcpu_mask);
+	spin_unlock(&tvmc->tvm_fence_lock);
+
+	return 0;
+}
+
+
+static int cove_convert_pages(unsigned long phys_addr, unsigned long npages, bool fence)
+{
+	int rc;
+
+	if (!IS_ALIGNED(phys_addr, PAGE_SIZE))
+		return -EINVAL;
+
+	if (!kvm_riscv_cove_capability(KVM_COVE_TSM_CAP_MEMORY_ALLOCATION)) {
+		return -EOPNOTSUPP;
+	}
+
+	rc = sbi_covh_tsm_convert_pages(phys_addr, npages);
+	if (rc)
+		return rc;
+
+	/* Conversion was successful. Flush the TLB if caller requested */
+	if (fence)
+		rc = kvm_riscv_cove_fence();
+
+	return rc;
+}
+
+__always_inline bool kvm_riscv_cove_enabled(void)
+{
+	return riscv_cove_enabled;
+}
+
+__always_inline bool kvm_riscv_cove_capability(unsigned long cap)
+{
+	return tinfo.capabilities & BIT(cap);
+}
+
+static void kvm_cove_imsic_clone(void *info)
+{
+	int rc;
+	struct kvm_vcpu *vcpu = info;
+	struct kvm *kvm = vcpu->kvm;
+
+	rc = sbi_covi_rebind_vcpu_imsic_clone(kvm->arch.tvmc->tvm_guest_id, vcpu->vcpu_idx);
+	if (rc)
+		kvm_err("Imsic clone failed guest %ld vcpu %d pcpu %d\n",
+			 kvm->arch.tvmc->tvm_guest_id, vcpu->vcpu_idx, smp_processor_id());
+}
+
+static void kvm_cove_imsic_unbind(void *info)
+{
+	struct kvm_vcpu *vcpu = info;
+	struct kvm_cove_tvm_context *tvmc = vcpu->kvm->arch.tvmc;
+
+	/*TODO: We probably want to return but the remote function call doesn't allow any return */
+	if (sbi_covi_unbind_vcpu_imsic_begin(tvmc->tvm_guest_id, vcpu->vcpu_idx))
+		return;
+
+	/* This may issue IPIs to running vcpus. */
+	if (kvm_riscv_cove_tvm_fence(vcpu))
+		return;
+
+	if (sbi_covi_unbind_vcpu_imsic_end(tvmc->tvm_guest_id, vcpu->vcpu_idx))
+		return;
+
+	kvm_info("Unbind success for guest %ld vcpu %d pcpu %d\n",
+		  tvmc->tvm_guest_id, smp_processor_id(), vcpu->vcpu_idx);
+}
+
+int kvm_riscv_cove_vcpu_imsic_addr(struct kvm_vcpu *vcpu)
+{
+	struct kvm_cove_tvm_context *tvmc;
+	struct kvm *kvm = vcpu->kvm;
+	struct kvm_vcpu_aia *vaia = &vcpu->arch.aia_context;
+	int ret;
+
+	if (!kvm->arch.tvmc)
+		return -EINVAL;
+
+	tvmc = kvm->arch.tvmc;
+
+	ret = sbi_covi_set_vcpu_imsic_addr(tvmc->tvm_guest_id, vcpu->vcpu_idx, vaia->imsic_addr);
+	if (ret)
+		return -EPERM;
+
+	return 0;
+}
+
+int kvm_riscv_cove_aia_convert_imsic(struct kvm_vcpu *vcpu, phys_addr_t imsic_pa)
+{
+	struct kvm *kvm = vcpu->kvm;
+	int ret;
+
+	if (!kvm->arch.tvmc)
+		return -EINVAL;
+
+	ret = sbi_covi_convert_imsic(imsic_pa);
+	if (ret)
+		return -EPERM;
+
+	ret = kvm_riscv_cove_fence();
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+int kvm_riscv_cove_aia_claim_imsic(struct kvm_vcpu *vcpu, phys_addr_t imsic_pa)
+{
+	int ret;
+	struct kvm *kvm = vcpu->kvm;
+
+	if (!kvm->arch.tvmc)
+		return -EINVAL;
+
+	ret = sbi_covi_reclaim_imsic(imsic_pa);
+	if (ret)
+		return -EPERM;
+
+	return 0;
+}
+
+int kvm_riscv_cove_vcpu_imsic_rebind(struct kvm_vcpu *vcpu, int old_pcpu)
+{
+	struct kvm_cove_tvm_context *tvmc;
+	struct kvm *kvm = vcpu->kvm;
+	struct kvm_cove_tvm_vcpu_context *tvcpu = vcpu->arch.tc;
+	int ret;
+	cpumask_t tmpmask;
+
+	if (!kvm->arch.tvmc)
+		return -EINVAL;
+
+	tvmc = kvm->arch.tvmc;
+
+	ret = sbi_covi_rebind_vcpu_imsic_begin(tvmc->tvm_guest_id, vcpu->vcpu_idx,
+					       BIT(tvcpu->imsic.vsfile_hgei));
+	if (ret) {
+		kvm_err("Imsic rebind begin failed guest %ld vcpu %d pcpu %d\n",
+			 tvmc->tvm_guest_id, vcpu->vcpu_idx, smp_processor_id());
+		return ret;
+	}
+
+	ret = kvm_riscv_cove_tvm_fence(vcpu);
+	if (ret)
+		return ret;
+
+	cpumask_clear(&tmpmask);
+	cpumask_set_cpu(old_pcpu, &tmpmask);
+	on_each_cpu_mask(&tmpmask, kvm_cove_imsic_clone, vcpu, 1);
+
+	ret = sbi_covi_rebind_vcpu_imsic_end(tvmc->tvm_guest_id, vcpu->vcpu_idx);
+	if (ret) {
+		kvm_err("Imsic rebind end failed guest %ld vcpu %d pcpu %d\n",
+			 tvmc->tvm_guest_id, vcpu->vcpu_idx, smp_processor_id());
+		return ret;
+	}
+
+	tvcpu->imsic.bound = true;
+
+	return 0;
+}
+
+int kvm_riscv_cove_vcpu_imsic_bind(struct kvm_vcpu *vcpu, unsigned long imsic_mask)
+{
+	struct kvm_cove_tvm_context *tvmc;
+	struct kvm *kvm = vcpu->kvm;
+	struct kvm_cove_tvm_vcpu_context *tvcpu = vcpu->arch.tc;
+	int ret;
+
+	if (!kvm->arch.tvmc)
+		return -EINVAL;
+
+	tvmc = kvm->arch.tvmc;
+
+	ret = sbi_covi_bind_vcpu_imsic(tvmc->tvm_guest_id, vcpu->vcpu_idx, imsic_mask);
+	if (ret) {
+		kvm_err("Imsic bind failed for imsic %lx guest %ld vcpu %d pcpu %d\n",
+			imsic_mask, tvmc->tvm_guest_id, vcpu->vcpu_idx, smp_processor_id());
+		return ret;
+	}
+	tvcpu->imsic.bound = true;
+	pr_err("%s: rebind success vcpu %d hgei %d pcpu %d\n", __func__,
+	vcpu->vcpu_idx, tvcpu->imsic.vsfile_hgei, smp_processor_id());
+
+	return 0;
+}
+
+int kvm_riscv_cove_vcpu_imsic_unbind(struct kvm_vcpu *vcpu, int old_pcpu)
+{
+	struct kvm *kvm = vcpu->kvm;
+	struct kvm_cove_tvm_vcpu_context *tvcpu = vcpu->arch.tc;
+	cpumask_t tmpmask;
+
+	if (!kvm->arch.tvmc)
+		return -EINVAL;
+
+	/* No need to unbind if it is not bound already */
+	if (!tvcpu->imsic.bound)
+		return 0;
+
+	/* Do it first even if there is failure to prevent it to try again */
+	tvcpu->imsic.bound = false;
+
+	if (smp_processor_id() == old_pcpu) {
+		kvm_cove_imsic_unbind(vcpu);
+	} else {
+		/* Unbind can be invoked from a different physical cpu */
+		cpumask_clear(&tmpmask);
+		cpumask_set_cpu(old_pcpu, &tmpmask);
+		on_each_cpu_mask(&tmpmask, kvm_cove_imsic_unbind, vcpu, 1);
+	}
+
+	return 0;
+}
+
+int kvm_riscv_cove_vcpu_inject_interrupt(struct kvm_vcpu *vcpu, unsigned long iid)
+{
+	struct kvm_cove_tvm_context *tvmc;
+	struct kvm *kvm = vcpu->kvm;
+	int ret;
+
+	if (!kvm->arch.tvmc)
+		return -EINVAL;
+
+	tvmc = kvm->arch.tvmc;
+
+	ret = sbi_covi_inject_external_interrupt(tvmc->tvm_guest_id, vcpu->vcpu_idx, iid);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+int kvm_riscv_cove_aia_init(struct kvm *kvm)
+{
+	struct kvm_aia *aia = &kvm->arch.aia;
+	struct sbi_cove_tvm_aia_params *tvm_aia;
+	struct kvm_vcpu *vcpu;
+	struct kvm_cove_tvm_context *tvmc;
+	int ret;
+
+	if (!kvm->arch.tvmc)
+		return -EINVAL;
+
+	tvmc = kvm->arch.tvmc;
+
+	/* Sanity Check */
+	if (aia->aplic_addr != KVM_RISCV_AIA_UNDEF_ADDR)
+		return -EINVAL;
+
+	/* TVMs must have a physical guest interrut file */
+	if (aia->mode != KVM_DEV_RISCV_AIA_MODE_HWACCEL)
+		return -ENODEV;
+
+	tvm_aia = kzalloc(sizeof(*tvm_aia), GFP_KERNEL);
+	if (!tvm_aia)
+		return -ENOMEM;
+
+	/* Address of the IMSIC group ID, hart ID & guest ID of 0 */
+	vcpu = kvm_get_vcpu_by_id(kvm, 0);
+	tvm_aia->imsic_base_addr = vcpu->arch.aia_context.imsic_addr;
+
+	tvm_aia->group_index_bits = aia->nr_group_bits;
+	tvm_aia->group_index_shift = aia->nr_group_shift;
+	tvm_aia->hart_index_bits = aia->nr_hart_bits;
+	tvm_aia->guest_index_bits = aia->nr_guest_bits;
+	/* Nested TVMs are not supported yet */
+	tvm_aia->guests_per_hart = 0;
+
+
+	ret = sbi_covi_tvm_aia_init(tvmc->tvm_guest_id, tvm_aia);
+	if (ret)
+		kvm_err("TVM AIA init failed with rc %d\n", ret);
+
+	return ret;
+}
+
+void kvm_riscv_cove_vcpu_load(struct kvm_vcpu *vcpu)
+{
+	kvm_riscv_vcpu_timer_restore(vcpu);
+}
+
+void kvm_riscv_cove_vcpu_put(struct kvm_vcpu *vcpu)
+{
+	void *nshmem;
+	struct kvm_vcpu_csr *csr = &vcpu->arch.guest_csr;
+
+	kvm_riscv_vcpu_timer_save(vcpu);
+	/* NACL is mandatory for CoVE */
+	nshmem = nacl_shmem();
+
+	/* Only VSIE needs to be read to manage the interrupt stuff */
+	csr->vsie = nacl_shmem_csr_read(nshmem, CSR_VSIE);
+}
+
+int kvm_riscv_cove_vcpu_sbi_ecall(struct kvm_vcpu *vcpu, struct kvm_run *run)
+{
+	void *nshmem;
+	const struct kvm_vcpu_sbi_extension *sbi_ext;
+	struct kvm_cpu_context *cp = &vcpu->arch.guest_context;
+	struct kvm_cpu_trap utrap = { 0 };
+	struct kvm_vcpu_sbi_return sbi_ret = {
+		.out_val = 0,
+		.err_val = 0,
+		.utrap = &utrap,
+	};
+	bool ext_is_01 = false;
+	int ret = 1;
+
+	nshmem = nacl_shmem();
+	cp->a0 = nacl_shmem_gpr_read_cove(nshmem, KVM_ARCH_GUEST_A0);
+	cp->a1 = nacl_shmem_gpr_read_cove(nshmem, KVM_ARCH_GUEST_A1);
+	cp->a6 = nacl_shmem_gpr_read_cove(nshmem, KVM_ARCH_GUEST_A6);
+	cp->a7 = nacl_shmem_gpr_read_cove(nshmem, KVM_ARCH_GUEST_A7);
+
+	/* TSM will only forward legacy console to the host */
+#ifdef CONFIG_RISCV_SBI_V01
+	if (cp->a7 == SBI_EXT_0_1_CONSOLE_PUTCHAR)
+		ext_is_01 = true;
+#endif
+
+	sbi_ext = kvm_vcpu_sbi_find_ext(vcpu, cp->a7);
+	if ((sbi_ext && sbi_ext->handler) && ((cp->a7 == SBI_EXT_DBCN) ||
+	    (cp->a7 == SBI_EXT_HSM) || (cp->a7 == SBI_EXT_SRST) ||
+	    (cp->a7 == SBI_EXT_COVG) || ext_is_01)) {
+		ret = sbi_ext->handler(vcpu, run, &sbi_ret);
+	} else {
+		kvm_err("%s: SBI EXT %lx not supported for TVM\n", __func__, cp->a7);
+		/* Return error for unsupported SBI calls */
+		sbi_ret.err_val = SBI_ERR_NOT_SUPPORTED;
+		goto ecall_done;
+	}
+
+	if (ret < 0)
+		goto ecall_done;
+
+	ret = (sbi_ret.uexit) ? 0 : 1;
+
+ecall_done:
+	/*
+	 * No need to update the sepc as TSM will take care of SEPC increment
+	 * for ECALLS that won't be forwarded to the user space (e.g. console)
+	 */
+	nacl_shmem_gpr_write_cove(nshmem, KVM_ARCH_GUEST_A0, sbi_ret.err_val);
+	if (!ext_is_01)
+		nacl_shmem_gpr_write_cove(nshmem, KVM_ARCH_GUEST_A1, sbi_ret.out_val);
+
+	return ret;
+}
+
+static int kvm_riscv_cove_gstage_map(struct kvm_vcpu *vcpu, gpa_t gpa,
+				     unsigned long hva)
+{
+	struct kvm_riscv_cove_page *tpage;
+	struct mm_struct *mm = current->mm;
+	struct kvm *kvm = vcpu->kvm;
+	unsigned int flags = FOLL_LONGTERM | FOLL_WRITE | FOLL_HWPOISON;
+	struct page *page;
+	int rc;
+	struct kvm_cove_tvm_context *tvmc = kvm->arch.tvmc;
+
+	tpage = kmalloc(sizeof(*tpage), GFP_KERNEL_ACCOUNT);
+	if (!tpage)
+		return -ENOMEM;
+
+	mmap_read_lock(mm);
+	rc = pin_user_pages(hva, 1, flags, &page);
+	mmap_read_unlock(mm);
+
+	if (rc == -EHWPOISON) {
+		send_sig_mceerr(BUS_MCEERR_AR, (void __user *)hva,
+				PAGE_SHIFT, current);
+		rc = 0;
+		goto free_tpage;
+	} else if (rc != 1) {
+		rc = -EFAULT;
+		goto free_tpage;
+	} else if (!PageSwapBacked(page)) {
+		rc = -EIO;
+		goto free_tpage;
+	}
+
+	rc = cove_convert_pages(page_to_phys(page), 1, true);
+	if (rc)
+		goto unpin_page;
+
+	rc = sbi_covh_add_zero_pages(tvmc->tvm_guest_id, page_to_phys(page),
+				     SBI_COVE_PAGE_4K, 1, gpa);
+	if (rc) {
+		pr_err("%s: Adding zero pages failed %d\n", __func__, rc);
+		goto zero_page_failed;
+	}
+	tpage->page = page;
+	tpage->npages = 1;
+	tpage->is_mapped = true;
+	tpage->gpa = gpa;
+	tpage->hva = hva;
+	INIT_LIST_HEAD(&tpage->link);
+
+	spin_lock(&kvm->mmu_lock);
+	list_add(&tpage->link, &kvm->arch.tvmc->zero_pages);
+	spin_unlock(&kvm->mmu_lock);
+
+	return 0;
+
+zero_page_failed:
+	//TODO: Do we need to reclaim the page now or VM gets destroyed ?
+
+unpin_page:
+	unpin_user_pages(&page, 1);
+
+free_tpage:
+	kfree(tpage);
+
+	return rc;
+}
+
+int kvm_riscv_cove_handle_pagefault(struct kvm_vcpu *vcpu, gpa_t gpa,
+				    unsigned long hva)
+{
+	struct kvm_cove_tvm_context *tvmc = vcpu->kvm->arch.tvmc;
+	struct kvm_riscv_cove_page *tpage, *next;
+	bool shared = false;
+
+	/* TODO: Implement a better approach to track regions to avoid
+	 * traversing the whole list on each fault.
+	 */
+	spin_lock(&vcpu->kvm->mmu_lock);
+	list_for_each_entry_safe(tpage, next, &tvmc->shared_pages, link) {
+		if (tpage->gpa == (gpa & PAGE_MASK)) {
+			shared = true;
+			break;
+		}
+	}
+	spin_unlock(&vcpu->kvm->mmu_lock);
+
+	if (shared) {
+		return sbi_covh_add_shared_pages(tvmc->tvm_guest_id,
+						 page_to_phys(tpage->page),
+						 SBI_COVE_PAGE_4K, 1,
+						 gpa & PAGE_MASK);
+	}
+
+	return kvm_riscv_cove_gstage_map(vcpu, gpa, hva);
+}
+
+void kvm_riscv_cove_gstage_preload(struct kvm_vcpu *vcpu) {
+	struct kvm_memory_slot *memslot;
+	unsigned long hva, gpa, page;
+	int bkt;
+
+	kvm_for_each_memslot(memslot, bkt, kvm_memslots(vcpu->kvm)) {
+		for (page = 0; page < memslot->npages; page++) {
+			gpa = gfn_to_gpa(memslot->base_gfn) + page * PAGE_SIZE;
+			hva = gfn_to_hva_memslot_prot(memslot, gpa_to_gfn(gpa), NULL);
+			if (!kvm_is_error_hva(hva))
+				kvm_riscv_gstage_map(vcpu, memslot, gpa, hva, NULL);
+		}
+	}
+}
+
+void noinstr kvm_riscv_cove_vcpu_switchto(struct kvm_vcpu *vcpu, struct kvm_cpu_trap *trap)
+{
+	struct kvm_cpu_context *cntx = &vcpu->arch.guest_context;
+	struct kvm_cove_tvm_vcpu_context *tvcpuc = vcpu->arch.tc;
+	struct kvm_guest_timer *gt = &vcpu->kvm->arch.timer;
+	struct kvm_cove_tvm_context *tvmc;
+	struct kvm *kvm = vcpu->kvm;
+	void *nshmem;
+	int rc;
+
+	if (!kvm->arch.tvmc)
+		return;
+
+	tvmc = kvm->arch.tvmc;
+
+	nshmem = nacl_shmem();
+	/* Invoke finalize to mark TVM is ready run for the first time */
+	if (unlikely(!tvmc->finalized_done)) {
+		if (is_cove_vm_multi_step_initializing(vcpu->kvm)) {
+			rc = sbi_covh_tsm_finalize_tvm(tvmc->tvm_guest_id, cntx->sepc, cntx->a1);
+		} else if (is_cove_vm_single_step_initializing(vcpu->kvm)) {
+			rc = sbi_covh_tsm_promote_to_tvm(cntx->a1, tvmc->cove_tap_addr, cntx->sepc,
+							 &tvmc->tvm_guest_id);
+		} else {
+			rc = -EOPNOTSUPP;
+		}
+		if (rc) {
+			kvm_err("TVM Finalized failed with %d\n", rc);
+			return;
+		}
+		tvmc->finalized_done = true;
+		kvm_info("CoVE Guest creation successful with guest id %lx\n", tvmc->tvm_guest_id);
+	}
+
+	/*
+	 * Bind the vsfile here instead during the new vsfile allocation because
+	 * COVI bind call requires the TVM to be in finalized state.
+	 */
+	if (kvm_riscv_cove_capability(KVM_COVE_TSM_CAP_AIA) && tvcpuc->imsic.bind_required) {
+		tvcpuc->imsic.bind_required = false;
+		rc = kvm_riscv_cove_vcpu_imsic_bind(vcpu, BIT(tvcpuc->imsic.vsfile_hgei));
+		if (rc) {
+			kvm_err("bind failed with rc %d\n", rc);
+			return;
+		}
+	}
+
+	rc = sbi_covh_run_tvm_vcpu(tvmc->tvm_guest_id, vcpu->vcpu_idx);
+	if (rc) {
+		trap->scause = EXC_CUSTOM_KVM_COVE_RUN_FAIL;
+		return;
+	}
+
+	/* Read htimedelta from shmem. Given it's written by TSM only when we
+	 * run first VCPU, we need to update this here rather than in timer
+	 * init.
+	 */
+	if (unlikely(!gt->time_delta))
+		gt->time_delta = nacl_shmem_csr_read(nshmem, CSR_HTIMEDELTA);
+}
+
+void kvm_riscv_cove_vcpu_destroy(struct kvm_vcpu *vcpu)
+{
+	struct kvm_cove_tvm_vcpu_context *tvcpuc = vcpu->arch.tc;
+	struct kvm *kvm = vcpu->kvm;
+
+	if (tvcpuc == NULL)
+		return;
+
+	/*
+	 * Just add the vcpu state pages to a list at this point as these can not
+	 * be claimed until tvm is destroyed. *
+	 */
+	list_add(&tvcpuc->vcpu_state.link, &kvm->arch.tvmc->reclaim_pending_pages);
+
+	vcpu->arch.tc = NULL;
+	kfree(tvcpuc);
+}
+
+int kvm_riscv_cove_vcpu_init(struct kvm_vcpu *vcpu)
+{
+	struct kvm_cove_tvm_vcpu_context *tvcpuc;
+	struct kvm_cove_tvm_context *tvmc;
+	unsigned long vcpus_phys_addr;
+	struct page *vcpus_page;
+	struct kvm *kvm;
+	int rc;
+
+	if (!vcpu)
+		return -EINVAL;
+
+	kvm = vcpu->kvm;
+
+	if (!kvm->arch.tvmc)
+		return -EINVAL;
+
+	tvmc = kvm->arch.tvmc;
+
+	if (tvmc->finalized_done) {
+		kvm_err("vcpu init must not happen after finalize\n");
+		return -EINVAL;
+	}
+
+	tvcpuc = kzalloc(sizeof(*tvcpuc), GFP_KERNEL);
+	if (!tvcpuc)
+		return -ENOMEM;
+
+	tvcpuc->vcpu = vcpu;
+	tvcpuc->vcpu_state.npages = tinfo.tvcpu_pages_needed;
+	vcpu->arch.tc = tvcpuc;
+
+	if (!is_cove_vm_multi_step_initializing(vcpu->kvm)) {
+		return 0;
+	}
+
+	vcpus_page = alloc_pages(GFP_KERNEL | __GFP_ZERO,
+				 get_order_num_pages(tinfo.tvcpu_pages_needed));
+	if (!vcpus_page) {
+		rc = -ENOMEM;
+		goto alloc_page_failed;
+	}
+
+	tvcpuc->vcpu_state.page = vcpus_page;
+	vcpus_phys_addr = page_to_phys(vcpus_page);
+
+	rc = cove_convert_pages(vcpus_phys_addr, tvcpuc->vcpu_state.npages, true);
+	if (rc)
+		goto convert_failed;
+
+	rc = sbi_covh_create_tvm_vcpu(tvmc->tvm_guest_id, vcpu->vcpu_idx, vcpus_phys_addr);
+	if (rc)
+		goto vcpu_create_failed;
+
+	return 0;
+
+vcpu_create_failed:
+	/* Reclaim all the pages or return to the confidential page pool */
+	sbi_covh_tsm_reclaim_pages(vcpus_phys_addr, tvcpuc->vcpu_state.npages);
+
+convert_failed:
+	__free_pages(vcpus_page, get_order_num_pages(tinfo.tvcpu_pages_needed));
+
+alloc_page_failed:
+	vcpu->arch.tc = NULL;
+	kfree(tvcpuc);
+	return rc;
+}
+
+int kvm_riscv_cove_vm_measure_pages(struct kvm *kvm, struct kvm_riscv_cove_measure_region *mr)
+{
+	struct kvm_cove_tvm_context *tvmc = kvm->arch.tvmc;
+	int rc = 0, idx, num_pages;
+	struct kvm_riscv_cove_mem_region *conf;
+	struct page *pinned_page, *conf_page;
+	struct kvm_riscv_cove_page *cpage;
+
+	if (!tvmc)
+		return -EFAULT;
+
+	if (tvmc->finalized_done) {
+		kvm_err("measured_mr pages can not be added after finalize\n");
+		return -EINVAL;
+	}
+
+	if (mr->type == KVM_RISCV_COVE_REGION_COVE_TAP) {
+		tvmc->cove_tap_addr = mr->gpa;
+	}
+
+	if (!is_cove_vm_multi_step_initializing(kvm))
+		return 0;
+
+	num_pages = bytes_to_pages(mr->size);
+	conf = &tvmc->confidential_region;
+
+	if (!IS_ALIGNED(mr->userspace_addr, PAGE_SIZE) ||
+	    !IS_ALIGNED(mr->gpa, PAGE_SIZE) || !mr->size ||
+	    !cove_is_within_region(conf->gpa, conf->npages << PAGE_SHIFT, mr->gpa, mr->size))
+		return -EINVAL;
+
+	idx = srcu_read_lock(&kvm->srcu);
+
+	/*TODO: Iterate one page at a time as pinning multiple pages fail with unmapped panic
+	 * with a virtual address range belonging to vmalloc region for some reason.
+	 */
+	while (num_pages) {
+		if (signal_pending(current)) {
+			rc = -ERESTARTSYS;
+			break;
+		}
+
+		if (need_resched())
+			cond_resched();
+
+		rc = get_user_pages_fast(mr->userspace_addr, 1, 0, &pinned_page);
+		if (rc < 0) {
+			kvm_err("Pinning the userpsace addr %lx failed\n", mr->userspace_addr);
+			break;
+		}
+
+		/* Enough pages are not available to be pinned */
+		if (rc != 1) {
+			rc = -ENOMEM;
+			break;
+		}
+		conf_page = alloc_page(GFP_KERNEL | __GFP_ZERO);
+		if (!conf_page) {
+			rc = -ENOMEM;
+			break;
+		}
+
+		rc = cove_convert_pages(page_to_phys(conf_page), 1, true);
+		if (rc)
+			break;
+
+		/*TODO: Support other pages sizes */
+		rc = sbi_covh_add_measured_pages(tvmc->tvm_guest_id, page_to_phys(pinned_page),
+						 page_to_phys(conf_page), SBI_COVE_PAGE_4K,
+						 1, mr->gpa);
+		if (rc)
+			break;
+
+		/* Unpin the page now */
+		put_page(pinned_page);
+
+		cpage = kmalloc(sizeof(*cpage), GFP_KERNEL_ACCOUNT);
+		if (!cpage) {
+			rc = -ENOMEM;
+			break;
+		}
+
+		cpage->page = conf_page;
+		cpage->npages = 1;
+		cpage->gpa = mr->gpa;
+		cpage->hva = mr->userspace_addr;
+		cpage->is_mapped = true;
+		INIT_LIST_HEAD(&cpage->link);
+		list_add(&cpage->link, &tvmc->measured_pages);
+
+		mr->userspace_addr += PAGE_SIZE;
+		mr->gpa += PAGE_SIZE;
+		num_pages--;
+		conf_page = NULL;
+
+		continue;
+	}
+	srcu_read_unlock(&kvm->srcu, idx);
+
+	if (rc < 0) {
+		/* We don't to need unpin pages as it is allocated by the hypervisor itself */
+		cove_delete_page_list(kvm, &tvmc->measured_pages, false);
+		/* Free the last allocated page for which conversion/measurement failed */
+		kfree(conf_page);
+		kvm_err("Adding/Converting measured pages failed %d\n", num_pages);
+	}
+
+	return rc;
+}
+
+int kvm_riscv_cove_vm_add_memreg(struct kvm *kvm, unsigned long gpa, unsigned long size)
+{
+	int rc;
+	struct kvm_cove_tvm_context *tvmc = kvm->arch.tvmc;
+
+	if (!tvmc)
+		return -EFAULT;
+
+	if (tvmc->finalized_done) {
+		kvm_err("Memory region can not be added after finalize\n");
+		return -EINVAL;
+	}
+
+	tvmc->confidential_region.gpa = gpa;
+	tvmc->confidential_region.npages = bytes_to_pages(size);
+
+	rc = sbi_covh_add_memory_region(tvmc->tvm_guest_id, gpa, size);
+	if (rc) {
+		kvm_err("Registering confidential memory region failed with rc %d\n", rc);
+		return rc;
+	}
+
+	kvm_info("%s: Success with gpa %lx size %lx\n", __func__, gpa, size);
+
+	return 0;
+}
+
+/*
+ * Destroying A TVM is expensive because we need to reclaim all the pages by iterating over it.
+ * Few ideas to improve:
+ * 1. At least do the reclaim part in a worker thread in the background
+ * 2. Define a page pool which can contain a pre-allocated/converted pages.
+ *    In this step, we just return to the confidential page pool. Thus, some other TVM
+ *    can use it.
+ */
+void kvm_riscv_cove_vm_destroy(struct kvm *kvm)
+{
+	int rc;
+	struct kvm_cove_tvm_context *tvmc = kvm->arch.tvmc;
+	unsigned long pgd_npages;
+
+	if (!tvmc)
+		return;
+
+	/* Release all the confidential pages using COVH SBI call */
+	rc = sbi_covh_tsm_destroy_tvm(tvmc->tvm_guest_id);
+	if (rc) {
+		kvm_err("TVM %ld destruction failed with rc = %d\n", tvmc->tvm_guest_id, rc);
+		return;
+	}
+
+	if (!kvm_riscv_cove_capability(KVM_COVE_TSM_CAP_MEMORY_ALLOCATION))
+		goto deallocate_tvmc;
+
+	cove_delete_page_list(kvm, &tvmc->reclaim_pending_pages, false);
+	cove_delete_page_list(kvm, &tvmc->measured_pages, false);
+	cove_delete_page_list(kvm, &tvmc->zero_pages, true);
+	cove_delete_shared_pinned_page_list(kvm, &tvmc->shared_pages);
+
+	/* Reclaim and Free the pages for tvm state management */
+	rc = sbi_covh_tsm_reclaim_pages(page_to_phys(tvmc->tvm_state.page), tvmc->tvm_state.npages);
+	if (rc)
+		goto reclaim_failed;
+
+	__free_pages(tvmc->tvm_state.page, get_order_num_pages(tvmc->tvm_state.npages));
+
+	/* Reclaim and Free the pages for gstage page table management */
+	rc = sbi_covh_tsm_reclaim_pages(page_to_phys(tvmc->pgtable.page), tvmc->pgtable.npages);
+	if (rc)
+		goto reclaim_failed;
+
+	__free_pages(tvmc->pgtable.page, get_order_num_pages(tvmc->pgtable.npages));
+
+	/* Reclaim the confidential page for pgd */
+	pgd_npages = kvm_riscv_gstage_pgd_size() >> PAGE_SHIFT;
+	rc = sbi_covh_tsm_reclaim_pages(kvm->arch.pgd_phys, pgd_npages);
+	if (rc)
+		goto reclaim_failed;
+
+deallocate_tvmc:
+	kfree(tvmc);
+	return;
+
+reclaim_failed:
+	kvm_err("Memory reclaim failed with rc %d\n", rc);
+}
+
+int kvm_riscv_cove_vm_single_step_init(struct kvm *kvm)
+{
+	struct kvm_cove_tvm_context *tvmc;
+
+	if (!kvm_riscv_cove_capability(KVM_COVE_TSM_CAP_PROMOTE_TVM))
+		return -EOPNOTSUPP;
+
+	tvmc = kzalloc(sizeof(*tvmc), GFP_KERNEL);
+	if (!tvmc)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&tvmc->measured_pages);
+	INIT_LIST_HEAD(&tvmc->zero_pages);
+	INIT_LIST_HEAD(&tvmc->shared_pages);
+	INIT_LIST_HEAD(&tvmc->reclaim_pending_pages);
+
+	tvmc->kvm = kvm;
+	kvm->arch.tvmc = tvmc;
+	kvm->arch.vm_type = KVM_VM_TYPE_RISCV_COVE_SINGLE_STEP_INIT;
+	return 0;
+}
+
+int kvm_riscv_cove_vm_multi_step_init(struct kvm *kvm)
+{
+	unsigned long gstage_pgd_size = kvm_riscv_gstage_pgd_size();
+	unsigned long tvm_gid, pgt_phys_addr, tvms_phys_addr;
+	struct kvm_cove_tvm_context *tvmc;
+	struct page *tvms_page, *pgt_page;
+	int rc = 0;
+
+	// Multi-step TVM creation requires TSM that supports dynamic page conversion
+	if (!kvm_riscv_cove_capability(KVM_COVE_TSM_CAP_MEMORY_ALLOCATION))
+		return -EOPNOTSUPP;
+
+	tvmc = kzalloc(sizeof(*tvmc), GFP_KERNEL);
+	if (!tvmc)
+		return -ENOMEM;
+
+	/* Allocate the pages required for gstage page table management */
+	/* TODO: Just give enough pages for page table pool for now */
+	pgt_page = alloc_pages(GFP_KERNEL | __GFP_ZERO, get_order(KVM_COVE_PGTABLE_SIZE_MAX));
+	if (!pgt_page)
+		return -ENOMEM;
+
+	/* pgd is always 16KB aligned */
+	rc = cove_convert_pages(kvm->arch.pgd_phys, gstage_pgd_size >> PAGE_SHIFT, false);
+	if (rc)
+		goto done;
+
+	/* Convert the gstage page table pages */
+	tvmc->pgtable.page = pgt_page;
+	tvmc->pgtable.npages = KVM_COVE_PGTABLE_SIZE_MAX >> PAGE_SHIFT;
+	pgt_phys_addr = page_to_phys(pgt_page);
+
+	rc = cove_convert_pages(pgt_phys_addr, tvmc->pgtable.npages, false);
+	if (rc) {
+		kvm_err("%s: page table pool conversion failed rc %d\n", __func__, rc);
+		goto pgt_convert_failed;
+	}
+
+	/* Allocate and convert the pages required for TVM state management */
+	tvms_page = alloc_pages(GFP_KERNEL | __GFP_ZERO,
+				get_order_num_pages(tinfo.tvm_pages_needed));
+	if (!tvms_page) {
+		rc = -ENOMEM;
+		goto tvms_alloc_failed;
+	}
+
+	tvmc->tvm_state.page = tvms_page;
+	tvmc->tvm_state.npages = tinfo.tvm_pages_needed;
+	tvms_phys_addr = page_to_phys(tvms_page);
+
+	rc = cove_convert_pages(tvms_phys_addr, tinfo.tvm_pages_needed, false);
+	if (rc) {
+		kvm_err("%s: tvm state page conversion failed rc %d\n", __func__, rc);
+		goto tvms_convert_failed;
+	}
+
+	rc = kvm_riscv_cove_fence();
+	if (rc)
+		goto tvm_init_failed;
+
+	INIT_LIST_HEAD(&tvmc->measured_pages);
+	INIT_LIST_HEAD(&tvmc->zero_pages);
+	INIT_LIST_HEAD(&tvmc->shared_pages);
+	INIT_LIST_HEAD(&tvmc->reclaim_pending_pages);
+
+	/* The required pages have been converted to confidential memory. Create the TVM now */
+	params.tvm_page_directory_addr = kvm->arch.pgd_phys;
+	params.tvm_state_addr = tvms_phys_addr;
+
+	rc = sbi_covh_tsm_create_tvm(&params, &tvm_gid);
+	if (rc)
+		goto tvm_init_failed;
+
+	tvmc->tvm_guest_id = tvm_gid;
+	spin_lock_init(&tvmc->tvm_fence_lock);
+	kvm->arch.tvmc = tvmc;
+
+	rc = sbi_covh_add_pgt_pages(tvm_gid, pgt_phys_addr, tvmc->pgtable.npages);
+	if (rc)
+		goto tvm_init_failed;
+
+	tvmc->kvm = kvm;
+	kvm->arch.vm_type = KVM_VM_TYPE_RISCV_COVE_MULTI_STEP_INIT;
+	kvm_info("Guest VM creation successful with guest id %lx\n", tvm_gid);
+
+	return 0;
+
+tvm_init_failed:
+	/* Reclaim tvm state pages */
+	sbi_covh_tsm_reclaim_pages(tvms_phys_addr, tvmc->tvm_state.npages);
+
+tvms_convert_failed:
+	__free_pages(tvms_page, get_order_num_pages(tinfo.tvm_pages_needed));
+
+tvms_alloc_failed:
+	/* Reclaim pgtable pages */
+	sbi_covh_tsm_reclaim_pages(pgt_phys_addr, tvmc->pgtable.npages);
+
+pgt_convert_failed:
+	__free_pages(pgt_page, get_order(KVM_COVE_PGTABLE_SIZE_MAX));
+	/* Reclaim pgd pages */
+	sbi_covh_tsm_reclaim_pages(kvm->arch.pgd_phys, gstage_pgd_size >> PAGE_SHIFT);
+
+done:
+	kfree(tvmc);
+	return rc;
+}
+
+int kvm_riscv_cove_init(void)
+{
+	int rc;
+
+	/* We currently support host in VS mode. Thus, NACL is mandatory */
+	if (sbi_probe_extension(SBI_EXT_COVH) <= 0 || !kvm_riscv_nacl_available())
+		return -EOPNOTSUPP;
+
+	rc = sbi_covh_tsm_get_info(&tinfo);
+	if (rc < 0)
+		return -EINVAL;
+
+	if (tinfo.tstate != TSM_READY) {
+		kvm_err("TSM is not ready yet. Can't run TVMs\n");
+		return -EAGAIN;
+	}
+
+	riscv_cove_enabled = true;
+	kvm_info("The platform has confidential computing feature enabled\n");
+	kvm_info("TSM version %d is loaded and ready to run\n", tinfo.version);
+
+	return 0;
+}
diff --git a/arch/riscv/kvm/cove_sbi.c b/arch/riscv/kvm/cove_sbi.c
new file mode 100644
index 000000000000..fe6050d356c3
--- /dev/null
+++ b/arch/riscv/kvm/cove_sbi.c
@@ -0,0 +1,505 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * COVE SBI extensions related helper functions.
+ *
+ * Copyright (c) 2023 RivosInc
+ *
+ * Authors:
+ *     Atish Patra <atishp@rivosinc.com>
+ */
+
+#include <linux/align.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/kvm_host.h>
+#include <asm/csr.h>
+#include <asm/kvm_cove_sbi.h>
+#include <asm/sbi.h>
+
+#define RISCV_COVE_ALIGN_4KB (1UL << 12)
+
+int sbi_covi_tvm_aia_init(unsigned long tvm_gid,
+			  struct sbi_cove_tvm_aia_params *tvm_aia_params)
+{
+	struct sbiret ret;
+
+	unsigned long pa = __pa(tvm_aia_params);
+
+	ret = sbi_ecall(SBI_EXT_COVI, SBI_EXT_COVI_TVM_AIA_INIT, tvm_gid, pa,
+			sizeof(*tvm_aia_params), 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covi_set_vcpu_imsic_addr(unsigned long tvm_gid, unsigned long vcpu_id,
+				 unsigned long imsic_addr)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVI, SBI_EXT_COVI_TVM_CPU_SET_IMSIC_ADDR,
+			tvm_gid, vcpu_id, imsic_addr, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+/*
+ * Converts the guest interrupt file at `imsic_addr` for use with a TVM.
+ * The guest interrupt file must not be used by the caller until reclaim.
+ */
+int sbi_covi_convert_imsic(unsigned long imsic_addr)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVI, SBI_EXT_COVI_TVM_CONVERT_IMSIC,
+			imsic_addr, 0, 0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covi_reclaim_imsic(unsigned long imsic_addr)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVI, SBI_EXT_COVI_TVM_RECLAIM_IMSIC,
+			imsic_addr, 0, 0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+/*
+ * Binds a vCPU to this physical CPU and the specified set of confidential guest
+ * interrupt files.
+ */
+int sbi_covi_bind_vcpu_imsic(unsigned long tvm_gid, unsigned long vcpu_id,
+			     unsigned long imsic_mask)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVI, SBI_EXT_COVI_TVM_CPU_BIND_IMSIC, tvm_gid,
+			vcpu_id, imsic_mask, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+/*
+ * Begins the unbind process for the specified vCPU from this physical CPU and its guest
+ * interrupt files. The host must complete a TLB invalidation sequence for the TVM before
+ * completing the unbind with `unbind_vcpu_imsic_end()`.
+ */
+int sbi_covi_unbind_vcpu_imsic_begin(unsigned long tvm_gid,
+				     unsigned long vcpu_id)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVI, SBI_EXT_COVI_TVM_CPU_UNBIND_IMSIC_BEGIN,
+			tvm_gid, vcpu_id, 0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+/*
+ * Completes the unbind process for the specified vCPU from this physical CPU and its guest
+ * interrupt files.
+ */
+int sbi_covi_unbind_vcpu_imsic_end(unsigned long tvm_gid, unsigned long vcpu_id)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVI, SBI_EXT_COVI_TVM_CPU_UNBIND_IMSIC_END,
+			tvm_gid, vcpu_id, 0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+/*
+ * Injects an external interrupt into the specified vCPU. The interrupt ID must
+ * have been allowed with `allow_external_interrupt()` by the guest.
+ */
+int sbi_covi_inject_external_interrupt(unsigned long tvm_gid,
+				       unsigned long vcpu_id,
+				       unsigned long interrupt_id)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVI, SBI_EXT_COVI_TVM_CPU_INJECT_EXT_INTERRUPT,
+			tvm_gid, vcpu_id, interrupt_id, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covi_rebind_vcpu_imsic_begin(unsigned long tvm_gid,
+				     unsigned long vcpu_id,
+				     unsigned long imsic_mask)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVI, SBI_EXT_COVI_TVM_REBIND_IMSIC_BEGIN,
+			tvm_gid, vcpu_id, imsic_mask, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covi_rebind_vcpu_imsic_clone(unsigned long tvm_gid,
+				     unsigned long vcpu_id)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVI, SBI_EXT_COVI_TVM_REBIND_IMSIC_CLONE,
+			tvm_gid, vcpu_id, 0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covi_rebind_vcpu_imsic_end(unsigned long tvm_gid, unsigned long vcpu_id)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVI, SBI_EXT_COVI_TVM_REBIND_IMSIC_END,
+			tvm_gid, vcpu_id, 0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tsm_get_info(struct sbi_cove_tsm_info *tinfo_addr)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TSM_GET_INFO, __pa(tinfo_addr),
+			sizeof(*tinfo_addr), 0, 0, 0, 0);
+
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tvm_initiate_fence(unsigned long tvmid)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TVM_INITIATE_FENCE, tvmid, 0, 0, 0, 0, 0);
+
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tsm_initiate_fence(void)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TSM_INITIATE_FENCE, 0, 0, 0, 0, 0, 0);
+
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tsm_local_fence(void)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TSM_LOCAL_FENCE, 0, 0, 0, 0, 0, 0);
+
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tsm_create_tvm(struct sbi_cove_tvm_create_params *tparam, unsigned long *tvmid)
+{
+	struct sbiret ret;
+	int rc = 0;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_CREATE_TVM, __pa(tparam),
+			sizeof(*tparam), 0, 0, 0, 0);
+
+	if (ret.error) {
+		rc = sbi_err_map_linux_errno(ret.error);
+		if (rc == -EFAULT)
+			kvm_err("Invalid phsyical address for tvm params structure\n");
+		goto done;
+	}
+
+	*tvmid = ret.value;
+done:
+	return rc;
+}
+
+int sbi_covh_tsm_finalize_tvm(unsigned long tvmid, unsigned long sepc, unsigned long entry_arg)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_FINALIZE_TVM, tvmid,
+			sepc, entry_arg, 0, 0, 0);
+
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tsm_destroy_tvm(unsigned long tvmid)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_DESTROY_TVM, tvmid,
+			0, 0, 0, 0, 0);
+
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_add_memory_region(unsigned long tvmid, unsigned long tgpaddr, unsigned long rlen)
+{
+	struct sbiret ret;
+
+	if (!IS_ALIGNED(tgpaddr, RISCV_COVE_ALIGN_4KB) || !IS_ALIGNED(rlen, RISCV_COVE_ALIGN_4KB))
+		return -EINVAL;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TVM_ADD_MEMORY_REGION, tvmid,
+			tgpaddr, rlen, 0, 0, 0);
+	if (ret.error) {
+		kvm_err("Add memory region failed with sbi error code %ld\n", ret.error);
+		return sbi_err_map_linux_errno(ret.error);
+	}
+
+	return 0;
+}
+
+int sbi_covh_tsm_convert_pages(unsigned long phys_addr, unsigned long npages)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TSM_CONVERT_PAGES, phys_addr,
+			npages, 0, 0, 0, 0);
+	if (ret.error) {
+		kvm_err("Convert pages failed ret %ld\n", ret.error);
+		return sbi_err_map_linux_errno(ret.error);
+	}
+	return 0;
+}
+
+int sbi_covh_tsm_reclaim_page(unsigned long page_addr_phys)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TSM_RECLAIM_PAGES, page_addr_phys,
+			1, 0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tsm_reclaim_pages(unsigned long phys_addr, unsigned long npages)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TSM_RECLAIM_PAGES, phys_addr,
+			npages, 0, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_add_pgt_pages(unsigned long tvmid, unsigned long page_addr_phys, unsigned long npages)
+{
+	struct sbiret ret;
+
+	if (!PAGE_ALIGNED(page_addr_phys))
+		return -EINVAL;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TVM_ADD_PGT_PAGES, tvmid, page_addr_phys,
+			npages, 0, 0, 0);
+	if (ret.error) {
+		kvm_err("Adding page table pages at %lx failed %ld\n", page_addr_phys, ret.error);
+		return sbi_err_map_linux_errno(ret.error);
+	}
+
+	return 0;
+}
+
+int sbi_covh_add_measured_pages(unsigned long tvmid, unsigned long src_addr,
+				unsigned long dest_addr, enum sbi_cove_page_type ptype,
+				unsigned long npages, unsigned long tgpa)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TVM_ADD_MEASURED_PAGES, tvmid, src_addr,
+			dest_addr, ptype, npages, tgpa);
+	if (ret.error) {
+		kvm_err("Adding measued pages failed ret %ld\n", ret.error);
+		return sbi_err_map_linux_errno(ret.error);
+	}
+
+	return 0;
+}
+
+int sbi_covh_add_zero_pages(unsigned long tvmid, unsigned long page_addr_phys,
+			    enum sbi_cove_page_type ptype, unsigned long npages,
+			    unsigned long tvm_base_page_addr)
+{
+	struct sbiret ret;
+
+	if (!PAGE_ALIGNED(page_addr_phys))
+		return -EINVAL;
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TVM_ADD_ZERO_PAGES, tvmid, page_addr_phys,
+			ptype, npages, tvm_base_page_addr, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_add_shared_pages(unsigned long tvmid, unsigned long page_addr_phys,
+			      enum sbi_cove_page_type ptype,
+			      unsigned long npages,
+			      unsigned long tvm_base_page_addr)
+{
+	struct sbiret ret;
+
+	if (!PAGE_ALIGNED(page_addr_phys))
+		return -EINVAL;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TVM_ADD_SHARED_PAGES, tvmid,
+			page_addr_phys, ptype, npages, tvm_base_page_addr, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_create_tvm_vcpu(unsigned long tvmid, unsigned long vcpuid,
+			     unsigned long vcpu_state_paddr)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TVM_CREATE_VCPU, tvmid, vcpuid,
+			vcpu_state_paddr, 0, 0, 0);
+	if (ret.error) {
+		kvm_err("create vcpu failed ret %ld\n", ret.error);
+		return sbi_err_map_linux_errno(ret.error);
+	}
+	return 0;
+}
+
+int sbi_covh_run_tvm_vcpu(unsigned long tvmid, unsigned long vcpuid)
+{
+	struct sbiret ret;
+
+	ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_TVM_VCPU_RUN, tvmid, vcpuid, 0, 0, 0, 0);
+	/* Non-zero return value indicate the vcpu is already terminated */
+	if (ret.error || !ret.value)
+		return ret.error ? sbi_err_map_linux_errno(ret.error) : ret.value;
+
+	return 0;
+}
+
+int sbi_covh_tvm_invalidate_pages(unsigned long tvmid,
+			     unsigned long tvm_base_page_addr,
+			     unsigned long len)
+{
+	struct sbiret ret = sbi_ecall(SBI_EXT_COVH,
+				      SBI_EXT_COVH_TVM_INVALIDATE_PAGES, tvmid,
+				      tvm_base_page_addr, len, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tvm_validate_pages(unsigned long tvmid,
+			       unsigned long tvm_base_page_addr,
+			       unsigned long len)
+{
+	struct sbiret ret = sbi_ecall(SBI_EXT_COVH,
+				      SBI_EXT_COVH_TVM_VALIDATE_PAGES, tvmid,
+				      tvm_base_page_addr, len, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tvm_promote_page(unsigned long tvmid,
+			      unsigned long tvm_base_page_addr,
+			      enum sbi_cove_page_type ptype)
+{
+	struct sbiret ret = sbi_ecall(SBI_EXT_COVH,
+				      SBI_EXT_COVH_TVM_PROMOTE_PAGE, tvmid,
+				      tvm_base_page_addr, ptype, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tvm_demote_page(unsigned long tvmid,
+			     unsigned long tvm_base_page_addr,
+			     enum sbi_cove_page_type ptype)
+{
+	struct sbiret ret = sbi_ecall(SBI_EXT_COVH,
+				      SBI_EXT_COVH_TVM_DEMOTE_PAGE, tvmid,
+				      tvm_base_page_addr, ptype, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tvm_remove_pages(unsigned long tvmid,
+			      unsigned long tvm_base_page_addr,
+			      unsigned long len)
+{
+	struct sbiret ret = sbi_ecall(SBI_EXT_COVH,
+				      SBI_EXT_COVH_TVM_REMOVE_PAGES, tvmid,
+				      tvm_base_page_addr, len, 0, 0, 0);
+	if (ret.error)
+		return sbi_err_map_linux_errno(ret.error);
+
+	return 0;
+}
+
+int sbi_covh_tsm_promote_to_tvm(unsigned long fdt_address,
+				unsigned long tap_addr,
+				unsigned long sepc,
+				unsigned long *tvmid)
+{
+	struct sbiret ret = sbi_ecall(SBI_EXT_COVH, SBI_EXT_COVH_PROMOTE_TO_TVM,
+				      fdt_address, tap_addr, sepc, 0, 0, 0);
+	if (ret.error) {
+		return sbi_err_map_linux_errno(ret.error);
+	}
+
+	*tvmid = ret.value;
+	return 0;
+}
diff --git a/arch/riscv/kvm/main.c b/arch/riscv/kvm/main.c
index 48ae0d4b3932..cfbf0f947ba6 100644
--- a/arch/riscv/kvm/main.c
+++ b/arch/riscv/kvm/main.c
@@ -10,9 +10,10 @@
 #include <linux/err.h>
 #include <linux/module.h>
 #include <linux/kvm_host.h>
-#include <asm/csr.h>
 #include <asm/hwcap.h>
+#include <asm/kvm_nacl.h>
 #include <asm/sbi.h>
+#include <asm/kvm_cove.h>
 
 long kvm_arch_dev_ioctl(struct file *filp,
 			unsigned int ioctl, unsigned long arg)
@@ -22,8 +23,21 @@ long kvm_arch_dev_ioctl(struct file *filp,
 
 int kvm_arch_hardware_enable(void)
 {
+	int rc;
 	unsigned long hideleg, hedeleg;
 
+	rc = kvm_riscv_nacl_enable();
+	if (rc)
+		return rc;
+
+	/*
+	 * We just need to invoke aia enable for CoVE if host is in VS mode and TSM
+	 * supports AIA (COVI extension). However, if the host is running in HS mode,
+	 * we need to initialize other CSRs as well for legacy VMs.
+	 */
+	if (unlikely(kvm_riscv_cove_enabled()) && kvm_riscv_cove_capability(KVM_COVE_TSM_CAP_AIA))
+		goto enable_aia;
+
 	hedeleg = 0;
 	hedeleg |= (1UL << EXC_INST_MISALIGNED);
 	hedeleg |= (1UL << EXC_BREAKPOINT);
@@ -44,6 +58,7 @@ int kvm_arch_hardware_enable(void)
 
 	csr_write(CSR_HVIP, 0);
 
+enable_aia:
 	kvm_riscv_aia_enable();
 
 	return 0;
@@ -53,6 +68,8 @@ void kvm_arch_hardware_disable(void)
 {
 	kvm_riscv_aia_disable();
 
+	if (unlikely(kvm_riscv_cove_enabled()))
+		goto disable_nacl;
 	/*
 	 * After clearing the hideleg CSR, the host kernel will receive
 	 * spurious interrupts if hvip CSR has pending interrupts and the
@@ -63,11 +80,15 @@ void kvm_arch_hardware_disable(void)
 	csr_write(CSR_HVIP, 0);
 	csr_write(CSR_HEDELEG, 0);
 	csr_write(CSR_HIDELEG, 0);
+
+disable_nacl:
+	kvm_riscv_nacl_disable();
 }
 
 static int __init riscv_kvm_init(void)
 {
 	int rc;
+	char slist[64];
 	const char *str;
 
 	if (!riscv_isa_extension_available(NULL, h)) {
@@ -80,21 +101,70 @@ static int __init riscv_kvm_init(void)
 		return -ENODEV;
 	}
 
+	// ACE potential problem
 	if (!sbi_probe_extension(SBI_EXT_RFENCE)) {
 		kvm_info("require SBI RFENCE extension\n");
 		return -ENODEV;
 	}
 
+	rc = kvm_riscv_nacl_init();
+	if (rc && rc != -ENODEV)
+		return rc;
+
+	kvm_riscv_cove_init();
+
 	kvm_riscv_gstage_mode_detect();
 
 	kvm_riscv_gstage_vmid_detect();
 
 	rc = kvm_riscv_aia_init();
-	if (rc && rc != -ENODEV)
+	if (rc && rc != -ENODEV) {
+		kvm_riscv_nacl_exit();
 		return rc;
+	}
+
+	/* TVM don't need RFENCE extension as hardware imsic support is mandatory for TVMs
+	 * TODO: This check should happen later if HW_ACCEL mode is not set as RFENCE
+	 * should only be mandatory in that case.
+	 */
+	if (!kvm_riscv_cove_enabled() && sbi_probe_extension(SBI_EXT_RFENCE) <= 0) {
+		kvm_info("require SBI RFENCE extension\n");
+		return -ENODEV;
+	}
 
 	kvm_info("hypervisor extension available\n");
 
+	if (kvm_riscv_nacl_available()) {
+		rc = 0;
+		slist[0] = '\0';
+		if (kvm_riscv_nacl_sync_csr_available()) {
+			if (rc)
+				strcat(slist, ", ");
+			strcat(slist, "sync_csr");
+			rc++;
+		}
+		if (kvm_riscv_nacl_sync_hfence_available()) {
+			if (rc)
+				strcat(slist, ", ");
+			strcat(slist, "sync_hfence");
+			rc++;
+		}
+		if (kvm_riscv_nacl_sync_sret_available()) {
+			if (rc)
+				strcat(slist, ", ");
+			strcat(slist, "sync_sret");
+			rc++;
+		}
+		if (kvm_riscv_nacl_autoswap_csr_available()) {
+			if (rc)
+				strcat(slist, ", ");
+			strcat(slist, "autoswap_csr");
+			rc++;
+		}
+		kvm_info("using SBI nested acceleration with %s\n",
+			 (rc) ? slist : "no features");
+	}
+
 	switch (kvm_riscv_gstage_mode()) {
 	case HGATP_MODE_SV32X4:
 		str = "Sv32x4";
@@ -122,6 +192,7 @@ static int __init riscv_kvm_init(void)
 	rc = kvm_init(sizeof(struct kvm_vcpu), 0, THIS_MODULE);
 	if (rc) {
 		kvm_riscv_aia_exit();
+		kvm_riscv_nacl_exit();
 		return rc;
 	}
 
@@ -133,6 +204,8 @@ static void __exit riscv_kvm_exit(void)
 {
 	kvm_riscv_aia_exit();
 
+	kvm_riscv_nacl_exit();
+
 	kvm_exit();
 }
 module_exit(riscv_kvm_exit);
diff --git a/arch/riscv/kvm/mmu.c b/arch/riscv/kvm/mmu.c
index 068c74593871..e987c7ec0880 100644
--- a/arch/riscv/kvm/mmu.c
+++ b/arch/riscv/kvm/mmu.c
@@ -15,7 +15,10 @@
 #include <linux/vmalloc.h>
 #include <linux/kvm_host.h>
 #include <linux/sched/signal.h>
+#include <asm/kvm_nacl.h>
 #include <asm/csr.h>
+#include <asm/kvm_host.h>
+#include <asm/kvm_cove.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
 
@@ -356,6 +359,11 @@ int kvm_riscv_gstage_ioremap(struct kvm *kvm, gpa_t gpa,
 		.gfp_zero = __GFP_ZERO,
 	};
 
+	if (is_cove_vm_finalized(kvm) || is_cove_vm_multi_step_initializing(kvm)) {
+		kvm_debug("%s: KVM doesn't support ioremap for TVM io regions\n", __func__);
+		return -EPERM;
+	}
+
 	end = (gpa + size + PAGE_SIZE - 1) & PAGE_MASK;
 	pfn = __phys_to_pfn(hpa);
 
@@ -385,6 +393,10 @@ int kvm_riscv_gstage_ioremap(struct kvm *kvm, gpa_t gpa,
 
 void kvm_riscv_gstage_iounmap(struct kvm *kvm, gpa_t gpa, unsigned long size)
 {
+	/* KVM doesn't map any IO region in gstage for TVM */
+	if (is_cove_vm_finalized(kvm) || is_cove_vm_multi_step_initializing(kvm))
+		return;
+
 	spin_lock(&kvm->mmu_lock);
 	gstage_unmap_range(kvm, gpa, size, false);
 	spin_unlock(&kvm->mmu_lock);
@@ -425,6 +437,10 @@ void kvm_arch_flush_shadow_memslot(struct kvm *kvm,
 	gpa_t gpa = slot->base_gfn << PAGE_SHIFT;
 	phys_addr_t size = slot->npages << PAGE_SHIFT;
 
+	/* No need to unmap gstage as it is managed by TSM */
+	if (is_cove_vm_finalized(kvm) || is_cove_vm_multi_step_initializing(kvm))
+		return;
+
 	spin_lock(&kvm->mmu_lock);
 	gstage_unmap_range(kvm, gpa, size, false);
 	spin_unlock(&kvm->mmu_lock);
@@ -435,6 +451,9 @@ void kvm_arch_commit_memory_region(struct kvm *kvm,
 				const struct kvm_memory_slot *new,
 				enum kvm_mr_change change)
 {
+	/* We don't support dirty logging for CoVE guests yet */
+	if (is_cove_vm_finalized(kvm) || is_cove_vm_multi_step_initializing(kvm))
+		return;
 	/*
 	 * At this point memslot has been committed and there is an
 	 * allocated dirty_bitmap[], dirty pages will be tracked while
@@ -474,6 +493,11 @@ int kvm_arch_prepare_memory_region(struct kvm *kvm,
 
 	mmap_read_lock(current->mm);
 
+	if (is_cove_vm_multi_step_initializing(kvm)) {
+		ret = kvm_riscv_cove_vm_add_memreg(kvm, base_gpa, size);
+		if (ret)
+			return ret;
+	}
 	/*
 	 * A memory region could potentially cover multiple VMAs, and
 	 * any holes between them, so iterate over all of them to find
@@ -541,7 +565,7 @@ int kvm_arch_prepare_memory_region(struct kvm *kvm,
 
 bool kvm_unmap_gfn_range(struct kvm *kvm, struct kvm_gfn_range *range)
 {
-	if (!kvm->arch.pgd)
+	if (!kvm->arch.pgd || is_cove_vm_finalized(kvm) || is_cove_vm_multi_step_initializing(kvm))
 		return false;
 
 	gstage_unmap_range(kvm, range->start << PAGE_SHIFT,
@@ -555,7 +579,7 @@ bool kvm_set_spte_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
 	int ret;
 	kvm_pfn_t pfn = pte_pfn(range->arg.pte);
 
-	if (!kvm->arch.pgd)
+	if (!kvm->arch.pgd || is_cove_vm_finalized(kvm) || is_cove_vm_multi_step_initializing(kvm))
 		return false;
 
 	WARN_ON(range->end - range->start != 1);
@@ -576,7 +600,7 @@ bool kvm_age_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
 	u32 ptep_level = 0;
 	u64 size = (range->end - range->start) << PAGE_SHIFT;
 
-	if (!kvm->arch.pgd)
+	if (!kvm->arch.pgd || is_cove_vm_finalized(kvm) || is_cove_vm_multi_step_initializing(kvm))
 		return false;
 
 	WARN_ON(size != PAGE_SIZE && size != PMD_SIZE && size != PUD_SIZE);
@@ -594,7 +618,7 @@ bool kvm_test_age_gfn(struct kvm *kvm, struct kvm_gfn_range *range)
 	u32 ptep_level = 0;
 	u64 size = (range->end - range->start) << PAGE_SHIFT;
 
-	if (!kvm->arch.pgd)
+	if (!kvm->arch.pgd || is_cove_vm_finalized(kvm) || is_cove_vm_multi_step_initializing(kvm))
 		return false;
 
 	WARN_ON(size != PAGE_SIZE && size != PMD_SIZE && size != PUD_SIZE);
@@ -731,6 +755,10 @@ void kvm_riscv_gstage_free_pgd(struct kvm *kvm)
 {
 	void *pgd = NULL;
 
+	/* PGD is mapped in TSM */
+	if (is_cove_vm_finalized(kvm) || is_cove_vm_multi_step_initializing(kvm))
+		return;
+
 	spin_lock(&kvm->mmu_lock);
 	if (kvm->arch.pgd) {
 		gstage_unmap_range(kvm, 0UL, gstage_gpa_size, false);
@@ -749,10 +777,14 @@ void kvm_riscv_gstage_update_hgatp(struct kvm_vcpu *vcpu)
 	unsigned long hgatp = gstage_mode;
 	struct kvm_arch *k = &vcpu->kvm->arch;
 
+	/* COVE VCPU hgatp is managed by TSM. */
+	if (is_cove_vm_finalized(vcpu->kvm))
+		return;
+
 	hgatp |= (READ_ONCE(k->vmid.vmid) << HGATP_VMID_SHIFT) & HGATP_VMID;
 	hgatp |= (k->pgd_phys >> PAGE_SHIFT) & HGATP_PPN;
 
-	csr_write(CSR_HGATP, hgatp);
+	nacl_csr_write(CSR_HGATP, hgatp);
 
 	if (!kvm_riscv_gstage_vmid_bits())
 		kvm_riscv_local_hfence_gvma_all();
@@ -791,3 +823,8 @@ int kvm_riscv_gstage_gpa_bits(void)
 {
 	return gstage_gpa_bits;
 }
+
+unsigned long kvm_riscv_gstage_pgd_size(void)
+{
+	return gstage_pgd_size;
+}
diff --git a/arch/riscv/kvm/nacl.c b/arch/riscv/kvm/nacl.c
new file mode 100644
index 000000000000..91ef6238310e
--- /dev/null
+++ b/arch/riscv/kvm/nacl.c
@@ -0,0 +1,152 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2022 Ventana Micro Systems Inc.
+ */
+
+#include <linux/kvm_host.h>
+#include <linux/vmalloc.h>
+#include <asm/kvm_nacl.h>
+
+DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_available);
+DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_csr_available);
+DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_hfence_available);
+DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_sret_available);
+DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_autoswap_csr_available);
+DEFINE_PER_CPU(struct kvm_riscv_nacl, kvm_riscv_nacl);
+
+void __kvm_riscv_nacl_hfence(void *shmem,
+			     unsigned long control,
+			     unsigned long page_num,
+			     unsigned long page_count)
+{
+	int i, ent = -1, try_count = 5;
+	unsigned long *entp;
+
+again:
+	for (i = 0; i < SBI_NACL_SHMEM_HFENCE_ENTRY_MAX; i++) {
+		entp = shmem + SBI_NACL_SHMEM_HFENCE_ENTRY_CTRL(i);
+		if (lelong_to_cpu(*entp) & SBI_NACL_SHMEM_HFENCE_CTRL_PEND)
+			continue;
+
+		ent = i;
+		break;
+	}
+
+	if (ent < 0) {
+		if (try_count) {
+			nacl_shmem_sync_hfence(-1UL);
+			goto again;
+		} else {
+			pr_warn("KVM: No free entry in NACL shared memory\n");
+			return;
+		}
+	}
+
+	entp = shmem + SBI_NACL_SHMEM_HFENCE_ENTRY_CTRL(i);
+	*entp = cpu_to_lelong(control);
+	entp = shmem + SBI_NACL_SHMEM_HFENCE_ENTRY_PNUM(i);
+	*entp = cpu_to_lelong(page_num);
+	entp = shmem + SBI_NACL_SHMEM_HFENCE_ENTRY_PCOUNT(i);
+	*entp = cpu_to_lelong(page_count);
+}
+
+int kvm_riscv_nacl_enable(void)
+{
+	int rc;
+	struct sbiret ret;
+	struct kvm_riscv_nacl *nacl;
+
+	if (!kvm_riscv_nacl_available())
+		return 0;
+	nacl = this_cpu_ptr(&kvm_riscv_nacl);
+
+	ret = sbi_ecall(SBI_EXT_NACL, SBI_EXT_NACL_SETUP_SHMEM,
+			nacl->shmem_phys, 0, 0, 0, 0, 0);
+	rc = sbi_err_map_linux_errno(ret.error);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+void kvm_riscv_nacl_disable(void)
+{
+	if (!kvm_riscv_nacl_available())
+		return;
+
+	sbi_ecall(SBI_EXT_NACL, SBI_EXT_NACL_SETUP_SHMEM,
+		  -1UL, -1UL, 0, 0, 0, 0);
+}
+
+void kvm_riscv_nacl_exit(void)
+{
+	int cpu;
+	struct kvm_riscv_nacl *nacl;
+
+	if (!kvm_riscv_nacl_available())
+		return;
+
+	/* Allocate per-CPU shared memory */
+	for_each_possible_cpu(cpu) {
+		nacl = per_cpu_ptr(&kvm_riscv_nacl, cpu);
+		if (!nacl->shmem)
+			continue;
+
+		free_pages((unsigned long)nacl->shmem,
+			   get_order(SBI_NACL_SHMEM_SIZE));
+		nacl->shmem = NULL;
+		nacl->shmem_phys = 0;
+	}
+}
+
+static long nacl_probe_feature(long feature_id)
+{
+	struct sbiret ret;
+
+	if (!kvm_riscv_nacl_available())
+		return 0;
+
+	ret = sbi_ecall(SBI_EXT_NACL, SBI_EXT_NACL_PROBE_FEATURE,
+			feature_id, 0, 0, 0, 0, 0);
+	return ret.value;
+}
+
+int kvm_riscv_nacl_init(void)
+{
+	int cpu;
+	struct page *shmem_page;
+	struct kvm_riscv_nacl *nacl;
+
+	if ((sbi_spec_version < sbi_mk_version(1, 0)) ||
+	    sbi_probe_extension(SBI_EXT_NACL) <= 0)
+		return -ENODEV;
+
+	/* Enable NACL support */
+	static_branch_enable(&kvm_riscv_nacl_available);
+
+	/* Probe NACL features */
+	if (nacl_probe_feature(SBI_NACL_FEAT_SYNC_CSR))
+		static_branch_enable(&kvm_riscv_nacl_sync_csr_available);
+	if (nacl_probe_feature(SBI_NACL_FEAT_SYNC_HFENCE))
+		static_branch_enable(&kvm_riscv_nacl_sync_hfence_available);
+	if (nacl_probe_feature(SBI_NACL_FEAT_SYNC_SRET))
+		static_branch_enable(&kvm_riscv_nacl_sync_sret_available);
+	if (nacl_probe_feature(SBI_NACL_FEAT_AUTOSWAP_CSR))
+		static_branch_enable(&kvm_riscv_nacl_autoswap_csr_available);
+
+	/* Allocate per-CPU shared memory */
+	for_each_possible_cpu(cpu) {
+		nacl = per_cpu_ptr(&kvm_riscv_nacl, cpu);
+
+		shmem_page = alloc_pages(GFP_KERNEL | __GFP_ZERO,
+					 get_order(SBI_NACL_SHMEM_SIZE));
+		if (!shmem_page) {
+			kvm_riscv_nacl_exit();
+			return -ENOMEM;
+		}
+		nacl->shmem = page_to_virt(shmem_page);
+		nacl->shmem_phys = page_to_phys(shmem_page);
+	}
+
+	return 0;
+}
diff --git a/arch/riscv/kvm/tlb.c b/arch/riscv/kvm/tlb.c
index 44bc324aeeb0..7d23956c4449 100644
--- a/arch/riscv/kvm/tlb.c
+++ b/arch/riscv/kvm/tlb.c
@@ -14,6 +14,8 @@
 #include <asm/csr.h>
 #include <asm/hwcap.h>
 #include <asm/insn-def.h>
+#include <asm/kvm_nacl.h>
+#include <asm/kvm_cove.h>
 
 #define has_svinval()	riscv_has_extension_unlikely(RISCV_ISA_EXT_SVINVAL)
 
@@ -71,6 +73,14 @@ void kvm_riscv_local_hfence_gvma_gpa(gpa_t gpa, gpa_t gpsz,
 
 void kvm_riscv_local_hfence_gvma_all(void)
 {
+	/* For TVMs, TSM will take care of hfence.
+	 * TODO: We can't skip unconditionally if cove is enabled
+	 * as the host may be running in HS-mode and need to issue hfence
+	 * for legacy VMs.
+	 */
+	if (kvm_riscv_cove_enabled())
+		return;
+
 	asm volatile(HFENCE_GVMA(zero, zero) : : : "memory");
 }
 
@@ -159,7 +169,7 @@ void kvm_riscv_local_tlb_sanitize(struct kvm_vcpu *vcpu)
 {
 	unsigned long vmid;
 
-	if (!kvm_riscv_gstage_vmid_bits() ||
+	if (is_cove_vm_finalized(vcpu->kvm) || !kvm_riscv_gstage_vmid_bits() ||
 	    vcpu->arch.last_exit_cpu == vcpu->cpu)
 		return;
 
@@ -186,18 +196,24 @@ void kvm_riscv_fence_i_process(struct kvm_vcpu *vcpu)
 
 void kvm_riscv_hfence_gvma_vmid_all_process(struct kvm_vcpu *vcpu)
 {
-	struct kvm_vmid *vmid;
+	struct kvm_vmid *v = &vcpu->kvm->arch.vmid;
+	unsigned long vmid = READ_ONCE(v->vmid);
 
-	vmid = &vcpu->kvm->arch.vmid;
-	kvm_riscv_local_hfence_gvma_vmid_all(READ_ONCE(vmid->vmid));
+	if (kvm_riscv_nacl_sync_hfence_available())
+		nacl_shmem_hfence_gvma_vmid_all(nacl_shmem(), vmid);
+	else
+		kvm_riscv_local_hfence_gvma_vmid_all(vmid);
 }
 
 void kvm_riscv_hfence_vvma_all_process(struct kvm_vcpu *vcpu)
 {
-	struct kvm_vmid *vmid;
+	struct kvm_vmid *v = &vcpu->kvm->arch.vmid;
+	unsigned long vmid = READ_ONCE(v->vmid);
 
-	vmid = &vcpu->kvm->arch.vmid;
-	kvm_riscv_local_hfence_vvma_all(READ_ONCE(vmid->vmid));
+	if (kvm_riscv_nacl_sync_hfence_available())
+		nacl_shmem_hfence_vvma_all(nacl_shmem(), vmid);
+	else
+		kvm_riscv_local_hfence_vvma_all(vmid);
 }
 
 static bool vcpu_hfence_dequeue(struct kvm_vcpu *vcpu,
@@ -251,6 +267,7 @@ static bool vcpu_hfence_enqueue(struct kvm_vcpu *vcpu,
 
 void kvm_riscv_hfence_process(struct kvm_vcpu *vcpu)
 {
+	unsigned long vmid;
 	struct kvm_riscv_hfence d = { 0 };
 	struct kvm_vmid *v = &vcpu->kvm->arch.vmid;
 
@@ -259,25 +276,45 @@ void kvm_riscv_hfence_process(struct kvm_vcpu *vcpu)
 		case KVM_RISCV_HFENCE_UNKNOWN:
 			break;
 		case KVM_RISCV_HFENCE_GVMA_VMID_GPA:
-			kvm_riscv_local_hfence_gvma_vmid_gpa(
-						READ_ONCE(v->vmid),
+			vmid = READ_ONCE(v->vmid);
+			if (kvm_riscv_nacl_sync_hfence_available())
+				nacl_shmem_hfence_gvma_vmid(
+						nacl_shmem(), vmid,
+						d.addr, d.size, d.order);
+			else
+				kvm_riscv_local_hfence_gvma_vmid_gpa(vmid,
 						d.addr, d.size, d.order);
 			break;
 		case KVM_RISCV_HFENCE_VVMA_ASID_GVA:
 			kvm_riscv_vcpu_pmu_incr_fw(vcpu, SBI_PMU_FW_HFENCE_VVMA_ASID_RCVD);
-			kvm_riscv_local_hfence_vvma_asid_gva(
-						READ_ONCE(v->vmid), d.asid,
+			vmid = READ_ONCE(v->vmid);
+			if (kvm_riscv_nacl_sync_hfence_available())
+				nacl_shmem_hfence_vvma_asid(
+						nacl_shmem(), vmid, d.asid,
+						d.addr, d.size, d.order);
+			else
+				kvm_riscv_local_hfence_vvma_asid_gva(
+						vmid, d.asid,
 						d.addr, d.size, d.order);
 			break;
 		case KVM_RISCV_HFENCE_VVMA_ASID_ALL:
 			kvm_riscv_vcpu_pmu_incr_fw(vcpu, SBI_PMU_FW_HFENCE_VVMA_ASID_RCVD);
-			kvm_riscv_local_hfence_vvma_asid_all(
-						READ_ONCE(v->vmid), d.asid);
+			vmid = READ_ONCE(v->vmid);
+			if (kvm_riscv_nacl_sync_hfence_available())
+				nacl_shmem_hfence_vvma_asid_all(
+						nacl_shmem(), vmid, d.asid);
+			else
+				kvm_riscv_local_hfence_vvma_asid_all(
+						vmid, d.asid);
 			break;
 		case KVM_RISCV_HFENCE_VVMA_GVA:
 			kvm_riscv_vcpu_pmu_incr_fw(vcpu, SBI_PMU_FW_HFENCE_VVMA_RCVD);
-			kvm_riscv_local_hfence_vvma_gva(
-						READ_ONCE(v->vmid),
+			vmid = READ_ONCE(v->vmid);
+			if (kvm_riscv_nacl_sync_hfence_available())
+				nacl_shmem_hfence_vvma(nacl_shmem(), vmid,
+						d.addr, d.size, d.order);
+			else
+				kvm_riscv_local_hfence_vvma_gva(vmid,
 						d.addr, d.size, d.order);
 			break;
 		default:
diff --git a/arch/riscv/kvm/vcpu.c b/arch/riscv/kvm/vcpu.c
index 82229db1ce73..725a180f4b8f 100644
--- a/arch/riscv/kvm/vcpu.c
+++ b/arch/riscv/kvm/vcpu.c
@@ -17,9 +17,12 @@
 #include <linux/sched/signal.h>
 #include <linux/fs.h>
 #include <linux/kvm_host.h>
-#include <asm/csr.h>
 #include <asm/cacheflush.h>
 #include <asm/kvm_vcpu_vector.h>
+#include <asm/kvm_nacl.h>
+#include <asm/hwcap.h>
+#include <asm/sbi.h>
+#include <asm/kvm_cove.h>
 
 const struct _kvm_stats_desc kvm_vcpu_stats_desc[] = {
 	KVM_GENERIC_VCPU_STATS(),
@@ -149,12 +152,30 @@ int kvm_arch_vcpu_create(struct kvm_vcpu *vcpu)
 
 void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)
 {
+	int rc;
+	/*
+	 * TODO: Ideally it should be invoked in vcpu_create. but vcpu_idx
+	 * is allocated after returning create_vcpu. Find a better place to do it
+	 */
+	if (unlikely(is_cove_vcpu(vcpu))) {
+		rc = kvm_riscv_cove_vcpu_init(vcpu);
+		if (rc)
+			pr_err("%s: cove vcpu init failed %d\n", __func__, rc);
+	}
+
 	/**
 	 * vcpu with id 0 is the designated boot cpu.
 	 * Keep all vcpus with non-zero id in power-off state so that
 	 * they can be brought up using SBI HSM extension.
 	 */
-	if (vcpu->vcpu_idx != 0)
+	if (vcpu->vcpu_idx == 0) {
+		/*
+		 * The single-step CoVE guest creation process requires that
+		 * all TVM pages are present in the main memory during promotion.
+		*/
+		if (unlikely(is_cove_vm_single_step_initializing(vcpu->kvm)))
+			kvm_riscv_cove_gstage_preload(vcpu);
+	} else
 		kvm_riscv_vcpu_power_off(vcpu);
 }
 
@@ -168,6 +189,9 @@ void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)
 
 	kvm_riscv_vcpu_pmu_deinit(vcpu);
 
+	if (unlikely(is_cove_vcpu(vcpu)))
+		kvm_riscv_cove_vcpu_destroy(vcpu);
+
 	/* Free unused pages pre-allocated for G-stage page table mappings */
 	kvm_mmu_free_memory_cache(&vcpu->arch.mmu_page_cache);
 
@@ -219,6 +243,9 @@ long kvm_arch_vcpu_async_ioctl(struct file *filp,
 
 	if (ioctl == KVM_INTERRUPT) {
 		struct kvm_interrupt irq;
+		/* We do not support user space emulated IRQCHIP for TVMs that utilize AIA yet */
+		if (is_cove_vm_finalized(vcpu->kvm) && kvm_riscv_cove_capability(KVM_COVE_TSM_CAP_AIA))
+			return -ENXIO;
 
 		if (copy_from_user(&irq, argp, sizeof(irq)))
 			return -EFAULT;
@@ -341,10 +368,13 @@ void kvm_riscv_vcpu_sync_interrupts(struct kvm_vcpu *vcpu)
 	struct kvm_vcpu_csr *csr = &vcpu->arch.guest_csr;
 
 	/* Read current HVIP and VSIE CSRs */
-	csr->vsie = csr_read(CSR_VSIE);
+	csr->vsie = nacl_csr_read(CSR_VSIE);
 
-	/* Sync-up HVIP.VSSIP bit changes does by Guest */
-	hvip = csr_read(CSR_HVIP);
+	/*
+	 * Sync-up HVIP.VSSIP bit changes does by Guest. For TVMs,
+	 * the HVIP is not updated by the TSM. Expect it to be zero.
+	 */
+	hvip = nacl_csr_read(CSR_HVIP);
 	if ((csr->hvip ^ hvip) & (1UL << IRQ_VS_SOFT)) {
 		if (hvip & (1UL << IRQ_VS_SOFT)) {
 			if (!test_and_set_bit(IRQ_VS_SOFT,
@@ -471,7 +501,7 @@ int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,
 	return -EINVAL;
 }
 
-static void kvm_riscv_vcpu_update_config(const unsigned long *isa)
+static u64 kvm_riscv_vcpu_get_henvcfg(const unsigned long *isa)
 {
 	u64 henvcfg = 0;
 
@@ -487,27 +517,62 @@ static void kvm_riscv_vcpu_update_config(const unsigned long *isa)
 	if (riscv_isa_extension_available(isa, ZICBOZ))
 		henvcfg |= ENVCFG_CBZE;
 
-	csr_write(CSR_HENVCFG, henvcfg);
+
+#ifndef CONFIG_SOC_SIFIVE_EIC7700
+	if (kvm_riscv_nacl_sync_csr_available()) {
+		nacl_csr_write(CSR_HENVCFG, henvcfg);
+	} else {
+		csr_write(CSR_HENVCFG, henvcfg);
+	}
+#endif
+
 #ifdef CONFIG_32BIT
-	csr_write(CSR_HENVCFGH, henvcfg >> 32);
+	nacl_csr_write(CSR_HENVCFGH, henvcfg >> 32);
 #endif
+	return henvcfg;
 }
 
 void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
 {
+	void *nshmem;
+	u64 henvcfg = kvm_riscv_vcpu_get_henvcfg(vcpu->arch.isa);
 	struct kvm_vcpu_csr *csr = &vcpu->arch.guest_csr;
 
-	csr_write(CSR_VSSTATUS, csr->vsstatus);
-	csr_write(CSR_VSIE, csr->vsie);
-	csr_write(CSR_VSTVEC, csr->vstvec);
-	csr_write(CSR_VSSCRATCH, csr->vsscratch);
-	csr_write(CSR_VSEPC, csr->vsepc);
-	csr_write(CSR_VSCAUSE, csr->vscause);
-	csr_write(CSR_VSTVAL, csr->vstval);
-	csr_write(CSR_HVIP, csr->hvip);
-	csr_write(CSR_VSATP, csr->vsatp);
+	if (is_cove_vm_finalized(vcpu->kvm)) {
+		kvm_riscv_cove_vcpu_load(vcpu);
+		goto skip_load;
+	}
 
-	kvm_riscv_vcpu_update_config(vcpu->arch.isa);
+	if (unlikely(kvm_riscv_cove_enabled()) || kvm_riscv_nacl_sync_csr_available()) {
+		nshmem = nacl_shmem();
+		nacl_shmem_csr_write(nshmem, CSR_VSSTATUS, csr->vsstatus);
+		nacl_shmem_csr_write(nshmem, CSR_VSIE, csr->vsie);
+		nacl_shmem_csr_write(nshmem, CSR_VSTVEC, csr->vstvec);
+		nacl_shmem_csr_write(nshmem, CSR_VSSCRATCH, csr->vsscratch);
+		nacl_shmem_csr_write(nshmem, CSR_VSEPC, csr->vsepc);
+		nacl_shmem_csr_write(nshmem, CSR_VSCAUSE, csr->vscause);
+		nacl_shmem_csr_write(nshmem, CSR_VSTVAL, csr->vstval);
+		nacl_shmem_csr_write(nshmem, CSR_HVIP, csr->hvip);
+		nacl_shmem_csr_write(nshmem, CSR_VSATP, csr->vsatp);
+		nacl_shmem_csr_write(nshmem, CSR_HENVCFG, henvcfg);
+#ifdef CONFIG_32BIT
+		nacl_shmem_csr_write(nshmem, CSR_HENVCFGH, henvcfg >> 32);
+#endif
+	} else {
+		csr_write(CSR_VSSTATUS, csr->vsstatus);
+		csr_write(CSR_VSIE, csr->vsie);
+		csr_write(CSR_VSTVEC, csr->vstvec);
+		csr_write(CSR_VSSCRATCH, csr->vsscratch);
+		csr_write(CSR_VSEPC, csr->vsepc);
+		csr_write(CSR_VSCAUSE, csr->vscause);
+		csr_write(CSR_VSTVAL, csr->vstval);
+		csr_write(CSR_HVIP, csr->hvip);
+		csr_write(CSR_VSATP, csr->vsatp);
+		csr_write(CSR_HENVCFG, henvcfg);
+#ifdef CONFIG_32BIT
+		csr_write(CSR_HENVCFGH, henvcfg >> 32);
+#endif
+	}
 
 	kvm_riscv_gstage_update_hgatp(vcpu);
 
@@ -522,15 +587,22 @@ void kvm_arch_vcpu_load(struct kvm_vcpu *vcpu, int cpu)
 
 	kvm_riscv_vcpu_aia_load(vcpu, cpu);
 
+skip_load:
 	vcpu->cpu = cpu;
 }
 
 void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
 {
+	void *nshmem;
 	struct kvm_vcpu_csr *csr = &vcpu->arch.guest_csr;
 
 	vcpu->cpu = -1;
 
+	if (is_cove_vm_finalized(vcpu->kvm) || is_cove_vm_multi_step_initializing(vcpu->kvm)) {
+		kvm_riscv_cove_vcpu_put(vcpu);
+		return;
+	}
+
 	kvm_riscv_vcpu_aia_put(vcpu);
 
 	kvm_riscv_vcpu_guest_fp_save(&vcpu->arch.guest_context,
@@ -542,15 +614,33 @@ void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
 					 vcpu->arch.isa);
 	kvm_riscv_vcpu_host_vector_restore(&vcpu->arch.host_context);
 
-	csr->vsstatus = csr_read(CSR_VSSTATUS);
-	csr->vsie = csr_read(CSR_VSIE);
-	csr->vstvec = csr_read(CSR_VSTVEC);
-	csr->vsscratch = csr_read(CSR_VSSCRATCH);
-	csr->vsepc = csr_read(CSR_VSEPC);
-	csr->vscause = csr_read(CSR_VSCAUSE);
-	csr->vstval = csr_read(CSR_VSTVAL);
-	csr->hvip = csr_read(CSR_HVIP);
-	csr->vsatp = csr_read(CSR_VSATP);
+	if (kvm_riscv_nacl_sync_csr_available()) {
+		/**
+		 * For TVMs, we don't need a separate case as TSM only updates
+		 * the required CSRs during the world switch. All other CSR
+		 * value should be zeroed out by TSM anyways.
+		 */
+		nshmem = nacl_shmem();
+		csr->vsstatus = nacl_shmem_csr_read(nshmem, CSR_VSSTATUS);
+		csr->vsie = nacl_shmem_csr_read(nshmem, CSR_VSIE);
+		csr->vstvec = nacl_shmem_csr_read(nshmem, CSR_VSTVEC);
+		csr->vsscratch = nacl_shmem_csr_read(nshmem, CSR_VSSCRATCH);
+		csr->vsepc = nacl_shmem_csr_read(nshmem, CSR_VSEPC);
+		csr->vscause = nacl_shmem_csr_read(nshmem, CSR_VSCAUSE);
+		csr->vstval = nacl_shmem_csr_read(nshmem, CSR_VSTVAL);
+		csr->hvip = nacl_shmem_csr_read(nshmem, CSR_HVIP);
+		csr->vsatp = nacl_shmem_csr_read(nshmem, CSR_VSATP);
+	} else {
+		csr->vsstatus = csr_read(CSR_VSSTATUS);
+		csr->vsie = csr_read(CSR_VSIE);
+		csr->vstvec = csr_read(CSR_VSTVEC);
+		csr->vsscratch = csr_read(CSR_VSSCRATCH);
+		csr->vsepc = csr_read(CSR_VSEPC);
+		csr->vscause = csr_read(CSR_VSCAUSE);
+		csr->vstval = csr_read(CSR_VSTVAL);
+		csr->hvip = csr_read(CSR_HVIP);
+		csr->vsatp = csr_read(CSR_VSATP);
+	}
 }
 
 static void kvm_riscv_check_vcpu_requests(struct kvm_vcpu *vcpu)
@@ -577,6 +667,15 @@ static void kvm_riscv_check_vcpu_requests(struct kvm_vcpu *vcpu)
 		if (kvm_check_request(KVM_REQ_VCPU_RESET, vcpu))
 			kvm_riscv_reset_vcpu(vcpu);
 
+		if (is_cove_vm_finalized(vcpu->kvm)) {
+			/*
+			 * KVM doesn't need to do anything special here
+			 * as the TSM is expected track the tlb version and issue
+			 * hfence when vcpu is scheduled again.
+			 */
+			return;
+		}
+
 		if (kvm_check_request(KVM_REQ_UPDATE_HGATP, vcpu))
 			kvm_riscv_gstage_update_hgatp(vcpu);
 
@@ -602,7 +701,7 @@ static void kvm_riscv_update_hvip(struct kvm_vcpu *vcpu)
 {
 	struct kvm_vcpu_csr *csr = &vcpu->arch.guest_csr;
 
-	csr_write(CSR_HVIP, csr->hvip);
+	nacl_csr_write(CSR_HVIP, csr->hvip);
 	kvm_riscv_vcpu_aia_update_hvip(vcpu);
 }
 
@@ -613,10 +712,86 @@ static void kvm_riscv_update_hvip(struct kvm_vcpu *vcpu)
  * This must be noinstr as instrumentation may make use of RCU, and this is not
  * safe during the EQS.
  */
-static void noinstr kvm_riscv_vcpu_enter_exit(struct kvm_vcpu *vcpu)
+static void noinstr kvm_riscv_vcpu_enter_exit(struct kvm_vcpu *vcpu,
+					      struct kvm_cpu_trap *trap)
 {
+	void *nshmem;
+	struct kvm_cpu_context *gcntx = &vcpu->arch.guest_context;
+	struct kvm_cpu_context *hcntx = &vcpu->arch.host_context;
+
+	/*
+	 * We save trap CSRs (such as SEPC, SCAUSE, STVAL, HTVAL, and
+	 * HTINST) here because we do local_irq_enable() after this
+	 * function in kvm_arch_vcpu_ioctl_run() which can result in
+	 * an interrupt immediately after local_irq_enable() and can
+	 * potentially change trap CSRs.
+	 */
+
 	guest_state_enter_irqoff();
-	__kvm_riscv_switch_to(&vcpu->arch);
+
+	if (kvm_riscv_nacl_sync_sret_available()) {
+		nshmem = nacl_shmem();
+
+		if (kvm_riscv_nacl_autoswap_csr_available()) {
+			hcntx->hstatus =
+				nacl_shmem_csr_read(nshmem, CSR_HSTATUS);
+			nacl_shmem_scratch_write_long(nshmem,
+					SBI_NACL_SHMEM_AUTOSWAP_OFFSET +
+					SBI_NACL_SHMEM_AUTOSWAP_HSTATUS,
+					gcntx->hstatus);
+			nacl_shmem_scratch_write_long(nshmem,
+					SBI_NACL_SHMEM_AUTOSWAP_OFFSET,
+					SBI_NACL_SHMEM_AUTOSWAP_FLAG_HSTATUS);
+		} else if (kvm_riscv_nacl_sync_csr_available()) {
+			hcntx->hstatus = nacl_shmem_csr_swap(nshmem,
+						CSR_HSTATUS, gcntx->hstatus);
+		} else {
+			hcntx->hstatus = csr_swap(CSR_HSTATUS, gcntx->hstatus);
+		}
+
+		nacl_shmem_scratch_write_longs(nshmem,
+					SBI_NACL_SHMEM_SRET_OFFSET +
+					SBI_NACL_SHMEM_SRET_X(1),
+					&gcntx->ra,
+					SBI_NACL_SHMEM_SRET_X_LAST);
+
+		__kvm_riscv_nacl_switch_to(&vcpu->arch, SBI_EXT_NACL,
+					   SBI_EXT_NACL_SYNC_SRET);
+
+		if (kvm_riscv_nacl_autoswap_csr_available()) {
+			nacl_shmem_scratch_write_long(nshmem,
+					SBI_NACL_SHMEM_AUTOSWAP_OFFSET,
+					0);
+			gcntx->hstatus = nacl_shmem_scratch_read_long(nshmem,
+					SBI_NACL_SHMEM_AUTOSWAP_OFFSET +
+					SBI_NACL_SHMEM_AUTOSWAP_HSTATUS);
+		} else {
+			gcntx->hstatus = csr_swap(CSR_HSTATUS, hcntx->hstatus);
+		}
+
+		trap->htval = nacl_shmem_csr_read(nshmem, CSR_HTVAL);
+		trap->htinst = nacl_shmem_csr_read(nshmem, CSR_HTINST);
+	} else if (is_cove_vcpu(vcpu)) {
+		nshmem = nacl_shmem();
+		kvm_riscv_cove_vcpu_switchto(vcpu, trap);
+
+		trap->htval = nacl_shmem_csr_read(nshmem, CSR_HTVAL);
+		trap->htinst = nacl_shmem_csr_read(nshmem, CSR_HTINST);
+	} else {
+		hcntx->hstatus = csr_swap(CSR_HSTATUS, gcntx->hstatus);
+
+		__kvm_riscv_switch_to(&vcpu->arch);
+
+		gcntx->hstatus = csr_swap(CSR_HSTATUS, hcntx->hstatus);
+
+		trap->htval = csr_read(CSR_HTVAL);
+		trap->htinst = csr_read(CSR_HTINST);
+	}
+
+	trap->sepc = gcntx->sepc;
+	trap->scause = csr_read(CSR_SCAUSE);
+	trap->stval = csr_read(CSR_STVAL);
+
 	vcpu->arch.last_exit_cpu = vcpu->cpu;
 	guest_state_exit_irqoff();
 }
@@ -676,14 +851,15 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
 
 		kvm_riscv_check_vcpu_requests(vcpu);
 
-		preempt_disable();
-
 		/* Update AIA HW state before entering guest */
+		// ACE potential merge problem with enable/disable irqs
+		preempt_disable();
 		ret = kvm_riscv_vcpu_aia_update(vcpu);
 		if (ret <= 0) {
 			preempt_enable();
 			continue;
 		}
+		// preempt_enable();
 
 		local_irq_disable();
 
@@ -704,11 +880,15 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
 		 */
 		kvm_riscv_vcpu_flush_interrupts(vcpu);
 
-		/* Update HVIP CSR for current CPU */
-		kvm_riscv_update_hvip(vcpu);
+		/*
+		 * Do not update HVIP CSR for TVMs with AIA because AIA
+		 * provides alternative method to inject interrupts.
+		*/
+		if (!is_cove_vcpu(vcpu) || !kvm_riscv_cove_capability(KVM_COVE_TSM_CAP_AIA))
+			kvm_riscv_update_hvip(vcpu);
 
 		if (ret <= 0 ||
-		    kvm_riscv_gstage_vmid_ver_changed(&vcpu->kvm->arch.vmid) ||
+		    kvm_riscv_gstage_vmid_ver_changed(vcpu->kvm) ||
 		    kvm_request_pending(vcpu) ||
 		    xfer_to_guest_mode_work_pending()) {
 			vcpu->mode = OUTSIDE_GUEST_MODE;
@@ -728,22 +908,11 @@ int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
 
 		guest_timing_enter_irqoff();
 
-		kvm_riscv_vcpu_enter_exit(vcpu);
+		kvm_riscv_vcpu_enter_exit(vcpu, &trap);
 
 		vcpu->mode = OUTSIDE_GUEST_MODE;
 		vcpu->stat.exits++;
 
-		/*
-		 * Save SCAUSE, STVAL, HTVAL, and HTINST because we might
-		 * get an interrupt between __kvm_riscv_switch_to() and
-		 * local_irq_enable() which can potentially change CSRs.
-		 */
-		trap.sepc = vcpu->arch.guest_context.sepc;
-		trap.scause = csr_read(CSR_SCAUSE);
-		trap.stval = csr_read(CSR_STVAL);
-		trap.htval = csr_read(CSR_HTVAL);
-		trap.htinst = csr_read(CSR_HTINST);
-
 		/* Syncup interrupts state with HW */
 		kvm_riscv_vcpu_sync_interrupts(vcpu);
 
diff --git a/arch/riscv/kvm/vcpu_exit.c b/arch/riscv/kvm/vcpu_exit.c
index 2415722c01b8..e47695c20dc5 100644
--- a/arch/riscv/kvm/vcpu_exit.c
+++ b/arch/riscv/kvm/vcpu_exit.c
@@ -9,6 +9,7 @@
 #include <linux/kvm_host.h>
 #include <asm/csr.h>
 #include <asm/insn-def.h>
+#include <asm/kvm_cove.h>
 
 static int gstage_page_fault(struct kvm_vcpu *vcpu, struct kvm_run *run,
 			     struct kvm_cpu_trap *trap)
@@ -40,8 +41,13 @@ static int gstage_page_fault(struct kvm_vcpu *vcpu, struct kvm_run *run,
 		};
 	}
 
-	ret = kvm_riscv_gstage_map(vcpu, memslot, fault_addr, hva,
-		(trap->scause == EXC_STORE_GUEST_PAGE_FAULT) ? true : false);
+	if (is_cove_vm_finalized(vcpu->kvm)) {
+		/* CoVE doesn't care about PTE prots now. No need to compute the prots */
+		ret = kvm_riscv_cove_handle_pagefault(vcpu, fault_addr, hva);
+	} else {
+		ret = kvm_riscv_gstage_map(vcpu, memslot, fault_addr, hva,
+			(trap->scause == EXC_STORE_GUEST_PAGE_FAULT) ? true : false);
+	}
 	if (ret < 0)
 		return ret;
 
@@ -135,8 +141,14 @@ unsigned long kvm_riscv_vcpu_unpriv_read(struct kvm_vcpu *vcpu,
 void kvm_riscv_vcpu_trap_redirect(struct kvm_vcpu *vcpu,
 				  struct kvm_cpu_trap *trap)
 {
-	unsigned long vsstatus = csr_read(CSR_VSSTATUS);
+	unsigned long vsstatus;
+
+	if (is_cove_vm_finalized(vcpu->kvm)) {
+		kvm_err("RISC-V KVM do not support redirect to CoVE guest yet\n");
+		return;
+	}
 
+	vsstatus = csr_read(CSR_VSSTATUS);
 	/* Change Guest SSTATUS.SPP bit */
 	vsstatus &= ~SR_SPP;
 	if (vcpu->arch.guest_context.sstatus & SR_SPP)
@@ -197,13 +209,26 @@ int kvm_riscv_vcpu_exit(struct kvm_vcpu *vcpu, struct kvm_run *run,
 	case EXC_INST_GUEST_PAGE_FAULT:
 	case EXC_LOAD_GUEST_PAGE_FAULT:
 	case EXC_STORE_GUEST_PAGE_FAULT:
+		//TODO: If the host runs in HS mode, this won't work as we don't
+		//read hstatus from the shared memory yet
 		if (vcpu->arch.guest_context.hstatus & HSTATUS_SPV)
 			ret = gstage_page_fault(vcpu, run, trap);
 		break;
 	case EXC_SUPERVISOR_SYSCALL:
-		if (vcpu->arch.guest_context.hstatus & HSTATUS_SPV)
+		if (is_cove_vm_finalized(vcpu->kvm))
+			ret = kvm_riscv_cove_vcpu_sbi_ecall(vcpu, run);
+		else if (vcpu->arch.guest_context.hstatus & HSTATUS_SPV)
 			ret = kvm_riscv_vcpu_sbi_ecall(vcpu, run);
 		break;
+	case EXC_CUSTOM_KVM_COVE_RUN_FAIL:
+		if (likely(is_cove_vm_finalized(vcpu->kvm))) {
+			ret = -EACCES;
+			run->fail_entry.hardware_entry_failure_reason =
+				KVM_EXIT_FAIL_ENTRY_COVE_RUN_VCPU;
+			run->fail_entry.cpu = vcpu->cpu;
+			run->exit_reason = KVM_EXIT_FAIL_ENTRY;
+		}
+		break;
 	default:
 		break;
 	}
@@ -211,6 +236,7 @@ int kvm_riscv_vcpu_exit(struct kvm_vcpu *vcpu, struct kvm_run *run,
 	/* Print details in-case of error */
 	if (ret < 0) {
 		kvm_err("VCPU exit error %d\n", ret);
+		//TODO: These values are bogus/stale for a TVM. Improve it
 		kvm_err("SEPC=0x%lx SSTATUS=0x%lx HSTATUS=0x%lx\n",
 			vcpu->arch.guest_context.sepc,
 			vcpu->arch.guest_context.sstatus,
diff --git a/arch/riscv/kvm/vcpu_insn.c b/arch/riscv/kvm/vcpu_insn.c
index 7a6abed41bc1..cd3366bd1d87 100644
--- a/arch/riscv/kvm/vcpu_insn.c
+++ b/arch/riscv/kvm/vcpu_insn.c
@@ -6,6 +6,10 @@
 
 #include <linux/bitops.h>
 #include <linux/kvm_host.h>
+#include <asm/kvm_cove.h>
+#include <asm/kvm_nacl.h>
+#include <asm/kvm_cove_sbi.h>
+#include <asm/asm-offsets.h>
 
 #define INSN_OPCODE_MASK	0x007c
 #define INSN_OPCODE_SHIFT	2
@@ -115,6 +119,10 @@
 #define REG_OFFSET(insn, pos)		\
 	(SHIFT_RIGHT((insn), (pos) - LOG_REGBYTES) & REG_MASK)
 
+#define REG_INDEX(insn, pos)                                    \
+	((SHIFT_RIGHT((insn), (pos)-LOG_REGBYTES) & REG_MASK) / \
+	 (__riscv_xlen / 8))
+
 #define REG_PTR(insn, pos, regs)	\
 	((ulong *)((ulong)(regs) + REG_OFFSET(insn, pos)))
 
@@ -153,6 +161,10 @@ static int truly_illegal_insn(struct kvm_vcpu *vcpu, struct kvm_run *run,
 {
 	struct kvm_cpu_trap utrap = { 0 };
 
+	/* The host can not redirect any illegal instruction trap to TVM */
+	if (unlikely(is_cove_vm_finalized(vcpu->kvm)))
+		return -EPERM;
+
 	/* Redirect trap to Guest VCPU */
 	utrap.sepc = vcpu->arch.guest_context.sepc;
 	utrap.scause = EXC_INST_ILLEGAL;
@@ -169,6 +181,10 @@ static int truly_virtual_insn(struct kvm_vcpu *vcpu, struct kvm_run *run,
 {
 	struct kvm_cpu_trap utrap = { 0 };
 
+	/* The host can not redirect any virtual instruction trap to TVM */
+	if (unlikely(is_cove_vm_finalized(vcpu->kvm)))
+		return -EPERM;
+
 	/* Redirect trap to Guest VCPU */
 	utrap.sepc = vcpu->arch.guest_context.sepc;
 	utrap.scause = EXC_VIRTUAL_INST_FAULT;
@@ -417,6 +433,10 @@ int kvm_riscv_vcpu_virtual_insn(struct kvm_vcpu *vcpu, struct kvm_run *run,
 	if (unlikely(INSN_IS_16BIT(insn))) {
 		if (insn == 0) {
 			ct = &vcpu->arch.guest_context;
+
+			if (unlikely(is_cove_vm_finalized(vcpu->kvm)))
+				return -EPERM;
+
 			insn = kvm_riscv_vcpu_unpriv_read(vcpu, true,
 							  ct->sepc,
 							  &utrap);
@@ -469,6 +489,8 @@ int kvm_riscv_vcpu_mmio_load(struct kvm_vcpu *vcpu, struct kvm_run *run,
 		insn = htinst | INSN_16BIT_MASK;
 		insn_len = (htinst & BIT(1)) ? INSN_LEN(insn) : 2;
 	} else {
+		if (unlikely(is_cove_vm_finalized(vcpu->kvm)))
+			return -EFAULT;
 		/*
 		 * Bit[0] == 0 implies trapped instruction value is
 		 * zero or special value.
@@ -585,6 +607,7 @@ int kvm_riscv_vcpu_mmio_store(struct kvm_vcpu *vcpu, struct kvm_run *run,
 	int len = 0, insn_len = 0;
 	struct kvm_cpu_trap utrap = { 0 };
 	struct kvm_cpu_context *ct = &vcpu->arch.guest_context;
+	void *nshmem;
 
 	/* Determine trapped instruction */
 	if (htinst & 0x1) {
@@ -595,6 +618,8 @@ int kvm_riscv_vcpu_mmio_store(struct kvm_vcpu *vcpu, struct kvm_run *run,
 		insn = htinst | INSN_16BIT_MASK;
 		insn_len = (htinst & BIT(1)) ? INSN_LEN(insn) : 2;
 	} else {
+		if (unlikely(is_cove_vm_finalized(vcpu->kvm)))
+			return -EFAULT;
 		/*
 		 * Bit[0] == 0 implies trapped instruction value is
 		 * zero or special value.
@@ -610,7 +635,15 @@ int kvm_riscv_vcpu_mmio_store(struct kvm_vcpu *vcpu, struct kvm_run *run,
 		insn_len = INSN_LEN(insn);
 	}
 
-	data = GET_RS2(insn, &vcpu->arch.guest_context);
+	if (is_cove_vm_finalized(vcpu->kvm)) {
+		nshmem = nacl_shmem();
+		data = nacl_shmem_gpr_read_cove(nshmem,
+					       REG_INDEX(insn, SH_RS2) * 8 +
+						       KVM_ARCH_GUEST_ZERO);
+	} else {
+		data = GET_RS2(insn, &vcpu->arch.guest_context);
+	}
+
 	data8 = data16 = data32 = data64 = data;
 
 	if ((insn & INSN_MASK_SW) == INSN_MATCH_SW) {
@@ -626,19 +659,43 @@ int kvm_riscv_vcpu_mmio_store(struct kvm_vcpu *vcpu, struct kvm_run *run,
 #ifdef CONFIG_64BIT
 	} else if ((insn & INSN_MASK_C_SD) == INSN_MATCH_C_SD) {
 		len = 8;
-		data64 = GET_RS2S(insn, &vcpu->arch.guest_context);
+		if (is_cove_vm_finalized(vcpu->kvm)) {
+			data64 = nacl_shmem_gpr_read_cove(
+				nshmem,
+				RVC_RS2S(insn) * 8 + KVM_ARCH_GUEST_ZERO);
+		} else {
+			data64 = GET_RS2S(insn, &vcpu->arch.guest_context);
+		}
 	} else if ((insn & INSN_MASK_C_SDSP) == INSN_MATCH_C_SDSP &&
 		   ((insn >> SH_RD) & 0x1f)) {
 		len = 8;
-		data64 = GET_RS2C(insn, &vcpu->arch.guest_context);
+		if (is_cove_vm_finalized(vcpu->kvm)) {
+			data64 = nacl_shmem_gpr_read_cove(
+				nshmem, REG_INDEX(insn, SH_RS2C) * 8 +
+						KVM_ARCH_GUEST_ZERO);
+		} else {
+			data64 = GET_RS2C(insn, &vcpu->arch.guest_context);
+		}
 #endif
 	} else if ((insn & INSN_MASK_C_SW) == INSN_MATCH_C_SW) {
 		len = 4;
-		data32 = GET_RS2S(insn, &vcpu->arch.guest_context);
+		if (is_cove_vm_finalized(vcpu->kvm)) {
+			data32 = nacl_shmem_gpr_read_cove(
+				nshmem,
+				RVC_RS2S(insn) * 8 + KVM_ARCH_GUEST_ZERO);
+		} else {
+			data32 = GET_RS2S(insn, &vcpu->arch.guest_context);
+		}
 	} else if ((insn & INSN_MASK_C_SWSP) == INSN_MATCH_C_SWSP &&
 		   ((insn >> SH_RD) & 0x1f)) {
 		len = 4;
-		data32 = GET_RS2C(insn, &vcpu->arch.guest_context);
+		if (is_cove_vm_finalized(vcpu->kvm)) {
+			data32 = nacl_shmem_gpr_read_cove(
+				nshmem, REG_INDEX(insn, SH_RS2C) * 8 +
+						KVM_ARCH_GUEST_ZERO);
+		} else {
+			data32 = GET_RS2C(insn, &vcpu->arch.guest_context);
+		}
 	} else {
 		return -EOPNOTSUPP;
 	}
@@ -708,6 +765,7 @@ int kvm_riscv_vcpu_mmio_return(struct kvm_vcpu *vcpu, struct kvm_run *run)
 	u64 data64;
 	ulong insn;
 	int len, shift;
+	void *nshmem;
 
 	if (vcpu->arch.mmio_decode.return_handled)
 		return 0;
@@ -721,26 +779,57 @@ int kvm_riscv_vcpu_mmio_return(struct kvm_vcpu *vcpu, struct kvm_run *run)
 	len = vcpu->arch.mmio_decode.len;
 	shift = vcpu->arch.mmio_decode.shift;
 
+	if (is_cove_vm_finalized(vcpu->kvm))
+		nshmem = nacl_shmem();
+
 	switch (len) {
 	case 1:
 		data8 = *((u8 *)run->mmio.data);
-		SET_RD(insn, &vcpu->arch.guest_context,
-			(ulong)data8 << shift >> shift);
+		if (is_cove_vm_finalized(vcpu->kvm)) {
+			nacl_shmem_gpr_write_cove(nshmem,
+						 REG_INDEX(insn, SH_RD) * 8 +
+							 KVM_ARCH_GUEST_ZERO,
+						 (unsigned long)data8);
+		} else {
+			SET_RD(insn, &vcpu->arch.guest_context,
+			       (ulong)data8 << shift >> shift);
+		}
 		break;
 	case 2:
 		data16 = *((u16 *)run->mmio.data);
-		SET_RD(insn, &vcpu->arch.guest_context,
-			(ulong)data16 << shift >> shift);
+		if (is_cove_vm_finalized(vcpu->kvm)) {
+			nacl_shmem_gpr_write_cove(nshmem,
+						 REG_INDEX(insn, SH_RD) * 8 +
+							 KVM_ARCH_GUEST_ZERO,
+						 (unsigned long)data16);
+		} else {
+			SET_RD(insn, &vcpu->arch.guest_context,
+			       (ulong)data16 << shift >> shift);
+		}
 		break;
 	case 4:
 		data32 = *((u32 *)run->mmio.data);
-		SET_RD(insn, &vcpu->arch.guest_context,
-			(ulong)data32 << shift >> shift);
+		if (is_cove_vm_finalized(vcpu->kvm)) {
+			nacl_shmem_gpr_write_cove(nshmem,
+						 REG_INDEX(insn, SH_RD) * 8 +
+							 KVM_ARCH_GUEST_ZERO,
+						 (unsigned long)data32);
+		} else {
+			SET_RD(insn, &vcpu->arch.guest_context,
+			       (ulong)data32 << shift >> shift);
+		}
 		break;
 	case 8:
 		data64 = *((u64 *)run->mmio.data);
-		SET_RD(insn, &vcpu->arch.guest_context,
-			(ulong)data64 << shift >> shift);
+		if (is_cove_vm_finalized(vcpu->kvm)) {
+			nacl_shmem_gpr_write_cove(nshmem,
+						 REG_INDEX(insn, SH_RD) * 8 +
+							 KVM_ARCH_GUEST_ZERO,
+						 (unsigned long)data64);
+		} else {
+			SET_RD(insn, &vcpu->arch.guest_context,
+			       (ulong)data64 << shift >> shift);
+		}
 		break;
 	default:
 		return -EOPNOTSUPP;
diff --git a/arch/riscv/kvm/vcpu_sbi.c b/arch/riscv/kvm/vcpu_sbi.c
index 9cd97091c723..2efbf22570e1 100644
--- a/arch/riscv/kvm/vcpu_sbi.c
+++ b/arch/riscv/kvm/vcpu_sbi.c
@@ -10,7 +10,11 @@
 #include <linux/err.h>
 #include <linux/kvm_host.h>
 #include <asm/sbi.h>
+#include <asm/kvm_nacl.h>
+#include <asm/kvm_cove_sbi.h>
 #include <asm/kvm_vcpu_sbi.h>
+#include <asm/asm-offsets.h>
+#include <asm/kvm_cove.h>
 
 #ifndef CONFIG_RISCV_SBI_V01
 static const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_v01 = {
@@ -28,6 +32,19 @@ static const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_pmu = {
 };
 #endif
 
+#ifndef CONFIG_RISCV_COVE_HOST
+static const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_covg = {
+	.extid_start = -1UL,
+	.extid_end = -1UL,
+	.handler = NULL,
+};
+static const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_covh = {
+	.extid_start = -1UL,
+	.extid_end = -1UL,
+	.handler = NULL,
+};
+#endif
+
 struct kvm_riscv_sbi_extension_entry {
 	enum KVM_RISCV_SBI_EXT_ID ext_idx;
 	const struct kvm_vcpu_sbi_extension *ext_ptr;
@@ -66,6 +83,10 @@ static const struct kvm_riscv_sbi_extension_entry sbi_ext[] = {
 		.ext_idx = KVM_RISCV_SBI_EXT_PMU,
 		.ext_ptr = &vcpu_sbi_ext_pmu,
 	},
+	{
+		.ext_idx = KVM_RISCV_SBI_EXT_DBCN,
+		.ext_ptr = &vcpu_sbi_ext_dbcn,
+	},
 	{
 		.ext_idx = KVM_RISCV_SBI_EXT_EXPERIMENTAL,
 		.ext_ptr = &vcpu_sbi_ext_experimental,
@@ -74,6 +95,14 @@ static const struct kvm_riscv_sbi_extension_entry sbi_ext[] = {
 		.ext_idx = KVM_RISCV_SBI_EXT_VENDOR,
 		.ext_ptr = &vcpu_sbi_ext_vendor,
 	},
+	{
+		.ext_idx = KVM_RISCV_SBI_EXT_COVG,
+		.ext_ptr = &vcpu_sbi_ext_covg,
+	},
+	{
+		.ext_idx = KVM_RISCV_SBI_EXT_COVH,
+		.ext_ptr = &vcpu_sbi_ext_covh,
+	},
 };
 
 void kvm_riscv_vcpu_sbi_forward(struct kvm_vcpu *vcpu, struct kvm_run *run)
diff --git a/arch/riscv/kvm/vcpu_sbi_covg.c b/arch/riscv/kvm/vcpu_sbi_covg.c
new file mode 100644
index 000000000000..3d52cc168a72
--- /dev/null
+++ b/arch/riscv/kvm/vcpu_sbi_covg.c
@@ -0,0 +1,226 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023 Rivos Inc.
+ *
+ * Authors:
+ *     Rajnesh Kanwal <rkanwal@rivosinc.com>
+ */
+
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/kvm_host.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/spinlock.h>
+#include <asm/csr.h>
+#include <asm/sbi.h>
+#include <asm/kvm_vcpu_sbi.h>
+#include <asm/kvm_cove.h>
+#include <asm/kvm_cove_sbi.h>
+
+static int cove_share_converted_page(struct kvm_vcpu *vcpu, gpa_t gpa,
+				     struct kvm_riscv_cove_page *tpage)
+{
+	struct kvm *kvm = vcpu->kvm;
+	struct kvm_cove_tvm_context *tvmc = kvm->arch.tvmc;
+	int rc;
+
+	rc = sbi_covh_tvm_invalidate_pages(tvmc->tvm_guest_id, gpa, PAGE_SIZE);
+	if (rc)
+		return rc;
+
+	rc = kvm_riscv_cove_tvm_fence(vcpu);
+	if (rc)
+		goto err;
+
+	rc = sbi_covh_tvm_remove_pages(tvmc->tvm_guest_id, gpa, PAGE_SIZE);
+	if (rc)
+		goto err;
+
+	rc = sbi_covh_tsm_reclaim_page(page_to_phys(tpage->page));
+	if (rc)
+		return rc;
+
+	spin_lock(&kvm->mmu_lock);
+	list_del(&tpage->link);
+	list_add(&tpage->link, &tvmc->shared_pages);
+	spin_unlock(&kvm->mmu_lock);
+
+	return 0;
+
+err:
+	sbi_covh_tvm_validate_pages(tvmc->tvm_guest_id, gpa, PAGE_SIZE);
+
+	return rc;
+}
+
+static int cove_share_page(struct kvm_vcpu *vcpu, gpa_t gpa,
+			   struct kvm_vcpu_sbi_return *retdata)
+{
+	unsigned long hva = gfn_to_hva(vcpu->kvm, gpa >> PAGE_SHIFT);
+	struct kvm_cove_tvm_context *tvmc = vcpu->kvm->arch.tvmc;
+	struct mm_struct *mm = current->mm;
+	struct kvm_riscv_cove_page *tpage;
+	struct page *page;
+	int rc;
+
+	if (kvm_is_error_hva(hva)) {
+		/* Address is out of the guest ram memory region. */
+		retdata->err_val = SBI_ERR_INVALID_PARAM;
+		return 0;
+	}
+
+	tpage = kmalloc(sizeof(*tpage), GFP_KERNEL_ACCOUNT);
+	if (!tpage)
+		return -ENOMEM;
+
+	mmap_read_lock(mm);
+	rc = pin_user_pages(hva, 1, FOLL_LONGTERM | FOLL_WRITE, &page);
+	mmap_read_unlock(mm);
+
+	if (rc != 1) {
+		rc = -EINVAL;
+		goto free_tpage;
+	} else if (!PageSwapBacked(page)) {
+		rc = -EIO;
+		goto free_tpage;
+	}
+
+	tpage->page = page;
+	tpage->gpa = gpa;
+	tpage->hva = hva;
+	INIT_LIST_HEAD(&tpage->link);
+
+	spin_lock(&vcpu->kvm->mmu_lock);
+	list_add(&tpage->link, &tvmc->shared_pages);
+	spin_unlock(&vcpu->kvm->mmu_lock);
+
+	retdata->out_val = page_to_phys(tpage->page);
+	return 0;
+
+free_tpage:
+	kfree(tpage);
+
+	return rc;
+}
+
+static int kvm_riscv_cove_share_page(struct kvm_vcpu *vcpu, gpa_t gpa,
+				     struct kvm_vcpu_sbi_return *retdata)
+{
+	struct kvm_cove_tvm_context *tvmc = vcpu->kvm->arch.tvmc;
+	struct kvm_riscv_cove_page *tpage, *next;
+	bool converted = false;
+
+	/*
+	 * Check if the shared memory is part of the pages already assigned
+	 * to the TVM.
+	 *
+	 * TODO: Implement a better approach to track regions to avoid
+	 * traversing the whole list.
+	 */
+	spin_lock(&vcpu->kvm->mmu_lock);
+	list_for_each_entry_safe(tpage, next, &tvmc->zero_pages, link) {
+		if (tpage->gpa == gpa) {
+			converted = true;
+			break;
+		}
+	}
+	spin_unlock(&vcpu->kvm->mmu_lock);
+
+	if (converted)
+		return cove_share_converted_page(vcpu, gpa, tpage);
+
+	return cove_share_page(vcpu, gpa, retdata);
+}
+
+static int kvm_riscv_cove_unshare_page(struct kvm_vcpu *vcpu, gpa_t gpa)
+{
+	struct kvm_riscv_cove_page *tpage, *next;
+	struct kvm *kvm = vcpu->kvm;
+	struct kvm_cove_tvm_context *tvmc = kvm->arch.tvmc;
+	struct page *page = NULL;
+	int rc;
+
+	spin_lock(&kvm->mmu_lock);
+	list_for_each_entry_safe(tpage, next, &tvmc->shared_pages, link) {
+		if (tpage->gpa == gpa) {
+			page = tpage->page;
+			break;
+		}
+	}
+	spin_unlock(&kvm->mmu_lock);
+
+	if (unlikely(!page))
+		return -EINVAL;
+
+	rc = sbi_covh_tvm_invalidate_pages(tvmc->tvm_guest_id, gpa, PAGE_SIZE);
+	if (rc)
+		return rc;
+
+	rc = kvm_riscv_cove_tvm_fence(vcpu);
+	if (rc)
+		return rc;
+
+	rc = sbi_covh_tvm_remove_pages(tvmc->tvm_guest_id, gpa, PAGE_SIZE);
+	if (rc)
+		return rc;
+
+	unpin_user_pages_dirty_lock(&page, 1, true);
+
+	spin_lock(&kvm->mmu_lock);
+	list_del(&tpage->link);
+	spin_unlock(&kvm->mmu_lock);
+
+	kfree(tpage);
+
+	return 0;
+}
+
+static int kvm_sbi_ext_covg_handler(struct kvm_vcpu *vcpu, struct kvm_run *run,
+				    struct kvm_vcpu_sbi_return *retdata)
+{
+	struct kvm_cpu_context *cp = &vcpu->arch.guest_context;
+	uint32_t num_pages = cp->a1 / PAGE_SIZE;
+	unsigned long funcid = cp->a6;
+	unsigned long *err_val = &retdata->err_val;
+	uint32_t i;
+	int ret;
+
+	switch (funcid) {
+	case SBI_EXT_COVG_SHARE_MEMORY:
+		for (i = 0; i < num_pages; i++) {
+			ret = kvm_riscv_cove_share_page(
+				vcpu, cp->a0 + i * PAGE_SIZE, retdata);
+			if (ret || *err_val != SBI_SUCCESS)
+				return ret;
+		}
+		return 0;
+
+	case SBI_EXT_COVG_UNSHARE_MEMORY:
+		for (i = 0; i < num_pages; i++) {
+			ret = kvm_riscv_cove_unshare_page(
+				vcpu, cp->a0 + i * PAGE_SIZE);
+			if (ret)
+				return ret;
+		}
+		return 0;
+
+	case SBI_EXT_COVG_ADD_MMIO_REGION:
+	case SBI_EXT_COVG_REMOVE_MMIO_REGION:
+	case SBI_EXT_COVG_ALLOW_EXT_INTERRUPT:
+	case SBI_EXT_COVG_DENY_EXT_INTERRUPT:
+		/* We don't really need to do anything here for now. */
+		return 0;
+
+	default:
+		kvm_err("%s: Unsupported guest SBI %ld.\n", __func__, funcid);
+		retdata->err_val = SBI_ERR_NOT_SUPPORTED;
+		return -EOPNOTSUPP;
+	}
+}
+
+const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_covg = {
+	.extid_start = SBI_EXT_COVG,
+	.extid_end = SBI_EXT_COVG,
+	.handler = kvm_sbi_ext_covg_handler,
+};
diff --git a/arch/riscv/kvm/vcpu_sbi_covh.c b/arch/riscv/kvm/vcpu_sbi_covh.c
new file mode 100644
index 000000000000..d6362e9e3b48
--- /dev/null
+++ b/arch/riscv/kvm/vcpu_sbi_covh.c
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2024 IBM.
+ *
+ * Authors:
+ *     Wojciech Ozga <woz@zurich.ibm.com>
+ */
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/kvm_host.h>
+#include <asm/sbi.h>
+#include <asm/kvm_cove.h>
+#include <asm/kvm_nacl.h>
+#include <asm/kvm_cove_sbi.h>
+
+static int kvm_riscv_cove_promote_to_tvm(struct kvm_vcpu *vcpu,
+					 unsigned long fdt_address,
+					 unsigned long tap_addr) {
+	struct kvm_cove_tvm_context *tvmc;
+	struct kvm_cpu_context *cntx;
+	struct kvm_vcpu *target_vcpu;
+	unsigned long target_vcpuid;
+	void *nshmem = nacl_shmem();
+	int rc, gpr_id, offset;
+
+	rc = kvm_riscv_cove_vm_single_step_init(vcpu->kvm);
+	if (rc)
+		goto exit;
+
+	tvmc = vcpu->kvm->arch.tvmc;
+	cntx = &vcpu->arch.guest_context;
+
+	/* Reset all but boot vcpu and preload VM's pages */
+	kvm_for_each_vcpu(target_vcpuid, target_vcpu, vcpu->kvm) {
+		kvm_arch_vcpu_postcreate(target_vcpu);
+		target_vcpu->requests = 0;
+	}
+
+	for (gpr_id = 1; gpr_id < 32; gpr_id++) {
+		offset = KVM_ARCH_GUEST_ZERO + gpr_id * sizeof(unsigned long);
+		nacl_shmem_gpr_write_cove(nshmem, offset,
+					  ((unsigned long *)cntx)[gpr_id]);
+	}
+	kvm_arch_vcpu_load(vcpu, smp_processor_id());
+	rc = sbi_covh_tsm_promote_to_tvm(fdt_address, tap_addr, cntx->sepc+4,
+					 &tvmc->tvm_guest_id);
+	if (rc)
+		goto vcpus_allocated;
+
+	tvmc->finalized_done = true;
+	kvm_info("CoVE Guest creation successful with guest id %lx\n", tvmc->tvm_guest_id);
+	return 0;
+
+vcpus_allocated:
+	kvm_for_each_vcpu(target_vcpuid, target_vcpu, vcpu->kvm)
+		kvm_riscv_cove_vcpu_destroy(vcpu);
+	kvm_riscv_cove_vm_destroy(vcpu->kvm);
+
+exit:
+	return rc;
+}
+
+static int kvm_sbi_ext_covh_handler(struct kvm_vcpu *vcpu, struct kvm_run *run,
+				    struct kvm_vcpu_sbi_return *retdata)
+{
+	struct kvm_cpu_context *cp = &vcpu->arch.guest_context;
+	unsigned long funcid = cp->a6;
+        int ret;
+
+	switch (funcid) {
+	case SBI_EXT_COVH_PROMOTE_TO_TVM:
+		ret = kvm_riscv_cove_promote_to_tvm(vcpu, cp->a0, cp->a1);
+		return ret;
+
+	default:
+		kvm_err("%s: Unsupported guest SBI %ld.\n", __func__, funcid);
+		retdata->err_val = SBI_ERR_NOT_SUPPORTED;
+		return -EOPNOTSUPP;
+	}
+}
+
+const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_covh = {
+	.extid_start = SBI_EXT_COVH,
+	.extid_end = SBI_EXT_COVH,
+	.handler = kvm_sbi_ext_covh_handler,
+};
diff --git a/arch/riscv/kvm/vcpu_sbi_replace.c b/arch/riscv/kvm/vcpu_sbi_replace.c
index 7c4d5d38a339..347c5856347e 100644
--- a/arch/riscv/kvm/vcpu_sbi_replace.c
+++ b/arch/riscv/kvm/vcpu_sbi_replace.c
@@ -175,3 +175,34 @@ const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_srst = {
 	.extid_end = SBI_EXT_SRST,
 	.handler = kvm_sbi_ext_srst_handler,
 };
+
+static int kvm_sbi_ext_dbcn_handler(struct kvm_vcpu *vcpu,
+				    struct kvm_run *run,
+				    struct kvm_vcpu_sbi_return *retdata)
+{
+	struct kvm_cpu_context *cp = &vcpu->arch.guest_context;
+	unsigned long funcid = cp->a6;
+
+	switch (funcid) {
+	case SBI_EXT_DBCN_CONSOLE_WRITE:
+	case SBI_EXT_DBCN_CONSOLE_READ:
+	case SBI_EXT_DBCN_CONSOLE_WRITE_BYTE:
+		/*
+		 * The SBI debug console functions are unconditionally
+		 * forwarded to the userspace.
+		 */
+		kvm_riscv_vcpu_sbi_forward(vcpu, run);
+		retdata->uexit = true;
+		break;
+	default:
+		retdata->err_val = SBI_ERR_NOT_SUPPORTED;
+	}
+
+	return 0;
+}
+
+const struct kvm_vcpu_sbi_extension vcpu_sbi_ext_dbcn = {
+	.extid_start = SBI_EXT_DBCN,
+	.extid_end = SBI_EXT_DBCN,
+	.handler = kvm_sbi_ext_dbcn_handler,
+};
diff --git a/arch/riscv/kvm/vcpu_switch.S b/arch/riscv/kvm/vcpu_switch.S
index d74df8eb4d71..b8ff2ae67c6e 100644
--- a/arch/riscv/kvm/vcpu_switch.S
+++ b/arch/riscv/kvm/vcpu_switch.S
@@ -11,11 +11,7 @@
 #include <asm/asm-offsets.h>
 #include <asm/csr.h>
 
-	.text
-	.altmacro
-	.option norelax
-
-ENTRY(__kvm_riscv_switch_to)
+.macro SAVE_HOST_GPRS
 	/* Save Host GPRs (except A0 and T0-T6) */
 	REG_S	ra, (KVM_ARCH_HOST_RA)(a0)
 	REG_S	sp, (KVM_ARCH_HOST_SP)(a0)
@@ -40,39 +36,38 @@ ENTRY(__kvm_riscv_switch_to)
 	REG_S	s9, (KVM_ARCH_HOST_S9)(a0)
 	REG_S	s10, (KVM_ARCH_HOST_S10)(a0)
 	REG_S	s11, (KVM_ARCH_HOST_S11)(a0)
+.endm
 
+.macro SAVE_HOST_AND_RESTORE_GUEST_CSRS __resume_addr
 	/* Load Guest CSR values */
 	REG_L	t0, (KVM_ARCH_GUEST_SSTATUS)(a0)
-	REG_L	t1, (KVM_ARCH_GUEST_HSTATUS)(a0)
-	REG_L	t2, (KVM_ARCH_GUEST_SCOUNTEREN)(a0)
-	la	t4, __kvm_switch_return
-	REG_L	t5, (KVM_ARCH_GUEST_SEPC)(a0)
+	REG_L	t1, (KVM_ARCH_GUEST_SCOUNTEREN)(a0)
+	la	t3, \__resume_addr
+	REG_L	t4, (KVM_ARCH_GUEST_SEPC)(a0)
 
 	/* Save Host and Restore Guest SSTATUS */
 	csrrw	t0, CSR_SSTATUS, t0
 
-	/* Save Host and Restore Guest HSTATUS */
-	csrrw	t1, CSR_HSTATUS, t1
-
 	/* Save Host and Restore Guest SCOUNTEREN */
-	csrrw	t2, CSR_SCOUNTEREN, t2
+	csrrw	t1, CSR_SCOUNTEREN, t1
 
 	/* Save Host STVEC and change it to return path */
-	csrrw	t4, CSR_STVEC, t4
+	csrrw	t3, CSR_STVEC, t3
 
 	/* Save Host SSCRATCH and change it to struct kvm_vcpu_arch pointer */
-	csrrw	t3, CSR_SSCRATCH, a0
+	csrrw	t2, CSR_SSCRATCH, a0
 
 	/* Restore Guest SEPC */
-	csrw	CSR_SEPC, t5
+	csrw	CSR_SEPC, t4
 
 	/* Store Host CSR values */
 	REG_S	t0, (KVM_ARCH_HOST_SSTATUS)(a0)
-	REG_S	t1, (KVM_ARCH_HOST_HSTATUS)(a0)
-	REG_S	t2, (KVM_ARCH_HOST_SCOUNTEREN)(a0)
-	REG_S	t3, (KVM_ARCH_HOST_SSCRATCH)(a0)
-	REG_S	t4, (KVM_ARCH_HOST_STVEC)(a0)
+	REG_S	t1, (KVM_ARCH_HOST_SCOUNTEREN)(a0)
+	REG_S	t2, (KVM_ARCH_HOST_SSCRATCH)(a0)
+	REG_S	t3, (KVM_ARCH_HOST_STVEC)(a0)
+.endm
 
+.macro RESTORE_GUEST_GPRS
 	/* Restore Guest GPRs (except A0) */
 	REG_L	ra, (KVM_ARCH_GUEST_RA)(a0)
 	REG_L	sp, (KVM_ARCH_GUEST_SP)(a0)
@@ -107,13 +102,9 @@ ENTRY(__kvm_riscv_switch_to)
 
 	/* Restore Guest A0 */
 	REG_L	a0, (KVM_ARCH_GUEST_A0)(a0)
+.endm
 
-	/* Resume Guest */
-	sret
-
-	/* Back to Host */
-	.align 2
-__kvm_switch_return:
+.macro SAVE_GUEST_GPRS
 	/* Swap Guest A0 with SSCRATCH */
 	csrrw	a0, CSR_SSCRATCH, a0
 
@@ -148,13 +139,14 @@ __kvm_switch_return:
 	REG_S	t4, (KVM_ARCH_GUEST_T4)(a0)
 	REG_S	t5, (KVM_ARCH_GUEST_T5)(a0)
 	REG_S	t6, (KVM_ARCH_GUEST_T6)(a0)
+.endm
 
+.macro SAVE_GUEST_AND_RESTORE_HOST_CSRS
 	/* Load Host CSR values */
 	REG_L	t1, (KVM_ARCH_HOST_STVEC)(a0)
 	REG_L	t2, (KVM_ARCH_HOST_SSCRATCH)(a0)
 	REG_L	t3, (KVM_ARCH_HOST_SCOUNTEREN)(a0)
-	REG_L	t4, (KVM_ARCH_HOST_HSTATUS)(a0)
-	REG_L	t5, (KVM_ARCH_HOST_SSTATUS)(a0)
+	REG_L	t4, (KVM_ARCH_HOST_SSTATUS)(a0)
 
 	/* Save Guest SEPC */
 	csrr	t0, CSR_SEPC
@@ -168,19 +160,17 @@ __kvm_switch_return:
 	/* Save Guest and Restore Host SCOUNTEREN */
 	csrrw	t3, CSR_SCOUNTEREN, t3
 
-	/* Save Guest and Restore Host HSTATUS */
-	csrrw	t4, CSR_HSTATUS, t4
-
 	/* Save Guest and Restore Host SSTATUS */
-	csrrw	t5, CSR_SSTATUS, t5
+	csrrw	t4, CSR_SSTATUS, t4
 
 	/* Store Guest CSR values */
 	REG_S	t0, (KVM_ARCH_GUEST_SEPC)(a0)
 	REG_S	t2, (KVM_ARCH_GUEST_A0)(a0)
 	REG_S	t3, (KVM_ARCH_GUEST_SCOUNTEREN)(a0)
-	REG_S	t4, (KVM_ARCH_GUEST_HSTATUS)(a0)
-	REG_S	t5, (KVM_ARCH_GUEST_SSTATUS)(a0)
+	REG_S	t4, (KVM_ARCH_GUEST_SSTATUS)(a0)
+.endm
 
+.macro RESTORE_HOST_GPRS
 	/* Restore Host GPRs (except A0 and T0-T6) */
 	REG_L	ra, (KVM_ARCH_HOST_RA)(a0)
 	REG_L	sp, (KVM_ARCH_HOST_SP)(a0)
@@ -205,6 +195,64 @@ __kvm_switch_return:
 	REG_L	s9, (KVM_ARCH_HOST_S9)(a0)
 	REG_L	s10, (KVM_ARCH_HOST_S10)(a0)
 	REG_L	s11, (KVM_ARCH_HOST_S11)(a0)
+.endm
+
+	.text
+	.altmacro
+	.option norelax
+
+	/*
+	 * Parameters:
+	 * A0 <= Pointer to struct kvm_vcpu_arch
+	 */
+ENTRY(__kvm_riscv_switch_to)
+	SAVE_HOST_GPRS
+
+	SAVE_HOST_AND_RESTORE_GUEST_CSRS __kvm_riscv_switch_to_return
+
+	RESTORE_GUEST_GPRS
+
+	/* Resume Guest using SRET */
+	sret
+
+	/* Back to Host */
+	.align 2
+__kvm_riscv_switch_to_return:
+	SAVE_GUEST_GPRS
+
+	SAVE_GUEST_AND_RESTORE_HOST_CSRS
+
+	RESTORE_HOST_GPRS
+
+	/* Return to C code */
+	ret
+ENDPROC(__kvm_riscv_switch_to)
+
+	/*
+	 * Parameters:
+	 * A0 <= Pointer to struct kvm_vcpu_arch
+	 * A1 <= SBI extension ID
+	 * A2 <= SBI function ID
+	 * A3 <= Flags for SBI sync SRET call
+	 */
+ENTRY(__kvm_riscv_nacl_switch_to)
+	SAVE_HOST_GPRS
+
+	SAVE_HOST_AND_RESTORE_GUEST_CSRS __kvm_riscv_nacl_switch_to_return
+
+	/* Resume Guest using SBI nested acceleration */
+	add	a6, a2, zero
+	add	a7, a1, zero
+	ecall
+
+	/* Back to Host */
+	.align 2
+__kvm_riscv_nacl_switch_to_return:
+	SAVE_GUEST_GPRS
+
+	SAVE_GUEST_AND_RESTORE_HOST_CSRS
+
+	RESTORE_HOST_GPRS
 
 	/* Return to C code */
 	ret
diff --git a/arch/riscv/kvm/vcpu_timer.c b/arch/riscv/kvm/vcpu_timer.c
index 75486b25ac45..575de56039af 100644
--- a/arch/riscv/kvm/vcpu_timer.c
+++ b/arch/riscv/kvm/vcpu_timer.c
@@ -11,9 +11,10 @@
 #include <linux/kvm_host.h>
 #include <linux/uaccess.h>
 #include <clocksource/timer-riscv.h>
-#include <asm/csr.h>
 #include <asm/delay.h>
+#include <asm/kvm_nacl.h>
 #include <asm/kvm_vcpu_timer.h>
+#include <asm/kvm_cove.h>
 
 static u64 kvm_riscv_current_cycles(struct kvm_guest_timer *gt)
 {
@@ -71,13 +72,17 @@ static int kvm_riscv_vcpu_timer_cancel(struct kvm_vcpu_timer *t)
 
 static int kvm_riscv_vcpu_update_vstimecmp(struct kvm_vcpu *vcpu, u64 ncycles)
 {
+	/* Host is not allowed to update the vstimecmp for the TVM */
+	if (is_cove_vm_finalized(vcpu->kvm))
+		return 0;
+
 #if defined(CONFIG_32BIT)
-		csr_write(CSR_VSTIMECMP, ncycles & 0xFFFFFFFF);
-		csr_write(CSR_VSTIMECMPH, ncycles >> 32);
+	nacl_csr_write(CSR_VSTIMECMP, ncycles & 0xFFFFFFFF);
+	nacl_csr_write(CSR_VSTIMECMPH, ncycles >> 32);
 #else
-		csr_write(CSR_VSTIMECMP, ncycles);
+	nacl_csr_write(CSR_VSTIMECMP, ncycles);
 #endif
-		return 0;
+	return 0;
 }
 
 static int kvm_riscv_vcpu_update_hrtimer(struct kvm_vcpu *vcpu, u64 ncycles)
@@ -222,6 +227,11 @@ int kvm_riscv_vcpu_set_reg_timer(struct kvm_vcpu *vcpu,
 			return -EINVAL;
 		break;
 	case KVM_REG_RISCV_TIMER_REG(time):
+		/* For trusted VMs we can not update htimedelta. We can just
+		 * read it from shared memory.
+		 */
+		if (is_cove_vm_finalized(vcpu->kvm))
+			return -EOPNOTSUPP;
 		gt->time_delta = reg_val - get_cycles64();
 		break;
 	case KVM_REG_RISCV_TIMER_REG(compare):
@@ -288,11 +298,12 @@ static void kvm_riscv_vcpu_update_timedelta(struct kvm_vcpu *vcpu)
 {
 	struct kvm_guest_timer *gt = &vcpu->kvm->arch.timer;
 
+
 #if defined(CONFIG_32BIT)
-	csr_write(CSR_HTIMEDELTA, (u32)(gt->time_delta));
-	csr_write(CSR_HTIMEDELTAH, (u32)(gt->time_delta >> 32));
+	nacl_csr_write(CSR_HTIMEDELTA, (u32)(gt->time_delta));
+	nacl_csr_write(CSR_HTIMEDELTAH, (u32)(gt->time_delta >> 32));
 #else
-	csr_write(CSR_HTIMEDELTA, gt->time_delta);
+	nacl_csr_write(CSR_HTIMEDELTA, gt->time_delta);
 #endif
 }
 
@@ -300,18 +311,23 @@ void kvm_riscv_vcpu_timer_restore(struct kvm_vcpu *vcpu)
 {
 	struct kvm_vcpu_timer *t = &vcpu->arch.timer;
 
+	/* While in CoVE, HOST must not manage HTIMEDELTA or VSTIMECMP for TVM */
+	if (is_cove_vm_finalized(vcpu->kvm))
+		goto skip_hcsr_update;
+
 	kvm_riscv_vcpu_update_timedelta(vcpu);
 
 	if (!t->sstc_enabled)
 		return;
 
 #if defined(CONFIG_32BIT)
-	csr_write(CSR_VSTIMECMP, (u32)t->next_cycles);
-	csr_write(CSR_VSTIMECMPH, (u32)(t->next_cycles >> 32));
+	nacl_csr_write(CSR_VSTIMECMP, (u32)t->next_cycles);
+	nacl_csr_write(CSR_VSTIMECMPH, (u32)(t->next_cycles >> 32));
 #else
-	csr_write(CSR_VSTIMECMP, t->next_cycles);
+	nacl_csr_write(CSR_VSTIMECMP, t->next_cycles);
 #endif
 
+skip_hcsr_update:
 	/* timer should be enabled for the remaining operations */
 	if (unlikely(!t->init_done))
 		return;
@@ -327,10 +343,10 @@ void kvm_riscv_vcpu_timer_sync(struct kvm_vcpu *vcpu)
 		return;
 
 #if defined(CONFIG_32BIT)
-	t->next_cycles = csr_read(CSR_VSTIMECMP);
-	t->next_cycles |= (u64)csr_read(CSR_VSTIMECMPH) << 32;
+	t->next_cycles = nacl_csr_read(CSR_VSTIMECMP);
+	t->next_cycles |= (u64)nacl_csr_read(CSR_VSTIMECMPH) << 32;
 #else
-	t->next_cycles = csr_read(CSR_VSTIMECMP);
+	t->next_cycles = nacl_csr_read(CSR_VSTIMECMP);
 #endif
 }
 
@@ -359,5 +375,13 @@ void kvm_riscv_guest_timer_init(struct kvm *kvm)
 	struct kvm_guest_timer *gt = &kvm->arch.timer;
 
 	riscv_cs_get_mult_shift(&gt->nsec_mult, &gt->nsec_shift);
-	gt->time_delta = -get_cycles64();
+	if (is_cove_vm_finalized(kvm)) {
+		/* For TVMs htimedelta is managed by TSM and it's communicated using
+		 * NACL shmem interface when first time VCPU is run. so we read it in
+		 * kvm_riscv_cove_vcpu_switchto() where we enter VCPUs.
+		 */
+		gt->time_delta = 0;
+	} else {
+		gt->time_delta = -get_cycles64();
+	}
 }
diff --git a/arch/riscv/kvm/vm.c b/arch/riscv/kvm/vm.c
index 7e2b50c692c1..20f539644918 100644
--- a/arch/riscv/kvm/vm.c
+++ b/arch/riscv/kvm/vm.c
@@ -11,6 +11,7 @@
 #include <linux/module.h>
 #include <linux/uaccess.h>
 #include <linux/kvm_host.h>
+#include <asm/kvm_cove.h>
 
 const struct _kvm_stats_desc kvm_vm_stats_desc[] = {
 	KVM_GENERIC_VM_STATS()
@@ -41,6 +42,24 @@ int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)
 		return r;
 	}
 
+	if (unlikely(type == KVM_VM_TYPE_RISCV_COVE_MULTI_STEP_INIT)) {
+		if (!kvm_riscv_cove_enabled()) {
+			kvm_err("Unable to init CoVE VM because CoVE extension is not enabled\n");
+			return -EPERM;
+		}
+		r = kvm_riscv_cove_vm_multi_step_init(kvm);
+		if (r)
+			return r;
+	} else if (unlikely(type == KVM_VM_TYPE_RISCV_COVE_SINGLE_STEP_INIT)) {
+		if (!kvm_riscv_cove_enabled()) {
+			kvm_err("Unable to init CoVE VM because CoVE extension is not enabled\n");
+			return -EPERM;
+		}
+		r = kvm_riscv_cove_vm_single_step_init(kvm);
+		if (r)
+			return r;
+	}
+
 	kvm_riscv_aia_init_vm(kvm);
 
 	kvm_riscv_guest_timer_init(kvm);
@@ -53,6 +72,9 @@ void kvm_arch_destroy_vm(struct kvm *kvm)
 	kvm_destroy_vcpus(kvm);
 
 	kvm_riscv_aia_destroy_vm(kvm);
+
+	if (unlikely(is_cove_vm_finalized(kvm)) || unlikely(is_cove_vm_multi_step_initializing(kvm)))
+		kvm_riscv_cove_vm_destroy(kvm);
 }
 
 int kvm_vm_ioctl_irq_line(struct kvm *kvm, struct kvm_irq_level *irql,
@@ -211,5 +233,18 @@ int kvm_vm_ioctl_check_extension(struct kvm *kvm, long ext)
 
 int kvm_arch_vm_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg)
 {
-	return -EINVAL;
+	struct kvm *kvm = filp->private_data;
+	void __user *argp = (void __user *)arg;
+	struct kvm_riscv_cove_measure_region mr;
+
+	switch (ioctl) {
+	case KVM_RISCV_COVE_MEASURE_REGION:
+		if (copy_from_user(&mr, argp, sizeof(mr)))
+			return -EFAULT;
+
+		return kvm_riscv_cove_vm_measure_pages(kvm, &mr);
+	default:
+		return -EINVAL;
+	}
+
 }
diff --git a/arch/riscv/kvm/vmid.c b/arch/riscv/kvm/vmid.c
index ddc98714ce8e..6f5a293235bb 100644
--- a/arch/riscv/kvm/vmid.c
+++ b/arch/riscv/kvm/vmid.c
@@ -14,6 +14,7 @@
 #include <linux/smp.h>
 #include <linux/kvm_host.h>
 #include <asm/csr.h>
+#include <asm/kvm_cove.h>
 
 static unsigned long vmid_version = 1;
 static unsigned long vmid_next;
@@ -54,12 +55,13 @@ int kvm_riscv_gstage_vmid_init(struct kvm *kvm)
 	return 0;
 }
 
-bool kvm_riscv_gstage_vmid_ver_changed(struct kvm_vmid *vmid)
+bool kvm_riscv_gstage_vmid_ver_changed(struct kvm *kvm)
 {
-	if (!vmid_bits)
+	/* VMID version can't be changed by the host for TVMs */
+	if (!vmid_bits || is_cove_vm_finalized(kvm) || is_cove_vm_multi_step_initializing(kvm))
 		return false;
 
-	return unlikely(READ_ONCE(vmid->vmid_version) !=
+	return unlikely(READ_ONCE(kvm->arch.vmid.vmid_version) !=
 			READ_ONCE(vmid_version));
 }
 
@@ -72,9 +74,14 @@ void kvm_riscv_gstage_vmid_update(struct kvm_vcpu *vcpu)
 {
 	unsigned long i;
 	struct kvm_vcpu *v;
+	struct kvm *kvm = vcpu->kvm;
 	struct kvm_vmid *vmid = &vcpu->kvm->arch.vmid;
 
-	if (!kvm_riscv_gstage_vmid_ver_changed(vmid))
+	/* No VMID management for TVMs by the host */
+	if (is_cove_vm_finalized(vcpu->kvm) || is_cove_vm_multi_step_initializing(vcpu->kvm))
+		return;
+
+	if (!kvm_riscv_gstage_vmid_ver_changed(kvm))
 		return;
 
 	spin_lock(&vmid_lock);
@@ -83,7 +90,7 @@ void kvm_riscv_gstage_vmid_update(struct kvm_vcpu *vcpu)
 	 * We need to re-check the vmid_version here to ensure that if
 	 * another vcpu already allocated a valid vmid for this vm.
 	 */
-	if (!kvm_riscv_gstage_vmid_ver_changed(vmid)) {
+	if (!kvm_riscv_gstage_vmid_ver_changed(kvm)) {
 		spin_unlock(&vmid_lock);
 		return;
 	}
diff --git a/arch/riscv/mm/Makefile b/arch/riscv/mm/Makefile
index 3a4dfc8babcf..c720ae3d4afc 100644
--- a/arch/riscv/mm/Makefile
+++ b/arch/riscv/mm/Makefile
@@ -18,6 +18,7 @@ obj-y += cacheflush.o
 obj-y += context.o
 obj-y += pgtable.o
 obj-y += pmem.o
+obj-y += ioremap.o
 
 ifeq ($(CONFIG_MMU),y)
 obj-$(CONFIG_SMP) += tlbflush.o
@@ -37,3 +38,5 @@ endif
 obj-$(CONFIG_DEBUG_VIRTUAL) += physaddr.o
 obj-$(CONFIG_RISCV_DMA_NONCOHERENT) += dma-noncoherent.o
 obj-$(CONFIG_RISCV_NONSTANDARD_CACHE_OPS) += cache-ops.o
+
+obj-$(CONFIG_RISCV_MEM_ENCRYPT)	+= mem_encrypt.o
diff --git a/arch/riscv/mm/cacheflush.c b/arch/riscv/mm/cacheflush.c
index f1387272a551..eef62cfa4cbd 100644
--- a/arch/riscv/mm/cacheflush.c
+++ b/arch/riscv/mm/cacheflush.c
@@ -19,6 +19,9 @@ void flush_icache_all(void)
 {
 	local_flush_icache_all();
 
+	if (num_online_cpus() == 1)
+		return;
+
 	if (IS_ENABLED(CONFIG_RISCV_SBI) && !riscv_use_ipi_for_rfence())
 		sbi_remote_fence_i(NULL);
 	else
diff --git a/arch/riscv/mm/dma-noncoherent.c b/arch/riscv/mm/dma-noncoherent.c
index 341bd6706b4c..39b2bea86960 100644
--- a/arch/riscv/mm/dma-noncoherent.c
+++ b/arch/riscv/mm/dma-noncoherent.c
@@ -10,6 +10,10 @@
 #include <linux/mm.h>
 #include <asm/cacheflush.h>
 #include <asm/dma-noncoherent.h>
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+#include <linux/io.h>
+#include <linux/iommu.h>
+#endif
 
 static bool noncoherent_supported __ro_after_init;
 int dma_cache_alignment __ro_after_init = ARCH_DMA_MINALIGN;
@@ -128,6 +132,13 @@ void arch_dma_prep_coherent(struct page *page, size_t size)
 	ALT_CMO_OP(flush, flush_addr, size, riscv_cbom_block_size);
 }
 
+#ifdef CONFIG_IOMMU_DMA
+void arch_teardown_dma_ops(struct device *dev)
+{
+    dev->dma_ops = NULL;
+}
+#endif
+
 void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
 		const struct iommu_ops *iommu, bool coherent)
 {
@@ -137,11 +148,18 @@ void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
 		   dev_driver_string(dev), dev_name(dev),
 		   ARCH_DMA_MINALIGN, riscv_cbom_block_size);
 
+#ifndef CONFIG_SOC_SIFIVE_EIC7700
 	WARN_TAINT(!coherent && !noncoherent_supported, TAINT_CPU_OUT_OF_SPEC,
 		   "%s %s: device non-coherent but no non-coherent operations supported",
 		   dev_driver_string(dev), dev_name(dev));
+#endif
 
 	dev->dma_coherent = coherent;
+
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	if (iommu)
+		iommu_setup_dma_ops(dev, dma_base, size);
+#endif
 }
 
 void riscv_noncoherent_supported(void)
@@ -156,3 +174,67 @@ void __init riscv_set_dma_cache_alignment(void)
 	if (!noncoherent_supported)
 		dma_cache_alignment = 1;
 }
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+static struct page **__iommu_dma_common_find_pages(void *cpu_addr)
+{
+    struct vm_struct *area = find_vm_area(cpu_addr);
+
+    if (!area || area->flags != VM_DMA_COHERENT)
+        return NULL;
+    return area->pages;
+}
+
+void arch_dma_clear_uncached(void *addr, size_t size)
+{
+    struct page **pages = NULL;
+
+    pages = __iommu_dma_common_find_pages(addr);
+    if (!pages) { // todo: supposed to handle this error
+        pr_err( "smmu_dbg, fail to find pages\n");
+
+        return;
+    }
+    kvfree(pages);
+    memunmap(addr);
+}
+
+void *arch_dma_set_uncached(void *addr, size_t size)
+{
+    struct page **pages = NULL;
+    static struct page *page = NULL;
+    struct vm_struct *area = NULL;
+    phys_addr_t phys_addr = convert_pha_from_mem_to_sys_port(__pa(addr));
+    void *mem_base = NULL;
+
+    mem_base = memremap(phys_addr, size, MEMREMAP_WT);
+    if (!mem_base) {
+        pr_err("%s memremap failed for addr %px\n", __func__, addr);
+        return ERR_PTR(-EINVAL);
+    }
+
+    pages = kvzalloc(sizeof(*pages), GFP_KERNEL);
+    if (!pages) {
+        pr_err("smmu_dbg, failed to alloc memory!\n");
+        goto err_pages_alloc;
+    }
+    page = virt_to_page(addr);
+    area = find_vm_area(mem_base);
+    if (!area) {
+        pr_err("smmu_dbg, failed to find vm area!\n");
+        goto err_find_vm_area;
+    }
+    pages[0] = page;
+    area->pages = pages;
+    area->flags = VM_DMA_COHERENT;
+
+    return mem_base;
+
+err_find_vm_area:
+    kvfree(pages);
+
+err_pages_alloc:
+    memunmap(mem_base);
+
+    return NULL;
+}
+#endif
diff --git a/arch/riscv/mm/init.c b/arch/riscv/mm/init.c
index b50faa232b5e..d2c43303e468 100644
--- a/arch/riscv/mm/init.c
+++ b/arch/riscv/mm/init.c
@@ -25,6 +25,7 @@
 #endif
 #include <linux/kfence.h>
 
+#include <asm/cove.h>
 #include <asm/fixmap.h>
 #include <asm/io.h>
 #include <asm/numa.h>
@@ -160,11 +161,25 @@ static void print_vm_layout(void) { }
 
 void __init mem_init(void)
 {
+	unsigned int flags = SWIOTLB_VERBOSE;
+	bool swiotlb_en;
+
+	if (is_cove_guest()) {
+		/* Since the guest memory is inaccessible to the host, devices
+		 * always need to use the SWIOTLB buffer for DMA even if
+		 * dma_capable() says otherwise.
+		 */
+		flags |= SWIOTLB_FORCE;
+		swiotlb_en = true;
+	} else {
+		swiotlb_en = !!(max_pfn > PFN_DOWN(dma32_phys_limit));
+	}
+
 #ifdef CONFIG_FLATMEM
 	BUG_ON(!mem_map);
 #endif /* CONFIG_FLATMEM */
 
-	swiotlb_init(max_pfn > PFN_DOWN(dma32_phys_limit), SWIOTLB_VERBOSE);
+	swiotlb_init(swiotlb_en, flags);
 	memblock_free_all();
 
 	print_vm_layout();
diff --git a/arch/riscv/mm/ioremap.c b/arch/riscv/mm/ioremap.c
new file mode 100644
index 000000000000..0d4e026447a9
--- /dev/null
+++ b/arch/riscv/mm/ioremap.c
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023 Rivos Inc.
+ *
+ * Authors:
+ *     Rajnesh Kanwal <rkanwal@rivosinc.com>
+ */
+
+#include <linux/export.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/io.h>
+#include <asm/covg_sbi.h>
+#include <asm/cove.h>
+#include <asm-generic/io.h>
+
+void ioremap_phys_range_hook(phys_addr_t addr, size_t size, pgprot_t prot)
+{
+	unsigned long offset;
+
+	if (!is_cove_guest())
+		return;
+
+	/* Page-align address and size. */
+	offset = addr & (~PAGE_MASK);
+	addr -= offset;
+	size = PAGE_ALIGN(size + offset);
+
+	sbi_covg_add_mmio_region(addr, size);
+}
+
+void iounmap_phys_range_hook(phys_addr_t addr, size_t size)
+{
+	unsigned long offset;
+
+	if (!is_cove_guest())
+		return;
+
+	/* Page-align address and size. */
+	offset = addr & (~PAGE_MASK);
+	addr -= offset;
+	size = PAGE_ALIGN(size + offset);
+
+	sbi_covg_remove_mmio_region(addr, size);
+}
diff --git a/arch/riscv/mm/mem_encrypt.c b/arch/riscv/mm/mem_encrypt.c
new file mode 100644
index 000000000000..8619444538a3
--- /dev/null
+++ b/arch/riscv/mm/mem_encrypt.c
@@ -0,0 +1,78 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2023 Rivos Inc.
+ *
+ * Authors:
+ *     Rajnesh Kanwal <rkanwal@rivosinc.com>
+ */
+
+#include <linux/dma-direct.h>
+#include <linux/swiotlb.h>
+#include <linux/cc_platform.h>
+#include <linux/mem_encrypt.h>
+#include <linux/virtio_anchor.h>
+#include <asm/covg_sbi.h>
+
+/* Override for DMA direct allocation check - ARCH_HAS_FORCE_DMA_UNENCRYPTED */
+bool force_dma_unencrypted(struct device *dev)
+{
+	/*
+	 * For authorized devices in trusted guest, all DMA must be to/from
+	 * unencrypted addresses.
+	 */
+	return cc_platform_has(CC_ATTR_GUEST_MEM_ENCRYPT);
+}
+
+int set_memory_encrypted(unsigned long addr, int numpages)
+{
+	int i, rc;
+
+	if (!cc_platform_has(CC_ATTR_MEM_ENCRYPT))
+		return 0;
+
+	if (!PAGE_ALIGNED(addr))
+		return -EINVAL;
+
+	rc = sbi_covg_unshare_memory(__pa(addr), numpages * PAGE_SIZE);
+	if (rc) {
+		rc = 0;
+		for (i = 0; i < numpages && rc == 0; i++)
+			rc = sbi_covg_unshare_memory(__pa(addr + i * PAGE_SIZE), PAGE_SIZE);
+	}
+	return rc;
+}
+EXPORT_SYMBOL_GPL(set_memory_encrypted);
+
+int set_memory_decrypted(unsigned long addr, int numpages)
+{
+	int i, rc;
+
+	if (!cc_platform_has(CC_ATTR_MEM_ENCRYPT))
+		return 0;
+
+	if (!PAGE_ALIGNED(addr))
+		return -EINVAL;
+
+	rc = sbi_covg_share_memory(__pa(addr), numpages * PAGE_SIZE);
+	if (rc) {
+		rc = 0;
+		/* Try page by page if TSM cannot share all pages at once */
+		for (i = 0; i < numpages && rc == 0; i++)
+			rc = sbi_covg_share_memory(__pa(addr + i * PAGE_SIZE), PAGE_SIZE);
+	}
+	return rc;
+}
+EXPORT_SYMBOL_GPL(set_memory_decrypted);
+
+/* Architecture __weak replacement functions */
+void __init mem_encrypt_init(void)
+{
+	if (!cc_platform_has(CC_ATTR_MEM_ENCRYPT))
+		return;
+
+	/* Call into SWIOTLB to update the SWIOTLB DMA buffers */
+	swiotlb_update_mem_attributes();
+
+	/* Set restricted memory access for virtio. */
+	virtio_set_mem_acc_cb(virtio_require_restricted_mem_acc);
+}
diff --git a/cov b/cov
new file mode 100644
index 000000000000..e3b630abf50b
--- /dev/null
+++ b/cov
@@ -0,0 +1,274 @@
+This patch series adds the RISC-V Confidential VM Extension (CoVE) support to
+Linux kernel. The RISC-V CoVE specification introduces non-ISA, SBI APIs. These
+APIs enable a confidential environment in which a guest VM's data can be isolated
+from the host while the host retains control of guest VM management and platform
+resources(memory, CPU, I/O).
+
+This is a very early WIP work. We want to share this with the community to get any
+feedback on overall architecture and direction. Any other feedback is welcome too.
+
+The detailed CoVE architecture document can be found here [0]. It used to be
+called AP-TEE and renamed to CoVE recently to avoid overloading term of TEE in
+general. The specification is in the draft stages and is subjected to change based
+on the feedback from the community.
+
+The CoVE specification introduces 3 new SBI extensions.
+COVH - CoVE Host side interface
+COVG - CoVE Guest side interface
+COVI - CoVE Secure Interrupt management extension
+
+Some key acronyms introduced:
+
+TSM - TEE Security Manager
+TVM - TEE VM (aka Confidential VM)
+
+CoVE Architecture:
+====================
+The CoVE APIs are designed to be implementation and architecture agnostic,
+allowing for different deployment models while retaining common host and guest
+kernel code. Two examples are shown in Figure 1 and Figure 2.
+As shown in both figures, the architecture introduces a new software component
+called the "TEE Security Manager" (TSM) that runs in HS mode. The TSM has minimal
+hw attested footprint on TCB as it is a passive component that doesn't support
+scheduling or timer interrupts. Both example deployment models provide memory 
+isolation between the host and the TEE VM (TVM).
+
+        
+	Non secure world       |         Secure world         |
+                               |                              |
+        Non                    |                              |
+    Virtualized |  Virtualized |   Virtualized  Virtualized   |            
+        Env     |      Env     |       Env          Env       |                
+   +----------+ | +----------+ |  +----------+ +----------+   |  --------------        
+   |          | | |          | |  |          | |          |   |  
+   | Host Apps| | |   Apps   | |  |   Apps   | |   Apps   |   |        VU-Mode
+   |  (VMM)   | | |          | |  |          | |          |   |         
+   +----------+ | +----------+ |  +----------+ +----------+   |  --------------
+        |       | +----------+ |  +----------+ +----------+   |                
+        |       | |          | |  |          | |          |   |      
+        |       | |          | |  |    TVM   | |    TVM   |   |      
+        |       | |   Guest  | |  |   Guest  | |   Guest  |   |       VS-Mode
+     Syscalls   | +----------+ |  +----------+ +----------+   |      
+        |              |       |        |                     |
+        |             SBI      |   SBI(COVG + COVI)           |   
+        |              |       |        |                     |
+  +--------------------------+ |  +---------------------------+  --------------
+  |     Host (Linux)         | |  |       TSM (Salus)         |        
+  +--------------------------+ |  +---------------------------+
+             |                 |            |                       HS-Mode
+     SBI (COVH + COVI)         |     SBI (COVH + COVI)            
+             |                 |            |
+  +-----------------------------------------------------------+  --------------
+  |                    Firmware(OpenSBI) + TSM Driver         |        M-Mode
+  +-----------------------------------------------------------+  --------------
+ +-----------------------------------------------------------------------------
+  |                    Hardware (RISC-V CPU + RoT + IOMMU)
+  +---------------------------------------------------------------------------- 
+ 		Figure 1: Host in HS model
+
+
+The deployment model shown in Figure 1 runs the host in HS mode where it is peer
+to the TSM which also runs in HS mode. It requires another component known as TSM
+Driver running in higher privilege mode than host/TSM. It is responsible for switching
+the context between the host and the TSM. TSM driver also manages the platform
+specific hardware solution via confidential domain bit as described in the specification[0]
+to provide the required memory isolation.
+
+ 
+	     Non secure world  |         Secure world
+                               |
+         Virtualized Env       |   Virtualized   Virtualized  |                  
+             		              Env           Env       |                       
+   +-------------------------+ |  +----------+  +----------+  |    ------------ 
+   |          | | |          | |  |          |  |          |  |                           
+   | Host Apps| | |   Apps   | |  |   Apps   |  |   Apps   |  |        VU-Mode              
+   +----------+ | +----------+ |  +----------+  +----------+  |    ------------ 
+        |                      |        |             |       |                          
+    Syscalls             SBI   |      	|             |       |                           
+        |                      |        |             |       |                           
+  +--------------------------+ |  +-----------+ +-----------+ |                          
+  |     Host (Linux)         | |  |  TVM Guest| |  TVM Guest| |       VS-Mode                
+  +--------------------------+ |  +-----------+ +-----------+ |               
+             |                 |        |             |       |               
+     SBI (COVH + COVI)         |       SBI           SBI      |              
+             |                 |   (COVG + COVI) (COVG + COVI)|              
+	     |                 |        |             |       |              
+  +-----------------------------------------------------------+    --------------
+  |                    TSM(Salus)	                      |        HS-Mode
+  +-----------------------------------------------------------+    --------------
+ 			      | 
+  			     SBI
+			      |
+  +---------------------------------------------------------+    --------------
+  |                    Firmware(OpenSBI)                  |        M-Mode
+  +---------------------------------------------------------+    --------------
+ +-----------------------------------------------------------------------------
+  |                    Hardware (RISC-V CPU + RoT + IOMMU)
+  +---------------------------------------------------------------------------- 
+ 			Figure 2: Host in VS model
+
+
+The deployment model shown in Figure 2 simplifies the context switch and memory isolation
+by running the host in VS mode as a guest of TSM. Thus, the memory isolation is
+achieved by gstage mapping by the TSM. We don't need any additional hardware confidential
+domain bit to provide memory isolation. The downside of this model the host has to run the
+non-confidential VMs in nested environment which may have lower performance (yet to be measured).
+The current implementation Salus(TSM) doesn't support full nested virtualization yet.
+
+The platform must have a RoT to provide attestation in either model.
+This patch series implements the APIs defined by CoVE. The current TSM implementation
+allows the host to run TVMs as shown in figure 2. We are working on deployment
+model 1 in parallel. We do not expect any significant changes in either host/guest side
+ABI due to that.
+
+Shared memory between the host & TSM:
+=====================================
+To accelerate the H-mode CSR/GPR access, CoVE also reuses the Nested Acceleration (NACL)
+SBI extension[1]. NACL defines a per physical cpu shared memory area that is allocated
+at the boot. It allows the host running in VS mode to access H-mode CSR/GPR easily
+without trapping into the TSM. The CoVE specification clearly defines the exact
+state of the shared memory with r/w permissions at every call. 
+
+Secure Interrupt management:
+===========================
+The CoVE specification relies on the MSI based interrupt scheme defined in Advanced Interrupt
+Architecture specification[2]. The COVI SBI extension adds functions to bind
+a guest interrupt file to a TVMs. After that, only TCB components (TSM, TVM, TSM driver)
+can modify that. The host can inject an interrupt via TSM only. 
+The TVMs are also in complete control of which interrupts it can receive. By default,
+all interrupts are denied. In this proof-of-concept implementation, all the interrupts
+are allowed by the guest at boot time to keep it simple.
+
+Device I/O: 
+===========
+In order to support paravirt I/O devices, SWIOTLB bounce buffer must be used by the
+guest. As the host can not access confidential memory, this buffer memory
+must be shared with the host via share/unshare functions defined in COVG SBI extension.
+RISC-V implementation achieves this generalizing mem_encrypt_init() similar to TDX/SEV/CCA.
+That's why, the CoVE Guest is only allowed to use virtio devices with VIRTIO_F_ACCESS_PLATFORM
+and VIRTIO_F_VERSION_1 as they force virtio drivers to use the DMA API.
+
+MMIO emulation:
+======================
+TVM can register regions of address space as MMIO regions to be emulated by
+the host. TSM provides explicit SBI functions i.e. SBI_EXT_COVG_[ADD/REMOVE]_MMIO_REGION
+to request/remove MMIO regions. Any reads or writes to those MMIO region after
+SBI_EXT_COVG_ADD_MMIO_REGION call are forwarded to the host for emulation. 
+
+This series allows any ioremapped memory to be emulated as MMIO region with
+above APIs via arch hookups inspired from pKVM work. We are aware that this model
+doesn't address all the threat vectors. We have also implemented the device 
+filtering/authorization approach adopted by TDX[4]. However, those patches are not
+part of this series as the base TDX patches are still under active development.
+RISC-V CoVE will also adapt the revamped device filtering work once it is accepted
+by the Linux community in the future.
+
+The direct assignment of devices are a work in progress and will be added in the future[4].
+
+VMM support:
+============
+This series is only tested with kvmtool support. Other VMM support (qemu-kvm, crossvm/rust-vmm)
+will be added later.
+
+Test cases:
+===========
+We are working on kvm selftest for CoVE. We will post them as soon as they are ready.
+We haven't started any work on kvm unit-tests as RISC-V doesn't have basic infrastructure
+to support that. Once the kvm uni-test infrastructure is in place, we will add
+support for CoVE as well. 
+
+Open design questions:
+======================
+
+1. The current implementation has two separate configs for guest(CONFIG_RISCV_COVE_GUEST)
+and the host (RISCV_COVE_HOST). The default defconfig will enable both so that
+same unified image works as both host & guest. Most likely distro prefer this way
+to minimize the maintenance burden but some may want a minimal CoVE guest image
+that has only hardened drivers. In addition to that, Android runs a microdroid instance
+in the confidential guests. A separate config will help in those case. Please let us
+know if there is any concern with two configs. 
+
+2. Lazy gstage page allocation vs upfront allocation with page pool.
+Currently, all gstage mappings happen at runtime during the fault. This is expensive
+as we need to convert that page to confidential memory as well. A page pool framework
+may be a better choice which can hold all the confidential pages which can be
+pre-allocated upfront. A generic page pool infrastructure may benefit other CC solutions ?
+
+3. In order to allow both confidential VM and non-confidential VM, the series
+uses regular branching instead of static branches for CoVE VM specific cases through
+out KVM. That may cause a few more branch penalties while running regular VMs. 
+The alternate option is to use function pointers for any function that needs to
+take a different path. As per my understanding, that would be worse than branches.  
+
+Patch organization:
+===================
+This series depends on quite a few RISC-V patches that are not upstream yet. 
+Here are the dependencies.
+
+1. RISC-V IPI improvement series
+2. RISC-V AIA support series.
+3. RISC-V NACL support series
+
+In this series, PATCH [0-5] are generic improvement and cleanup patches which
+can be merged independently.
+
+PATCH [6-26, 34-37] adds host side for CoVE.
+PATCH [27-33] adds the interrupt related changes.
+PATCH [34-49] Adds the guest side changes for CoVE.
+
+The TSM project is written in rust and can be found here:
+https://github.com/rivosinc/salus
+
+Running the stack
+====================
+
+To run/test the stack, you would need the following components :
+
+1) Qemu
+2) Common Host & Guest Kernel
+3) kvmtool
+4) Host RootFS with KVMTOOL and Guest Kernel
+5) Salus
+
+The detailed steps are available at[6]
+
+The Linux kernel patches are also available at [7] and the kvmtool patches
+are available at [8].
+
+TODOs
+=======
+As this is a very early work, the todo list is quite long :).
+Here are some of them (not in any specific order)
+
+1. Support fd based private memory interface proposed in
+   https://lkml.org/lkml/2022/1/18/395
+2. Align with updated guest runtime device filtering approach.
+3. IOMMU integration
+4. Dedicated device assignment via TDSIP & SPDM[4]
+5. Support huge pages
+6. Page pool allocator to avoid convert/reclaim at every fault
+7. Other VMM support (qemu-kvm, crossvm)
+8. Complete the PoC for the deployment model 1 where host runs in HS mode
+9. Attestation integration
+10. Harden the interrupt allowed list
+11. kvm self-tests support for CoVE
+11. kvm unit-tests support for CoVE
+12. Guest hardening
+13. Port pKVM on RISC-V using CoVE
+14. Any other ?
+
+Links
+============
+[0] CoVE architecture Specification.
+    https://github.com/riscv-non-isa/riscv-ap-tee/blob/main/specification/riscv-aptee-spec.pdf
+[1] https://lists.riscv.org/g/sig-hypervisors/message/260 
+[2] https://github.com/riscv/riscv-aia/releases/download/1.0-RC2/riscv-interrupts-1.0-RC2.pdf 
+[3] https://github.com/rivosinc/linux/tree/cove_integration_device_filtering1
+[4] https://github.com/intel/tdx/commits/guest-filter-upstream 
+[5] https://lists.riscv.org/g/tech-ap-tee/message/83
+[6] https://github.com/rivosinc/cove/wiki/CoVE-KVM-RISCV64-on-QEMU
+[7] https://github.com/rivosinc/linux/commits/cove-integration
+[8] https://github.com/rivosinc/kvmtool/tree/cove-integration-03072023
+
+option-subject RISC-V CoVE support
+option-prefix RFC
diff --git a/drivers/ata/Kconfig b/drivers/ata/Kconfig
index 42b51c9812a0..4761bf0d39d1 100644
--- a/drivers/ata/Kconfig
+++ b/drivers/ata/Kconfig
@@ -216,6 +216,15 @@ config AHCI_CEVA
 
 	  If unsure, say N.
 
+config AHCI_ESWIN
+	tristate "Eswin AHCI SATA support"
+	select SATA_HOST
+	help
+	  This option enables support for Eswin AHCI Serial ATA
+	  controllers.
+
+	  If unsure, say N.
+
 config AHCI_MTK
 	tristate "MediaTek AHCI SATA support"
 	depends on ARCH_MEDIATEK || COMPILE_TEST
diff --git a/drivers/ata/Makefile b/drivers/ata/Makefile
index 20e6645ab737..515e62a23ae7 100644
--- a/drivers/ata/Makefile
+++ b/drivers/ata/Makefile
@@ -18,6 +18,7 @@ obj-$(CONFIG_AHCI_CEVA)		+= ahci_ceva.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_DA850)	+= ahci_da850.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_DM816)	+= ahci_dm816.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_DWC)		+= ahci_dwc.o libahci.o libahci_platform.o
+obj-$(CONFIG_AHCI_ESWIN)	+= ahci_eswin.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_IMX)		+= ahci_imx.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_MTK)		+= ahci_mtk.o libahci.o libahci_platform.o
 obj-$(CONFIG_AHCI_MVEBU)	+= ahci_mvebu.o libahci.o libahci_platform.o
diff --git a/drivers/ata/ahci_eswin.c b/drivers/ata/ahci_eswin.c
new file mode 100644
index 000000000000..0bc04cd2d8ba
--- /dev/null
+++ b/drivers/ata/ahci_eswin.c
@@ -0,0 +1,344 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN AHCI SATA Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: Yulin Lu <luyulin@eswincomputing.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pm.h>
+#include <linux/device.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/libata.h>
+#include <linux/ahci_platform.h>
+#include <linux/acpi.h>
+#include <linux/pci_ids.h>
+#include <linux/iommu.h>
+#include <linux/eic7700-sid-cfg.h>
+#include  <linux/mfd/syscon.h>
+#include <linux/bitfield.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include "ahci.h"
+
+#define DRV_NAME "ahci"
+
+#define AWSMMUSID                     GENMASK(31, 24) // The sid of write operation
+#define AWSMMUSSID                    GENMASK(23, 16) // The ssid of write operation
+#define ARSMMUSID                     GENMASK(15, 8)  // The sid of read operation
+#define ARSMMUSSID                    GENMASK(7, 0)   // The ssid of read operation
+#define SATA_REF_CTRL1                0x338
+#define SATA_PHY_CTRL0                0x328
+#define SATA_PHY_CTRL1                0x32c
+#define SATA_LOS_IDEN                 0x33c
+#define SATA_AXI_LP_CTRL              0x308
+#define SATA_REG_CTRL                 0x334
+#define SATA_MPLL_CTRL                0x320
+#define SATA_RESET_CTRL               0x340
+#define SATA_RESET_CTRL_ASSERT        0x3
+#define SATA_RESET_CTRL_DEASSERT      0x0
+#define SATA_PHY_RESET                BIT(0)
+#define SATA_P0_RESET                 BIT(1)
+#define SATA_LOS_LEVEL                0x9
+#define SATA_LOS_BIAS                 (0x02 << 16)
+#define SATA_REF_REPEATCLK_EN         BIT(0)
+#define SATA_REF_USE_PAD              BIT(20)
+#define SATA_P0_AMPLITUDE_GEN1        0x42
+#define SATA_P0_AMPLITUDE_GEN2        (0x46 << 8)
+#define SATA_P0_AMPLITUDE_GEN3        (0x73 << 16)
+#define SATA_P0_PHY_TX_PREEMPH_GEN1   0x05
+#define SATA_P0_PHY_TX_PREEMPH_GEN2   (0x05 << 8)
+#define SATA_P0_PHY_TX_PREEMPH_GEN3   (0x23 << 16)
+#define SATA_MPLL_MULTIPLIER          (0x3c << 16)
+#define SATA_M_CSYSREQ                BIT(0)
+#define SATA_S_CSYSREQ                BIT(16)
+#define HSPDME_RST_CTRL               0x41C
+#define SW_HSP_SATA_ARSTN             BIT(27)
+#define SW_SATA_RSTN                  (0xf << 9)
+
+static const struct ata_port_info ahci_port_info = {
+    .flags		= AHCI_FLAG_COMMON,
+    .pio_mask	= ATA_PIO4,
+    .udma_mask	= ATA_UDMA6,
+    .port_ops	= &ahci_platform_ops,
+};
+
+static const struct ata_port_info ahci_port_info_nolpm = {
+    .flags		= AHCI_FLAG_COMMON | ATA_FLAG_NO_LPM,
+    .pio_mask	= ATA_PIO4,
+    .udma_mask	= ATA_UDMA6,
+    .port_ops	= &ahci_platform_ops,
+};
+
+static struct scsi_host_template ahci_platform_sht = {
+    AHCI_SHT(DRV_NAME),
+};
+
+static int eswin_sata_sid_cfg(struct device *dev)
+{
+    int ret;
+    struct regmap *regmap;
+    int hsp_mmu_sata_reg;
+    u32 rdwr_sid_ssid;
+    u32 sid;
+    struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+
+    /* not behind smmu, use the default reset value(0x0) of the reg as streamID*/
+    if (fwspec == NULL) {
+        dev_dbg(dev, "dev is not behind smmu, skip configuration of sid\n");
+        return 0;
+    }
+    sid = fwspec->ids[0];
+    regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "eswin,hsp_sp_csr");
+    if (IS_ERR(regmap)) {
+        dev_dbg(dev, "No hsp_sp_csr phandle specified\n");
+        return 0;
+    }
+    ret = of_property_read_u32_index(dev->of_node, "eswin,hsp_sp_csr", 1,
+            &hsp_mmu_sata_reg);
+    if (ret) {
+        dev_err(dev, "can't get sata sid cfg reg offset (%d)\n", ret);
+        return ret;
+    }
+
+    /* make the reading sid the same as writing sid, ssid is fixed to zero */
+    rdwr_sid_ssid  = FIELD_PREP(AWSMMUSID, sid);
+    rdwr_sid_ssid |= FIELD_PREP(ARSMMUSID, sid);
+    rdwr_sid_ssid |= FIELD_PREP(AWSMMUSSID, 0);
+    rdwr_sid_ssid |= FIELD_PREP(ARSMMUSSID, 0);
+    regmap_write(regmap, hsp_mmu_sata_reg, rdwr_sid_ssid);
+
+    ret = eic7700_dynm_sid_enable(dev_to_node(dev));
+    if (ret < 0)
+        dev_err(dev, "failed to config sata streamID(%d)!\n", sid);
+     else
+        dev_dbg(dev, "success to config sata streamID(%d)!\n", sid);
+    pr_err("eswin_sata_sid_cfg success\n");
+   
+	return ret;
+}
+
+static int eswin_sata_init(struct device *dev)
+{
+    struct regmap *regmap;
+    regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "eswin,hsp_sp_csr");
+    if (IS_ERR(regmap)) {
+        dev_dbg(dev, "No hsp_sp_csr phandle specified\n");
+        return -1;
+    }
+    regmap_write(regmap, SATA_REF_CTRL1, 0x1);
+    regmap_write(regmap, SATA_PHY_CTRL0, (SATA_P0_AMPLITUDE_GEN1|SATA_P0_AMPLITUDE_GEN2|SATA_P0_AMPLITUDE_GEN3));
+    regmap_write(regmap, SATA_PHY_CTRL1, (SATA_P0_PHY_TX_PREEMPH_GEN1|SATA_P0_PHY_TX_PREEMPH_GEN2|SATA_P0_PHY_TX_PREEMPH_GEN3));
+    regmap_write(regmap, SATA_LOS_IDEN, SATA_LOS_LEVEL|SATA_LOS_BIAS);
+    regmap_write(regmap, SATA_AXI_LP_CTRL, (SATA_M_CSYSREQ|SATA_S_CSYSREQ));
+    regmap_write(regmap, SATA_REG_CTRL, (SATA_REF_REPEATCLK_EN|SATA_REF_USE_PAD));
+    regmap_write(regmap, SATA_MPLL_CTRL, SATA_MPLL_MULTIPLIER);
+    regmap_write(regmap, SATA_RESET_CTRL, 0x0);
+    
+	return 0;
+}
+
+static int __init eswin_reset(struct device *dev)
+{
+    struct reset_control *asic0_rst;
+    struct reset_control *oob_rst;
+    struct reset_control *pmalive_rst;
+    struct reset_control *rbc_rst;
+    struct reset_control *apb_rst;
+    int rc;
+    
+	asic0_rst = devm_reset_control_get_shared(dev, "asic0");
+    if (IS_ERR_OR_NULL(asic0_rst)) {
+        dev_err(dev, "Failed to asic0_rst handle\n");
+        return -EFAULT;
+    }
+    oob_rst = devm_reset_control_get_shared(dev, "oob");
+    if (IS_ERR_OR_NULL(oob_rst)) {
+        dev_err(dev, "Failed to oob_rst handle\n");
+        return -EFAULT;
+    }
+    pmalive_rst = devm_reset_control_get_shared(dev, "pmalive");
+    if (IS_ERR_OR_NULL(pmalive_rst)) {
+        dev_err(dev, "Failed to pmalive_rst handle\n");
+        return -EFAULT;
+    }
+    rbc_rst = devm_reset_control_get_shared(dev, "rbc");
+    if (IS_ERR_OR_NULL(rbc_rst)) {
+        dev_err(dev, "Failed to rbc_rst handle\n");
+        return -EFAULT;
+    }
+    apb_rst = devm_reset_control_get_shared(dev, "apb");
+    if (IS_ERR_OR_NULL(apb_rst)) {
+        dev_err(dev, "Failed to apb_rst handle\n");
+        return -EFAULT;
+    }
+
+    if (asic0_rst) {
+        rc = reset_control_deassert(asic0_rst);
+        WARN_ON(0 != rc);
+    }
+    if (oob_rst) {
+        rc = reset_control_deassert(oob_rst);
+        WARN_ON(0 != rc);
+    }
+    if (pmalive_rst) {
+        rc = reset_control_deassert(pmalive_rst);
+        WARN_ON(0 != rc);
+    }
+    if (rbc_rst) {
+        rc = reset_control_deassert(rbc_rst);
+        WARN_ON(0 != rc);
+    }
+    if (apb_rst) {
+        rc = reset_control_deassert(apb_rst);
+        WARN_ON(0 != rc);
+    }
+
+    return 0;
+}
+
+
+static int eswin_unreset(struct device *dev)
+{
+    struct reset_control *asic0_rst;
+    struct reset_control *oob_rst;
+    struct reset_control *pmalive_rst;
+    struct reset_control *rbc_rst;
+    int rc;
+
+    asic0_rst = devm_reset_control_get_shared(dev, "asic0");
+    if (IS_ERR_OR_NULL(asic0_rst)) {
+        dev_err(dev, "Failed to asic0_rst handle\n");
+        return -EFAULT;
+    }
+    oob_rst = devm_reset_control_get_shared(dev, "oob");
+    if (IS_ERR_OR_NULL(oob_rst)) {
+        dev_err(dev, "Failed to oob_rst handle\n");
+        return -EFAULT;
+    }
+    pmalive_rst = devm_reset_control_get_shared(dev, "pmalive");
+    if (IS_ERR_OR_NULL(pmalive_rst)) {
+        dev_err(dev, "Failed to pmalive_rst handle\n");
+        return -EFAULT;
+    }
+    rbc_rst = devm_reset_control_get_shared(dev, "rbc");
+    if (IS_ERR_OR_NULL(rbc_rst)) {
+        dev_err(dev, "Failed to rbc_rst handle\n");
+        return -EFAULT;
+    }
+    if (asic0_rst) {
+        rc = reset_control_assert(asic0_rst);
+        WARN_ON(0 != rc);
+    }
+    if (oob_rst) {
+        rc = reset_control_assert(oob_rst);
+        WARN_ON(0 != rc);
+    }
+    if (pmalive_rst) {
+        rc = reset_control_assert(pmalive_rst);
+        WARN_ON(0 != rc);
+    }
+    if (rbc_rst) {
+        rc = reset_control_assert(rbc_rst);
+        WARN_ON(0 != rc);
+    }
+
+return 0;
+}
+
+static int ahci_probe(struct platform_device *pdev)
+{
+    struct device *dev = &pdev->dev;
+    struct ahci_host_priv *hpriv;
+    const struct ata_port_info *port;
+    int rc;
+
+    hpriv = ahci_platform_get_resources(pdev,
+                        0);
+    if (IS_ERR(hpriv))
+        return PTR_ERR(hpriv);
+
+    rc = eswin_reset(dev);
+    if (rc)
+        return rc;
+    eswin_sata_init(dev);
+    eswin_sata_sid_cfg(dev);
+    eic7700_tbu_power(&pdev->dev, true);
+    rc = dma_set_mask_and_coherent(dev,DMA_BIT_MASK(64));
+
+    if (of_device_is_compatible(dev->of_node, "hisilicon,hisi-ahci"))
+        hpriv->flags |= AHCI_HFLAG_NO_FBS | AHCI_HFLAG_NO_NCQ;
+
+    port = acpi_device_get_match_data(dev);
+    if (!port){
+        port = &ahci_port_info;
+    }
+    rc = ahci_platform_init_host(pdev, hpriv, port,
+                &ahci_platform_sht);
+    if (rc)
+        goto disable_resources;
+
+    return 0;
+
+disable_resources:
+    ahci_platform_disable_resources(hpriv);
+    return rc;
+}
+
+static void ahci_remove(struct platform_device *pdev)
+{
+    eic7700_tbu_power(&pdev->dev, false);
+    eswin_unreset(&pdev->dev);
+
+    ata_platform_remove_one(pdev);
+}
+
+static SIMPLE_DEV_PM_OPS(ahci_pm_ops, ahci_platform_suspend,
+            ahci_platform_resume);
+
+static const struct of_device_id ahci_of_match[] = {
+    { .compatible = "snps,eswin-ahci", },
+    {},
+};
+MODULE_DEVICE_TABLE(of, ahci_of_match);
+
+static const struct acpi_device_id ahci_acpi_match[] = {
+    { "APMC0D33", (unsigned long)&ahci_port_info_nolpm },
+    { ACPI_DEVICE_CLASS(PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff) },
+    {},
+};
+MODULE_DEVICE_TABLE(acpi, ahci_acpi_match);
+
+static struct platform_driver ahci_driver = {
+    .probe = ahci_probe,
+    .remove_new = ahci_remove,
+    .shutdown = ahci_platform_shutdown,
+    .driver = {
+        .name = DRV_NAME,
+        .of_match_table = ahci_of_match,
+        .acpi_match_table = ahci_acpi_match,
+        .pm = &ahci_pm_ops,
+    },
+};
+module_platform_driver(ahci_driver);
+
+MODULE_DESCRIPTION("ESWIN AHCI SATA driver");
+MODULE_AUTHOR("Lu Yulin <luyulin@eswincomputing.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/clk/Kconfig b/drivers/clk/Kconfig
index c30099866174..151de7e16525 100644
--- a/drivers/clk/Kconfig
+++ b/drivers/clk/Kconfig
@@ -471,6 +471,7 @@ source "drivers/clk/actions/Kconfig"
 source "drivers/clk/analogbits/Kconfig"
 source "drivers/clk/baikal-t1/Kconfig"
 source "drivers/clk/bcm/Kconfig"
+source "drivers/clk/eswin/Kconfig"
 source "drivers/clk/hisilicon/Kconfig"
 source "drivers/clk/imgtec/Kconfig"
 source "drivers/clk/imx/Kconfig"
diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index 18969cbd4bb1..1d36e1ef74df 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -91,6 +91,7 @@ obj-$(CONFIG_CLK_BAIKAL_T1)		+= baikal-t1/
 obj-y					+= bcm/
 obj-$(CONFIG_ARCH_BERLIN)		+= berlin/
 obj-$(CONFIG_ARCH_DAVINCI)		+= davinci/
+obj-$(CONFIG_SOC_SIFIVE_EIC7700)	+= eswin/
 obj-$(CONFIG_ARCH_HISI)			+= hisilicon/
 obj-y					+= imgtec/
 obj-y					+= imx/
diff --git a/drivers/clk/eswin/Kconfig b/drivers/clk/eswin/Kconfig
new file mode 100755
index 000000000000..cc906e4b2343
--- /dev/null
+++ b/drivers/clk/eswin/Kconfig
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0-only
+
+config COMMON_CLK_EIC7700
+	bool "EIC7700 Clock Driver"
+	help
+	  Build the Eswin EIC7700 clock driver based on the common clock framework.
diff --git a/drivers/clk/eswin/Makefile b/drivers/clk/eswin/Makefile
new file mode 100755
index 000000000000..a3139e34ee22
--- /dev/null
+++ b/drivers/clk/eswin/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Eswin Clock specific Makefile
+#
+
+obj-y	+= clk.o
+
+obj-$(CONFIG_COMMON_CLK_EIC7700)	+= clk-eic7700.o
diff --git a/drivers/clk/eswin/clk-eic7700.c b/drivers/clk/eswin/clk-eic7700.c
new file mode 100755
index 000000000000..1b6c0b9e0450
--- /dev/null
+++ b/drivers/clk/eswin/clk-eic7700.c
@@ -0,0 +1,1187 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Clk Provider Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+
+#include <dt-bindings/reset/eic7700-syscrg.h>
+#include <dt-bindings/clock/eic7700-clock.h>
+
+#include "clk.h"
+
+/* clock parent list */
+static const char *const mux_u_cpu_root_3mux1_gfree_p[] = {"clk_pll_cpu", "clk_clk_u84_core_lp", "fixed_rate_clk_xtal_24m"};
+static u32  mux_u_cpu_root_3mux1_gfree_p_table[] = {0x000000, 0x000001, 0x000002};
+
+static const char *const mux_u_cpu_aclk_2mux1_gfree_p[] = {"fixed_factor_u_cpu_div2", "mux_u_cpu_root_3mux1_gfree"};
+
+static const char *const dsp_aclk_root_2mux1_gfree_mux_p[] = {"fixed_rate_clk_spll2_fout1", "fixed_rate_clk_spll0_fout1"};
+
+static const char *const d2d_aclk_root_2mux1_gfree_mux_p[] = { "fixed_rate_clk_spll2_fout1", "fixed_rate_clk_spll0_fout1", };
+
+static const char *const ddr_aclk_root_2mux1_gfree_mux_p[] = { "fixed_rate_clk_spll2_fout1", "fixed_rate_clk_spll0_fout1", };
+
+static const char *const mshcore_root_3mux1_0_mux_p[] = {"fixed_rate_clk_spll0_fout3", "fixed_rate_clk_spll2_fout3", "fixed_rate_clk_xtal_24m"};
+static u32  mshcore_root_3mux1_0_mux_p_table[] = {0x000000, 0x000001, 0x100000};
+
+static const char *const mshcore_root_3mux1_1_mux_p[] = {"fixed_rate_clk_spll0_fout3", "fixed_rate_clk_spll2_fout3", "fixed_rate_clk_xtal_24m"};
+static u32  mshcore_root_3mux1_1_mux_p_table[] = {0x000000, 0x000001, 0x100000};
+
+static const char *const mshcore_root_3mux1_2_mux_p[] = {"fixed_rate_clk_spll0_fout3", "fixed_rate_clk_spll2_fout3", "fixed_rate_clk_xtal_24m"};
+static u32  mshcore_root_3mux1_2_mux_p_table[] = {0x000000, 0x000001, 0x100000};
+
+static const char *const npu_llclk_3mux1_gfree_mux_p[] = { "clk_clk_npu_llc_src0", "clk_clk_npu_llc_src1", "fixed_rate_clk_vpll_fout1"};
+static u32  npu_llclk_3mux1_gfree_mux_p_table[] = {0x000000, 0x000001, 0x000002};
+
+static const char *const npu_core_3mux1_gfree_mux_p[] = { "fixed_rate_clk_spll1_fout1", "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll2_fout2"};
+static u32  npu_core_3mux1_gfree_mux_p_table[] = {0x000000, 0x000001, 0x000002};
+
+static const char *const npu_e31_3mux1_gfree_mux_p[] = { "fixed_rate_clk_spll1_fout1", "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll2_fout2"};
+static u32  npu_e31_3mux1_gfree_mux_p_table[] = {0x000000, 0x000100, 0x000200};
+
+static const char *const vi_aclk_root_2mux1_gfree_mux_p[] = { "fixed_rate_clk_spll0_fout1", "fixed_rate_clk_spll2_fout1"};
+
+static const char *const mux_u_vi_dw_root_2mux1_p[] = { "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll0_fout1"};
+
+static const char *const mux_u_vi_dvp_root_2mux1_gfree_p[] = { "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll0_fout1"};
+
+static const char *const mux_u_vi_dig_isp_root_2mux1_gfree_p[] = { "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll0_fout1"};
+
+static const char *const mux_u_vo_aclk_root_2mux1_gfree_p[] = { "fixed_rate_clk_spll0_fout1", "fixed_rate_clk_spll2_fout1"};
+
+static const char *const mux_u_vo_pixel_root_2mux1_p[] = { "fixed_rate_clk_vpll_fout1", "fixed_rate_clk_spll2_fout2"};
+
+static const char *const mux_u_vcdec_root_2mux1_gfree_p[] = { "fixed_rate_clk_spll0_fout1", "fixed_rate_clk_spll2_fout1"};
+
+static const char *const mux_u_vcaclk_root_2mux1_gfree_p[] = { "fixed_rate_clk_spll0_fout1", "fixed_rate_clk_spll2_fout1"};
+
+static const char *const mux_u_syscfg_clk_root_2mux1_gfree_p[] = { "divder_u_sys_cfg_div_dynm", "fixed_rate_clk_xtal_24m"};
+
+static const char *const mux_u_bootspi_clk_2mux1_gfree_p[] = {  "divder_u_bootspi_div_dynm", "fixed_rate_clk_xtal_24m"};
+
+static const char *const mux_u_scpu_core_clk_2mux1_gfree_p[] = { "divder_u_scpu_core_div_dynm", "fixed_rate_clk_xtal_24m"};
+
+static const char *const mux_u_lpcpu_core_clk_2mux1_gfree_p[] = {"divder_u_lpcpu_core_div_dynm", "fixed_rate_clk_xtal_24m"};
+
+static const char *const mux_u_vo_mclk_2mux_ext_mclk_p[] = {"divder_u_vo_mclk_div_dynm", "fixed_rate_ext_mclk"};
+
+static const char *const mux_u_aondma_axi2mux1_gfree_p[] = { "divder_u_aondma_axi_div_dynm", "fixed_rate_clk_xtal_24m"};
+
+static const char *const mux_u_rmii_ref_2mux1_p[] = { "fixed_factor_u_hsp_rmii_ref_div6", "fixed_rate_lpddr_ref_bak"};
+
+static const char *const mux_u_eth_core_2mux1_p[] = { "fixed_rate_clk_spll1_fout3", "fixed_rate_lpddr_ref_bak"};
+
+static const char *const mux_u_sata_phy_2mux1_p[] = { "divder_u_sata_phy_ref_div_dynm", "fixed_rate_lpddr_ref_bak"};
+
+/* fixed rate clocks */
+static struct eswin_fixed_rate_clock eic7700_fixed_rate_clks[] = {
+	{ EIC7700_XTAL_24M,		"fixed_rate_clk_xtal_24m",	NULL, 0,	24000000, },
+	{ EIC7700_XTAL_32K,		"fixed_rate_clk_xtal_32k",	NULL, 0,	32768, },
+	{ EIC7700_SPLL0_FOUT1,		"fixed_rate_clk_spll0_fout1",	NULL, 0,	1600000000, },
+	{ EIC7700_SPLL0_FOUT2,		"fixed_rate_clk_spll0_fout2",	NULL, 0,	800000000, },
+	{ EIC7700_SPLL0_FOUT3,		"fixed_rate_clk_spll0_fout3",	NULL, 0,	400000000, },
+	{ EIC7700_SPLL1_FOUT1,		"fixed_rate_clk_spll1_fout1",	NULL, 0,	1500000000, },
+	{ EIC7700_SPLL1_FOUT2,  	"fixed_rate_clk_spll1_fout2",	NULL, 0,	300000000, },
+	{ EIC7700_SPLL1_FOUT3,		"fixed_rate_clk_spll1_fout3",	NULL, 0,	250000000, },
+	{ EIC7700_SPLL2_FOUT1,		"fixed_rate_clk_spll2_fout1",	NULL, 0,	2080000000, },
+	{ EIC7700_SPLL2_FOUT2,		"fixed_rate_clk_spll2_fout2",	NULL, 0,	1040000000, },
+	{ EIC7700_SPLL2_FOUT3,		"fixed_rate_clk_spll2_fout3",	NULL, 0,	416000000, },
+	{ EIC7700_VPLL_FOUT1,		"fixed_rate_clk_vpll_fout1",	NULL, 0,	1188000000, },
+	{ EIC7700_VPLL_FOUT2,		"fixed_rate_clk_vpll_fout2",	NULL, 0,	594000000, },
+	{ EIC7700_VPLL_FOUT3,		"fixed_rate_clk_vpll_fout3",	NULL, 0,	49500000, },
+	{ EIC7700_APLL_FOUT2,		"fixed_rate_clk_apll_fout2",	NULL, 0,	0, },
+	{ EIC7700_APLL_FOUT3,		"fixed_rate_clk_apll_fout3",	NULL, 0,	0, },
+	{ EIC7700_EXT_MCLK,		"fixed_rate_ext_mclk",		NULL, 0,	0, },
+	{ EIC7700_LPDDR_REF_BAK,	"fixed_rate_lpddr_ref_bak",	NULL, 0,	50000000, },
+};
+
+static struct eswin_pll_clock eic7700_pll_clks[] = {
+	{
+		EIC7700_APLL_FOUT1, "clk_apll_fout1", NULL,
+		EIC7700_REG_OFFSET_APLL_CFG_0, 0, 1, 12,6, 20,12,
+		EIC7700_REG_OFFSET_APLL_CFG_1, 4,24,
+		EIC7700_REG_OFFSET_APLL_CFG_2, 1,3, 16, 3,
+		EIC7700_REG_OFFSET_PLL_STATUS, 4, 1,
+	},
+	{
+		EIC7700_PLL_CPU, "clk_pll_cpu", NULL,
+		EIC7700_REG_OFFSET_MCPUT_PLL_CFG_0, 0,1, 12,6, 20,12,
+		EIC7700_REG_OFFSET_MCPUT_PLL_CFG_1, 4, 24,
+		EIC7700_REG_OFFSET_MCPUT_PLL_CFG_2, 1,3, 16,3,
+		EIC7700_REG_OFFSET_PLL_STATUS, 5, 1,
+	},
+};
+
+/* fixed factor clocks */
+static struct eswin_fixed_factor_clock eic7700_fixed_factor_clks[] = {
+	{ EIC7700_FIXED_FACTOR_U_CPU_DIV2,	 "fixed_factor_u_cpu_div2",   "mux_u_cpu_root_3mux1_gfree", 1, 2, 0, },
+
+	{ EIC7700_FIXED_FACTOR_U_CLK_1M_DIV24,   "fixed_factor_u_clk_1m_div24",   "fixed_rate_clk_xtal_24m", 1, 24, 0, },
+
+	{ EIC7700_FIXED_FACTOR_U_MIPI_TXESC_DIV10, "fixed_factor_u_mipi_txesc_div10", "clk_clk_sys_cfg",  1, 10, 0, },
+
+	{ EIC7700_FIXED_FACTOR_U_U84_CORE_LP_DIV2,   "fixed_factor_u_u84_core_lp_div2",   "gate_clk_spll0_fout2", 1, 2, 0, },
+
+	{ EIC7700_FIXED_FACTOR_U_SCPU_BUS_DIV2,   "fixed_factor_u_scpu_bus_div2",   "mux_u_scpu_core_clk_2mux1_gfree", 1, 2, 0, },
+
+	{ EIC7700_FIXED_FACTOR_U_LPCPU_BUS_DIV2, "fixed_factor_u_lpcpu_bus_div2", "mux_u_lpcpu_core_clk_2mux1_gfree",  1, 2, 0, },
+
+	{ EIC7700_FIXED_FACTOR_U_PCIE_CR_DIV2,   "fixed_factor_u_pcie_cr_div2",   "clk_clk_sys_cfg", 1, 2, 0, },
+
+	{ EIC7700_FIXED_FACTOR_U_PCIE_AUX_DIV4,   "fixed_factor_u_pcie_aux_div4",   "clk_clk_sys_cfg", 1, 4, 0, },
+
+	{ EIC7700_FIXED_FACTOR_U_PVT_DIV20, "fixed_factor_u_pvt_div20", "fixed_rate_clk_xtal_24m",  1, 20, 0, },
+
+	{ EIC7700_FIXED_FACTOR_U_HSP_RMII_REF_DIV6, "fixed_factor_u_hsp_rmii_ref_div6", "fixed_rate_clk_spll1_fout2",  1, 6, 0, },
+};
+
+static struct eswin_mux_clock eic7700_mux_clks[] = {
+	{ EIC7700_MUX_U_CPU_ROOT_3MUX1_GFREE, "mux_u_cpu_root_3mux1_gfree", mux_u_cpu_root_3mux1_gfree_p,
+		ARRAY_SIZE(mux_u_cpu_root_3mux1_gfree_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_U84_CLK_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(1), 0, mux_u_cpu_root_3mux1_gfree_p_table, },
+
+	{ EIC7700_MUX_U_CPU_ACLK_2MUX1_GFREE, "mux_u_cpu_aclk_2mux1_gfree", mux_u_cpu_aclk_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_cpu_aclk_2mux1_gfree_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_U84_CLK_CTRL,
+		20, 1, 0,},
+
+	{ EIC7700_MUX_U_DSP_ACLK_ROOT_2MUX1_GFREE, "mux_u_dsp_aclk_root_2mux1_gfree", dsp_aclk_root_2mux1_gfree_mux_p,
+		ARRAY_SIZE(dsp_aclk_root_2mux1_gfree_mux_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_DSP_ACLK_CTRL,
+		0, 1, 0,},
+
+	{ EIC7700_MUX_U_D2D_ACLK_ROOT_2MUX1_GFREE, "mux_u_d2d_aclk_root_2mux1_gfree", d2d_aclk_root_2mux1_gfree_mux_p,
+		ARRAY_SIZE(d2d_aclk_root_2mux1_gfree_mux_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_D2D_ACLK_CTRL,
+		0, 1, 0,},
+
+	{ EIC7700_MUX_U_DDR_ACLK_ROOT_2MUX1_GFREE, "mux_u_ddr_aclk_root_2mux1_gfree", ddr_aclk_root_2mux1_gfree_mux_p,
+		ARRAY_SIZE(ddr_aclk_root_2mux1_gfree_mux_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_DDR_CLK_CTRL,
+		16, 1, 0,},
+
+	{ EIC7700_MUX_U_MSHCORE_ROOT_3MUX1_0, "mux_u_mshcore_root_3mux1_0", mshcore_root_3mux1_0_mux_p,
+		ARRAY_SIZE(mshcore_root_3mux1_0_mux_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_MSHC0_CORECLK_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(20), 0, mshcore_root_3mux1_0_mux_p_table},
+
+	{ EIC7700_MUX_U_MSHCORE_ROOT_3MUX1_1, "mux_u_mshcore_root_3mux1_1", mshcore_root_3mux1_1_mux_p,
+		ARRAY_SIZE(mshcore_root_3mux1_1_mux_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_MSHC1_CORECLK_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(20), 0, mshcore_root_3mux1_1_mux_p_table, },
+
+	{ EIC7700_MUX_U_MSHCORE_ROOT_3MUX1_2, "mux_u_mshcore_root_3mux1_2", mshcore_root_3mux1_2_mux_p,
+		ARRAY_SIZE(mshcore_root_3mux1_2_mux_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_MSHC2_CORECLK_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(20), 0, mshcore_root_3mux1_2_mux_p_table },
+
+	{ EIC7700_MUX_U_NPU_LLCLK_3MUX1_GFREE, "mux_u_npu_llclk_3mux1_gfree", npu_llclk_3mux1_gfree_mux_p,
+		ARRAY_SIZE(npu_llclk_3mux1_gfree_mux_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_NPU_LLC_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(1), 0, npu_llclk_3mux1_gfree_mux_p_table},
+
+	{ EIC7700_MUX_U_NPU_CORE_3MUX1_GFREE, "mux_u_npu_core_3mux1_gfree", npu_core_3mux1_gfree_mux_p,
+		ARRAY_SIZE(npu_core_3mux1_gfree_mux_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_NPU_CORE_CTRL,
+		0, BIT_MASK(0) | BIT_MASK(1), 0, npu_core_3mux1_gfree_mux_p_table},
+
+	{ EIC7700_MUX_U_NPU_E31_3MUX1_GFREE, "mux_u_npu_e31_3mux1_gfree", npu_e31_3mux1_gfree_mux_p,
+		ARRAY_SIZE(npu_e31_3mux1_gfree_mux_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_NPU_CORE_CTRL,
+		0, BIT_MASK(8) | BIT_MASK(9), 0, npu_e31_3mux1_gfree_mux_p_table},
+
+	{ EIC7700_MUX_U_VI_ACLK_ROOT_2MUX1_GFREE, "mux_u_vi_aclk_root_2mux1_gfree", vi_aclk_root_2mux1_gfree_mux_p,
+		ARRAY_SIZE(vi_aclk_root_2mux1_gfree_mux_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_VI_ACLK_CTRL,
+		0, 1, 0,},
+
+	{ EIC7700_MUX_U_VI_DW_ROOT_2MUX1, "mux_u_vi_dw_root_2mux1", mux_u_vi_dw_root_2mux1_p,
+		ARRAY_SIZE(mux_u_vi_dw_root_2mux1_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_VI_DWCLK_CTRL,
+		0, 1, 0,},
+
+	{ EIC7700_MUX_U_VI_DVP_ROOT_2MUX1_GFREE, "mux_u_vi_dvp_root_2mux1_gfree", mux_u_vi_dvp_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_vi_dvp_root_2mux1_gfree_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_VI_DVP_CLK_CTRL,
+		0, 1, 0, },
+
+	{ EIC7700_MUX_U_VI_DIG_ISP_ROOT_2MUX1_GFREE, "mux_u_vi_dig_isp_root_2mux1_gfree", mux_u_vi_dig_isp_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_vi_dig_isp_root_2mux1_gfree_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_VI_DIG_ISP_CLK_CTRL,
+		0, 1, 0, },
+
+	{ EIC7700_MUX_U_VO_ACLK_ROOT_2MUX1_GFREE, "mux_u_vo_aclk_root_2mux1_gfree", mux_u_vo_aclk_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_vo_aclk_root_2mux1_gfree_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_VO_ACLK_CTRL,
+		0, 1, 0, },
+
+	{ EIC7700_MUX_U_VO_PIXEL_ROOT_2MUX1, "mux_u_vo_pixel_root_2mux1", mux_u_vo_pixel_root_2mux1_p,
+		ARRAY_SIZE(mux_u_vo_pixel_root_2mux1_p), CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_VO_PIXEL_CTRL,
+		0, 1, 0, },
+
+	{ EIC7700_MUX_U_VCDEC_ROOT_2MUX1_GFREE,  "mux_u_vcdec_root_2mux1_gfree",  mux_u_vcdec_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_vcdec_root_2mux1_gfree_p),  CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_VCDEC_ROOTCLK_CTRL,
+		0, 1, 0, },
+
+	{ EIC7700_MUX_U_VCACLK_ROOT_2MUX1_GFREE,  "mux_u_vcaclk_root_2mux1_gfree",  mux_u_vcaclk_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_vcaclk_root_2mux1_gfree_p),  CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_VC_ACLK_CTRL,
+		0, 1, 0, },
+
+	{ EIC7700_MUX_U_SYSCFG_CLK_ROOT_2MUX1_GFREE,  "mux_u_syscfg_clk_root_2mux1_gfree",  mux_u_syscfg_clk_root_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_syscfg_clk_root_2mux1_gfree_p),  CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_SYSCFG_CLK_CTRL,
+		0, 1, 0, },
+
+	{ EIC7700_MUX_U_BOOTSPI_CLK_2MUX1_GFREE,  "mux_u_bootspi_clk_2mux1_gfree",  mux_u_bootspi_clk_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_bootspi_clk_2mux1_gfree_p),  CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_BOOTSPI_CLK_CTRL,
+		0, 1, 0, },
+
+	{ EIC7700_MUX_U_SCPU_CORE_CLK_2MUX1_GFREE,  "mux_u_scpu_core_clk_2mux1_gfree",  mux_u_scpu_core_clk_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_scpu_core_clk_2mux1_gfree_p),  CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_SCPU_CORECLK_CTRL,
+		0, 1, 0, },
+
+	{ EIC7700_MUX_U_LPCPU_CORE_CLK_2MUX1_GFREE,  "mux_u_lpcpu_core_clk_2mux1_gfree",  mux_u_lpcpu_core_clk_2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_lpcpu_core_clk_2mux1_gfree_p),  CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_LPCPU_CORECLK_CTRL,
+		0, 1, 0, },
+
+	{ EIC7700_MUX_U_VO_MCLK_2MUX_EXT_MCLK,  "mux_u_vo_mclk_2mux_ext_mclk",  mux_u_vo_mclk_2mux_ext_mclk_p,
+		ARRAY_SIZE(mux_u_vo_mclk_2mux_ext_mclk_p),  CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_VO_MCLK_CTRL,
+		0, 1, 0, },
+
+	{ EIC7700_MUX_U_AONDMA_AXI2MUX1_GFREE,  "mux_u_aondma_axi2mux1_gfree",  mux_u_aondma_axi2mux1_gfree_p,
+		ARRAY_SIZE(mux_u_aondma_axi2mux1_gfree_p),  CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_AON_DMA_CLK_CTRL,
+		20, 1, 0, },
+
+	{ EIC7700_MUX_U_RMII_REF_2MUX,  "mux_u_rmii_ref_2mux1",  mux_u_rmii_ref_2mux1_p,
+		ARRAY_SIZE(mux_u_rmii_ref_2mux1_p),  CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_ETH0_CTRL,
+		2, 1, 0, },
+
+	{ EIC7700_MUX_U_ETH_CORE_2MUX1,  "mux_u_eth_core_2mux1",  mux_u_eth_core_2mux1_p,
+		ARRAY_SIZE(mux_u_eth_core_2mux1_p),  CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_ETH0_CTRL,
+		1, 1, 0, },
+
+	{ EIC7700_MUX_U_SATA_PHY_2MUX1,  "mux_u_sata_phy_2mux1",  mux_u_sata_phy_2mux1_p,
+		ARRAY_SIZE(mux_u_sata_phy_2mux1_p),  CLK_SET_RATE_PARENT, EIC7700_REG_OFFSET_SATA_OOB_CTRL,
+		9, 1, 0, },
+
+};
+
+/*The hardware decides vaule 0, 1 and 2 both means 2 divsor, so we have to add these ugly tables*/
+static struct clk_div_table u_3_bit_special_div_table[8];
+static struct clk_div_table u_4_bit_special_div_table[16];
+static struct clk_div_table u_6_bit_special_div_table[64];
+static struct clk_div_table u_7_bit_special_div_table[128];
+static struct clk_div_table u_8_bit_special_div_table[256];
+static struct clk_div_table u_11_bit_special_div_table[2048];
+static struct clk_div_table u_16_bit_special_div_table[65536];
+
+static struct eswin_divider_clock eic7700_div_clks[] = {
+	{ EIC7700_DIVDER_U_SYS_CFG_DIV_DYNM, "divder_u_sys_cfg_div_dynm",   "fixed_rate_clk_spll0_fout3", 0,
+		EIC7700_REG_OFFSET_SYSCFG_CLK_CTRL, 4, 3, CLK_DIVIDER_ROUND_CLOSEST, u_3_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_NOC_NSP_DIV_DYNM,   "divder_u_noc_nsp_div_dynm", "fixed_rate_clk_spll2_fout1", 0,
+		EIC7700_REG_OFFSET_NOC_CLK_CTRL, 0, 3, CLK_DIVIDER_ROUND_CLOSEST, u_3_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_BOOTSPI_DIV_DYNM,       "divder_u_bootspi_div_dynm",     "gate_clk_spll0_fout2", 0,
+		EIC7700_REG_OFFSET_BOOTSPI_CLK_CTRL, 4, 6, CLK_DIVIDER_ROUND_CLOSEST, u_6_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_SCPU_CORE_DIV_DYNM,     "divder_u_scpu_core_div_dynm",   "fixed_rate_clk_spll0_fout1", 0,
+		EIC7700_REG_OFFSET_SCPU_CORECLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_LPCPU_CORE_DIV_DYNM,     "divder_u_lpcpu_core_div_dynm",   "fixed_rate_clk_spll0_fout1", 0,
+		EIC7700_REG_OFFSET_LPCPU_CORECLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_GPU_ACLK_DIV_DYNM,     "divder_u_gpu_aclk_div_dynm",   "fixed_rate_clk_spll0_fout1", 0,
+		EIC7700_REG_OFFSET_GPU_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_DSP_ACLK_DIV_DYNM,     "divder_u_dsp_aclk_div_dynm",   "clk_clk_dsp_root", 0,
+		EIC7700_REG_OFFSET_DSP_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_D2D_ACLK_DIV_DYNM, "divder_u_d2d_aclk_div_dynm",   "mux_u_d2d_aclk_root_2mux1_gfree", 0,
+		EIC7700_REG_OFFSET_D2D_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_DDR_ACLK_DIV_DYNM, "divder_u_ddr_aclk_div_dynm",   "mux_u_ddr_aclk_root_2mux1_gfree", 0,
+		EIC7700_REG_OFFSET_DDR_CLK_CTRL, 20, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_HSP_ACLK_DIV_DYNM,   "divder_u_hsp_aclk_div_dynm", "fixed_rate_clk_spll0_fout1", 0,
+		EIC7700_REG_OFFSET_HSP_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_ETH_TXCLK_DIV_DYNM_0,     "divder_u_eth_txclk_div_dynm_0",   "mux_u_eth_core_2mux1", 0,
+		EIC7700_REG_OFFSET_ETH0_CTRL, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_ETH_TXCLK_DIV_DYNM_1,     "divder_u_eth_txclk_div_dynm_1",   "mux_u_eth_core_2mux1", 0,
+		EIC7700_REG_OFFSET_ETH1_CTRL, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_MSHC_CORE_DIV_DYNM_0,     "divder_u_mshc_core_div_dynm_0",   "mux_u_mshcore_root_3mux1_0", 0,
+		EIC7700_REG_OFFSET_MSHC0_CORECLK_CTRL, 4, 12, CLK_DIVIDER_ONE_BASED},
+
+	{ EIC7700_DIVDER_U_MSHC_CORE_DIV_DYNM_1,     "divder_u_mshc_core_div_dynm_1",   "mux_u_mshcore_root_3mux1_1", 0,
+		EIC7700_REG_OFFSET_MSHC1_CORECLK_CTRL, 4, 12, CLK_DIVIDER_ONE_BASED},
+
+	{ EIC7700_DIVDER_U_MSHC_CORE_DIV_DYNM_2,     "divder_u_mshc_core_div_dynm_2",   "mux_u_mshcore_root_3mux1_2",  0,
+		EIC7700_REG_OFFSET_MSHC2_CORECLK_CTRL, 4, 12, CLK_DIVIDER_ONE_BASED},
+
+	{ EIC7700_DIVDER_U_PCIE_ACLK_DIV_DYNM,   "divder_u_pcie_aclk_div_dynm", "fixed_rate_clk_spll2_fout2", 0,
+		EIC7700_REG_OFFSET_PCIE_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_NPU_ACLK_DIV_DYNM,        "divder_u_npu_aclk_div_dynm", "fixed_rate_clk_spll0_fout1", 0,
+		EIC7700_REG_OFFSET_NPU_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_NPU_LLC_SRC0_DIV_DYNM,    "divder_u_npu_llc_src0_div_dynm",  "fixed_rate_clk_spll0_fout1", 0,
+		EIC7700_REG_OFFSET_NPU_LLC_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_NPU_LLC_SRC1_DIV_DYNM,    "divder_u_npu_llc_src1_div_dynm",   "fixed_rate_clk_spll2_fout1", 0,
+		EIC7700_REG_OFFSET_NPU_LLC_CTRL, 8, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_NPU_CORECLK_DIV_DYNM,     "divder_u_npu_coreclk_div_dynm",   "mux_u_npu_core_3mux1_gfree", 0,
+		EIC7700_REG_OFFSET_NPU_CORE_CTRL, 4, 4, CLK_DIVIDER_ONE_BASED},
+
+	{ EIC7700_DIVDER_U_NPU_E31_DIV_DYNM,         "divder_u_npu_e31_div_dynm",   "mux_u_npu_e31_3mux1_gfree", 0,
+		EIC7700_REG_OFFSET_NPU_CORE_CTRL, 12, 4, CLK_DIVIDER_ONE_BASED},
+
+	{ EIC7700_DIVDER_U_VI_ACLK_DIV_DYNM,          "divder_u_vi_aclk_div_dynm",   "mux_u_vi_aclk_root_2mux1_gfree", 0,
+		EIC7700_REG_OFFSET_VI_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VI_DW_DIV_DYNM,            "divder_u_vi_dw_div_dynm",   "mux_u_vi_dw_root_2mux1", 0,
+		EIC7700_REG_OFFSET_VI_DWCLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VI_DVP_DIV_DYNM,        "divder_u_vi_dvp_div_dynm",   "mux_u_vi_dig_root_2mux1_gfree", 0,
+		EIC7700_REG_OFFSET_VI_DVP_CLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VI_DIG_ISP_DIV_DYNM,       "divder_u_vi_dig_isp_div_dynm", "mux_u_vi_dig_isp_root_2mux1_gfree", 0,
+		EIC7700_REG_OFFSET_VI_DIG_ISP_CLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_0,     "divder_u_vi_shutter_div_dynm_0",   "fixed_rate_clk_vpll_fout2",0,
+		EIC7700_REG_OFFSET_VI_SHUTTER0, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_1,     "divder_u_vi_shutter_div_dynm_1",   "fixed_rate_clk_vpll_fout2", 0,
+		EIC7700_REG_OFFSET_VI_SHUTTER1, 4, 7,  CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_2,     "divder_u_vi_shutter_div_dynm_2",   "fixed_rate_clk_vpll_fout2", 0,
+		EIC7700_REG_OFFSET_VI_SHUTTER2, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_3,     "divder_u_vi_shutter_div_dynm_3",   "fixed_rate_clk_vpll_fout2", 0,
+		EIC7700_REG_OFFSET_VI_SHUTTER3, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_4,     "divder_u_vi_shutter_div_dynm_4",   "fixed_rate_clk_vpll_fout2", 0,
+		EIC7700_REG_OFFSET_VI_SHUTTER4, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_5,     "divder_u_vi_shutter_div_dynm_5",   "fixed_rate_clk_vpll_fout2", 0,
+		EIC7700_REG_OFFSET_VI_SHUTTER5, 4, 7, CLK_DIVIDER_ROUND_CLOSEST, u_7_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VO_ACLK_DIV_DYNM,         "divder_u_vo_aclk_div_dynm", "mux_u_vo_aclk_root_2mux1_gfree", 0,
+		EIC7700_REG_OFFSET_VO_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_IESMCLK_DIV_DYNM,       "divder_u_iesmclk_div_dynm",     "fixed_rate_clk_spll0_fout3", 0,
+		EIC7700_REG_OFFSET_VO_IESMCLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VO_PIXEL_DIV_DYNM,	 "divder_u_vo_pixel_div_dynm",	"mux_u_vo_pixel_root_2mux1", 0,
+		EIC7700_REG_OFFSET_VO_PIXEL_CTRL, 4, 6, CLK_DIVIDER_ROUND_CLOSEST, u_6_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VO_MCLK_DIV_DYNM,     "divder_u_vo_mclk_div_dynm",   "clk_apll_fout1", 0,
+		EIC7700_REG_OFFSET_VO_MCLK_CTRL, 4, 8, CLK_DIVIDER_ROUND_CLOSEST, u_8_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VO_CEC_DIV_DYNM,     "divder_u_vo_cec_div_dynm",   "fixed_rate_clk_vpll_fout2", 0,
+		EIC7700_REG_OFFSET_VO_PHY_CLKCTRL, 16, 16, CLK_DIVIDER_ROUND_CLOSEST, u_16_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VC_ACLK_DIV_DYNM,     "divder_u_vc_aclk_div_dynm",   "mux_u_vcaclk_root_2mux1_gfree", 0,
+		EIC7700_REG_OFFSET_VC_ACLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_JD_DIV_DYNM,     "divder_u_jd_div_dynm",   "clk_clk_vc_root", 0,
+		EIC7700_REG_OFFSET_JD_CLK_CTRL, 4, 4,  CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_JE_DIV_DYNM,     "divder_u_je_div_dynm",   "clk_clk_vc_root", 0,
+		EIC7700_REG_OFFSET_JE_CLK_CTRL, 4, 4,  CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VE_DIV_DYNM,     "divder_u_ve_div_dynm",   "clk_clk_vc_root", 0,
+		EIC7700_REG_OFFSET_VE_CLK_CTRL, 4, 4,  CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_VD_DIV_DYNM,     "divder_u_vd_div_dynm",    "clk_clk_vc_root", 0,
+		EIC7700_REG_OFFSET_VD_CLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_G2D_DIV_DYNM,       "divder_u_g2d_div_dynm",     "clk_clk_dsp_root", 0,
+		EIC7700_REG_OFFSET_G2D_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_AONDMA_AXI_DIV_DYNM,     "divder_u_aondma_axi_div_dynm",   "fixed_rate_clk_spll0_fout1", 0,
+		EIC7700_REG_OFFSET_AON_DMA_CLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_CRYPTO_DIV_DYNM,     "divder_u_crypto_div_dynm",   "fixed_rate_clk_spll0_fout1", 0,
+		EIC7700_REG_OFFSET_SPACC_CLK_CTRL, 4, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_SATA_PHY_REF_DIV_DYNM,     "divder_u_sata_phy_ref_div_dynm",   "fixed_rate_clk_spll1_fout2", 0,
+		EIC7700_REG_OFFSET_SATA_OOB_CTRL, 0, 4, CLK_DIVIDER_ROUND_CLOSEST, u_4_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_DSP_0_ACLK_DIV_DYNM,     "divder_u_dsp_0_aclk_div_dynm",   "gate_dspt_aclk", 0,
+		EIC7700_REG_OFFSET_DSP_CFG_CTRL, 19, 1, },
+
+	{ EIC7700_DIVDER_U_DSP_1_ACLK_DIV_DYNM,     "divder_u_dsp_1_aclk_div_dynm",   "gate_dspt_aclk", 0,
+		EIC7700_REG_OFFSET_DSP_CFG_CTRL, 20, 1, },
+
+	{ EIC7700_DIVDER_U_DSP_2_ACLK_DIV_DYNM,     "divder_u_dsp_2_aclk_div_dynm",   "gate_dspt_aclk", 0,
+		EIC7700_REG_OFFSET_DSP_CFG_CTRL, 21, 1, },
+
+	{ EIC7700_DIVDER_U_DSP_3_ACLK_DIV_DYNM,     "divder_u_dsp_3_aclk_div_dynm",   "gate_dspt_aclk", 0,
+		EIC7700_REG_OFFSET_DSP_CFG_CTRL, 22, 1, },
+
+	{ EIC7700_DIVDER_U_AON_RTC_DIV_DYNM,     "divder_u_aon_rtc_div_dynm",   "clk_clk_1m", 0,
+		EIC7700_REG_OFFSET_RTC_CLK_CTRL, 21, 11, CLK_DIVIDER_ROUND_CLOSEST, u_11_bit_special_div_table},
+
+	{ EIC7700_DIVDER_U_U84_RTC_TOGGLE_DIV_DYNM,     "divder_u_u84_rtc_toggle_dynm",   "fixed_rate_clk_xtal_24m", 0,
+		EIC7700_REG_OFFSET_RTC_CLK_CTRL, 16, 5, CLK_DIVIDER_ONE_BASED | CLK_DIVIDER_ROUND_CLOSEST},
+
+};
+
+/*
+	these clks should init early to cost down the whole clk module init time
+*/
+static struct eswin_clock eic7700_clks_early_0[] = {
+	{ EIC7700_CLK_CLK_DSP_ROOT , "clk_clk_dsp_root", "mux_u_dsp_aclk_root_2mux1_gfree", CLK_SET_RATE_PARENT,},
+	{ EIC7700_CLK_CLK_VC_ROOT, "clk_clk_vc_root", "mux_u_vcdec_root_2mux1_gfree", CLK_SET_RATE_PARENT,},
+};
+
+static struct eswin_clock eic7700_clks_early_1[] = {
+	{ EIC7700_CLK_CLK_SYS_CFG	,"clk_clk_sys_cfg", "mux_u_syscfg_clk_root_2mux1_gfree", CLK_SET_RATE_PARENT,},
+	{ EIC7700_CLK_CLK_D2DDR_ACLK	,"clk_clk_d2ddr_aclk", "divder_u_ddr_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+	{ EIC7700_CLK_CLK_AONDMA_AXI_ST3,"clk_clk_aondma_axi_st3","mux_u_aondma_axi2mux1_gfree", CLK_SET_RATE_PARENT,},
+	{ EIC7700_CLK_CLK_G2D_ST2	,"clk_clk_g2d_st2",	"divder_u_g2d_div_dynm", CLK_SET_RATE_PARENT,},
+	{ EIC7700_CLK_CLK_MIPI_TXESC	,"clk_clk_mipi_txesc",	"fixed_factor_u_mipi_txesc_div10", CLK_SET_RATE_PARENT,},
+	{ EIC7700_CLK_CLK_VI_ACLK_ST1	,"clk_clk_vi_aclk_st1",	"divder_u_vi_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+};
+
+static struct eswin_gate_clock eic7700_gate_clks[] = {
+
+	{ EIC7700_GATE_CLK_CPU_EXT_SRC_CORE_CLK_0 ,	"gate_clk_cpu_ext_src_core_clk_0", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_U84_CLK_CTRL, 28, 0, },
+
+	{ EIC7700_GATE_CLK_CPU_EXT_SRC_CORE_CLK_1 ,	"gate_clk_cpu_ext_src_core_clk_1", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_U84_CLK_CTRL, 29, 0, },
+
+	{ EIC7700_GATE_CLK_CPU_EXT_SRC_CORE_CLK_2 ,	"gate_clk_cpu_ext_src_core_clk_2", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_U84_CLK_CTRL, 30, 0, },
+
+	{ EIC7700_GATE_CLK_CPU_EXT_SRC_CORE_CLK_3 ,	"gate_clk_cpu_ext_src_core_clk_3", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_U84_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_CPU_TRACE_CLK_0 ,		"gate_clk_cpu_trace_clk_0", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_U84_CLK_CTRL, 24, 0, },
+
+	{ EIC7700_GATE_CLK_CPU_TRACE_CLK_1 ,		"gate_clk_cpu_trace_clk_1", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_U84_CLK_CTRL, 25, 0, },
+
+	{ EIC7700_GATE_CLK_CPU_TRACE_CLK_2 ,		"gate_clk_cpu_trace_clk_2", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_U84_CLK_CTRL, 26, 0, },
+
+	{ EIC7700_GATE_CLK_CPU_TRACE_CLK_3 ,		"gate_clk_cpu_trace_clk_3", "mux_u_cpu_root_3mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_U84_CLK_CTRL, 27, 0, },
+
+	{ EIC7700_GATE_CLK_CPU_TRACE_COM_CLK ,		"gate_clk_cpu_trace_com_clk", "mux_u_cpu_aclk_2mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_U84_CLK_CTRL, 23, 0, },
+
+	{ EIC7700_GATE_CLK_CPU_CLK ,			"gate_clk_cpu_clk", "mux_u_cpu_aclk_2mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_U84_CLK_CTRL, 28, 0, }, /*same as EIC7700_GATE_CLK_CPU_EXT_SRC_CORE_CLK_0 */
+
+	{ EIC7700_GATE_CLK_SPLL0_FOUT2 ,		"gate_clk_spll0_fout2", "fixed_rate_clk_spll0_fout2", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_SPLL0_CFG_2, 31, 0, },
+
+	{ EIC7700_GATE_NOC_NSP_CLK ,			"gate_noc_nsp_clk", "divder_u_noc_nsp_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_NOC_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_BOOTSPI ,			"gate_clk_bootspi", "mux_u_bootspi_clk_2mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_BOOTSPI_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_BOOTSPI_CFG	,		"gate_clk_bootspi_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_BOOTSPI_CFGCLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_SCPU_CORE	,		"gate_clk_scpu_core",   "mux_u_scpu_core_clk_2mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_SCPU_CORECLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_SCPU_BUS 			,"gate_clk_scpu_bus",   "fixed_factor_u_scpu_bus_div2", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_SCPU_BUSCLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_LPCPU_CORE			,"gate_clk_lpcpu_core",   "mux_u_lpcpu_core_clk_2mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LPCPU_CORECLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_LPCPU_BUS			,"gate_clk_lpcpu_bus",   "fixed_factor_u_lpcpu_bus_div2", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LPCPU_BUSCLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_GPU_ACLK 			,"gate_gpu_aclk",   "divder_u_gpu_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_GPU_ACLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_GPU_GRAY_CLK 			,"gate_gpu_gray_clk",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_GPU_GRAY_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_GPU_CFG_CLK			,"gate_gpu_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_GPU_CFG_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_DSPT_ACLK			,"gate_dspt_aclk",   "divder_u_dsp_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DSP_ACLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_DSPT_CFG_CLK 			,"gate_dspt_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DSP_CFG_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_D2D_ACLK 			,"gate_d2d_aclk",   "divder_u_d2d_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_D2D_ACLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_D2D_CFG_CLK			,"gate_d2d_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_D2D_CFG_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_TCU_ACLK 			,"gate_tcu_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TCU_ACLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_TCU_CFG_CLK			,"gate_tcu_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TCU_CFG_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_DDRT_CFG_CLK			,"gate_ddrt_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DDR_CLK_CTRL, 9, 0, },
+
+	{ EIC7700_GATE_DDRT0_P0_ACLK			,"gate_ddrt0_p0_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DDR_CLK_CTRL, 4, 0, },
+
+	{ EIC7700_GATE_DDRT0_P1_ACLK			,"gate_ddrt0_p1_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DDR_CLK_CTRL, 5, 0, },
+
+	{ EIC7700_GATE_DDRT0_P2_ACLK			,"gate_ddrt0_p2_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DDR_CLK_CTRL, 6, 0, },
+
+	{ EIC7700_GATE_DDRT0_P3_ACLK			,"gate_ddrt0_p3_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DDR_CLK_CTRL, 7, 0, },
+
+	{ EIC7700_GATE_DDRT0_P4_ACLK			,"gate_ddrt0_p4_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DDR_CLK_CTRL, 8, 0, },
+
+	{ EIC7700_GATE_DDRT1_P0_ACLK			,"gate_ddrt1_p0_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DDR1_CLK_CTRL, 4, 0, },
+
+	{ EIC7700_GATE_DDRT1_P1_ACLK			,"gate_ddrt1_p1_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DDR1_CLK_CTRL, 5, 0, },
+
+	{ EIC7700_GATE_DDRT1_P2_ACLK			,"gate_ddrt1_p2_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DDR1_CLK_CTRL, 6, 0, },
+
+	{ EIC7700_GATE_DDRT1_P3_ACLK			,"gate_ddrt1_p3_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DDR1_CLK_CTRL, 7, 0, },
+
+	{ EIC7700_GATE_DDRT1_P4_ACLK			,"gate_ddrt1_p4_aclk",   "clk_clk_d2ddr_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_DDR1_CLK_CTRL, 8, 0, },
+
+	{ EIC7700_GATE_CLK_HSP_ACLK			,"gate_clk_hsp_aclk",   "divder_u_hsp_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_HSP_ACLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_HSP_CFGCLK			,"gate_clk_hsp_cfgclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_HSP_CFG_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_PCIET_ACLK			,"gate_pciet_aclk",   "divder_u_pcie_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_PCIE_ACLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_PCIET_CFG_CLK			,"gate_pciet_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_PCIE_CFG_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_PCIET_CR_CLK 			,"gate_pciet_cr_clk",   "fixed_factor_u_pcie_cr_div2", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_PCIE_CFG_CTRL, 0, 0, },
+
+	{ EIC7700_GATE_PCIET_AUX_CLK			,"gate_pciet_aux_clk",   "fixed_factor_u_pcie_aux_div4", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_PCIE_CFG_CTRL, 1, 0, },
+
+	{ EIC7700_GATE_NPU_ACLK 			,"gate_npu_aclk",   "divder_u_npu_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_NPU_ACLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_NPU_CFG_CLK			,"gate_npu_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_NPU_ACLK_CTRL, 30, 0, },
+
+	{ EIC7700_GATE_NPU_LLC_ACLK 			,"gate_npu_llc_aclk",   "mux_u_npu_llclk_3mux1_gfree", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_NPU_LLC_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_NPU_CLK				,"gate_npu_clk",   "divder_u_npu_coreclk_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_NPU_CORE_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_NPU_E31_CLK			,"gate_npu_e31_clk",   "divder_u_npu_e31_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_NPU_CORE_CTRL, 30, 0, },
+
+	{ EIC7700_GATE_VI_ACLK				,"gate_vi_aclk",   "clk_clk_vi_aclk_st1", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_ACLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VI_CFG_CLK			,"gate_vi_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_ACLK_CTRL, 30, 0, },
+
+	{ EIC7700_GATE_VI_DIG_DW_CLK			,"gate_vi_dig_dw_clk",   "divder_u_vi_dw_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_DWCLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VI_DVP_CLK			,"gate_vi_dvp_clk",   "divder_u_vi_dvp_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_DVP_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VI_DIG_ISP_CLK			,"gate_vi_dig_isp_clk",   "divder_u_vi_dig_isp_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_DIG_ISP_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VI_SHUTTER_0			,"gate_vi_shutter_0",   "divder_u_vi_shutter_div_dynm_0", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_SHUTTER0, 31, 0, },
+
+	{ EIC7700_GATE_VI_SHUTTER_1			,"gate_vi_shutter_1",   "divder_u_vi_shutter_div_dynm_1", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_SHUTTER1, 31, 0, },
+
+	{ EIC7700_GATE_VI_SHUTTER_2			,"gate_vi_shutter_2",   "divder_u_vi_shutter_div_dynm_2", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_SHUTTER2, 31, 0, },
+
+	{ EIC7700_GATE_VI_SHUTTER_3			,"gate_vi_shutter_3",   "divder_u_vi_shutter_div_dynm_3", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_SHUTTER3, 31, 0, },
+
+	{ EIC7700_GATE_VI_SHUTTER_4			,"gate_vi_shutter_4",   "divder_u_vi_shutter_div_dynm_4", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_SHUTTER4, 31, 0, },
+
+	{ EIC7700_GATE_VI_SHUTTER_5			,"gate_vi_shutter_5",   "divder_u_vi_shutter_div_dynm_5", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_SHUTTER5, 31, 0, },
+
+	{ EIC7700_GATE_VI_PHY_TXCLKESC			,"gate_vi_phy_txclkesc",   "clk_clk_mipi_txesc", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_PHY_CLKCTRL, 0, 0, },
+
+	{ EIC7700_GATE_VI_PHY_CFG			,"gate_vi_phy_cfg",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VI_PHY_CLKCTRL, 1, 0, },
+
+	{ EIC7700_GATE_VO_ACLK				,"gate_vo_aclk",   "divder_u_vo_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VO_ACLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VO_CFG_CLK			,"gate_vo_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VO_ACLK_CTRL, 30, 0, },
+
+	{ EIC7700_GATE_VO_HDMI_IESMCLK			,"gate_vo_hdmi_iesmclk",   "divder_u_iesmclk_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VO_IESMCLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VO_PIXEL_CLK 			,"gate_vo_pixel_clk",   "divder_u_vo_pixel_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VO_PIXEL_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VO_I2S_MCLK			,"gate_vo_i2s_mclk",   "mux_u_vo_mclk_2mux_ext_mclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VO_MCLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VO_CR_CLK			,"gate_vo_cr_clk",   "clk_clk_mipi_txesc", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VO_PHY_CLKCTRL, 1, 0, },
+
+	{ EIC7700_GATE_VC_ACLK				,"gate_vc_aclk",   "divder_u_vc_aclk_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VC_ACLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VC_CFG_CLK			,"gate_vc_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VC_CLKEN_CTRL, 0, 0, },
+
+	{ EIC7700_GATE_VC_JE_CLK			,"gate_vc_je_clk",   "divder_u_je_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_JE_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VC_JD_CLK			,"gate_vc_jd_clk",   "divder_u_jd_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_JD_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VC_VE_CLK			,"gate_vc_ve_clk",   "divder_u_ve_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VE_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_VC_VD_CLK			,"gate_vc_vd_clk",   "divder_u_vd_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VD_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_G2D_CFG_CLK			,"gate_g2d_cfg_clk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_G2D_CTRL, 28, 0, },
+
+	{ EIC7700_GATE_G2D_CLK				,"gate_g2d_clk",   "clk_clk_g2d_st2", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_G2D_CTRL, 30, 0, },
+
+	{ EIC7700_GATE_G2D_ACLK 			,"gate_g2d_aclk",   "clk_clk_g2d_st2", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_G2D_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_AONDMA_CFG			,"gate_clk_aondma_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_AON_DMA_CLK_CTRL, 30, 0, },
+
+	{ EIC7700_GATE_AONDMA_ACLK			,"gate_aondma_aclk",   "clk_clk_aondma_axi_st3", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_AON_DMA_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_AON_ACLK 			,"gate_aon_aclk",   "clk_clk_aondma_axi_st3", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_AON_DMA_CLK_CTRL, 29, 0, },
+
+	{ EIC7700_GATE_TIMER_CLK_0 			,"gate_time_clk_0",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TIMER_CLK_CTRL, 0, 0, },
+
+	{ EIC7700_GATE_TIMER_CLK_1 			,"gate_time_clk_1",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TIMER_CLK_CTRL, 1, 0, },
+
+	{ EIC7700_GATE_TIMER_CLK_2 			,"gate_time_clk_2",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TIMER_CLK_CTRL, 2, 0, },
+
+	{ EIC7700_GATE_TIMER_CLK_3 			,"gate_time_clk_3",   "fixed_rate_clk_xtal_24m", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TIMER_CLK_CTRL, 3, 0, },
+
+	{ EIC7700_GATE_TIMER_PCLK_0			,"gate_timer_pclk_0",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TIMER_CLK_CTRL, 4, 0, },
+
+	{ EIC7700_GATE_TIMER_PCLK_1			,"gate_timer_pclk_1",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TIMER_CLK_CTRL, 5, 0, },
+
+	{ EIC7700_GATE_TIMER_PCLK_2			,"gate_timer_pclk_2",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TIMER_CLK_CTRL, 6, 0, },
+
+	{ EIC7700_GATE_TIMER_PCLK_3			,"gate_timer_pclk_3",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TIMER_CLK_CTRL, 7, 0, },
+
+	{ EIC7700_GATE_TIMER3_CLK8			,"gate_timer3_clk8",   "fixed_rate_clk_vpll_fout3", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TIMER_CLK_CTRL, 8, 0, },
+
+	{ EIC7700_GATE_CLK_RTC_CFG			,"gate_clk_rtc_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_RTC_CLK_CTRL, 2, 0, },
+
+	{ EIC7700_GATE_CLK_RTC				,"gate_clk_rtc",   "divder_u_aon_rtc_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_RTC_CLK_CTRL, 1, 0, },
+
+	{ EIC7700_GATE_CLK_PKA_CFG			,"gate_clk_pka_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_PKA_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_SPACC_CFG			,"gate_clk_spacc_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_SPACC_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_CRYPTO			,"gate_clk_crypto",   "divder_u_crypto_div_dynm", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_SPACC_CLK_CTRL, 30, 0, },
+
+	{ EIC7700_GATE_CLK_TRNG_CFG 			,"gate_clk_trng_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_TRNG_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_OTP_CFG			,"gate_clk_otp_cfg",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_OTP_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_0			,"gate_clk_mailbox_0",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 0, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_1			,"gate_clk_mailbox_1",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 1, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_2			,"gate_clk_mailbox_2",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 2, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_3			,"gate_clk_mailbox_3",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 3, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_4			,"gate_clk_mailbox_4",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 4, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_5			,"gate_clk_mailbox_5",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 5, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_6			,"gate_clk_mailbox_6",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 6, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_7			,"gate_clk_mailbox_7",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 7, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_8			,"gate_clk_mailbox_8",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 8, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_9			,"gate_clk_mailbox_9",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 9, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_10			,"gate_clk_mailbox_10",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 10, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_11			,"gate_clk_mailbox_11",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 11, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_12			,"gate_clk_mailbox_12",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 12, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_13			,"gate_clk_mailbox_13",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 13, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_14			,"gate_clk_mailbox_14",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 14, 0, },
+
+	{ EIC7700_GATE_CLK_MAILBOX_15			,"gate_clk_mailbox_15",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 15, 0, },
+
+	{ EIC7700_GATE_LSP_I2C0_PCLK			,"gate_i2c0_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 7, 0, },
+
+	{ EIC7700_GATE_LSP_I2C1_PCLK			,"gate_i2c1_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 8, 0, },
+
+	{ EIC7700_GATE_LSP_I2C2_PCLK			,"gate_i2c2_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 9, 0, },
+
+	{ EIC7700_GATE_LSP_I2C3_PCLK			,"gate_i2c3_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 10, 0, },
+
+	{ EIC7700_GATE_LSP_I2C4_PCLK			,"gate_i2c4_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 11, 0, },
+
+	{ EIC7700_GATE_LSP_I2C5_PCLK			,"gate_i2c5_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 12, 0, },
+
+	{ EIC7700_GATE_LSP_I2C6_PCLK			,"gate_i2c6_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 13, 0, },
+
+	{ EIC7700_GATE_LSP_I2C7_PCLK			,"gate_i2c7_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 14, 0, },
+
+	{ EIC7700_GATE_LSP_I2C8_PCLK			,"gate_i2c8_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 15, 0, },
+
+	{ EIC7700_GATE_LSP_I2C9_PCLK			,"gate_i2c9_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 16, 0, },
+
+	{ EIC7700_GATE_LSP_WDT0_PCLK			,"gate_lsp_wdt0_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 28, 0, },
+
+	{ EIC7700_GATE_LSP_WDT1_PCLK			,"gate_lsp_wdt1_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 29, 0, },
+
+	{ EIC7700_GATE_LSP_WDT2_PCLK			,"gate_lsp_wdt2_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 30, 0, },
+
+	{ EIC7700_GATE_LSP_WDT3_PCLK			,"gate_lsp_wdt3_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 31, 0, },
+
+	{ EIC7700_GATE_LSP_SSI0_PCLK			,"gate_lsp_ssi0_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 26, 0, },
+
+	{ EIC7700_GATE_LSP_SSI1_PCLK			,"gate_lsp_ssi1_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 27, 0, },
+
+	{ EIC7700_GATE_LSP_UART0_PCLK			,"gate_lsp_uart0_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 17, 0, },
+
+	{ EIC7700_GATE_LSP_UART1_PCLK			,"gate_lsp_uart1_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 18, 0, },
+
+	{ EIC7700_GATE_LSP_UART2_PCLK			,"gate_lsp_uart2_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 19, 0, },
+
+	{ EIC7700_GATE_LSP_UART3_PCLK			,"gate_lsp_uart3_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 20, 0, },
+
+	{ EIC7700_GATE_LSP_UART4_PCLK			,"gate_lsp_uart4_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 21, 0, },
+
+	{ EIC7700_GATE_LSP_TIMER_PCLK			,"gate_lsp_timer_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 25, 0, },
+
+	{ EIC7700_GATE_LSP_FAN_PCLK			,"gate_lsp_fan_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 0, 0, },
+
+	{ EIC7700_GATE_LSP_PVT_PCLK			,"gate_lsp_pvt_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN0, 1, 0, },
+
+	{ EIC7700_GATE_LSP_PVT0_CLK			,"gate_pvt0_clk",   "fixed_factor_u_pvt_div20", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 16, 0, },
+
+	{ EIC7700_GATE_LSP_PVT1_CLK			,"gate_pvt1_clk",   "fixed_factor_u_pvt_div20", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_LSP_CLK_EN1, 17, 0, },
+
+	{ EIC7700_GATE_VC_JE_PCLK			,"gate_vc_je_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VC_CLKEN_CTRL, 2, 0, },
+
+	{ EIC7700_GATE_VC_JD_PCLK			,"gate_vc_jd_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VC_CLKEN_CTRL, 1, 0, },
+
+	{ EIC7700_GATE_VC_VE_PCLK			,"gate_vc_ve_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VC_CLKEN_CTRL, 5, 0, },
+
+	{ EIC7700_GATE_VC_VD_PCLK			,"gate_vc_vd_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VC_CLKEN_CTRL, 4, 0, },
+
+	{ EIC7700_GATE_VC_MON_PCLK			,"gate_vc_mon_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_VC_CLKEN_CTRL, 3, 0, },
+
+	{ EIC7700_GATE_HSP_MSHC0_CORE_CLK		,"gate_hsp_mshc0_core_clk",   "divder_u_mshc_core_div_dynm_0", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_MSHC0_CORECLK_CTRL, 16, 0, },
+
+	{ EIC7700_GATE_HSP_MSHC1_CORE_CLK		,"gate_hsp_mshc1_core_clk",   "divder_u_mshc_core_div_dynm_1", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_MSHC1_CORECLK_CTRL, 16, 0, },
+
+	{ EIC7700_GATE_HSP_MSHC2_CORE_CLK		,"gate_hsp_mshc2_core_clk",   "divder_u_mshc_core_div_dynm_2", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_MSHC2_CORECLK_CTRL, 16, 0, },
+
+	{ EIC7700_GATE_HSP_SATA_RBC_CLK			,"gate_hsp_sata_rbc_clk",   "fixed_rate_clk_spll1_fout2", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_SATA_RBC_CTRL, 0, 0, },
+
+	{ EIC7700_GATE_HSP_SATA_OOB_CLK			,"gate_hsp_sata_oob_clk",   "mux_u_sata_phy_2mux1", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_SATA_OOB_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_HSP_DMA0_CLK			,"gate_hsp_dma0_clk",   "gate_clk_hsp_aclk", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_HSP_ACLK_CTRL, 0, 0, },
+
+	{ EIC7700_GATE_HSP_ETH0_CORE_CLK		,"gate_hsp_eth0_core_clk",   "divder_u_eth_txclk_div_dynm_0", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_ETH0_CTRL, 0, 0, },
+
+	{ EIC7700_GATE_HSP_ETH1_CORE_CLK		,"gate_hsp_eth1_core_clk",   "divder_u_eth_txclk_div_dynm_1", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_ETH1_CTRL, 0, 0, },
+
+	{ EIC7700_GATE_HSP_RMII_REF_0			,"gate_hsp_rmii_ref_0",   "mux_u_rmii_ref_2mux1", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_ETH0_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_HSP_RMII_REF_1			,"gate_hsp_rmii_ref_1",   "mux_u_rmii_ref_2mux1", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_ETH1_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_AON_I2C0_PCLK			,"gate_aon_i2c0_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_I2C0_CLK_CTRL, 31, 0, },
+
+	{ EIC7700_GATE_AON_I2C1_PCLK			,"gate_aon_i2c1_pclk",   "clk_clk_sys_cfg", CLK_SET_RATE_PARENT,
+		EIC7700_REG_OFFSET_I2C1_CLK_CTRL, 31, 0, },
+};
+
+/* eic7700 clocks */
+static struct eswin_clock eic7700_clks[] = {
+	{  EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_0	,"clk_cpu_ext_src_core_clk_0",	"gate_clk_cpu_ext_src_core_clk_0", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_1	,"clk_cpu_ext_src_core_clk_1",	"gate_clk_cpu_ext_src_core_clk_1", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_2	,"clk_cpu_ext_src_core_clk_2",	"gate_clk_cpu_ext_src_core_clk_2", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_3	,"clk_cpu_ext_src_core_clk_3",	"gate_clk_cpu_ext_src_core_clk_3", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CPU_TRACE_CLK_0		,"clk_cpu_trace_clk_0",	 	"gate_clk_cpu_trace_clk_0", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CPU_TRACE_CLK_1		,"clk_cpu_trace_clk_1",	 	"gate_clk_cpu_trace_clk_1", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CPU_TRACE_CLK_2		,"clk_cpu_trace_clk_2",	 	"gate_clk_cpu_trace_clk_2", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CPU_TRACE_CLK_3		,"clk_cpu_trace_clk_3",	 	"gate_clk_cpu_trace_clk_3", CLK_SET_RATE_PARENT,},
+
+	{  EIC7700_CLK_CPU_TRACE_COM_CLK 	,"clk_cpu_trace_com_clk",	"gate_clk_cpu_trace_com_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CPU_CLK			,"clk_cpu_clk",			"gate_clk_cpu_clk", CLK_SET_RATE_PARENT,},
+
+	{  EIC7700_CLK_CLK_1M			,"clk_clk_1m",			"fixed_factor_u_clk_1m_div24", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_NOC_CFG_CLK		,"clk_noc_cfg_clk",		"clk_clk_sys_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_NOC_NSP_CLK		,"clk_noc_nsp_clk",		"gate_noc_nsp_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_BOOTSPI		,"clk_clk_bootspi",		"gate_clk_bootspi", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_BOOTSPI_CFG		,"clk_clk_bootspi_cfg",		"gate_clk_bootspi_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_U84_CORE_LP		,"clk_clk_u84_core_lp",		"fixed_factor_u_u84_core_lp_div2", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_SCPU_CORE		,"clk_clk_scpu_core",		"gate_clk_scpu_core", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_SCPU_BUS 		,"clk_clk_scpu_bus",		"gate_clk_scpu_bus", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_LPCPU_CORE		,"clk_clk_lpcpu_core",		"gate_clk_lpcpu_core", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_LPCPU_BUS		,"clk_clk_lpcpu_bus",		"gate_clk_lpcpu_bus", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_GPU_ACLK 		,"clk_gpu_aclk",		"gate_gpu_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_GPU_GRAY_CLK 		,"clk_gpu_gray_clk",		"gate_gpu_gray_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_GPU_CFG_CLK		,"clk_gpu_cfg_clk",		"gate_gpu_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DSPT_ACLK		,"clk_dspt_aclk",		"gate_dspt_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DSPT_CFG_CLK 		,"clk_dspt_cfg_clk",		"gate_dspt_cfg_clk", CLK_SET_RATE_PARENT | CLK_GET_RATE_NOCACHE,},
+	{  EIC7700_CLK_D2D_ACLK 		,"clk_d2d_aclk",		"gate_d2d_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_D2D_CFG_CLK		,"clk_d2d_cfg_clk",	 	"gate_d2d_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_TCU_ACLK 		,"clk_tcu_aclk",		"gate_tcu_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_TCU_CFG_CLK		,"clk_tcu_cfg_clk",		"gate_tcu_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DDRT_CFG_CLK 		,"clk_ddrt_cfg_clk",		"gate_ddrt_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DDRT0_P0_ACLK		,"clk_ddrt0_p0_aclk",		"gate_ddrt0_p0_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DDRT0_P1_ACLK		,"clk_ddrt0_p1_aclk",		"gate_ddrt0_p1_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DDRT0_P2_ACLK		,"clk_ddrt0_p2_aclk",		"gate_ddrt0_p2_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DDRT0_P3_ACLK		,"clk_ddrt0_p3_aclk",		"gate_ddrt0_p3_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DDRT0_P4_ACLK		,"clk_ddrt0_p4_aclk",		"gate_ddrt0_p4_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DDRT1_P0_ACLK		,"clk_ddrt1_p0_aclk",		"gate_ddrt1_p0_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DDRT1_P1_ACLK		,"clk_ddrt1_p1_aclk",		"gate_ddrt1_p1_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DDRT1_P2_ACLK		,"clk_ddrt1_p2_aclk",		"gate_ddrt1_p2_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DDRT1_P3_ACLK		,"clk_ddrt1_p3_aclk",		"gate_ddrt1_p3_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DDRT1_P4_ACLK		,"clk_ddrt1_p4_aclk",		"gate_ddrt1_p4_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_ACLK 		,"clk_hsp_aclk",		"gate_clk_hsp_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_CFG_CLK		,"clk_hsp_cfg_clk",		"gate_clk_hsp_cfgclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_SATA_RBC_CLK 	,"clk_hsp_sata_rbc_clk",	"gate_hsp_sata_rbc_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_SATA_OOB_CLK 	,"clk_hsp_sata_oob_clk",	"gate_hsp_sata_oob_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_SATA_PHY_REF		,"clk_hsp_sata_phy_ref",	"gate_hsp_sata_oob_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_SATA_PMALIVE_CLK 	,"clk_hsp_sata_pmalive_clk",  	"gate_hsp_sata_oob_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_ETH_APP_CLK		,"clk_hsp_eth_app_clk",		"clk_clk_sys_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_ETH_CSR_CLK		,"clk_hsp_eth_csr_clk",		"clk_clk_sys_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_ETH0_CORE_CLK	,"clk_hsp_eth0_core_clk",	"gate_hsp_eth0_core_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_ETH1_CORE_CLK	,"clk_hsp_eth1_core_clk",	"gate_hsp_eth1_core_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_MSHC0_CORE_CLK	,"clk_hsp_mshc0_core_clk",	"gate_hsp_mshc0_core_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_MSHC1_CORE_CLK	,"clk_hsp_mshc1_core_clk",	"gate_hsp_mshc1_core_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_MSHC2_CORE_CLK	,"clk_hsp_mshc2_core_clk",	"gate_hsp_mshc2_core_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_MSHC0_TMR_CLK	,"clk_hsp_mshc0_tmr_clk",	"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_MSHC1_TMR_CLK	,"clk_hsp_mshc1_tmr_clk",	"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_MSHC2_TMR_CLK	,"clk_hsp_mshc2_tmr_clk",	"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_USB0_SUSPEND_CLK 	,"clk_hsp_usb0_suspend_clk",	"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_USB1_SUSPEND_CLK 	,"clk_hsp_usb1_suspend_clk",	"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_PCIET_ACLK		,"clk_pciet_aclk",		"gate_pciet_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_PCIET_CFG_CLK		,"clk_pciet_cfg_clk",		"gate_pciet_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_PCIET_CR_CLK 		,"clk_pciet_cr_clk",		"gate_pciet_cr_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_PCIET_AUX_CLK		,"clk_pciet_aux_clk",		"gate_pciet_aux_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_NPU_ACLK 		,"clk_npu_aclk",		"gate_npu_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_NPU_CFG_CLK		,"clk_npu_cfg_clk",		"gate_npu_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_NPU_LLC_SRC0 	,"clk_clk_npu_llc_src0",	"divder_u_npu_llc_src0_div_dynm", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_NPU_LLC_SRC1 	,"clk_clk_npu_llc_src1",	"divder_u_npu_llc_src1_div_dynm", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_NPU_LLC_ACLK 		,"clk_npu_llc_aclk",		"gate_npu_llc_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_NPU_CLK			,"clk_npu_clk",			"gate_npu_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_NPU_E31_CLK		,"clk_npu_e31_clk",		"gate_npu_e31_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_ACLK			,"clk_vi_aclk",			"gate_vi_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_DIG_DW_CLK		,"clk_vi_dig_dw_clk",		"gate_vi_dig_dw_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_CFG_CLK		,"clk_vi_cfg_clk",		"gate_vi_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_DVP_CLK		,"clk_vi_dvp_clk",		"gate_vi_dvp_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_DIG_ISP_CLK		,"clk_vi_dig_isp_clk",		"gate_vi_dig_isp_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_SHUTTER_0 		,"clk_vi_shutter_0",		"gate_vi_shutter_0", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_SHUTTER_1 		,"clk_vi_shutter_1",		"gate_vi_shutter_1", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_SHUTTER_2 		,"clk_vi_shutter_2",		"gate_vi_shutter_2", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_SHUTTER_3 		,"clk_vi_shutter_3",		"gate_vi_shutter_3", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_SHUTTER_4 		,"clk_vi_shutter_4",		"gate_vi_shutter_4", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_SHUTTER_5 		,"clk_vi_shutter_5",		"gate_vi_shutter_5", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_PHY_TXCLKESC		,"clk_vi_phy_txclkesc",		"gate_vi_phy_txclkesc", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VI_PHY_CFG		,"clk_vi_phy_cfg",		"gate_vi_phy_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VO_ACLK			,"clk_vo_aclk",			"gate_vo_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VO_CFG_CLK		,"clk_vo_cfg_clk",		"gate_vo_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VO_HDMI_IESMCLK		,"clk_vo_hdmi_iesmclk",		"gate_vo_hdmi_iesmclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VO_PIXEL_CLK 		,"clk_vo_pixel_clk",		"gate_vo_pixel_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VO_I2S_MCLK		,"clk_vo_i2s_mclk",		"gate_vo_i2s_mclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VO_CR_CLK		,"clk_vo_cr_clk",		"gate_vo_cr_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VO_CEC_CLK		,"clk_vo_cec_clk",		"divder_u_vo_cec_div_dynm", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VC_ACLK			,"clk_vc_aclk",			"gate_vc_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VC_CFG_CLK		,"clk_vc_cfg_clk",		"gate_vc_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VC_JE_CLK		,"clk_vc_je_clk",		"gate_vc_je_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VC_JD_CLK		,"clk_vc_jd_clk",		"gate_vc_jd_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VC_VE_CLK		,"clk_vc_ve_clk",		"gate_vc_ve_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VC_VD_CLK		,"clk_vc_vd_clk",		"gate_vc_vd_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_G2D_CFG_CLK		,"clk_g2d_cfg_clk",		"gate_g2d_cfg_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_G2D_CLK			,"clk_g2d_clk",			"gate_g2d_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_G2D_ACLK 		,"clk_g2d_aclk",		"gate_g2d_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_AONDMA_CFG		,"clk_aondma_cfg",		"gate_clk_aondma_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_AONDMA_ACLK		,"clk_aondma_aclk",		"gate_aondma_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_AON_ACLK 		,"clk_aon_aclk",		"gate_aon_aclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_TIMER_CLK_0 		,"clk_timer_clk_0",		"gate_time_clk_0", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_TIMER_CLK_1 		,"clk_timer_clk_1",		"gate_time_clk_1", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_TIMER_CLK_2 		,"clk_timer_clk_2",		"gate_time_clk_2", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_TIMER_CLK_3 		,"clk_timer_clk_3",		"gate_time_clk_3", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_TIMER_PCLK_0		,"clk_timer_pclk_0",		"gate_timer_pclk_0", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_TIMER_PCLK_1		,"clk_timer_pclk_1",		"gate_timer_pclk_1", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_TIMER_PCLK_2		,"clk_timer_pclk_2",		"gate_timer_pclk_2", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_TIMER_PCLK_3		,"clk_timer_pclk_3",		"gate_timer_pclk_3", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_TIMER3_CLK8		,"clk_timer3_clk8",		"gate_timer3_clk8", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_RTC_CFG		,"clk_clk_rtc_cfg",		"gate_clk_rtc_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_RTC			,"clk_clk_rtc",			"gate_clk_rtc", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_PKA_CFG		,"clk_clk_pka_cfg",	 	"gate_clk_pka_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_SPACC_CFG		,"clk_clk_spacc_cfg",		"gate_clk_spacc_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_CRYPTO		,"clk_clk_crypto",		"gate_clk_crypto", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_TRNG_CFG 		,"clk_clk_trng_cfg",		"gate_clk_trng_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_OTP_CFG		,"clk_clk_otp_cfg",	 	"gate_clk_otp_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLMM_CFG_CLK 		,"clk_clmm_cfg_clk",		"clk_clk_sys_cfg", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLMM_DEB_CLK 		,"clk_clmm_deb_clk",		"clk_clk_1m", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_0 		,"clk_mailbox0",		"gate_clk_mailbox_0", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_1 		,"clk_mailbox1",		"gate_clk_mailbox_1", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_2 		,"clk_mailbox2",		"gate_clk_mailbox_2", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_3 		,"clk_mailbox3",		"gate_clk_mailbox_3", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_4 		,"clk_mailbox4",		"gate_clk_mailbox_4", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_5 		,"clk_mailbox5",		"gate_clk_mailbox_5", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_6 		,"clk_mailbox6",		"gate_clk_mailbox_6", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_7 		,"clk_mailbox7",		"gate_clk_mailbox_7", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_8 		,"clk_mailbox8",		"gate_clk_mailbox_8", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_9 		,"clk_mailbox9",		"gate_clk_mailbox_9", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_10 		,"clk_mailbox10",		"gate_clk_mailbox_10", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_11 		,"clk_mailbox11",		"gate_clk_mailbox_11", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_12 		,"clk_mailbox12",		"gate_clk_mailbox_12", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_13 		,"clk_mailbox13",		"gate_clk_mailbox_13", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_14 		,"clk_mailbox14",		"gate_clk_mailbox_14", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_MAILBOX_15 		,"clk_mailbox15",		"gate_clk_mailbox_15", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_I2C0_PCLK		,"clk_i2c0_pclk",		"gate_i2c0_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_I2C1_PCLK		,"clk_i2c1_pclk",		"gate_i2c1_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_I2C2_PCLK		,"clk_i2c2_pclk",		"gate_i2c2_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_I2C3_PCLK		,"clk_i2c3_pclk",		"gate_i2c3_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_I2C4_PCLK		,"clk_i2c4_pclk",		"gate_i2c4_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_I2C5_PCLK		,"clk_i2c5_pclk",		"gate_i2c5_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_I2C6_PCLK		,"clk_i2c6_pclk",		"gate_i2c6_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_I2C7_PCLK		,"clk_i2c7_pclk",		"gate_i2c7_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_I2C8_PCLK		,"clk_i2c8_pclk",		"gate_i2c8_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_I2C9_PCLK		,"clk_i2c9_pclk",		"gate_i2c9_pclk", CLK_SET_RATE_PARENT,},
+
+	{  EIC7700_CLK_LSP_WDT0_PCLK		,"clk_lsp_wdt0_pclk",		"gate_lsp_wdt0_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_WDT1_PCLK		,"clk_lsp_wdt1_pclk",		"gate_lsp_wdt1_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_WDT2_PCLK		,"clk_lsp_wdt2_pclk",		"gate_lsp_wdt2_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_WDT3_PCLK		,"clk_lsp_wdt3_pclk",		"gate_lsp_wdt3_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_SSI0_PCLK		,"clk_lsp_ssi0_pclk",		"gate_lsp_ssi0_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_SSI1_PCLK		,"clk_lsp_ssi1_pclk",		"gate_lsp_ssi1_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_UART0_PCLK		,"clk_lsp_uart0_pclk",		"gate_lsp_uart0_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_UART1_PCLK		,"clk_lsp_uart1_pclk",		"gate_lsp_uart1_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_UART2_PCLK		,"clk_lsp_uart2_pclk",		"gate_lsp_uart2_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_UART3_PCLK		,"clk_lsp_uart3_pclk",		"gate_lsp_uart3_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_UART4_PCLK		,"clk_lsp_uart4_pclk",		"gate_lsp_uart4_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_TIMER_PCLK		,"clk_lsp_timer_pclk",		"gate_lsp_timer_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_FAN_PCLK		,"clk_lsp_fan_pclk",		"gate_lsp_fan_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_LSP_PVT_PCLK		,"clk_lsp_pvt_pclk",		"gate_lsp_pvt_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_PVT_CLK_0		,"clk_pvt0_clk",		"gate_pvt0_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_PVT_CLK_1		,"clk_pvt1_clk",		"gate_pvt1_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VC_JE_PCLK		,"clk_vc_je_pclk",		"gate_vc_je_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VC_JD_PCLK		,"clk_vc_jd_pclk",		"gate_vc_jd_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VC_VE_PCLK		,"clk_vc_ve_pclk",		"gate_vc_ve_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VC_VD_PCLK		,"clk_vc_vd_pclk",		"gate_vc_vd_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_VC_MON_PCLK		,"clk_vc_mon_pclk",		"gate_vc_mon_pclk", CLK_SET_RATE_PARENT,},
+
+	{  EIC7700_CLK_HSP_DMA0_CLK		,"clk_hsp_dma0_clk",		"gate_hsp_dma0_clk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_RMII_REF_0		,"clk_hsp_rmii_ref_0",		"gate_hsp_rmii_ref_0", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_HSP_RMII_REF_1		,"clk_hsp_rmii_ref_1",		"gate_hsp_rmii_ref_1", CLK_SET_RATE_PARENT,},
+
+	{  EIC7700_CLK_DSP_ACLK_0		,"clk_dsp_aclk_0",	"divder_u_dsp_0_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DSP_ACLK_1		,"clk_dsp_aclk_1",	"divder_u_dsp_1_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DSP_ACLK_2		,"clk_dsp_aclk_2",	"divder_u_dsp_2_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_DSP_ACLK_3		,"clk_dsp_aclk_3",	"divder_u_dsp_3_aclk_div_dynm", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_CLK_U84_RTC_TOGGLE		,"clk_clk_u84_rtc_toggle",	"divder_u_u84_rtc_toggle_dynm", CLK_SET_RATE_PARENT,},
+
+	{  EIC7700_CLK_AON_I2C0_PCLK		,"clk_aon_i2c0_pclk",	"gate_aon_i2c0_pclk", CLK_SET_RATE_PARENT,},
+	{  EIC7700_CLK_AON_I2C1_PCLK		,"clk_aon_i2c1_pclk",	"gate_aon_i2c1_pclk", CLK_SET_RATE_PARENT,},
+};
+
+static void special_div_table_init(struct clk_div_table *table, int table_size)
+{
+	int i;
+
+	if (table_size < 3) {
+		return;
+	}
+	if (!table) {
+		return;
+	}
+	/*The hardware decides vaule 0, 1 and 2 both means 2 divsor*/
+	for (i = 0; i < 3; i++) {
+		table[i].val = i;
+		table[i].div = 2;
+	}
+	for (i = 3; i < table_size; i++) {
+		table[i].val = i;
+		table[i].div = i;
+	}
+	return;
+}
+
+static int eswin_clk_probe(struct platform_device *pdev)
+{
+	struct eswin_clock_data *clk_data;
+
+	clk_data = eswin_clk_init(pdev, EIC7700_NR_CLKS);
+	if (!clk_data)
+		return -EAGAIN;
+
+	special_div_table_init(u_3_bit_special_div_table, ARRAY_SIZE(u_3_bit_special_div_table));
+	special_div_table_init(u_4_bit_special_div_table, ARRAY_SIZE(u_4_bit_special_div_table));
+	special_div_table_init(u_6_bit_special_div_table, ARRAY_SIZE(u_6_bit_special_div_table));
+	special_div_table_init(u_7_bit_special_div_table, ARRAY_SIZE(u_7_bit_special_div_table));
+	special_div_table_init(u_8_bit_special_div_table, ARRAY_SIZE(u_8_bit_special_div_table));
+	special_div_table_init(u_11_bit_special_div_table, ARRAY_SIZE(u_11_bit_special_div_table));
+	special_div_table_init(u_16_bit_special_div_table, ARRAY_SIZE(u_16_bit_special_div_table));
+
+	eswin_clk_register_fixed_rate(eic7700_fixed_rate_clks,
+				ARRAY_SIZE(eic7700_fixed_rate_clks),
+				clk_data);
+	eswin_clk_register_pll(eic7700_pll_clks,
+			ARRAY_SIZE(eic7700_pll_clks), clk_data, &pdev->dev);
+
+	eswin_clk_register_fixed_factor(eic7700_fixed_factor_clks,
+				ARRAY_SIZE(eic7700_fixed_factor_clks),
+				clk_data);
+	eswin_clk_register_mux(eic7700_mux_clks, ARRAY_SIZE(eic7700_mux_clks),
+				clk_data);
+	eswin_clk_register_clk(eic7700_clks_early_0, ARRAY_SIZE(eic7700_clks_early_0),
+				clk_data);
+	eswin_clk_register_divider(eic7700_div_clks, ARRAY_SIZE(eic7700_div_clks),
+				clk_data);
+	eswin_clk_register_clk(eic7700_clks_early_1, ARRAY_SIZE(eic7700_clks_early_1),
+				clk_data);
+	eswin_clk_register_gate(eic7700_gate_clks, ARRAY_SIZE(eic7700_gate_clks),
+				clk_data);
+	eswin_clk_register_clk(eic7700_clks, ARRAY_SIZE(eic7700_clks), clk_data);
+	return 0;
+}
+
+static const struct of_device_id eswin_clock_dt_ids[] = {
+	 { .compatible = "eswin,eic7700-clock", },
+	 { /* sentinel */ },
+};
+
+static struct platform_driver eswin_clock_driver = {
+	.probe	= eswin_clk_probe,
+	.driver = {
+		.name	= "eswin-clock",
+		.of_match_table	= eswin_clock_dt_ids,
+	},
+};
+static int __init eic7700_clk_init(void)
+{
+	return platform_driver_register(&eswin_clock_driver);
+}
+arch_initcall(eic7700_clk_init);
diff --git a/drivers/clk/eswin/clk.c b/drivers/clk/eswin/clk.c
new file mode 100755
index 000000000000..62bd09700a00
--- /dev/null
+++ b/drivers/clk/eswin/clk.c
@@ -0,0 +1,915 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Clk Provider Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#include <linux/clkdev.h>
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/util_macros.h>
+#include <dt-bindings/clock/eic7700-clock.h>
+
+#include "clk.h"
+
+struct clk_hw *eswin_clk_find_parent(struct eswin_clock_data *data, char *parent_name)
+{
+	int i;
+	struct clk *clks;
+
+	for (i = 0; i < data->clk_data.clk_num; i++) {
+		clks = data->clk_data.clks[i];
+		if (NULL == clks) {
+			continue;
+		}
+		if (!strcmp(__clk_get_name(clks), parent_name)) {
+			return __clk_get_hw(clks);
+		}
+	}
+	return NULL;
+}
+
+struct eswin_clock_data *eswin_clk_init(struct platform_device *pdev,
+					     int nr_clks)
+{
+	struct eswin_clock_data *clk_data;
+	struct clk **clk_table;
+	void __iomem *base;
+	struct device *parent;
+
+	parent = pdev->dev.parent;
+	if (!parent) {
+		dev_err(&pdev->dev, "no parent\n");
+		goto err;
+	}
+
+	base = of_iomap(parent->of_node, 0);
+	if (!base) {
+		dev_err(&pdev->dev,"failed to map clock registers\n");
+		goto err;
+	}
+	clk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);
+	if (!clk_data)
+		goto err;
+
+	clk_data->base = base;
+	clk_table = kcalloc(nr_clks, sizeof(*clk_table), GFP_KERNEL);
+	if (!clk_table)
+		goto err_data;
+
+	clk_data->clk_data.clks = clk_table;
+	clk_data->clk_data.clk_num = nr_clks;
+	clk_data->numa_id = dev_to_node(parent);
+	spin_lock_init(&clk_data->lock);
+
+	of_clk_add_provider(pdev->dev.of_node, of_clk_src_onecell_get, &clk_data->clk_data);
+	return clk_data;
+
+err_data:
+	kfree(clk_data);
+err:
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(eswin_clk_init);
+
+int eswin_clk_register_fixed_rate(const struct eswin_fixed_rate_clock *clks,
+					 int nums, struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	int i;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name) + 2 * sizeof(char) + sizeof(int),
+			GFP_KERNEL );
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+		}
+		clk = clk_register_fixed_rate(NULL, name, clks[i].parent_name,
+				clks[i].flags, clks[i].fixed_rate);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register clock %s\n", __func__, name);
+			kfree(name);
+			goto err;
+		}
+		data->clk_data.clks[clks[i].id] = clk;
+		kfree(name);
+	}
+
+	return 0;
+err:
+	while (i--)
+		clk_unregister_fixed_rate(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_fixed_rate);
+
+static int eswin_calc_pll(u32 *frac_val, u32 *postdiv1_val,
+				 u32 *fbdiv_val, u32 *refdiv_val, u64 rate,
+				 const struct eswin_clk_pll *clk)
+{
+	int ret = 0;
+
+	switch (clk->id) {
+		case EIC7700_APLL_FOUT1:
+			switch (rate) {
+				case APLL_LOW_FREQ:
+					*frac_val = 10603200;
+					*postdiv1_val = 0;
+					*fbdiv_val = 37;
+					*refdiv_val = 1;
+					break;
+				case APLL_HIGH_FREQ:
+				default:
+					*frac_val = 14092861;
+					*postdiv1_val = 0;
+					*fbdiv_val = 163;
+					*refdiv_val = 1;
+					break;
+			}
+			break;
+		case EIC7700_PLL_CPU:
+			switch (rate) {
+				case CLK_FREQ_1800M:
+					*frac_val = 0;
+					*postdiv1_val = 0;
+					*fbdiv_val = 300;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1700M:
+					*frac_val = 5592405;
+					*postdiv1_val = 0;
+					*fbdiv_val = 283;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1600M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 266;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1500M:
+					*frac_val = 0;
+					*postdiv1_val = 0;
+					*fbdiv_val = 250;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1300M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 216;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1200M:
+					*frac_val = 0;
+					*postdiv1_val = 0;
+					*fbdiv_val = 200;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1000M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 166;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_900M:
+					*frac_val = 0;
+					*postdiv1_val = 0;
+					*fbdiv_val = 150;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_800M:
+					*frac_val = 5592405;
+					*postdiv1_val = 0;
+					*fbdiv_val = 133;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_700M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 116;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_600M:
+					*frac_val = 0;
+					*postdiv1_val = 0;
+					*fbdiv_val = 100;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_500M:
+					*frac_val = 5592405;
+					*postdiv1_val = 0;
+					*fbdiv_val = 83;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_400M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 66;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_200M:
+					*frac_val = 5592405;
+					*postdiv1_val = 0;
+					*fbdiv_val = 33;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_100M:
+					*frac_val = 11184810;
+					*postdiv1_val = 0;
+					*fbdiv_val = 16;
+					*refdiv_val = 1;
+					break;
+				case CLK_FREQ_1400M:
+				default:
+					*frac_val = 5592405;
+					*postdiv1_val = 0;
+					*fbdiv_val = 233;
+					*refdiv_val = 1;
+					break;
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			pr_err("%s %d, Invalid pll set req, rate %lld, clk id %d\n", __func__, __LINE__, rate, clk->id);
+			break;
+	}
+	return ret;
+}
+
+#define to_pll_clk(_hw) container_of(_hw, struct eswin_clk_pll, hw)
+static int clk_pll_set_rate(struct clk_hw *hw,
+			    unsigned long rate,
+			    unsigned long parent_rate)
+{
+	struct eswin_clk_pll *clk = to_pll_clk(hw);
+	u32 frac_val = 0, postdiv1_val, fbdiv_val, refdiv_val;
+	u32 val;
+	int ret;
+	struct clk *clk_cpu_mux = NULL;
+	struct clk *clk_cpu_lp_pll = NULL;
+	struct clk *clk_cpu_pll = NULL;
+	int try_count = 0;
+	bool lock_flag = false;
+	char clk_cpu_mux_name[50] = {0};
+	char clk_cpu_lp_pll_name[50] = {0};
+	char clk_cpu_pll_name[50] = {0};
+
+	ret = eswin_calc_pll(&frac_val, &postdiv1_val, &fbdiv_val, &refdiv_val, (u64)rate, clk);
+	if (ret) {
+		return ret;
+	}
+
+	/*
+	  we must switch the cpu to other clk before we change the cpu pll
+	*/
+	if (EIC7700_PLL_CPU == clk->id) {
+		if (clk->numa_id < 0) {
+			sprintf(clk_cpu_mux_name, "%s", "mux_u_cpu_root_3mux1_gfree");
+			sprintf(clk_cpu_lp_pll_name, "%s", "clk_clk_u84_core_lp");
+			sprintf(clk_cpu_pll_name, "%s", "clk_pll_cpu");
+		} else {
+			sprintf(clk_cpu_mux_name, "d%d_%s", clk->numa_id, "mux_u_cpu_root_3mux1_gfree");
+			sprintf(clk_cpu_lp_pll_name, "d%d_%s", clk->numa_id, "clk_clk_u84_core_lp");
+			sprintf(clk_cpu_pll_name, "d%d_%s", clk->numa_id, "clk_pll_cpu");
+		}
+
+		clk_cpu_mux = __clk_lookup(clk_cpu_mux_name);
+		if (!clk_cpu_mux) {
+			pr_err("%s %d, failed to get %s\n",__func__,__LINE__, clk_cpu_mux_name);
+			return -EINVAL;
+		}
+		clk_cpu_lp_pll = __clk_lookup(clk_cpu_lp_pll_name);
+		if (!clk_cpu_lp_pll) {
+			pr_err("%s %d, failed to get %s\n",__func__,__LINE__, clk_cpu_lp_pll_name);
+			return -EINVAL;
+		}
+		clk_cpu_pll = __clk_lookup(clk_cpu_pll_name);
+		if (!clk_cpu_pll) {
+			pr_err("%s %d, failed to get %s\n",__func__,__LINE__, clk_cpu_pll_name);
+			return -EINVAL;
+		}
+
+		ret = clk_set_parent(clk_cpu_mux, clk_cpu_lp_pll);
+		if (ret) {
+			pr_err("%s %d, faild to switch %s to %s, ret %d\n",__func__,__LINE__, clk_cpu_mux_name,
+				clk_cpu_lp_pll_name, ret);
+			return -EPERM;
+		}
+	}
+
+	/*first disable pll */
+	val = readl_relaxed(clk->ctrl_reg0);
+	val &= ~(((1 << clk->pllen_width) - 1) << clk->pllen_shift);
+	val |= 0 << clk->pllen_shift;
+	writel_relaxed(val, clk->ctrl_reg0);
+
+	val = readl_relaxed(clk->ctrl_reg0);
+	val &= ~(((1 << clk->fbdiv_width) - 1) << clk->fbdiv_shift);
+	val &= ~(((1 << clk->refdiv_width) - 1) << clk->refdiv_shift);
+	val |= refdiv_val << clk->refdiv_shift;
+	val |= fbdiv_val << clk->fbdiv_shift;
+	writel_relaxed(val, clk->ctrl_reg0);
+
+	val = readl_relaxed(clk->ctrl_reg1);
+	val &= ~(((1 << clk->frac_width) - 1) << clk->frac_shift);
+	val |= frac_val << clk->frac_shift;
+	writel_relaxed(val, clk->ctrl_reg1);
+
+	val = readl_relaxed(clk->ctrl_reg2);
+	val &= ~(((1 << clk->postdiv1_width) - 1) << clk->postdiv1_shift);
+	val |= postdiv1_val << clk->postdiv1_shift;
+	writel_relaxed(val, clk->ctrl_reg2);
+
+	/*at last, enable pll */
+	val = readl_relaxed(clk->ctrl_reg0);
+	val &= ~(((1 << clk->pllen_width) - 1) << clk->pllen_shift);
+	val |= 1 << clk->pllen_shift;
+	writel_relaxed(val, clk->ctrl_reg0);
+
+	/*
+	  usually the pll wil lock in 50us
+	*/
+	do {
+		usleep_range(refdiv_val * 80, refdiv_val * 80 * 2);
+		val = readl_relaxed(clk->status_reg);
+		if (val & 1 << clk->lock_shift) {
+			lock_flag = true;
+			break;
+		}
+	} while (try_count++ < 10);
+
+	if (false == lock_flag) {
+		pr_err("%s %d, faild to lock the cpu pll, cpu will work on low power pll\n",__func__,__LINE__);
+		return -EBUSY;
+	}
+	if (EIC7700_PLL_CPU == clk->id) {
+		ret = clk_set_parent(clk_cpu_mux, clk_cpu_pll);
+		if (ret) {
+			pr_err("%s %d, faild to switch %s to %s, ret %d\n",__func__,__LINE__,
+				clk_cpu_mux_name, clk_cpu_pll_name, ret);
+			return -EPERM;
+		}
+	}
+	return  0;
+}
+
+static unsigned long clk_pll_recalc_rate(struct clk_hw *hw,
+		unsigned long parent_rate)
+{
+	struct eswin_clk_pll *clk = to_pll_clk(hw);
+	u64 frac_val, fbdiv_val, refdiv_val;
+	u32 postdiv1_val;
+	u32 val;
+	u64 rate;
+
+	val = readl_relaxed(clk->ctrl_reg0);
+	val = val >> clk->fbdiv_shift;
+	val &= ((1 << clk->fbdiv_width) - 1);
+	fbdiv_val = val;
+
+	val = readl_relaxed(clk->ctrl_reg0);
+	val = val >> clk->refdiv_shift;
+	val &= ((1 << clk->refdiv_width) - 1);
+	refdiv_val = val;
+
+	val = readl_relaxed(clk->ctrl_reg1);
+	val = val >> clk->frac_shift;
+	val &= ((1 << clk->frac_width) - 1);
+	frac_val = val;
+
+	val = readl_relaxed(clk->ctrl_reg2);
+	val = val >> clk->postdiv1_shift;
+	val &= ((1 << clk->postdiv1_width) - 1);
+	postdiv1_val = val;
+
+	switch (clk->id) {
+		case EIC7700_APLL_FOUT1:
+			switch (frac_val) {
+				case 14092861:
+					rate = APLL_HIGH_FREQ;
+					break;
+				case 10603200:
+					rate = APLL_LOW_FREQ;
+					break;
+				default:
+					pr_err("%s %d, clk id %d, unknow frac_val %llu\n", __func__, __LINE__, clk->id, frac_val);
+					rate = 0;
+					break;
+			}
+			break;
+		case EIC7700_PLL_CPU:
+			switch (fbdiv_val) {
+				case 300:
+					rate = CLK_FREQ_1800M;
+					break;
+				case 283:
+					rate = CLK_FREQ_1700M;
+					break;
+				case 266:
+					rate = CLK_FREQ_1600M;
+					break;
+				case 250:
+					rate = CLK_FREQ_1500M;
+					break;
+				case 216:
+					rate = CLK_FREQ_1300M;
+					break;
+				case 200:
+					rate = CLK_FREQ_1200M;
+					break;
+				case 166:
+					rate = CLK_FREQ_1000M;
+					break;
+				case 150:
+					rate = CLK_FREQ_900M;
+					break;
+				case 133:
+					rate = CLK_FREQ_800M;
+					break;
+				case 116:
+					rate = CLK_FREQ_700M;
+					break;
+				case 100:
+					rate = CLK_FREQ_600M;
+					break;
+				case 83:
+					rate = CLK_FREQ_500M;
+					break;
+				case 66:
+					rate = CLK_FREQ_400M;
+					break;
+				case 33:
+					rate = CLK_FREQ_200M;
+					break;
+				case 16:
+					rate = CLK_FREQ_100M;
+					break;
+				case 233:
+					rate = CLK_FREQ_1400M;
+					break;
+				default:
+					pr_err("%s %d, clk id %d, unknow fbdiv_val %llu\n", __func__, __LINE__, clk->id, fbdiv_val);
+					rate = 0;
+					break;
+			}
+			break;
+		default:
+			pr_err("%s %d, unknow clk id %d\n", __func__, __LINE__, clk->id);
+			rate = 0;
+			break;
+	}
+	return rate;
+}
+
+static long clk_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+					unsigned long *parent_rate)
+{
+	struct eswin_clk_pll *clk = to_pll_clk(hw);
+	int index;
+	u64 round_rate = 0;
+
+	/*Must be sorted in ascending order*/
+	u64 apll_clk[] = {APLL_LOW_FREQ, APLL_HIGH_FREQ};
+	u64 cpu_pll_clk[] = {CLK_FREQ_100M, CLK_FREQ_200M, CLK_FREQ_400M, CLK_FREQ_500M, CLK_FREQ_600M, CLK_FREQ_700M,
+				CLK_FREQ_800M, CLK_FREQ_900M, CLK_FREQ_1000M, CLK_FREQ_1200M, CLK_FREQ_1300M,
+				CLK_FREQ_1400M, CLK_FREQ_1500M, CLK_FREQ_1600M, CLK_FREQ_1700M, CLK_FREQ_1800M};
+
+	switch (clk->id) {
+		case EIC7700_APLL_FOUT1:
+			index = find_closest(rate, apll_clk, ARRAY_SIZE(apll_clk));
+			round_rate = apll_clk[index];
+			break;
+		case EIC7700_PLL_CPU:
+			index = find_closest(rate, cpu_pll_clk, ARRAY_SIZE(cpu_pll_clk));
+			round_rate = cpu_pll_clk[index];
+			break;
+		default:
+			pr_err("%s %d, unknow clk id %d\n", __func__, __LINE__, clk->id);
+			round_rate = 0;
+			break;
+	}
+	return round_rate;
+}
+
+static const struct clk_ops eswin_clk_pll_ops = {
+	.set_rate = clk_pll_set_rate,
+	.recalc_rate = clk_pll_recalc_rate,
+	.round_rate = clk_pll_round_rate,
+};
+
+void eswin_clk_register_pll(struct eswin_pll_clock *clks,
+		int nums, struct eswin_clock_data *data, struct device *dev)
+{
+	void __iomem *base = data->base;
+	struct eswin_clk_pll *p_clk = NULL;
+	struct clk *clk = NULL;
+	struct clk_init_data init;
+	int i;
+
+	p_clk = devm_kzalloc(dev, sizeof(*p_clk) * nums, GFP_KERNEL);
+
+	if (!p_clk)
+		return;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL);
+		const char *parent_name = clks[i].parent_name ? kzalloc(strlen(clks[i].parent_name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL) : NULL;
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+			if (parent_name) {
+				sprintf((char *)parent_name, "%s", clks[i].parent_name);
+			}
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+			if (parent_name) {
+				sprintf((char *)parent_name, "d%d_%s", data->numa_id, clks[i].parent_name);
+			}
+		}
+
+		init.name = name;
+		init.flags = 0;
+		init.parent_names = parent_name ? &parent_name : NULL;
+		init.num_parents = parent_name ? 1 : 0;
+		init.ops = &eswin_clk_pll_ops;
+
+		p_clk->id = clks[i].id;
+		p_clk->numa_id = data->numa_id;
+		p_clk->ctrl_reg0 = base + clks[i].ctrl_reg0;
+		p_clk->pllen_shift = clks[i].pllen_shift;
+		p_clk->pllen_width = clks[i].pllen_width;
+		p_clk->refdiv_shift = clks[i].refdiv_shift;
+		p_clk->refdiv_width = clks[i].refdiv_width;
+		p_clk->fbdiv_shift = clks[i].fbdiv_shift;
+		p_clk->fbdiv_width = clks[i].fbdiv_width;
+
+		p_clk->ctrl_reg1 = base + clks[i].ctrl_reg1;
+		p_clk->frac_shift = clks[i].frac_shift;
+		p_clk->frac_width = clks[i].frac_width;
+
+		p_clk->ctrl_reg2 = base + clks[i].ctrl_reg2;
+		p_clk->postdiv1_shift = clks[i].postdiv1_shift;
+		p_clk->postdiv1_width = clks[i].postdiv1_width;
+		p_clk->postdiv2_shift = clks[i].postdiv2_shift;
+		p_clk->postdiv2_width = clks[i].postdiv2_width;
+
+		p_clk->status_reg = base + clks[i].status_reg;
+		p_clk->lock_shift = clks[i].lock_shift;
+		p_clk->lock_width = clks[i].lock_width;
+
+		p_clk->hw.init = &init;
+
+		clk = clk_register(dev, &p_clk->hw);
+		if (IS_ERR(clk)) {
+			devm_kfree(dev, p_clk);
+			dev_err(dev, "%s: failed to register clock %s\n", __func__, clks[i].name);
+			continue;
+		}
+
+		data->clk_data.clks[clks[i].id] = clk;
+		p_clk++;
+		kfree(name);
+		if (parent_name) {
+			kfree(parent_name);
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_pll);
+
+int eswin_clk_register_fixed_factor(const struct eswin_fixed_factor_clock *clks,
+					   int nums,
+					   struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	int i;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		char *parent_name = kzalloc(strlen(clks[i].parent_name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+			sprintf(parent_name, "%s", clks[i].parent_name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+			sprintf(parent_name, "d%d_%s", data->numa_id, clks[i].parent_name);
+		}
+
+		clk = clk_register_fixed_factor(NULL, name,
+						parent_name,
+						clks[i].flags, clks[i].mult,
+						clks[i].div);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register clock %s\n", __func__, name);
+			kfree(name);
+			kfree(parent_name);
+			goto err;
+		}
+		data->clk_data.clks[clks[i].id] = clk;
+
+		kfree(name);
+		kfree(parent_name);
+	}
+
+	return 0;
+
+err:
+	while (i--)
+		clk_unregister_fixed_factor(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_fixed_factor);
+
+int eswin_clk_register_mux(const struct eswin_mux_clock *clks,
+				  int nums, struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	void __iomem *base = data->base;
+	int i;
+	int j;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+
+		char **parent_names = kzalloc(sizeof(char *) * clks[i].num_parents,
+			GFP_KERNEL );
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+		}
+		for (j = 0; j < clks[i].num_parents; j++) {
+			parent_names[j] = kzalloc(strlen(clks[i].parent_names[j])
+				+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+			if (data->numa_id < 0) {
+				sprintf(parent_names[j], "%s", clks[i].parent_names[j]);
+			} else {
+				sprintf(parent_names[j], "d%d_%s",
+					data->numa_id, clks[i].parent_names[j]);
+			}
+		}
+		clk = clk_register_mux_table(NULL, name,
+				(const char * const*)parent_names,
+				clks[i].num_parents, clks[i].flags,
+				base + clks[i].offset, clks[i].shift,
+				clks[i].mask, clks[i].mux_flags,
+				clks[i].table, &data->lock);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register clock %s\n", __func__, clks[i].name);
+			kfree(name);
+			for (j = 0; j < clks[i].num_parents; j++) {
+				kfree(parent_names[j]);
+			}
+			kfree(parent_names);
+			goto err;
+		}
+
+		if (clks[i].alias)
+			clk_register_clkdev(clk, clks[i].alias, NULL);
+
+		data->clk_data.clks[clks[i].id] = clk;
+
+		kfree(name);
+		for (j = 0; j < clks[i].num_parents; j++) {
+			kfree(parent_names[j]);
+		}
+		kfree(parent_names);
+	}
+	return 0;
+
+err:
+	while (i--)
+		clk_unregister_mux(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_mux);
+
+int eswin_clk_register_divider(const struct eswin_divider_clock *clks,
+				      int nums, struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	void __iomem *base = data->base;
+	int i;
+	struct clk_hw *clk_hw;
+	struct clk_hw *parent_hw;
+	struct clk_parent_data	parent_data;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		char *parent_name = kzalloc(strlen(clks[i].parent_name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+			sprintf(parent_name, "%s", clks[i].parent_name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+			sprintf(parent_name, "d%d_%s", data->numa_id, clks[i].parent_name);
+		}
+		parent_hw = eswin_clk_find_parent(data, parent_name);
+		parent_data.name = parent_name;
+		parent_data.hw = parent_hw;
+		parent_data.fw_name = NULL;
+		clk_hw = clk_hw_register_divider_table_parent_data(NULL, name,
+						&parent_data,
+						clks[i].flags,
+						base + clks[i].offset,
+						clks[i].shift, clks[i].width,
+						clks[i].div_flags,
+						clks[i].table,
+						&data->lock);
+		if (IS_ERR(clk_hw)) {
+			pr_err("%s: failed to register clock %s\n", __func__, clks[i].name);
+			kfree(name);
+			kfree(parent_name);
+			goto err;
+		}
+		clk = clk_hw->clk;
+		if (clks[i].alias)
+			clk_register_clkdev(clk, clks[i].alias, NULL);
+
+		data->clk_data.clks[clks[i].id] = clk;
+		kfree(name);
+		kfree(parent_name);
+	}
+	return 0;
+
+err:
+	while (i--)
+		clk_unregister_divider(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_divider);
+
+int eswin_clk_register_gate(const struct eswin_gate_clock *clks,
+				       int nums, struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	void __iomem *base = data->base;
+	int i;
+	struct clk_hw *clk_hw;
+	struct clk_hw *parent_hw;
+	struct clk_parent_data	parent_data;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL);
+		char *parent_name = kzalloc(strlen(clks[i].parent_name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL);
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+			sprintf(parent_name, "%s", clks[i].parent_name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+			sprintf(parent_name, "d%d_%s", data->numa_id, clks[i].parent_name);
+		}
+		parent_hw = eswin_clk_find_parent(data, parent_name);
+		parent_data.name = parent_name;
+		parent_data.hw = parent_hw;
+		parent_data.fw_name = NULL;
+		clk_hw = clk_hw_register_gate_parent_data(NULL, name,
+				&parent_data,
+				clks[i].flags,
+				base + clks[i].offset,
+				clks[i].bit_idx,
+				clks[i].gate_flags,
+				&data->lock);
+		if (IS_ERR(clk_hw)) {
+			pr_err("%s: failed to register clock %s\n",__func__, clks[i].name);
+			kfree(name);
+			kfree(parent_name);
+			goto err;
+		}
+		clk = clk_hw->clk;
+		if (clks[i].alias)
+			clk_register_clkdev(clk, clks[i].alias, NULL);
+
+		data->clk_data.clks[clks[i].id] = clk;
+		kfree(name);
+		kfree(parent_name);
+	}
+	return 0;
+
+err:
+	while (i--)
+		clk_unregister_gate(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_gate);
+
+static const struct clk_ops clk_dummpy_ops = {
+
+};
+
+struct clk *eswin_register_clk(struct eswin_clock_data *data,
+				     struct device *dev, const char *name,
+				      const char *parent_name,
+				      unsigned long flags,
+				      spinlock_t *lock)
+{
+	struct eswin_clock *eclk;
+	struct clk *clk;
+	struct clk_init_data init;
+	struct clk_parent_data	parent_data;
+	struct clk_hw 		*parent_hw;
+
+	eclk = kzalloc(sizeof(*eclk), GFP_KERNEL );
+	if (!eclk)
+		return ERR_PTR(-ENOMEM);
+
+	init.ops = &clk_dummpy_ops;
+
+	init.name = name;
+	init.flags = flags;
+	init.parent_names = NULL;
+	init.num_parents = (parent_name ? 1 : 0);
+	init.parent_data = &parent_data;
+
+	parent_hw = eswin_clk_find_parent(data, (char *)parent_name);
+	parent_data.name = parent_name;
+	parent_data.hw = parent_hw;
+	parent_data.fw_name = NULL;
+
+	eclk->hw.init = &init;
+
+	clk = clk_register(dev, &eclk->hw);
+	if (IS_ERR(clk))
+		kfree(eclk);
+
+	return clk;
+}
+
+int eswin_clk_register_clk(const struct eswin_clock *clks,
+				       int nums, struct eswin_clock_data *data)
+{
+	struct clk *clk;
+	int 	i;
+
+	for (i = 0; i < nums; i++) {
+		char *name = kzalloc(strlen(clks[i].name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		char *parent_name = kzalloc(strlen(clks[i].parent_name)
+			+ 2 * sizeof(char) + sizeof(int), GFP_KERNEL );
+		if (data->numa_id < 0) {
+			sprintf(name, "%s", clks[i].name);
+			sprintf(parent_name, "%s", clks[i].parent_name);
+		} else {
+			sprintf(name, "d%d_%s", data->numa_id, clks[i].name);
+			sprintf(parent_name, "d%d_%s", data->numa_id, clks[i].parent_name);
+		}
+		clk = eswin_register_clk(data, NULL, name, parent_name,
+					clks[i].flags, &data->lock);
+		if (IS_ERR(clk)) {
+			pr_err("%s: failed to register clock %s\n", __func__, clks[i].name);
+			kfree(name);
+			kfree(parent_name);
+			goto err;
+		}
+
+		if (clks[i].alias)
+			clk_register_clkdev(clk, clks[i].alias, NULL);
+
+		data->clk_data.clks[clks[i].id] = clk;
+		kfree(name);
+		kfree(parent_name);
+	}
+	return 0;
+err:
+	while (i--)
+		clk_unregister_gate(data->clk_data.clks[clks[i].id]);
+
+	return PTR_ERR(clk);
+}
+EXPORT_SYMBOL_GPL(eswin_clk_register_clk);
diff --git a/drivers/clk/eswin/clk.h b/drivers/clk/eswin/clk.h
new file mode 100755
index 000000000000..c5906c420769
--- /dev/null
+++ b/drivers/clk/eswin/clk.h
@@ -0,0 +1,198 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Clk Provider Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#ifndef	__ESWIN_CLK_H
+#define	__ESWIN_CLK_H
+
+#include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+
+struct platform_device;
+
+struct eswin_clock_data {
+	struct clk_onecell_data	clk_data;
+	void __iomem		*base;
+	int 			numa_id;
+	spinlock_t 		lock;
+};
+
+struct eswin_clock {
+	unsigned int		id;
+	char			*name;
+	const char		*parent_name;
+	unsigned long		flags;
+	struct clk_hw		hw;
+	const char		*alias;
+};
+
+struct eswin_fixed_rate_clock {
+	unsigned int		id;
+	char			*name;
+	const char		*parent_name;
+	unsigned long		flags;
+	unsigned long		fixed_rate;
+};
+
+struct eswin_fixed_factor_clock {
+	unsigned int		id;
+	char				*name;
+	const char			*parent_name;
+	unsigned long		mult;
+	unsigned long		div;
+	unsigned long		flags;
+};
+
+struct eswin_mux_clock {
+	unsigned int		id;
+	const char			*name;
+	const char	*const 	*parent_names;
+	u8					num_parents;
+	unsigned long		flags;
+	unsigned long		offset;
+	u8					shift;
+	u32 				mask;
+	u8					mux_flags;
+	u32					*table;
+	const char			*alias;
+};
+
+
+struct eswin_divider_clock {
+	unsigned int		id;
+	const char		*name;
+	const char		*parent_name;
+	unsigned long		flags;
+	unsigned long		offset;
+	u8			shift;
+	u8			width;
+	u8			div_flags;
+	struct clk_div_table	*table;
+	const char		*alias;
+};
+
+struct eswin_gate_clock {
+	unsigned int		id;
+	const char		*name;
+	const char		*parent_name;
+	unsigned long		flags;
+	unsigned long		offset;
+	u8			bit_idx;
+	u8			gate_flags;
+	const char		*alias;
+};
+
+struct eswin_pll_clock {
+	u32	id;
+	const char	*name;
+	const char	*parent_name;
+	const u32	ctrl_reg0;
+	const u8	pllen_shift;
+	const u8	pllen_width;
+	const u8	refdiv_shift;
+	const u8	refdiv_width;
+	const u8	fbdiv_shift;
+	const u8	fbdiv_width;
+
+	const u32	ctrl_reg1;
+	const u8	frac_shift;
+	const u8	frac_width;
+
+	const u32	ctrl_reg2;
+	const u8	postdiv1_shift;
+	const u8	postdiv1_width;
+	const u8	postdiv2_shift;
+	const u8	postdiv2_width;
+
+	const u32	status_reg;
+	const u8	lock_shift;
+	const u8	lock_width;
+};
+
+struct eswin_clk_pll {
+	struct clk_hw	hw;
+	u32	id;
+	int 	numa_id;
+	void __iomem	*ctrl_reg0;
+	u8	pllen_shift;
+	u8	pllen_width;
+	u8	refdiv_shift;
+	u8	refdiv_width;
+	u8	fbdiv_shift;
+	u8	fbdiv_width;
+
+	void __iomem	*ctrl_reg1;
+	u8	frac_shift;
+	u8	frac_width;
+
+	void __iomem	*ctrl_reg2;
+	u8	postdiv1_shift;
+	u8	postdiv1_width;
+	u8	postdiv2_shift;
+	u8	postdiv2_width;
+
+	void __iomem	*status_reg;
+	u8	lock_shift;
+	u8	lock_width;
+};
+
+struct eswin_clock_data *eswin_clk_init(struct platform_device *, int);
+int eswin_clk_register_fixed_rate(const struct eswin_fixed_rate_clock *,
+				int, struct eswin_clock_data *);
+
+void eswin_clk_register_pll(struct eswin_pll_clock *clks,
+		int nums, struct eswin_clock_data *data, struct device *dev);
+
+int eswin_clk_register_fixed_factor(const struct eswin_fixed_factor_clock *,
+				int, struct eswin_clock_data *);
+int eswin_clk_register_mux(const struct eswin_mux_clock *, int,
+				struct eswin_clock_data *);
+
+int eswin_clk_register_divider(const struct eswin_divider_clock *,
+				int, struct eswin_clock_data *);
+int eswin_clk_register_gate(const struct eswin_gate_clock *,
+				int, struct eswin_clock_data *);
+
+int eswin_clk_register_clk(const struct eswin_clock *,
+				       int , struct eswin_clock_data *);
+
+#define eswin_clk_unregister(type) \
+static inline \
+void eswin_clk_unregister_##type(const struct eswin_##type##_clock *clks, \
+				int nums, struct eswin_clock_data *data) \
+{ \
+	struct clk **clocks = data->clk_data.clks; \
+	int i; \
+	for (i = 0; i < nums; i++) { \
+		int id = clks[i].id; \
+		if (clocks[id])  \
+			clk_unregister_##type(clocks[id]); \
+	} \
+}
+
+eswin_clk_unregister(fixed_rate)
+eswin_clk_unregister(fixed_factor)
+eswin_clk_unregister(mux)
+eswin_clk_unregister(divider)
+eswin_clk_unregister(gate)
+
+#endif	/* __ESWIN_CLK_H */
diff --git a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
index dd02f84e404d..0d73bebaadbe 100644
--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
+++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
@@ -32,6 +32,13 @@
 #include "dw-axi-dmac.h"
 #include "../dmaengine.h"
 #include "../virt-dma.h"
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+#include <linux/iommu.h>
+#include <linux/mfd/syscon.h>
+#include <linux/bitfield.h>
+#include <linux/regmap.h>
+#include <linux/eic7700-sid-cfg.h>
+#endif
 
 /*
  * The set of bus widths supported by the DMA controller. DW AXI DMAC supports
@@ -51,6 +58,15 @@
 #define AXI_DMA_FLAG_HAS_RESETS		BIT(1)
 #define AXI_DMA_FLAG_USE_CFG2		BIT(2)
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+#define AWSMMUSID	GENMASK(31, 24) // The sid of write operation
+#define AWSMMUSSID	GENMASK(23, 16) // The ssid of write operation
+#define ARSMMUSID	GENMASK(15, 8)	// The sid of read operation
+#define ARSMMUSSID	GENMASK(7, 0)	// The ssid of read operation
+
+static int eswin_dma_sid_cfg(struct device *dev);
+#endif
+
 static inline void
 axi_dma_iowrite32(struct axi_dma_chip *chip, u32 reg, u32 val)
 {
@@ -98,14 +114,26 @@ static inline void axi_chan_config_write(struct axi_dma_chan *chan,
 			 config->hs_sel_dst << CH_CFG_H_HS_SEL_DST_POS |
 			 config->src_per << CH_CFG_H_SRC_PER_POS |
 			 config->dst_per << CH_CFG_H_DST_PER_POS |
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+			 config->prior << CH_CFG_H_PRIORITY_POS |
+			 0xF <<CH_CFG_H_SRC_OSR_LMT_POS |
+			 0xF <<CH_CFG_H_DST_OSR_LMT_POS;
+#else
 			 config->prior << CH_CFG_H_PRIORITY_POS;
+#endif
 	} else {
 		cfg_lo |= config->src_per << CH_CFG2_L_SRC_PER_POS |
 			  config->dst_per << CH_CFG2_L_DST_PER_POS;
 		cfg_hi = config->tt_fc << CH_CFG2_H_TT_FC_POS |
 			 config->hs_sel_src << CH_CFG2_H_HS_SEL_SRC_POS |
 			 config->hs_sel_dst << CH_CFG2_H_HS_SEL_DST_POS |
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+			 config->prior << CH_CFG2_H_PRIORITY_POS |
+			 0xF <<CH_CFG2_H_SRC_OSR_LMT_POS |
+			 0xF <<CH_CFG2_H_DST_OSR_LMT_POS;
+#else
 			 config->prior << CH_CFG2_H_PRIORITY_POS;
+#endif
 	}
 	axi_chan_iowrite32(chan, CH_CFG_L, cfg_lo);
 	axi_chan_iowrite32(chan, CH_CFG_H, cfg_hi);
@@ -228,6 +256,20 @@ static void axi_dma_hw_init(struct axi_dma_chip *chip)
 	ret = dma_set_mask_and_coherent(chip->dev, DMA_BIT_MASK(64));
 	if (ret)
 		dev_warn(chip->dev, "Unable to set coherent mask\n");
+
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	if (of_node_name_prefix(chip->dev->of_node, "dma-controller-hsp"))
+	{
+		eswin_dma_sid_cfg(chip->dev);
+	}
+	else
+	{
+		eic7700_aon_sid_cfg(chip->dev);
+	}
+
+	/* TBU power up */
+	eic7700_tbu_power(chip->dev, true);
+#endif
 }
 
 static u32 axi_chan_get_xfer_width(struct axi_dma_chan *chan, dma_addr_t src,
@@ -332,7 +374,12 @@ dma_chan_tx_status(struct dma_chan *dchan, dma_cookie_t cookie,
 		completed_length = completed_blocks * len;
 		bytes = length - completed_length;
 	}
-
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	else
+	{
+		bytes = vd_to_axi_desc(vdesc)->length;
+	}
+#endif
 	spin_unlock_irqrestore(&chan->vc.lock, flags);
 	dma_set_residue(txstate, bytes);
 
@@ -454,6 +501,9 @@ static void dma_chan_issue_pending(struct dma_chan *dchan)
 	unsigned long flags;
 
 	spin_lock_irqsave(&chan->vc.lock, flags);
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	chan->trigger = true;
+#endif
 	if (vchan_issue_pending(&chan->vc))
 		axi_chan_start_first_queued(chan);
 	spin_unlock_irqrestore(&chan->vc.lock, flags);
@@ -574,25 +624,60 @@ static void write_desc_dar(struct axi_dma_hw_desc *desc, dma_addr_t adr)
 	desc->lli->dar = cpu_to_le64(adr);
 }
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+static void set_desc_src_master(struct axi_dma_hw_desc *desc, struct axi_dma_chan *chan)
+#else
 static void set_desc_src_master(struct axi_dma_hw_desc *desc)
+#endif
 {
 	u32 val;
 
 	/* Select AXI0 for source master */
 	val = le32_to_cpu(desc->lli->ctl_lo);
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	if (chan->chip->dw->hdata->nr_masters > 1)
+	{
+		if(DMA_DEV_TO_MEM == chan->direction || DMA_DEV_TO_DEV == chan->direction) {
+			val |= CH_CTL_L_SRC_MAST;
+		}
+		else
+		{
+			val &= ~CH_CTL_L_SRC_MAST;
+		}
+	}
+	else
+		val &= ~CH_CTL_L_SRC_MAST;
+#else
 	val &= ~CH_CTL_L_SRC_MAST;
+#endif
 	desc->lli->ctl_lo = cpu_to_le32(val);
 }
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+static void set_desc_dest_master(struct axi_dma_hw_desc *hw_desc,
+				 struct axi_dma_chan *chan)
+#else
 static void set_desc_dest_master(struct axi_dma_hw_desc *hw_desc,
 				 struct axi_dma_desc *desc)
+#endif
 {
 	u32 val;
 
 	/* Select AXI1 for source master if available */
 	val = le32_to_cpu(hw_desc->lli->ctl_lo);
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	if (chan->chip->dw->hdata->nr_masters > 1)
+	{
+		if(DMA_MEM_TO_DEV == chan->direction || DMA_DEV_TO_DEV == chan->direction) {
+			val |= CH_CTL_L_DST_MAST;
+		}
+		else
+			val &= ~CH_CTL_L_DST_MAST;
+	}
+#else
 	if (desc->chan->chip->dw->hdata->nr_masters > 1)
 		val |= CH_CTL_L_DST_MAST;
+#endif
 	else
 		val &= ~CH_CTL_L_DST_MAST;
 
@@ -611,6 +696,10 @@ static int dw_axi_dma_set_hw_desc(struct axi_dma_chan *chan,
 	size_t block_ts;
 	u32 ctllo, ctlhi;
 	u32 burst_len;
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	u32 src_maxburst;
+	u32 dst_maxburst;
+#endif
 
 	axi_block_ts = chan->chip->dw->hdata->block_size[chan->id];
 
@@ -623,6 +712,11 @@ static int dw_axi_dma_set_hw_desc(struct axi_dma_chan *chan,
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	src_maxburst = chan->chip->dw->hdata->max_msize;
+	dst_maxburst  = chan->chip->dw->hdata->max_msize;
+#endif
+
 	switch (chan->direction) {
 	case DMA_MEM_TO_DEV:
 		reg_width = __ffs(chan->config.dst_addr_width);
@@ -631,6 +725,9 @@ static int dw_axi_dma_set_hw_desc(struct axi_dma_chan *chan,
 			mem_width << CH_CTL_L_SRC_WIDTH_POS |
 			DWAXIDMAC_CH_CTL_L_NOINC << CH_CTL_L_DST_INC_POS |
 			DWAXIDMAC_CH_CTL_L_INC << CH_CTL_L_SRC_INC_POS;
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+		dst_maxburst = chan->config.dst_maxburst;
+#endif
 		block_ts = len >> mem_width;
 		break;
 	case DMA_DEV_TO_MEM:
@@ -640,6 +737,9 @@ static int dw_axi_dma_set_hw_desc(struct axi_dma_chan *chan,
 			mem_width << CH_CTL_L_DST_WIDTH_POS |
 			DWAXIDMAC_CH_CTL_L_INC << CH_CTL_L_DST_INC_POS |
 			DWAXIDMAC_CH_CTL_L_NOINC << CH_CTL_L_SRC_INC_POS;
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+		src_maxburst = chan->config.src_maxburst;
+#endif
 		block_ts = len >> reg_width;
 		break;
 	default:
@@ -673,12 +773,27 @@ static int dw_axi_dma_set_hw_desc(struct axi_dma_chan *chan,
 	}
 
 	hw_desc->lli->block_ts_lo = cpu_to_le32(block_ts - 1);
-
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	if(is_power_of_2(dst_maxburst) && is_power_of_2(src_maxburst))
+	{
+		dst_maxburst = order_base_2(dst_maxburst)? order_base_2(dst_maxburst) - 1 : 0;
+		src_maxburst = order_base_2(src_maxburst)? order_base_2(src_maxburst) - 1 : 0;
+	}else
+		dev_err(chan->chip->dev, "dst_burst or src_burst error!\n");
+	ctllo |= dst_maxburst << CH_CTL_L_DST_MSIZE_POS |
+		 src_maxburst << CH_CTL_L_SRC_MSIZE_POS;
+#else
 	ctllo |= DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_DST_MSIZE_POS |
-		 DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_SRC_MSIZE_POS;
+	         DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_SRC_MSIZE_POS;
+#endif
 	hw_desc->lli->ctl_lo = cpu_to_le32(ctllo);
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	set_desc_src_master(hw_desc, chan);
+	set_desc_dest_master(hw_desc, chan);
+#else
 	set_desc_src_master(hw_desc);
+#endif
 
 	hw_desc->len = len;
 	return 0;
@@ -879,6 +994,9 @@ dma_chan_prep_dma_memcpy(struct dma_chan *dchan, dma_addr_t dst_adr,
 	struct axi_dma_hw_desc *hw_desc = NULL;
 	struct axi_dma_desc *desc = NULL;
 	u32 xfer_width, reg, num;
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	u32 max_burst_len;
+#endif
 	u64 llp = 0;
 	u8 lms = 0; /* Select AXI0 master for LLI fetching */
 
@@ -886,6 +1004,12 @@ dma_chan_prep_dma_memcpy(struct dma_chan *dchan, dma_addr_t dst_adr,
 		axi_chan_name(chan), &src_adr, &dst_adr, len, flags);
 
 	max_block_ts = chan->chip->dw->hdata->block_size[chan->id];
+
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	max_burst_len = chan->chip->dw->hdata->max_msize;
+	max_burst_len = order_base_2(max_burst_len)? order_base_2(max_burst_len) - 1 : 0;
+#endif
+
 	xfer_width = axi_chan_get_xfer_width(chan, src_adr, dst_adr, len);
 	num = DIV_ROUND_UP(len, max_block_ts << xfer_width);
 	desc = axi_desc_alloc(num);
@@ -936,17 +1060,26 @@ dma_chan_prep_dma_memcpy(struct dma_chan *dchan, dma_addr_t dst_adr,
 		}
 		hw_desc->lli->ctl_hi = cpu_to_le32(reg);
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+		reg = (max_burst_len << CH_CTL_L_DST_MSIZE_POS |
+		       max_burst_len << CH_CTL_L_SRC_MSIZE_POS |
+#else
 		reg = (DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_DST_MSIZE_POS |
 		       DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_SRC_MSIZE_POS |
+#endif
 		       xfer_width << CH_CTL_L_DST_WIDTH_POS |
 		       xfer_width << CH_CTL_L_SRC_WIDTH_POS |
 		       DWAXIDMAC_CH_CTL_L_INC << CH_CTL_L_DST_INC_POS |
 		       DWAXIDMAC_CH_CTL_L_INC << CH_CTL_L_SRC_INC_POS);
 		hw_desc->lli->ctl_lo = cpu_to_le32(reg);
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+		set_desc_src_master(hw_desc, chan);
+		set_desc_dest_master(hw_desc, chan);
+#else
 		set_desc_src_master(hw_desc);
 		set_desc_dest_master(hw_desc, desc);
-
+#endif
 		hw_desc->len = xfer_len;
 		desc->length += hw_desc->len;
 		/* update the length and addresses for the next loop cycle */
@@ -1159,7 +1292,9 @@ static int dma_chan_terminate_all(struct dma_chan *dchan)
 	spin_lock_irqsave(&chan->vc.lock, flags);
 
 	vchan_get_all_descriptors(&chan->vc, &head);
-
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	chan->trigger = false;
+#endif
 	chan->cyclic = false;
 	spin_unlock_irqrestore(&chan->vc.lock, flags);
 
@@ -1248,8 +1383,9 @@ static int axi_dma_suspend(struct axi_dma_chip *chip)
 	axi_dma_disable(chip);
 
 	clk_disable_unprepare(chip->core_clk);
+#ifndef CONFIG_SOC_SIFIVE_EIC7700
 	clk_disable_unprepare(chip->cfgr_clk);
-
+#endif
 	return 0;
 }
 
@@ -1257,9 +1393,11 @@ static int axi_dma_resume(struct axi_dma_chip *chip)
 {
 	int ret;
 
+#ifndef CONFIG_SOC_SIFIVE_EIC7700
 	ret = clk_prepare_enable(chip->cfgr_clk);
 	if (ret < 0)
 		return ret;
+#endif
 
 	ret = clk_prepare_enable(chip->core_clk);
 	if (ret < 0)
@@ -1285,6 +1423,43 @@ static int __maybe_unused axi_dma_runtime_resume(struct device *dev)
 	return axi_dma_resume(chip);
 }
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+int eic7700_dma_sel_cfg(struct axi_dma_chan *chan, u32 val)
+{
+	struct axi_dma_chip *chip = chan->chip;
+	struct device *dev = chan->chip->dev;
+	int ret = 0;
+	struct regmap *regmap;
+	int dma_sel_reg;
+	u32 dma_sel = 0;
+
+	regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "eswin,syscfg");
+	if (IS_ERR(regmap)) {
+		dev_err(dev, "No eswin,syscfg phandle specified\n");
+		return -1;
+	}
+
+	ret = of_property_read_u32_index(dev->of_node, "eswin,syscfg", 2,
+					&dma_sel_reg);
+	if (ret) {
+		dev_err(dev, "can't get sid cfg reg offset in sys_con(errno:%d)\n", ret);
+		return ret;
+	}
+	regmap_read(regmap, dma_sel_reg, &dma_sel);
+
+	if (of_node_name_prefix(chip->dev->of_node, "dma-controller-hsp")) {
+		if (val < 32)
+			dma_sel &= ~(1 << val);
+	}
+	else {
+		if (val < 32)
+			dma_sel |= (1 << val);
+	}
+	regmap_write(regmap, dma_sel_reg, dma_sel);
+	return 0;
+}
+#endif
+
 static struct dma_chan *dw_axi_dma_of_xlate(struct of_phandle_args *dma_spec,
 					    struct of_dma *ofdma)
 {
@@ -1298,6 +1473,10 @@ static struct dma_chan *dw_axi_dma_of_xlate(struct of_phandle_args *dma_spec,
 
 	chan = dchan_to_axi_dma_chan(dchan);
 	chan->hw_handshake_num = dma_spec->args[0];
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	if (dma_spec->args_count > 1)
+		eic7700_dma_sel_cfg(chan, dma_spec->args[1]);
+#endif
 	return dchan;
 }
 
@@ -1368,6 +1547,20 @@ static int parse_device_properties(struct axi_dma_chip *chip)
 		chip->dw->hdata->axi_rw_burst_len = tmp;
 	}
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	/* max-size is optional property */
+	ret = device_property_read_u32(dev, "snps,max-msize", &tmp);
+	if (!ret) {
+		if (tmp > 1024)
+			return -EINVAL;
+		if (tmp < 1)
+			return -EINVAL;
+
+		chip->dw->hdata->max_msize = tmp;
+	}else
+		chip->dw->hdata->max_msize = 4;
+#endif
+
 	return 0;
 }
 
@@ -1428,10 +1621,31 @@ static int dw_probe(struct platform_device *pdev)
 	if (IS_ERR(chip->core_clk))
 		return PTR_ERR(chip->core_clk);
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	chip->arst = devm_reset_control_get_optional(&pdev->dev, "arst");
+	if (IS_ERR_OR_NULL(chip->arst)) {
+		dev_err(chip->dev, "Failed to get axi reset handle\n");
+		return -EFAULT;
+	}
+	reset_control_deassert(chip->arst);
+
+	chip->prst = devm_reset_control_get_optional(&pdev->dev, "prst");
+	if (IS_ERR_OR_NULL(chip->prst)) {
+		dev_err(chip->dev, "Failed to get ahb reset handle\n");
+		return -EFAULT;
+	}
+	reset_control_deassert(chip->prst);
+#endif
+
+	/*
+	  For EIC7700 SoC, aon dma has separate cfg clk register bit while dma0 havn't.
+	  Since dma cfg clk is default on, so we don't control it
+	*/
+#ifndef CONFIG_SOC_SIFIVE_EIC7700
 	chip->cfgr_clk = devm_clk_get(chip->dev, "cfgr-clk");
 	if (IS_ERR(chip->cfgr_clk))
 		return PTR_ERR(chip->cfgr_clk);
-
+#endif
 	ret = parse_device_properties(chip);
 	if (ret)
 		return ret;
@@ -1465,7 +1679,12 @@ static int dw_probe(struct platform_device *pdev)
 	dma_cap_set(DMA_CYCLIC, dw->dma.cap_mask);
 
 	/* DMA capabilities */
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	dw->dma.chancnt = hdata->nr_channels;
+	dw->dma.max_burst = hdata->max_msize;
+#else
 	dw->dma.max_burst = hdata->axi_rw_burst_len;
+#endif
 	dw->dma.src_addr_widths = AXI_DMA_BUSWIDTHS;
 	dw->dma.dst_addr_widths = AXI_DMA_BUSWIDTHS;
 	dw->dma.directions = BIT(DMA_MEM_TO_MEM);
@@ -1535,6 +1754,53 @@ static int dw_probe(struct platform_device *pdev)
 	return ret;
 }
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+static int eswin_dma_sid_cfg(struct device *dev)
+{
+	int ret;
+	struct regmap *regmap;
+	int hsp_mmu_dma_reg;
+	u32 rdwr_sid_ssid;
+	u32 sid;
+	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+
+	/* not behind smmu, use the default reset value(0x0) of the reg as streamID*/
+	if (fwspec == NULL) {
+		dev_dbg(dev, "dev is not behind smmu, skip configuration of sid\n");
+		return 0;
+	}
+	sid = fwspec->ids[0];
+
+	regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "eswin,hsp_sp_csr");
+	if (IS_ERR(regmap)) {
+		dev_dbg(dev, "No hsp_sp_csr phandle specified\n");
+		return 0;
+	}
+
+	ret = of_property_read_u32_index(dev->of_node, "eswin,hsp_sp_csr", 1,
+					&hsp_mmu_dma_reg);
+	if (ret) {
+		dev_err(dev, "can't get dma sid cfg reg offset (%d)\n", ret);
+		return ret;
+	}
+
+	/* make the reading sid the same as writing sid, ssid is fixed to zero */
+	rdwr_sid_ssid  = FIELD_PREP(AWSMMUSID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(ARSMMUSID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(AWSMMUSSID, 0);
+	rdwr_sid_ssid |= FIELD_PREP(ARSMMUSSID, 0);
+	regmap_write(regmap, hsp_mmu_dma_reg, rdwr_sid_ssid);
+
+	ret = eic7700_dynm_sid_enable(dev_to_node(dev));
+	if (ret < 0)
+		dev_err(dev, "failed to config dma streamID(%d)!\n", sid);
+	else
+		dev_dbg(dev, "success to config dma streamID(%d)!\n", sid);
+
+	return ret;
+}
+#endif
+
 static int dw_remove(struct platform_device *pdev)
 {
 	struct axi_dma_chip *chip = platform_get_drvdata(pdev);
@@ -1543,7 +1809,9 @@ static int dw_remove(struct platform_device *pdev)
 	u32 i;
 
 	/* Enable clk before accessing to registers */
+#ifndef CONFIG_SOC_SIFIVE_EIC7700
 	clk_prepare_enable(chip->cfgr_clk);
+#endif
 	clk_prepare_enable(chip->core_clk);
 	axi_dma_irq_disable(chip);
 	for (i = 0; i < dw->hdata->nr_channels; i++) {
@@ -1561,10 +1829,20 @@ static int dw_remove(struct platform_device *pdev)
 
 	list_for_each_entry_safe(chan, _chan, &dw->dma.channels,
 			vc.chan.device_node) {
+#ifndef CONFIG_SOC_SIFIVE_EIC7700
 		list_del(&chan->vc.chan.device_node);
+#endif
 		tasklet_kill(&chan->vc.task);
 	}
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	/* TBU power down before reset */
+	eic7700_tbu_power(chip->dev, false);
+
+	reset_control_assert(chip->arst);
+	reset_control_assert(chip->prst);
+#endif
+
 	return 0;
 }
 
diff --git a/drivers/dma/dw-axi-dmac/dw-axi-dmac.h b/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
index eb267cb24f67..b38672ecf73a 100644
--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
+++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
@@ -15,7 +15,9 @@
 #include <linux/device.h>
 #include <linux/dmaengine.h>
 #include <linux/types.h>
-
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+#include <linux/reset.h>
+#endif
 #include "../virt-dma.h"
 
 #define DMAC_MAX_CHANNELS	16
@@ -30,6 +32,9 @@ struct dw_axi_dma_hcfg {
 	u32	priority[DMAC_MAX_CHANNELS];
 	/* maximum supported axi burst length */
 	u32	axi_rw_burst_len;
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	u32	max_msize;
+#endif
 	/* Register map for DMAX_NUM_CHANNELS <= 8 */
 	bool	reg_map_8_channels;
 	bool	restrict_axi_burst_len;
@@ -52,6 +57,9 @@ struct axi_dma_chan {
 	bool				cyclic;
 	/* these other elements are all protected by vc.lock */
 	bool				is_paused;
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	bool				trigger;
+#endif
 };
 
 struct dw_axi_dma {
@@ -71,6 +79,10 @@ struct axi_dma_chip {
 	struct clk		*core_clk;
 	struct clk		*cfgr_clk;
 	struct dw_axi_dma	*dw;
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	struct reset_control	*arst;
+	struct reset_control	*prst;
+#endif
 };
 
 /* LLI == Linked List Item */
@@ -202,7 +214,11 @@ static inline struct axi_dma_chan *dchan_to_axi_dma_chan(struct dma_chan *dchan)
 #define UNUSED_CHANNEL		0x3F /* Set unused DMA channel to 0x3F */
 #define DMA_APB_HS_SEL_BIT_SIZE	0x08 /* HW handshake bits per channel */
 #define DMA_APB_HS_SEL_MASK	0xFF /* HW handshake select masks */
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+#define MAX_BLOCK_SIZE		0x80000 /* 1024 blocks * 512 bytes data width */
+#else
 #define MAX_BLOCK_SIZE		0x1000 /* 1024 blocks * 4 bytes data width */
+#endif
 #define DMA_REG_MAP_CH_REF	0x08 /* Channel count to choose register map */
 
 /* DMAC_CFG */
@@ -282,6 +298,10 @@ enum {
 #define CH_CTL_L_SRC_MAST		BIT(0)
 
 /* CH_CFG_H */
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+#define CH_CFG_H_DST_OSR_LMT_POS	27
+#define CH_CFG_H_SRC_OSR_LMT_POS	23
+#endif
 #define CH_CFG_H_PRIORITY_POS		17
 #define CH_CFG_H_DST_PER_POS		12
 #define CH_CFG_H_SRC_PER_POS		7
@@ -321,7 +341,13 @@ enum {
 #define CH_CFG2_H_TT_FC_POS		0
 #define CH_CFG2_H_HS_SEL_SRC_POS	3
 #define CH_CFG2_H_HS_SEL_DST_POS	4
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+#define CH_CFG2_H_PRIORITY_POS		15
+#define CH_CFG2_H_SRC_OSR_LMT_POS	23
+#define CH_CFG2_H_DST_OSR_LMT_POS	27
+#else
 #define CH_CFG2_H_PRIORITY_POS		20
+#endif
 
 /**
  * DW AXI DMA channel interrupts
diff --git a/drivers/gpu/drm/drm_gem_vram_helper.c b/drivers/gpu/drm/drm_gem_vram_helper.c
index b67eafa55715..aaf97dde9b73 100644
--- a/drivers/gpu/drm/drm_gem_vram_helper.c
+++ b/drivers/gpu/drm/drm_gem_vram_helper.c
@@ -870,7 +870,11 @@ static struct ttm_tt *bo_driver_ttm_tt_create(struct ttm_buffer_object *bo,
 	if (!tt)
 		return NULL;
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	ret = ttm_tt_init(tt, bo, page_flags, ttm_write_combined, 0);
+#else
 	ret = ttm_tt_init(tt, bo, page_flags, ttm_cached, 0);
+#endif
 	if (ret < 0)
 		goto err_ttm_tt_init;
 
diff --git a/drivers/gpu/drm/ttm/ttm_bo_util.c b/drivers/gpu/drm/ttm/ttm_bo_util.c
index fd9fd3d15101..9c2ba0a430aa 100644
--- a/drivers/gpu/drm/ttm/ttm_bo_util.c
+++ b/drivers/gpu/drm/ttm/ttm_bo_util.c
@@ -346,6 +346,7 @@ static int ttm_bo_kmap_ttm(struct ttm_buffer_object *bo,
 	if (ret)
 		return ret;
 
+#ifndef CONFIG_SOC_SIFIVE_EIC7700
 	if (num_pages == 1 && ttm->caching == ttm_cached) {
 		/*
 		 * We're mapping a single page, and the desired
@@ -365,6 +366,12 @@ static int ttm_bo_kmap_ttm(struct ttm_buffer_object *bo,
 		map->virtual = vmap(ttm->pages + start_page, num_pages,
 				    0, prot);
 	}
+#else
+	prot = ttm_io_prot(bo, mem, PAGE_KERNEL);
+	map->bo_kmap_type = ttm_bo_map_vmap;
+	map->virtual = vmap(ttm->pages + start_page, num_pages,
+				0, prot);
+#endif
 	return (!map->virtual) ? -ENOMEM : 0;
 }
 
diff --git a/drivers/gpu/drm/ttm/ttm_module.c b/drivers/gpu/drm/ttm/ttm_module.c
index b3fffe7b5062..aa137ead5cc5 100644
--- a/drivers/gpu/drm/ttm/ttm_module.c
+++ b/drivers/gpu/drm/ttm/ttm_module.c
@@ -74,7 +74,8 @@ pgprot_t ttm_prot_from_caching(enum ttm_caching caching, pgprot_t tmp)
 #endif /* CONFIG_UML */
 #endif /* __i386__ || __x86_64__ */
 #if defined(__ia64__) || defined(__arm__) || defined(__aarch64__) || \
-	defined(__powerpc__) || defined(__mips__) || defined(__loongarch__)
+	defined(__powerpc__) || defined(__mips__) || defined(__loongarch__) || \
+	defined(__riscv)
 	if (caching == ttm_write_combined)
 		tmp = pgprot_writecombine(tmp);
 	else
diff --git a/drivers/gpu/drm/ttm/ttm_resource.c b/drivers/gpu/drm/ttm/ttm_resource.c
index 46ff9c75bb12..7b097ccb5142 100644
--- a/drivers/gpu/drm/ttm/ttm_resource.c
+++ b/drivers/gpu/drm/ttm/ttm_resource.c
@@ -187,7 +187,11 @@ void ttm_resource_init(struct ttm_buffer_object *bo,
 	res->bus.addr = NULL;
 	res->bus.offset = 0;
 	res->bus.is_iomem = false;
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	res->bus.caching = ttm_write_combined;
+#else
 	res->bus.caching = ttm_cached;
+#endif
 	res->bo = bo;
 
 	man = ttm_manager_type(bo->bdev, place->mem_type);
@@ -670,6 +674,7 @@ ttm_kmap_iter_linear_io_init(struct ttm_kmap_iter_linear_io *iter_io,
 	} else {
 		iter_io->needs_unmap = true;
 		memset(&iter_io->dmap, 0, sizeof(iter_io->dmap));
+#ifndef CONFIG_SOC_SIFIVE_EIC7700
 		if (mem->bus.caching == ttm_write_combined)
 			iosys_map_set_vaddr_iomem(&iter_io->dmap,
 						  ioremap_wc(mem->bus.offset,
@@ -680,7 +685,12 @@ ttm_kmap_iter_linear_io_init(struct ttm_kmap_iter_linear_io *iter_io,
 						     MEMREMAP_WB |
 						     MEMREMAP_WT |
 						     MEMREMAP_WC));
-
+#else
+		if (mem->bus.caching == ttm_write_combined || mem->bus.caching == ttm_cached)
+			iosys_map_set_vaddr_iomem(&iter_io->dmap,
+						  ioremap_wc(mem->bus.offset,
+							     mem->size));
+#endif
 		/* If uncached requested or if mapping cached or wc failed */
 		if (iosys_map_is_null(&iter_io->dmap))
 			iosys_map_set_vaddr_iomem(&iter_io->dmap,
diff --git a/drivers/gpu/drm/ttm/ttm_tt.c b/drivers/gpu/drm/ttm/ttm_tt.c
index e0a77671edd6..ad1a7eefe750 100644
--- a/drivers/gpu/drm/ttm/ttm_tt.c
+++ b/drivers/gpu/drm/ttm/ttm_tt.c
@@ -141,7 +141,11 @@ static void ttm_tt_init_fields(struct ttm_tt *ttm,
 	ttm->dma_address = NULL;
 	ttm->swap_storage = NULL;
 	ttm->sg = bo->sg;
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	ttm->caching = ttm_write_combined;
+#else
 	ttm->caching = caching;
+#endif
 }
 
 int ttm_tt_init(struct ttm_tt *ttm, struct ttm_buffer_object *bo,
diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index ec38c8892158..4f1939f839f0 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -310,6 +310,15 @@ config SENSORS_AXI_FAN_CONTROL
 	  This driver can also be built as a module. If so, the module
 	  will be called axi-fan-control
 
+config SENSORS_ESWIN_FAN_CONTROL
+	tristate "ESWIN FAN Control Core driver"
+	help
+	  If you say yes here you get support for the Analog Devices
+	  ESWIN FAN monitoring core.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called eswin-fan-control
+
 config SENSORS_K8TEMP
 	tristate "AMD Athlon64/FX or Opteron temperature sensor"
 	depends on X86 && PCI
@@ -557,6 +566,12 @@ config SENSORS_DA9055
 	  This driver can also be built as a module. If so, the module
 	  will be called da9055-hwmon.
 
+config SENSORS_ESWIN_PVT
+	tristate "Eswin Process, Voltage, Temperature sensor driver"
+	depends on HWMON
+	help
+	  If you say yes here you get support for Eswin PVT sensor.
+
 config SENSORS_I5K_AMB
 	tristate "FB-DIMM AMB temperature sensor on Intel 5000 series chipsets"
 	depends on PCI
@@ -1485,6 +1500,13 @@ config SENSORS_LM95245
 	  This driver can also be built as a module. If so, the module
 	  will be called lm95245.
 
+config SENSORS_PAC1934
+	tristate "microchip PAC193X  Hardware Monitoring"
+	depends on I2C
+	help
+	  If you say yes here you get support for microchip PAC193X
+	  Single/Multi-Channel DC Power/Energy  Monitor with Accumulator.
+
 config SENSORS_PC87360
 	tristate "National Semiconductor PC87360 family"
 	depends on !PPC
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index 4ac9452b5430..e32c22b61622 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -72,6 +72,8 @@ obj-$(CONFIG_SENSORS_EMC1403)	+= emc1403.o
 obj-$(CONFIG_SENSORS_EMC2103)	+= emc2103.o
 obj-$(CONFIG_SENSORS_EMC2305)	+= emc2305.o
 obj-$(CONFIG_SENSORS_EMC6W201)	+= emc6w201.o
+obj-$(CONFIG_SENSORS_ESWIN_FAN_CONTROL)	+= eswin-fan-control.o
+obj-$(CONFIG_SENSORS_ESWIN_PVT)	+= eswin_pvt.o
 obj-$(CONFIG_SENSORS_F71805F)	+= f71805f.o
 obj-$(CONFIG_SENSORS_F71882FG)	+= f71882fg.o
 obj-$(CONFIG_SENSORS_F75375S)	+= f75375s.o
@@ -173,6 +175,7 @@ obj-$(CONFIG_SENSORS_NTC_THERMISTOR)	+= ntc_thermistor.o
 obj-$(CONFIG_SENSORS_NZXT_KRAKEN2) += nzxt-kraken2.o
 obj-$(CONFIG_SENSORS_NZXT_SMART2) += nzxt-smart2.o
 obj-$(CONFIG_SENSORS_OXP) += oxp-sensors.o
+obj-$(CONFIG_SENSORS_PAC1934)	+= pac193x.o
 obj-$(CONFIG_SENSORS_PC87360)	+= pc87360.o
 obj-$(CONFIG_SENSORS_PC87427)	+= pc87427.o
 obj-$(CONFIG_SENSORS_PCF8591)	+= pcf8591.o
diff --git a/drivers/hwmon/eswin-fan-control.c b/drivers/hwmon/eswin-fan-control.c
new file mode 100644
index 000000000000..5b7311cc9d6d
--- /dev/null
+++ b/drivers/hwmon/eswin-fan-control.c
@@ -0,0 +1,493 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Fan Control CORE driver
+ *
+ * Copyright 2022 ESWIN Inc.
+ */
+#include <linux/bits.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/wait.h>
+
+#define FAN_PWM_DUTY           0x0
+#define FAN_PWM_PERIOD         0x1
+#define FAN_PWM_FREE	       0x2
+
+/* register map */
+#define REG_FAN_INT            0x0
+#define REG_FAN_RPM            0x4
+
+/* wait for 50 times pwm period to trigger read interrupt */
+#define TIMEOUT(period)        nsecs_to_jiffies(50*(period))
+
+struct eswin_fan_control_data {
+	struct reset_control *fan_rst;
+	struct clk *clk;
+	void __iomem *base;
+	struct device *hdev;
+	unsigned long clk_rate;
+	int pwm_id;
+	struct pwm_device *pwm;
+	wait_queue_head_t wq;
+	bool wait_flag;
+	int irq;
+	/* pwm minimum period */
+	u32 min_period;
+	/* pulses per revolution */
+	u32 ppr;
+	/* revolutions per minute */
+	u32 rpm;
+};
+
+static inline void fan_iowrite(const u32 val, const u32 reg,
+			       const struct eswin_fan_control_data *ctl)
+{
+	iowrite32(val, ctl->base + reg);
+}
+
+static inline u32 fan_ioread(const u32 reg,
+			     const struct eswin_fan_control_data *ctl)
+{
+	return ioread32(ctl->base + reg);
+}
+
+static ssize_t eswin_fan_pwm_ctl_show(struct device *dev, struct device_attribute *da, char *buf)
+{
+	struct eswin_fan_control_data *ctl = dev_get_drvdata(dev);
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	long temp = 0;
+
+	if (FAN_PWM_DUTY == attr->index) {
+		temp = pwm_get_duty_cycle(ctl->pwm);
+	}
+	else if (FAN_PWM_PERIOD == attr->index) {
+		temp = pwm_get_period(ctl->pwm);
+	}
+	else {
+		dev_err(dev, "get error attr index 0x%x\n", attr->index);
+	}
+
+	return sprintf(buf, "%lu\n", temp);
+}
+
+static ssize_t eswin_fan_pwm_ctl_store(struct device *dev, struct device_attribute *da,
+				     const char *buf, size_t count)
+{
+	struct eswin_fan_control_data *ctl = dev_get_drvdata(dev);
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct pwm_state state;
+	int ret;
+
+	pwm_get_state(ctl->pwm, &state);
+
+	if (FAN_PWM_DUTY == attr->index) {
+		long val = 0;
+		ret = kstrtoul(buf, 10, &val);
+		if (ret)
+			return ret;
+
+		state.duty_cycle = val;
+	}
+	else if (FAN_PWM_PERIOD == attr->index) {
+		long val = 0;
+		ret = kstrtoul(buf, 10, &val);
+		if (ret)
+			return ret;
+		if (val >= ctl->min_period)
+			state.period = val;
+		else
+			dev_err(dev, "invalid pwm period!\n");
+	}
+	else {
+		dev_err(dev, "get error attr index 0x%x\n", attr->index);
+	}
+
+	pwm_apply_state(ctl->pwm, &state);
+
+	return count;
+}
+
+static ssize_t eswin_fan_pwm_free_store(struct device *dev, struct device_attribute *da,
+				     const char *buf, size_t count)
+{
+	struct eswin_fan_control_data *ctl = dev_get_drvdata(dev);
+	long val;
+	int ret;
+	ret = kstrtoul(buf, 10, &val);
+	if (ret)
+		return ret;
+
+	if (val) {
+		pwm_put(ctl->pwm);
+	}
+
+	return count;
+}
+
+static long eswin_fan_control_get_pwm_duty(const struct eswin_fan_control_data *ctl)
+{
+	struct pwm_state state;
+	int duty;
+
+	pwm_get_state(ctl->pwm, &state);
+	duty = pwm_get_relative_duty_cycle(&state, 100);
+
+	return duty;
+}
+
+static long eswin_fan_control_get_fan_rpm(struct eswin_fan_control_data *ctl)
+{
+	unsigned int val;
+	long period, timeout;
+	int ret;
+
+	ctl->wait_flag = false;
+	period = pwm_get_period(ctl->pwm);
+	timeout = TIMEOUT(period);
+	if(!timeout)
+		timeout = TIMEOUT(ctl->min_period);
+
+	val = fan_ioread(REG_FAN_INT, ctl);
+	val = val | 0x1;
+	fan_iowrite(val, REG_FAN_INT, ctl);
+
+	/* wait read interrupt */
+	ret = wait_event_interruptible_timeout(ctl->wq,
+                                        ctl->wait_flag,
+                                        timeout);
+
+	if (!ret){
+		/* timeout, set rpm to 0 */
+		ctl->rpm = 0;
+	}
+
+	if(ctl->rpm)
+		ctl->rpm = DIV_ROUND_CLOSEST(60 * ctl->clk_rate, ctl->ppr * ctl->rpm);
+
+	return ret;
+}
+
+static int eswin_fan_control_read_fan(struct device *dev, u32 attr, long *val)
+{
+	struct eswin_fan_control_data *ctl = dev_get_drvdata(dev);
+
+	switch (attr) {
+	case hwmon_fan_input:
+		if(!eswin_fan_control_get_fan_rpm(ctl)){
+			dev_err(dev, "wait read interrupt timeout!\n");
+		}
+		*val = ctl->rpm;
+		return 0;
+	default:
+		return -ENOTSUPP;
+	}
+}
+
+static int eswin_fan_control_read_pwm(struct device *dev, u32 attr, long *val)
+{
+	struct eswin_fan_control_data *ctl = dev_get_drvdata(dev);
+
+	switch (attr) {
+	case hwmon_pwm_input:
+		*val = eswin_fan_control_get_pwm_duty(ctl);
+		return 0;
+	default:
+		return -ENOTSUPP;
+	}
+}
+
+static int eswin_fan_control_set_pwm_duty(const long val, struct eswin_fan_control_data *ctl)
+{
+	struct pwm_state state;
+
+	pwm_get_state(ctl->pwm, &state);
+	pwm_set_relative_duty_cycle(&state, val, 100);
+	pwm_apply_state(ctl->pwm, &state);
+
+	return 0;
+}
+
+static int eswin_fan_control_write_pwm(struct device *dev, u32 attr, long val)
+{
+	struct eswin_fan_control_data *ctl = dev_get_drvdata(dev);
+
+	switch (attr) {
+		case hwmon_pwm_input:
+	if((val < 0)||(val > 100))
+		return -EINVAL;
+	else
+		return eswin_fan_control_set_pwm_duty(val, ctl);
+	default:
+		return -ENOTSUPP;
+	}
+
+	return 0;
+}
+
+static int eswin_fan_control_read_labels(struct device *dev,
+					enum hwmon_sensor_types type,
+					u32 attr, int channel, const char **str)
+{
+	switch (type) {
+	case hwmon_fan:
+		*str = "FAN";
+		return 0;
+	default:
+		return -ENOTSUPP;
+	}
+}
+
+static int eswin_fan_control_read(struct device *dev,
+				enum hwmon_sensor_types type,
+				u32 attr, int channel, long *val)
+{
+	switch (type) {
+	case hwmon_fan:
+		return eswin_fan_control_read_fan(dev, attr, val);
+	case hwmon_pwm:
+		return eswin_fan_control_read_pwm(dev, attr, val);
+	default:
+		return -ENOTSUPP;
+	}
+}
+
+static int eswin_fan_control_write(struct device *dev,
+				 enum hwmon_sensor_types type,
+				 u32 attr, int channel, long val)
+{
+	switch (type) {
+	case hwmon_pwm:
+		return eswin_fan_control_write_pwm(dev, attr, val);
+	default:
+		return -ENOTSUPP;
+	}
+}
+
+static umode_t eswin_fan_control_fan_is_visible(const u32 attr)
+{
+	switch (attr) {
+	case hwmon_fan_input:
+	case hwmon_fan_label:
+		return 0444;
+	default:
+		return 0;
+	}
+}
+
+static umode_t eswin_fan_control_pwm_is_visible(const u32 attr)
+{
+	switch (attr) {
+	case hwmon_pwm_input:
+		return 0644;
+	default:
+		return 0;
+	}
+}
+
+static umode_t eswin_fan_control_is_visible(const void *data,
+					enum hwmon_sensor_types type,
+					u32 attr, int channel)
+{
+	switch (type) {
+	case hwmon_fan:
+		return eswin_fan_control_fan_is_visible(attr);
+	case hwmon_pwm:
+		return eswin_fan_control_pwm_is_visible(attr);
+	default:
+		return 0;
+	}
+}
+
+static irqreturn_t eswin_fan_control_irq_handler(int irq, void *data)
+{
+	struct eswin_fan_control_data *ctl = (struct eswin_fan_control_data *)data;
+	u32 status = 0;
+
+	status = fan_ioread(REG_FAN_INT, ctl);
+	if (0x3 == (status & 0x3)){
+		ctl->rpm = fan_ioread(REG_FAN_RPM, ctl);
+
+		/* clear interrupt */
+		fan_iowrite(0x5, REG_FAN_INT, ctl);
+
+		/* wake up fan_rpm read */
+		ctl->wait_flag = true;
+		wake_up_interruptible(&ctl->wq);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int eswin_fan_control_init(struct eswin_fan_control_data *ctl,
+				const struct device_node *np)
+{
+	int ret;
+	/* get fan pulses per revolution */
+	ret = of_property_read_u32(np, "pulses-per-revolution", &ctl->ppr);
+	if (ret)
+		return ret;
+
+	/* 1, 2 and 4 are the typical and accepted values */
+	if (ctl->ppr != 1 && ctl->ppr != 2 && ctl->ppr != 4)
+		return -EINVAL;
+
+	/* get pwm minimum period */
+	ret = of_property_read_u32(np, "pwm-minimum-period", &ctl->min_period);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
+static void eswin_fan_control_remove(void *data)
+{
+	int ret;
+	struct eswin_fan_control_data *ctl = data;
+	pwm_put(ctl->pwm);
+	ret = reset_control_assert(ctl->fan_rst);
+	WARN_ON(0 != ret);
+	clk_disable_unprepare(ctl->clk);
+}
+
+static const struct hwmon_channel_info *eswin_fan_control_info[] = {
+	HWMON_CHANNEL_INFO(pwm, HWMON_PWM_INPUT),
+	HWMON_CHANNEL_INFO(fan, HWMON_F_INPUT | HWMON_F_LABEL),
+	NULL
+};
+
+static const struct hwmon_ops eswin_fan_control_hwmon_ops = {
+	.is_visible = eswin_fan_control_is_visible,
+	.read = eswin_fan_control_read,
+	.write = eswin_fan_control_write,
+	.read_string = eswin_fan_control_read_labels,
+};
+
+static const struct hwmon_chip_info eswin_chip_info = {
+	.ops = &eswin_fan_control_hwmon_ops,
+	.info = eswin_fan_control_info,
+};
+
+static SENSOR_DEVICE_ATTR_RW(fan_pwm_duty,   eswin_fan_pwm_ctl,    FAN_PWM_DUTY);
+static SENSOR_DEVICE_ATTR_RW(fan_pwm_period, eswin_fan_pwm_ctl,    FAN_PWM_PERIOD);
+static SENSOR_DEVICE_ATTR_WO(fan_pwm_free,   eswin_fan_pwm_free,   FAN_PWM_FREE);
+
+static struct attribute *eswin_fan_control_attrs[] = {
+	&sensor_dev_attr_fan_pwm_duty.dev_attr.attr,
+	&sensor_dev_attr_fan_pwm_period.dev_attr.attr,
+	&sensor_dev_attr_fan_pwm_free.dev_attr.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(eswin_fan_control);
+
+static const struct of_device_id eswin_fan_control_of_match[] = {
+	{ .compatible = "eswin-fan-control"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, eswin_fan_control_of_match);
+
+static int eswin_fan_control_probe(struct platform_device *pdev)
+{
+	struct eswin_fan_control_data *ctl;
+	const struct of_device_id *id;
+	const char *name = "eswin_fan_control";
+	int ret;
+
+	id = of_match_node(eswin_fan_control_of_match, pdev->dev.of_node);
+	if (!id)
+		return -EINVAL;
+
+	ctl = devm_kzalloc(&pdev->dev, sizeof(*ctl), GFP_KERNEL);
+	if (!ctl)
+		return -ENOMEM;
+
+	ctl->base = devm_platform_ioremap_resource(pdev, 0);
+
+	if (IS_ERR(ctl->base))
+		return PTR_ERR(ctl->base);
+
+	ctl->clk = devm_clk_get(&pdev->dev, "pclk");
+	if (IS_ERR(ctl->clk)) {
+		dev_err(&pdev->dev, "Couldn't get the clock for fan-controller\n");
+		return -ENODEV;
+	}
+
+	ret = clk_prepare_enable(ctl->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to enable clock for fan-controller\n");
+		return ret;
+	}
+
+	ctl->clk_rate = clk_get_rate(ctl->clk);
+	if (!ctl->clk_rate)
+		return -EINVAL;
+
+	ctl->fan_rst = devm_reset_control_get_optional(&pdev->dev, "fan_rst");
+	if (IS_ERR_OR_NULL(ctl->fan_rst)) {
+		dev_err(&pdev->dev, "Failed to get fan_rst reset handle\n");
+		return -EFAULT;
+	}
+	ret = reset_control_reset(ctl->fan_rst);
+	WARN_ON(0 != ret);
+
+	init_waitqueue_head(&ctl->wq);
+
+	ctl->irq = platform_get_irq(pdev, 0);
+	if (ctl->irq < 0)
+		return ctl->irq;
+
+	ret = devm_request_threaded_irq(&pdev->dev, ctl->irq,
+					eswin_fan_control_irq_handler, NULL,
+					IRQF_ONESHOT | IRQF_TRIGGER_HIGH,
+					pdev->driver_override, ctl);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to request an irq, %d", ret);
+		return ret;
+	}
+
+	ret = eswin_fan_control_init(ctl, pdev->dev.of_node);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to initialize device\n");
+		return ret;
+	}
+
+	ctl->pwm = pwm_get(&pdev->dev, NULL);
+	if (IS_ERR(ctl->pwm)) {
+		ret = PTR_ERR(ctl->pwm);
+		dev_err(&pdev->dev, "Failed to request pwm device: %d\n", ret);
+		return ret;
+	}
+	pwm_enable(ctl->pwm);
+
+	ret = devm_add_action_or_reset(&pdev->dev, eswin_fan_control_remove, ctl);
+	if (ret)
+		return ret;
+
+	ctl->hdev = devm_hwmon_device_register_with_info(&pdev->dev,
+							 name,
+							 ctl,
+							 &eswin_chip_info,
+							 eswin_fan_control_groups);
+	return PTR_ERR_OR_ZERO(ctl->hdev);
+}
+
+static struct platform_driver eswin_fan_control_driver = {
+	.driver = {
+		.name = "eswin_fan_control_driver",
+		.of_match_table = eswin_fan_control_of_match,
+	},
+	.probe = eswin_fan_control_probe,
+};
+module_platform_driver(eswin_fan_control_driver);
+
+MODULE_AUTHOR("Han Min <hanmin@eswincomputing.com>");
+MODULE_DESCRIPTION("ESWIN Fan Control CORE driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hwmon/eswin_pvt.c b/drivers/hwmon/eswin_pvt.c
new file mode 100644
index 000000000000..6436330fde1c
--- /dev/null
+++ b/drivers/hwmon/eswin_pvt.c
@@ -0,0 +1,874 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN PVT Device Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: Bingzheng Yu <yubingzheng@eswincomputing.com>
+ */
+
+#include <linux/bitfield.h>
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/hwmon.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/ktime.h>
+#include <linux/limits.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/seqlock.h>
+#include <linux/sysfs.h>
+#include <linux/types.h>
+#include "eswin_pvt.h"
+
+/*
+ * For the sake of the code simplification we created the sensors info table
+ * with the sensor names, activation modes, threshold registers base address
+ * and the thresholds bit fields.
+ */
+static const struct pvt_sensor_info pvt_info[] = {
+	PVT_SENSOR_INFO(0, "CPU Core Temperature", hwmon_temp, TEMP, TTHRES),
+	PVT_SENSOR_INFO(0, "CPU Core Voltage", hwmon_in, VOLT, VTHRES),
+	PVT_SENSOR_INFO(1, "CPU Core Low-Vt", hwmon_in, LVT, LTHRES),
+	PVT_SENSOR_INFO(2, "CPU Core UltraLow-Vt", hwmon_in, ULVT, ULTHRES),
+	PVT_SENSOR_INFO(3, "CPU Core Standard-Vt", hwmon_in, SVT, STHRES),
+};
+
+/*
+ * The original translation formulae of the temperature (in degrees of Celsius)
+ * to PVT data and vice-versa are following:
+ * N = 6.0818e-8*(T^4) +1.2873e-5*(T^3) + 7.2244e-3*(T^2) + 3.6484*(T^1) +
+ *     1.6198e2,
+ * T = -1.8439e-11*(N^4) + 8.0705e-8*(N^3) + -1.8501e-4*(N^2) +
+ *     3.2843e-1*(N^1) - 4.8690e1,
+ * where T = [-40, 125]C and N = [27, 771].
+ * They must be accordingly altered to be suitable for the integer arithmetics.
+ * The technique is called 'factor redistribution', which just makes sure the
+ * multiplications and divisions are made so to have a result of the operations
+ * within the integer numbers limit. In addition we need to translate the
+ * formulae to accept millidegrees of Celsius. Here what they look like after
+ * the alterations:
+ * N = (60818e-20*(T^4) + 12873e-14*(T^3) + 72244e-9*(T^2) + 36484e-3*T +
+ *     16198e2) / 1e4,
+ * T = -18439e-12*(N^4) + 80705e-9*(N^3) - 185010e-6*(N^2) + 328430e-3*N -
+ *     48690,
+ * where T = [-40000, 125000] mC and N = [27, 771].
+ */
+static const struct pvt_poly __maybe_unused poly_temp_to_N = {
+	.total_divider = 10000,
+	.terms = {
+		{4, 60818, 10000, 10000},
+		{3, 12873, 10000, 100},
+		{2, 72244, 10000, 10},
+		{1, 36484, 1000, 1},
+		{0, 1619800, 1, 1}
+	}
+};
+
+static const struct pvt_poly poly_N_to_temp = {
+	.total_divider = 1,
+	.terms = {
+		{4, -18439, 1000, 1},
+		{3, 80705, 1000, 1},
+		{2, -185010, 1000, 1},
+		{1, 328430, 1000, 1},
+		{0, -48690, 1, 1}
+	}
+};
+
+/*
+ * Similar alterations are performed for the voltage conversion equations.
+ * The original formulae are:
+ * N = 1.3905e3*V - 5.7685e2,
+ * V = (N + 5.7685e2) / 1.3905e3,
+ * where V = [0.72, 0.88] V and N = [424, 646].
+ * After the optimization they looks as follows:
+ * N = (13905e-3*V - 5768.5) / 10,
+ * V = (N * 10^5 / 13905 + 57685 * 10^3 / 13905) / 10.
+ * where V = [720, 880] mV and N = [424, 646].
+ */
+static const struct pvt_poly __maybe_unused poly_volt_to_N = {
+	.total_divider = 10,
+	.terms = {
+		{1, 13905, 1000, 1},
+		{0, -57685, 1, 10}
+	}
+};
+
+static const struct pvt_poly poly_N_to_volt = {
+	.total_divider = 10,
+	.terms = {
+		{1, 100000, 13905, 1},
+		{0, 57685000, 1, 13905}
+	}
+};
+
+/*
+ * Here is the polynomial calculation function, which performs the
+ * redistributed terms calculations. It's pretty straightforward. We walk
+ * over each degree term up to the free one, and perform the redistributed
+ * multiplication of the term coefficient, its divider (as for the rationale
+ * fraction representation), data power and the rational fraction divider
+ * leftover. Then all of this is collected in a total sum variable, which
+ * value is normalized by the total divider before being returned.
+ */
+static long eswin_pvt_calc_poly(const struct pvt_poly *poly, long data)
+{
+	const struct pvt_poly_term *term = poly->terms;
+	long tmp, ret = 0;
+	int deg;
+	do {
+		tmp = term->coef;
+		for (deg = 0; deg < term->deg; ++deg)
+			tmp = mult_frac(tmp, data, term->divider);
+		ret += tmp / term->divider_leftover;
+	} while ((term++)->deg);
+
+	return ret / poly->total_divider;
+}
+
+static inline u32 eswin_pvt_update(void __iomem *reg, u32 mask, u32 data)
+{
+	u32 old;
+
+	old = readl_relaxed(reg);
+	writel((old & ~mask) | (data & mask), reg);
+
+	return old & mask;
+}
+
+static inline void eswin_pvt_set_mode(struct pvt_hwmon *pvt, u32 mode)
+{
+	u32 old;
+
+	mode = FIELD_PREP(PVT_MODE_MASK, mode);
+
+	old = eswin_pvt_update(pvt->regs + PVT_ENA, PVT_ENA_EN, 0);
+	eswin_pvt_update(pvt->regs + PVT_MODE, PVT_MODE_MASK, mode);
+	eswin_pvt_update(pvt->regs + PVT_ENA, PVT_ENA_EN, old);
+}
+
+static inline u32 eswin_pvt_calc_trim(long temp)
+{
+	temp = clamp_val(temp, 0, PVT_TRIM_TEMP);
+
+	return DIV_ROUND_UP(temp, PVT_TRIM_STEP);
+}
+
+static inline void eswin_pvt_set_trim(struct pvt_hwmon *pvt, u32 val)
+{
+	u32 old;
+
+	old = eswin_pvt_update(pvt->regs + PVT_ENA, PVT_ENA_EN, 0);
+	writel(val, pvt->regs + PVT_TRIM);
+	eswin_pvt_update(pvt->regs + PVT_ENA, PVT_ENA_EN, old);
+}
+
+static irqreturn_t eswin_pvt_hard_isr(int irq, void *data)
+{
+	struct pvt_hwmon *pvt = data;
+	struct pvt_cache *cache;
+	u32 val;
+
+	eswin_pvt_update(pvt->regs + PVT_INT, PVT_INT_CLR, PVT_INT_CLR);
+
+	/*
+	 * Nothing special for alarm-less driver. Just read the data, update
+	 * the cache and notify a waiter of this event.
+	 */
+
+	val = readl(pvt->regs + PVT_DATA);
+
+	cache = &pvt->cache[pvt->sensor];
+
+	WRITE_ONCE(cache->data, FIELD_GET(PVT_DATA_OUT, val));
+
+	complete(&cache->conversion);
+
+	return IRQ_HANDLED;
+}
+
+static inline umode_t eswin_pvt_limit_is_visible(enum pvt_sensor_type type)
+{
+	return 0;
+}
+
+static inline umode_t eswin_pvt_pvt_alarm_is_visible(enum pvt_sensor_type type)
+{
+	return 0;
+}
+
+static int eswin_pvt_read_data(struct pvt_hwmon *pvt, enum pvt_sensor_type type,
+			 long *val)
+{
+	struct pvt_cache *cache = &pvt->cache[type];
+	unsigned long timeout;
+	u32 data;
+	int ret;
+
+	/*
+	 * Lock PVT conversion interface until data cache is updated. The
+	 * data read procedure is following: set the requested PVT sensor
+	 * mode, enable IRQ and conversion, wait until conversion is finished,
+	 * then disable conversion and IRQ, and read the cached data.
+	 */
+	ret = mutex_lock_interruptible(&pvt->iface_mtx);
+	if (ret)
+		return ret;
+
+	pvt->sensor = type;
+	eswin_pvt_set_mode(pvt, pvt_info[type].mode);
+
+	eswin_pvt_update(pvt->regs + PVT_ENA, PVT_ENA_EN, PVT_ENA_EN);
+
+	/*
+	 * Wait with timeout since in case if the sensor is suddenly powered
+	 * down the request won't be completed and the caller will hang up on
+	 * this procedure until the power is back up again. Multiply the
+	 * timeout by the factor of two to prevent a false timeout.
+	 */
+	timeout = 2 * usecs_to_jiffies(ktime_to_us(pvt->timeout));
+	if(type==PVT_TEMP){
+		timeout = 20 * usecs_to_jiffies(ktime_to_us(pvt->timeout));
+	}
+	ret = wait_for_completion_timeout(&cache->conversion, timeout);
+
+	eswin_pvt_update(pvt->regs + PVT_ENA, PVT_ENA_EN, 0);
+	eswin_pvt_update(pvt->regs + PVT_INT, PVT_INT_CLR, PVT_INT_CLR);
+
+	data = READ_ONCE(cache->data);
+
+	mutex_unlock(&pvt->iface_mtx);
+
+	if (!ret)
+		return -ETIMEDOUT;
+
+	if (type == PVT_TEMP)
+		*val = eswin_pvt_calc_poly(&poly_N_to_temp, data);
+	else if (type == PVT_VOLT)
+		*val = eswin_pvt_calc_poly(&poly_N_to_volt, data);
+	else
+		*val = data;
+
+	return 0;
+}
+
+static int eswin_pvt_read_limit(struct pvt_hwmon *pvt, enum pvt_sensor_type type,
+			  bool is_low, long *val)
+{
+	return -EOPNOTSUPP;
+}
+
+static int eswin_pvt_write_limit(struct pvt_hwmon *pvt, enum pvt_sensor_type type,
+			   bool is_low, long val)
+{
+	return -EOPNOTSUPP;
+}
+
+static int eswin_pvt_read_alarm(struct pvt_hwmon *pvt, enum pvt_sensor_type type,
+			  bool is_low, long *val)
+{
+	return -EOPNOTSUPP;
+}
+
+static const struct hwmon_channel_info *pvt_channel_info[] = {
+	HWMON_CHANNEL_INFO(chip,
+			   HWMON_C_REGISTER_TZ | HWMON_C_UPDATE_INTERVAL),
+	HWMON_CHANNEL_INFO(temp,
+			   HWMON_T_INPUT | HWMON_T_TYPE | HWMON_T_LABEL |
+			   HWMON_T_OFFSET),
+	HWMON_CHANNEL_INFO(in,
+			   HWMON_I_INPUT | HWMON_I_LABEL,
+			   HWMON_I_INPUT | HWMON_I_LABEL,
+			   HWMON_I_INPUT | HWMON_I_LABEL,
+			   HWMON_I_INPUT | HWMON_I_LABEL),
+	NULL
+};
+
+static inline bool eswin_pvt_hwmon_channel_is_valid(enum hwmon_sensor_types type,
+					      int ch)
+{
+	switch (type) {
+	case hwmon_temp:
+		if (ch < 0 || ch >= PVT_TEMP_CHS)
+			return false;
+		break;
+	case hwmon_in:
+		if (ch < 0 || ch >= PVT_VOLT_CHS)
+			return false;
+		break;
+	default:
+		break;
+	}
+
+	/* The rest of the types are independent from the channel number. */
+	return true;
+}
+
+static umode_t eswin_pvt_hwmon_is_visible(const void *data,
+				    enum hwmon_sensor_types type,
+				    u32 attr, int ch)
+{
+	if (!eswin_pvt_hwmon_channel_is_valid(type, ch))
+		return 0;
+
+	switch (type) {
+	case hwmon_chip:
+		switch (attr) {
+		case hwmon_chip_update_interval:
+			return 0644;
+		}
+		break;
+	case hwmon_temp:
+		switch (attr) {
+		case hwmon_temp_input:
+		case hwmon_temp_type:
+		case hwmon_temp_label:
+			return 0444;
+		case hwmon_temp_min:
+		case hwmon_temp_max:
+			return eswin_pvt_limit_is_visible(ch);
+		case hwmon_temp_min_alarm:
+		case hwmon_temp_max_alarm:
+			return eswin_pvt_pvt_alarm_is_visible(ch);
+		case hwmon_temp_offset:
+			return 0644;
+		}
+		break;
+	case hwmon_in:
+		switch (attr) {
+		case hwmon_in_input:
+		case hwmon_in_label:
+			return 0444;
+		case hwmon_in_min:
+		case hwmon_in_max:
+			return eswin_pvt_limit_is_visible(PVT_VOLT + ch);
+		case hwmon_in_min_alarm:
+		case hwmon_in_max_alarm:
+			return eswin_pvt_pvt_alarm_is_visible(PVT_VOLT + ch);
+		}
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int eswin_pvt_read_trim(struct pvt_hwmon *pvt, long *val)
+{
+	u32 data;
+
+	data = readl(pvt->regs + PVT_TRIM);
+	*val = data;
+
+	return 0;
+}
+
+static int eswin_pvt_write_trim(struct pvt_hwmon *pvt, long val)
+{
+	int ret;
+	/*
+	 * Serialize trim update, since a part of the register is changed and
+	 * the controller is supposed to be disabled during this operation.
+	 */
+	ret = mutex_lock_interruptible(&pvt->iface_mtx);
+	if (ret)
+		return ret;
+
+	eswin_pvt_set_trim(pvt, val);
+
+	mutex_unlock(&pvt->iface_mtx);
+
+	return 0;
+}
+
+static int eswin_pvt_read_timeout(struct pvt_hwmon *pvt, long *val)
+{
+	int ret;
+
+	ret = mutex_lock_interruptible(&pvt->iface_mtx);
+	if (ret)
+		return ret;
+
+	/* Return the result in msec as hwmon sysfs interface requires. */
+	*val = ktime_to_ms(pvt->timeout);
+
+	mutex_unlock(&pvt->iface_mtx);
+
+	return 0;
+}
+
+static int eswin_pvt_write_timeout(struct pvt_hwmon *pvt, long val)
+{
+	unsigned long rate;
+	ktime_t kt, cache;
+	u32 data;
+	int ret;
+
+	rate = clk_get_rate(pvt->clk);
+	if (!rate)
+		return -ENODEV;
+
+	/*
+	 * If alarms are enabled, the requested timeout must be divided
+	 * between all available sensors to have the requested delay
+	 * applicable to each individual sensor.
+	 */
+	cache = kt = ms_to_ktime(val);
+
+	/*
+	 * Subtract a constant lag, which always persists due to the limited
+	 * PVT sampling rate. Make sure the timeout is not negative.
+	 */
+	kt = ktime_sub_ns(kt, PVT_TOUT_MIN);
+	if (ktime_to_ns(kt) < 0)
+		kt = ktime_set(0, 0);
+
+	/*
+	 * Finally recalculate the timeout in terms of the reference clock
+	 * period.
+	 */
+	data = ktime_divns(kt * rate, NSEC_PER_SEC);
+
+	/*
+	 * Update the measurements delay, but lock the interface first, since
+	 * we have to disable PVT in order to have the new delay actually
+	 * updated.
+	 */
+	ret = mutex_lock_interruptible(&pvt->iface_mtx);
+	if (ret)
+		return ret;
+
+	pvt->timeout = cache;
+
+	mutex_unlock(&pvt->iface_mtx);
+
+	return 0;
+}
+
+static int eswin_pvt_hwmon_read(struct device *dev, enum hwmon_sensor_types type,
+			  u32 attr, int ch, long *val)
+{
+	struct pvt_hwmon *pvt = dev_get_drvdata(dev);
+
+	if (!eswin_pvt_hwmon_channel_is_valid(type, ch))
+		return -EINVAL;
+
+	switch (type) {
+	case hwmon_chip:
+		switch (attr) {
+		case hwmon_chip_update_interval:
+			return eswin_pvt_read_timeout(pvt, val);
+		}
+		break;
+	case hwmon_temp:
+		switch (attr) {
+		case hwmon_temp_input:
+			return eswin_pvt_read_data(pvt, ch, val);
+		case hwmon_temp_type:
+			*val = 1;
+			return 0;
+		case hwmon_temp_min:
+			return eswin_pvt_read_limit(pvt, ch, true, val);
+		case hwmon_temp_max:
+			return eswin_pvt_read_limit(pvt, ch, false, val);
+		case hwmon_temp_min_alarm:
+			return eswin_pvt_read_alarm(pvt, ch, true, val);
+		case hwmon_temp_max_alarm:
+			return eswin_pvt_read_alarm(pvt, ch, false, val);
+		case hwmon_temp_offset:
+			return eswin_pvt_read_trim(pvt, val);
+		}
+		break;
+	case hwmon_in:
+		switch (attr) {
+		case hwmon_in_input:
+			return eswin_pvt_read_data(pvt, PVT_VOLT + ch, val);
+		case hwmon_in_min:
+			return eswin_pvt_read_limit(pvt, PVT_VOLT + ch, true, val);
+		case hwmon_in_max:
+			return eswin_pvt_read_limit(pvt, PVT_VOLT + ch, false, val);
+		case hwmon_in_min_alarm:
+			return eswin_pvt_read_alarm(pvt, PVT_VOLT + ch, true, val);
+		case hwmon_in_max_alarm:
+			return eswin_pvt_read_alarm(pvt, PVT_VOLT + ch, false, val);
+		}
+		break;
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static int eswin_pvt_hwmon_read_string(struct device *dev,
+				 enum hwmon_sensor_types type,
+				 u32 attr, int ch, const char **str)
+{
+	if (!eswin_pvt_hwmon_channel_is_valid(type, ch))
+		return -EINVAL;
+
+	switch (type) {
+	case hwmon_temp:
+		switch (attr) {
+		case hwmon_temp_label:
+			*str = pvt_info[ch].label;
+			return 0;
+		}
+		break;
+	case hwmon_in:
+		switch (attr) {
+		case hwmon_in_label:
+			*str = pvt_info[PVT_VOLT + ch].label;
+			return 0;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static int eswin_pvt_hwmon_write(struct device *dev, enum hwmon_sensor_types type,
+			   u32 attr, int ch, long val)
+{
+	struct pvt_hwmon *pvt = dev_get_drvdata(dev);
+
+	if (!eswin_pvt_hwmon_channel_is_valid(type, ch))
+		return -EINVAL;
+
+	switch (type) {
+	case hwmon_chip:
+		switch (attr) {
+		case hwmon_chip_update_interval:
+			return eswin_pvt_write_timeout(pvt, val);
+		}
+		break;
+	case hwmon_temp:
+		switch (attr) {
+		case hwmon_temp_min:
+			return eswin_pvt_write_limit(pvt, ch, true, val);
+		case hwmon_temp_max:
+			return eswin_pvt_write_limit(pvt, ch, false, val);
+		case hwmon_temp_offset:
+			return eswin_pvt_write_trim(pvt, val);
+		}
+		break;
+	case hwmon_in:
+		switch (attr) {
+		case hwmon_in_min:
+			return eswin_pvt_write_limit(pvt, PVT_VOLT + ch, true, val);
+		case hwmon_in_max:
+			return eswin_pvt_write_limit(pvt, PVT_VOLT + ch, false, val);
+		}
+		break;
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static const struct hwmon_ops pvt_hwmon_ops = {
+	.is_visible = eswin_pvt_hwmon_is_visible,
+	.read = eswin_pvt_hwmon_read,
+	.read_string = eswin_pvt_hwmon_read_string,
+	.write = eswin_pvt_hwmon_write
+};
+
+static const struct hwmon_chip_info pvt_hwmon_info = {
+	.ops = &pvt_hwmon_ops,
+	.info = pvt_channel_info
+};
+
+static void pvt_clear_data(void *data)
+{
+	struct pvt_hwmon *pvt = data;
+	int idx;
+
+	for (idx = 0; idx < PVT_SENSORS_NUM; ++idx)
+		complete_all(&pvt->cache[idx].conversion);
+
+	mutex_destroy(&pvt->iface_mtx);
+}
+
+static struct pvt_hwmon *eswin_pvt_create_data(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct pvt_hwmon *pvt;
+	int ret, idx;
+
+	pvt = devm_kzalloc(dev, sizeof(*pvt), GFP_KERNEL);
+	if (!pvt)
+		return ERR_PTR(-ENOMEM);
+
+	ret = devm_add_action(dev, pvt_clear_data, pvt);
+	if (ret) {
+		dev_err(dev, "Can't add PVT data clear action\n");
+		return ERR_PTR(ret);
+	}
+
+	pvt->dev = dev;
+	pvt->sensor = PVT_SENSOR_FIRST;
+	mutex_init(&pvt->iface_mtx);
+
+	for (idx = 0; idx < PVT_SENSORS_NUM; ++idx)
+		init_completion(&pvt->cache[idx].conversion);
+
+	return pvt;
+}
+
+static int eswin_pvt_request_regs(struct pvt_hwmon *pvt)
+{
+	struct platform_device *pdev = to_platform_device(pvt->dev);
+	struct resource *res;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(pvt->dev, "Couldn't find PVT memresource\n");
+		return -EINVAL;
+	}
+
+	pvt->regs = devm_ioremap_resource(pvt->dev, res);
+	if (IS_ERR(pvt->regs))
+		return PTR_ERR(pvt->regs);
+
+	return 0;
+}
+
+static void eswin_pvt_remove(void *data)
+{
+	int ret;
+	struct pvt_hwmon *pvt = data;
+	ret = reset_control_assert(pvt->pvt_rst);
+	WARN_ON(0 != ret);
+	clk_disable_unprepare(pvt->clk);
+}
+
+static int eswin_pvt_request_clks(struct pvt_hwmon *pvt)
+{
+	int ret;
+
+	pvt->clk = devm_clk_get(pvt->dev, "pvt_clk");
+	if (IS_ERR(pvt->clk)) {
+		dev_err(pvt->dev, "Couldn't get PVT clock\n");
+		return -ENODEV;
+	}
+
+	ret = clk_prepare_enable(pvt->clk);
+	if (ret) {
+		dev_err(pvt->dev, "Couldn't enable the PVT clocks\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int eswin_pvt_request_rst(struct pvt_hwmon *pvt)
+{
+	int ret;
+	pvt->pvt_rst = devm_reset_control_get_optional(pvt->dev, "pvt_rst");
+	if(IS_ERR_OR_NULL(pvt->pvt_rst)){
+		dev_err(pvt->dev, "Couldn't get PVT reset\n");
+	}
+	ret = reset_control_reset(pvt->pvt_rst);
+	WARN_ON(0 != ret);
+	return 0;
+}
+
+static int eswin_pvt_check_pwr(struct pvt_hwmon *pvt)
+{
+	unsigned long tout;
+	int ret = 0;
+	u32 data;
+
+	/*
+	 * Test out the sensor conversion functionality. If it is not done on
+	 * time then the domain must have been unpowered and we won't be able
+	 * to use the device later in this driver.
+	 * Note If the power source is lost during the normal driver work the
+	 * data read procedure will either return -ETIMEDOUT (for the
+	 * alarm-less driver configuration) or just stop the repeated
+	 * conversion. In the later case alas we won't be able to detect the
+	 * problem.
+	 */
+
+	eswin_pvt_update(pvt->regs + PVT_ENA, PVT_ENA_EN, PVT_ENA_EN);
+	readl(pvt->regs + PVT_DATA);
+
+	tout = PVT_TOUT_MIN / NSEC_PER_USEC;
+	usleep_range(tout, 2 * tout);
+
+	data = readl(pvt->regs + PVT_DATA);
+
+	eswin_pvt_update(pvt->regs + PVT_ENA, PVT_ENA_EN, 0);
+	eswin_pvt_update(pvt->regs + PVT_INT, PVT_INT_CLR, PVT_INT_CLR);
+
+	return ret;
+}
+
+static int eswin_pvt_init_iface(struct pvt_hwmon *pvt)
+{
+	unsigned long rate;
+
+	rate = clk_get_rate(pvt->clk);
+	if (!rate) {
+		dev_err(pvt->dev, "Invalid reference clock rate\n");
+		return -ENODEV;
+	}
+
+	/*
+	 * Make sure all interrupts and controller are disabled so not to
+	 * accidentally have ISR executed before the driver data is fully
+	 * initialized. Clear the IRQ status as well.
+	 */
+	eswin_pvt_update(pvt->regs + PVT_ENA, PVT_ENA_EN, 0);
+	eswin_pvt_update(pvt->regs + PVT_INT, PVT_INT_CLR, PVT_INT_CLR);
+
+	readl(pvt->regs + PVT_DATA);
+
+	/* Setup default sensor mode, timeout and temperature trim. */
+	eswin_pvt_set_mode(pvt, pvt_info[pvt->sensor].mode);
+
+	/*
+	 * Preserve the current ref-clock based delay (Ttotal) between the
+	 * sensors data samples in the driver data so not to recalculate it
+	 * each time on the data requests and timeout reads. It consists of the
+	 * delay introduced by the internal ref-clock timer (N / Fclk) and the
+	 * constant timeout caused by each conversion latency (Tmin):
+	 *   Ttotal = N / Fclk + Tmin
+	 * If alarms are enabled the sensors are polled one after another and
+	 * in order to get the next measurement of a particular sensor the
+	 * caller will have to wait for at most until all the others are
+	 * polled. In that case the formulae will look a bit different:
+	 *   Ttotal = 5 * (N / Fclk + Tmin)
+	 */
+
+	pvt->timeout = ktime_set(PVT_TOUT_DEF, 0);
+	pvt->timeout = ktime_divns(pvt->timeout, rate);
+	pvt->timeout = ktime_add_ns(pvt->timeout, PVT_TOUT_MIN);
+
+	return 0;
+}
+
+static int eswin_pvt_request_irq(struct pvt_hwmon *pvt)
+{
+	struct platform_device *pdev = to_platform_device(pvt->dev);
+	int ret;
+
+	pvt->irq = platform_get_irq(pdev, 0);
+	if (pvt->irq < 0)
+		return pvt->irq;
+
+	ret = devm_request_threaded_irq(pvt->dev, pvt->irq,
+					eswin_pvt_hard_isr, NULL,
+					IRQF_SHARED | IRQF_TRIGGER_HIGH,
+					"pvt", pvt);
+	if (ret) {
+		dev_err(pvt->dev, "Couldn't request PVT IRQ\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int eswin_pvt_create_hwmon(struct pvt_hwmon *pvt)
+{
+	pvt->hwmon = devm_hwmon_device_register_with_info(pvt->dev, "pvt", pvt,
+		&pvt_hwmon_info, NULL);
+	if (IS_ERR(pvt->hwmon)) {
+		dev_err(pvt->dev, "Couldn't create hwmon device\n");
+		return PTR_ERR(pvt->hwmon);
+	}
+
+	return 0;
+}
+
+static int eswin_pvt_probe(struct platform_device *pdev)
+{
+	struct pvt_hwmon *pvt;
+	int ret;
+
+	pvt = eswin_pvt_create_data(pdev);
+	if (IS_ERR(pvt))
+		return PTR_ERR(pvt);
+
+	ret = eswin_pvt_request_regs(pvt);
+	if (ret)
+		return ret;
+
+	ret = eswin_pvt_request_clks(pvt);
+	if (ret)
+		return ret;
+
+	ret = eswin_pvt_request_rst(pvt);
+	if (ret)
+		return ret;
+
+	ret = eswin_pvt_check_pwr(pvt);
+	if (ret)
+		return ret;
+
+	ret = eswin_pvt_init_iface(pvt);
+	if (ret)
+		return ret;
+
+	ret = eswin_pvt_request_irq(pvt);
+	if (ret)
+		return ret;
+
+	ret = eswin_pvt_create_hwmon(pvt);
+	if (ret)
+		return ret;
+
+	ret = devm_add_action_or_reset(pvt->dev, eswin_pvt_remove, pvt);
+	if (ret) {
+		dev_err(pvt->dev, "Can't add PVT clocks disable action\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct of_device_id pvt_of_match[] = {
+	{ .compatible = "eswin,eswin-pvt" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pvt_of_match);
+
+static struct platform_driver pvt_driver = {
+	.probe = eswin_pvt_probe,
+	.driver = {
+		.name = "eswin-pvt",
+		.of_match_table = pvt_of_match
+	},
+};
+module_platform_driver(pvt_driver);
+
+MODULE_DESCRIPTION("Eswin PVT driver");
+MODULE_AUTHOR("Yu Bingzheng <yubingzheng@eswincomputing.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/hwmon/eswin_pvt.h b/drivers/hwmon/eswin_pvt.h
new file mode 100644
index 000000000000..1c0c9252317c
--- /dev/null
+++ b/drivers/hwmon/eswin_pvt.h
@@ -0,0 +1,227 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) ESWIN Electronics Co.Ltd
+ *
+ * Eswin Process, Voltage, Temperature sensor driver
+ */
+#ifndef __HWMON_ESWIN_PVT_H__
+#define __HWMON_ESWIN_PVT_H__
+
+#include <linux/completion.h>
+#include <linux/hwmon.h>
+#include <linux/kernel.h>
+#include <linux/ktime.h>
+#include <linux/mutex.h>
+#include <linux/seqlock.h>
+
+/* Eswin PVT registers and their bitfields */
+#define PVT_DIV               0x00
+#define PVT_TRIM              0x04
+#define PVT_TRIM_G            GENMASK(4,0)
+#define PVT_TRIM_O            GENMASK(13,8)
+#define PVT_MODE              0x08
+#define PVT_MODE_MASK         GENMASK(2, 0)
+#define PVT_CTRL_MODE_TEMP    0x0
+#define PVT_CTRL_MODE_VOLT    0x4
+#define PVT_CTRL_MODE_LVT     0x1
+#define PVT_CTRL_MODE_ULVT    0x2
+#define PVT_CTRL_MODE_SVT     0x3
+#define PVT_MODE_PSAMPLE_0    BIT(0)
+#define PVT_MODE_PSAMPLE_1    BIT(1)
+#define PVT_MODE_VSAMPLE      BIT(2)
+#define PVT_ENA               0x0c
+#define PVT_ENA_EN            BIT(0)
+#define PVT_INT               0x10
+#define PVT_INT_CLR           BIT(1)
+#define PVT_DATA              0x14
+#define PVT_DATA_OUT          GENMASK(9,0)
+
+/* alarm related */
+#define PVT_TTHRES			0x08
+#define PVT_VTHRES			0x0C
+#define PVT_LTHRES			0x10
+#define PVT_ULTHRES			0x14
+#define PVT_STHRES			0x18
+#define PVT_INTR_DVALID			BIT(0)
+#define PVT_INTR_TTHRES_LO		BIT(1)
+#define PVT_INTR_TTHRES_HI		BIT(2)
+#define PVT_INTR_VTHRES_LO		BIT(3)
+#define PVT_INTR_VTHRES_HI		BIT(4)
+#define PVT_INTR_LTHRES_LO		BIT(5)
+#define PVT_INTR_LTHRES_HI		BIT(6)
+#define PVT_INTR_ULTHRES_LO		BIT(7)
+#define PVT_INTR_ULTHRES_HI		BIT(8)
+#define PVT_INTR_STHRES_LO		BIT(9)
+#define PVT_INTR_STHRES_HI		BIT(10)
+
+/*
+ * PVT sensors-related limits and default values
+ * @PVT_TEMP_MIN: Minimal temperature in millidegrees of Celsius.
+ * @PVT_TEMP_MAX: Maximal temperature in millidegrees of Celsius.
+ * @PVT_TEMP_CHS: Number of temperature hwmon channels.
+ * @PVT_VOLT_MIN: Minimal voltage in mV.
+ * @PVT_VOLT_MAX: Maximal voltage in mV.
+ * @PVT_VOLT_CHS: Number of voltage hwmon channels.
+ * @PVT_DATA_MIN: Minimal PVT raw data value.
+ * @PVT_DATA_MAX: Maximal PVT raw data value.
+ * @PVT_TRIM_MIN: Minimal temperature sensor trim value.
+ * @PVT_TRIM_MAX: Maximal temperature sensor trim value.
+ * @PVT_TRIM_DEF: Default temperature sensor trim value (set a proper value
+ *		  when one is determined for ESWIN SoC).
+ * @PVT_TRIM_TEMP: Maximum temperature encoded by the trim factor.
+ * @PVT_TRIM_STEP: Temperature stride corresponding to the trim value.
+ * @PVT_TOUT_MIN: Minimal timeout between samples in nanoseconds.
+ * @PVT_TOUT_DEF: Default data measurements timeout. In case if alarms are
+ *		  activated the PVT IRQ is enabled to be raised after each
+ *		  conversion in order to have the thresholds checked and the
+ *		  converted value cached. Too frequent conversions may cause
+ *		  the system CPU overload. Lets set the 50ms delay between
+ *		  them by default to prevent this.
+ */
+#define PVT_TEMP_MIN		-40000L
+#define PVT_TEMP_MAX		125000L
+#define PVT_TEMP_CHS		1
+#define PVT_VOLT_MIN		720L
+#define PVT_VOLT_MAX		880L
+#define PVT_VOLT_CHS		4
+#define PVT_DATA_MIN		0
+#define PVT_DATA_DATA_FLD       0
+#define PVT_CTRL_TRIM_FLD       4
+#define PVT_CTRL_TRIM_MASK      GENMASK(8,4)
+#define PVT_DATA_MAX		(PVT_DATA_DATA_MASK >> PVT_DATA_DATA_FLD)
+#define PVT_TRIM_MIN		0
+#define PVT_TRIM_MAX		(PVT_CTRL_TRIM_MASK >> PVT_CTRL_TRIM_FLD)
+#define PVT_TRIM_TEMP		7130
+#define PVT_TRIM_STEP		(PVT_TRIM_TEMP / PVT_TRIM_MAX)
+#define PVT_TRIM_DEF		0
+#define PVT_TOUT_MIN		(NSEC_PER_SEC / 3000)
+# define PVT_TOUT_DEF		0
+
+/*
+ * enum pvt_sensor_type - ESWIN PVT sensor types (correspond to each PVT
+ *			  sampling mode)
+ * @PVT_SENSOR*: helpers to traverse the sensors in loops.
+ * @PVT_TEMP: PVT Temperature sensor.
+ * @PVT_VOLT: PVT Voltage sensor.
+ * @PVT_LVT: PVT Low-Voltage threshold sensor.
+ * @PVT_HVT: PVT High-Voltage threshold sensor.
+ * @PVT_SVT: PVT Standard-Voltage threshold sensor.
+ */
+enum pvt_sensor_type {
+	PVT_SENSOR_FIRST,
+	PVT_TEMP = PVT_SENSOR_FIRST,
+	PVT_VOLT,
+	PVT_LVT,
+	PVT_ULVT,
+	PVT_SVT,
+	PVT_SENSOR_LAST = PVT_SVT,
+	PVT_SENSORS_NUM
+};
+
+/*
+ * struct pvt_sensor_info - ESWIN PVT sensor informational structure
+ * @channel: Sensor channel ID.
+ * @label: hwmon sensor label.
+ * @mode: PVT mode corresponding to the channel.
+ * @thres_base: upper and lower threshold values of the sensor.
+ * @thres_sts_lo: low threshold status bitfield.
+ * @thres_sts_hi: high threshold status bitfield.
+ * @type: Sensor type.
+ * @attr_min_alarm: Min alarm attribute ID.
+ * @attr_min_alarm: Max alarm attribute ID.
+ */
+struct pvt_sensor_info {
+	int channel;
+	const char *label;
+	u32 mode;
+	unsigned long thres_base;
+	u32 thres_sts_lo;
+	u32 thres_sts_hi;
+	enum hwmon_sensor_types type;
+	u32 attr_min_alarm;
+	u32 attr_max_alarm;
+};
+
+#define PVT_SENSOR_INFO(_ch, _label, _type, _mode, _thres)	\
+	{							\
+		.channel = _ch,					\
+		.label = _label,				\
+		.mode = PVT_CTRL_MODE_ ##_mode,			\
+		.thres_base = PVT_ ##_thres,			\
+		.thres_sts_lo = PVT_INTR_ ##_thres## _LO,	\
+		.thres_sts_hi = PVT_INTR_ ##_thres## _HI,	\
+		.type = _type,					\
+		.attr_min_alarm = _type## _min,			\
+		.attr_max_alarm = _type## _max,			\
+	}
+
+/*
+ * struct pvt_cache - PVT sensors data cache
+ * @data: data cache in raw format.
+ * @thres_sts_lo: low threshold status saved on the previous data conversion.
+ * @thres_sts_hi: high threshold status saved on the previous data conversion.
+ * @data_seqlock: cached data seq-lock.
+ * @conversion: data conversion completion.
+ */
+struct pvt_cache {
+	u32 data;
+	struct completion conversion;
+};
+
+/*
+ * struct pvt_hwmon - Eswin PVT private data
+ * @dev: device structure of the PVT platform device.
+ * @hwmon: hwmon device structure.
+ * @regs: pointer to the Eswin PVT registers region.
+ * @irq: PVT events IRQ number.
+ * @clk: PVT core clock (1.2MHz).
+ * @pvt_rst: pointer to the reset descriptor.
+ * @iface_mtx: Generic interface mutex (used to lock the alarm registers
+ *	       when the alarms enabled, or the data conversion interface
+ *	       if alarms are disabled).
+ * @sensor: current PVT sensor the data conversion is being performed for.
+ * @cache: data cache descriptor.
+ * @timeout: conversion timeout cache.
+ */
+struct pvt_hwmon {
+	struct device *dev;
+	struct device *hwmon;
+
+	void __iomem *regs;
+	int irq;
+
+	struct clk *clk;
+	struct reset_control *pvt_rst;
+	struct mutex iface_mtx;
+	enum pvt_sensor_type sensor;
+	struct pvt_cache cache[PVT_SENSORS_NUM];
+	ktime_t timeout;
+};
+
+/*
+ * struct pvt_poly_term - a term descriptor of the PVT data translation
+ *			  polynomial
+ * @deg: degree of the term.
+ * @coef: multiplication factor of the term.
+ * @divider: distributed divider per each degree.
+ * @divider_leftover: divider leftover, which couldn't be redistributed.
+ */
+struct pvt_poly_term {
+	unsigned int deg;
+	long coef;
+	long divider;
+	long divider_leftover;
+};
+
+/*
+ * struct pvt_poly - PVT data translation polynomial descriptor
+ * @total_divider: total data divider.
+ * @terms: polynomial terms up to a free one.
+ */
+struct pvt_poly {
+	long total_divider;
+	struct pvt_poly_term terms[];
+};
+
+#endif /* __HWMON_ESWIN_PVT_H__ */
+
diff --git a/drivers/hwmon/pac193x.c b/drivers/hwmon/pac193x.c
new file mode 100644
index 000000000000..8a9ca9ec07b5
--- /dev/null
+++ b/drivers/hwmon/pac193x.c
@@ -0,0 +1,818 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ *  Driver for microchip  pac1931,pac1932,pac1933,pac1934 power monitor chips
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: Yang Wei <yangwei1@eswincomputing.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/jiffies.h>
+#include <linux/of_device.h>
+#include <linux/of.h>
+#include <linux/delay.h>
+#include <linux/util_macros.h>
+
+#define PAC193X_MAX_CHAN_CNT 4
+
+#define PAC193X_REGISTERS 0x27
+#define PAC193X_VPOWERN_ACC_LEN 6
+#define PAC193X_VOLT_VALUE_LEN 2
+#define PAC193X_VPOWERN_VALUE_LEN 4
+#define PAC193X_ACC_COUNT_LEN 3
+
+#define PAC193X_CMD_REFRESH 0x0
+#define PAC193X_CMD_CTRL 0x1
+#define PAC193X_CMD_ACC_COUNT 0x2
+#define PAC193X_CMD_VPOWER1_ACC 0x3
+#define PAC193X_CMD_VPOWER2_ACC 0x4
+#define PAC193X_CMD_VPOWER3_ACC 0x5
+#define PAC193X_CMD_VPOWER4_ACC 0x6
+#define PAC193X_CMD_VBUS1 0x7
+#define PAC193X_CMD_VBUS2 0x8
+#define PAC193X_CMD_VBUS3 0x9
+#define PAC193X_CMD_VBUS4 0xa
+#define PAC193X_CMD_VSENSE1 0xb
+#define PAC193X_CMD_VSENSE2 0xc
+#define PAC193X_CMD_VSENSE3 0xd
+#define PAC193X_CMD_VSENSE4 0xe
+#define PAC193X_CMD_VBUS1_AVG 0xf
+#define PAC193X_CMD_VBUS2_AVG 0x10
+#define PAC193X_CMD_VBUS3_AVG 0x11
+#define PAC193X_CMD_VBUS4_AVG 0x12
+#define PAC193X_CMD_VSENSE1_AVG 0x13
+#define PAC193X_CMD_VSENSE2_AVG 0x14
+#define PAC193X_CMD_VSENSE3_AVG 0x15
+#define PAC193X_CMD_VSENSE4_AVG 0x16
+#define PAC193X_CMD_VPOWER1 0x17
+#define PAC193X_CMD_VPOWER2 0x18
+#define PAC193X_CMD_VPOWER3 0x19
+#define PAC193X_CMD_VPOWER4 0x1a
+#define PAC193X_CMD_CHANNEL_SMBUS 0x1c
+#define PAC193X_CMD_NEG_PWR 0x1D
+#define PAC193X_CMD_REFRESH_G 0x1E
+#define PAC193X_CMD_REFRESH_V 0x1F
+#define PAC193X_CMD_SLOW 0x1F
+#define PAC193X_CMD_CTRL_ACT 0x21
+#define PAC193X_CMD_DIS_ACT 0x22
+#define PAC193X_CMD_NEG_PWR_ACT 0x23
+#define PAC193X_CMD_CTRL_LAT 0x24
+#define PAC193X_CMD_DIS_LAT 0x25
+#define PAC193X_CMD_NEG_PWR_LAT 0x26
+#define PAC193X_CMD_PID 0xFD
+#define PAC193X_CMD_MID 0xFE
+#define PAC193X_CMD_REVERSION_ID 0xFF
+
+#define PAC1932X_COSTANT_PWR_M 3200000000ull /* 3.2V^2*1000mO*/
+#define PAC1932X_COSTANT_CURRENT_M 100000 /* 100mv*1000mO*/
+
+struct pac193x_data {
+	struct mutex config_lock;
+	struct i2c_client *client;
+	u32 update_time_ms;
+	u32 energy_acc_count;
+	struct workqueue_struct *update_workqueue;
+	struct delayed_work update_work;
+	u32 vbus_denominator[PAC193X_MAX_CHAN_CNT];
+	u32 vsense_denominator[PAC193X_MAX_CHAN_CNT];
+	u32 vpower_denominator[PAC193X_MAX_CHAN_CNT];
+	u32 sense_resistances[PAC193X_MAX_CHAN_CNT];
+	u32 sample_rate;
+};
+
+enum PAC193X_CHAN_INDEX {
+	pac1931_index = 0,
+	pac1932_index,
+	pac1933_index,
+	pac1934_index
+};
+
+static int pac193x_get_energy(struct device *dev, u8 commmd, u8 chan, long *val)
+{
+	struct pac193x_data *data = dev_get_drvdata(dev);
+	int ret;
+	u64 cache = 0;
+	u8 *pcache = (u8 *)&cache;
+	u64 energy_value = 0;
+
+	commmd = commmd + chan;
+	dev_dbg(dev, "%s.%d,chan:%d,commad:%d,LEN:%ld\n", __FUNCTION__,
+		__LINE__, chan, commmd, sizeof(cache));
+	mutex_lock(&data->config_lock);
+	ret = i2c_smbus_read_i2c_block_data(data->client, commmd,
+					    PAC193X_VPOWERN_ACC_LEN, pcache);
+	mutex_unlock(&data->config_lock);
+
+	energy_value = ((cache & 0xff) << 40) | (((cache >> 8) & 0xff) << 32) |
+		       (((cache >> 16) & 0xff) << 24) |
+		       (((cache >> 24) & 0xff) << 16) |
+		       (((cache >> 32) & 0xff) << 8) | (((cache >> 40) & 0xff));
+	energy_value = energy_value & 0xffffffffffffULL;
+	dev_dbg(dev,
+		"%s.%d,commd:0x%x,value:%lld,ret:%d,resistances:%u,denominator:%u,sample_rate:%u\n",
+		__FUNCTION__, __LINE__, commmd, energy_value, ret,
+		data->sense_resistances[chan], data->vpower_denominator[chan],
+		data->sample_rate);
+
+	/* energy=3200000*Vpower/(Rsense*denominator*sample_rate) */
+	energy_value = ((energy_value / (u64)data->vpower_denominator[chan]) *
+			(PAC1932X_COSTANT_PWR_M /
+			 (data->sense_resistances[chan] * data->sample_rate)));
+
+	*val = energy_value;
+
+	return 0;
+}
+
+static u16 pac193x_get_word(struct pac193x_data *data, u8 commmd)
+{
+	int ret;
+	u16 cache = 0;
+
+	mutex_lock(&data->config_lock);
+	ret = i2c_smbus_read_word_data(data->client, commmd);
+	mutex_unlock(&data->config_lock);
+	cache = ((ret & 0xff) << 8) | ((ret >> 8) & 0xff);
+	dev_dbg(&data->client->dev, "%s.%d,commd:0x%x,value:0x%x,ret:0x%x\n",
+		__FUNCTION__, __LINE__, commmd, cache, ret);
+
+	return cache;
+}
+
+static int pac193x_get_volt(struct device *dev, u8 commmd, u8 chan, long *val)
+{
+	struct pac193x_data *data = dev_get_drvdata(dev);
+	u16 cache = 0;
+
+	commmd = commmd + chan;
+	dev_dbg(dev, "%s.%d,commd:0x%x,chan:%d,vbus_denominator:%d\n",
+		__FUNCTION__, __LINE__, commmd, chan,
+		data->vbus_denominator[chan]);
+	cache = pac193x_get_word(data, commmd);
+	/*to mV*/
+	cache = cache * 1000 / data->vbus_denominator[chan];
+	*val = cache;
+	return 0;
+}
+
+static int pac193x_get_current(struct device *dev, u8 commmd, u8 chan,
+			       long *val)
+{
+	struct pac193x_data *data = dev_get_drvdata(dev);
+	u16 cache = 0;
+
+	commmd = commmd + chan;
+	dev_dbg(dev,
+		"%s.%d,commd:0x%x,chan:%d,vbus_denominator:%d,resistances:%d\n",
+		__FUNCTION__, __LINE__, commmd, chan,
+		data->vsense_denominator[chan], data->sense_resistances[chan]);
+	cache = pac193x_get_word(data, commmd);
+	/* I=Vsense*100/(Rsense*denominator)	*/
+	cache = cache * PAC1932X_COSTANT_CURRENT_M /
+		(data->vsense_denominator[chan] *
+		 data->sense_resistances[chan]);
+	*val = cache;
+	return 0;
+}
+
+static int pac193x_get_power(struct device *dev, u8 commmd, u8 chan, long *val)
+{
+	struct pac193x_data *data = dev_get_drvdata(dev);
+	int ret;
+	u32 cache = 0;
+	u8 *pcache = (u8 *)&cache;
+	u64 pwr_value = 0;
+
+	commmd = commmd + chan;
+	mutex_lock(&data->config_lock);
+	ret = i2c_smbus_read_i2c_block_data(data->client, commmd,
+					    PAC193X_VPOWERN_VALUE_LEN, pcache);
+	mutex_unlock(&data->config_lock);
+	pwr_value = ((cache & 0xff) << 24) | (((cache >> 8) & 0xff) << 16) |
+		    (((cache >> 16) & 0xff) << 8) | ((cache >> 24) & 0xff);
+	pwr_value = pwr_value >> 4;
+	dev_dbg(dev,
+		"%s.%d,commd:0x%x,chan:%d,value:0x%x,pwr_value:0x%llx,%llu,ret:%d,resistances:%u,denominator:%u\n",
+		__FUNCTION__, __LINE__, commmd, chan, cache, pwr_value,
+		pwr_value, ret, data->sense_resistances[chan],
+		data->vpower_denominator[chan]);
+	/* pwr=3200000*Vpower/Rsense*denominator */
+	pwr_value = pwr_value * PAC1932X_COSTANT_PWR_M /
+		    ((u64)data->sense_resistances[chan] *
+		     (u64)data->vpower_denominator[chan]);
+	*val = pwr_value;
+	return 0;
+}
+
+static int pac193x_send_refresh_cmd(struct pac193x_data *data, u8 command)
+{
+	int ret = 0;
+
+	mutex_lock(&data->config_lock);
+	ret = i2c_smbus_write_byte(data->client, command);
+	mutex_unlock(&data->config_lock);
+	dev_dbg(&data->client->dev, "%s.%d,commd:0x%x,ret:%d\n", __FUNCTION__,
+		__LINE__, command, ret);
+	return ret;
+}
+
+static ssize_t pac193x_refresh_store(struct device *dev,
+				     struct device_attribute *da,
+				     const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(da);
+	struct pac193x_data *data = dev_get_drvdata(dev);
+
+	pac193x_send_refresh_cmd(data, (u8)sensor_attr->index);
+	return count;
+}
+
+static struct sensor_device_attribute pac1934_refreshs[] = {
+	SENSOR_ATTR_WO(refresh_clear_acc, pac193x_refresh, PAC193X_CMD_REFRESH),
+	SENSOR_ATTR_WO(refresh_all_193x, pac193x_refresh,
+		       PAC193X_CMD_REFRESH_G),
+	SENSOR_ATTR_WO(refresh_updata_value, pac193x_refresh,
+		       PAC193X_CMD_REFRESH_V),
+};
+
+static u8 pac193x_read_byte_data(struct pac193x_data *data, u8 command)
+{
+	int cache = 0;
+	int cnt = 0;
+	while (1) {
+		mutex_lock(&data->config_lock);
+		cache = i2c_smbus_read_byte_data(data->client, command);
+		mutex_unlock(&data->config_lock);
+		if (0xff != cache) {
+			break;
+		}
+		cnt++;
+		if (cnt > 100) {
+			dev_err(&data->client->dev,
+				"get command:%d value error\n", command);
+			return 0xff;
+		}
+	}
+	return (u8)cache;
+}
+
+static ssize_t pac193x_ctrl_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct pac193x_data *data = dev_get_drvdata(dev);
+	u8 set_val = 0, act_val = 0, lat_val = 0;
+
+	set_val = pac193x_read_byte_data(data, PAC193X_CMD_CTRL);
+	act_val = pac193x_read_byte_data(data, PAC193X_CMD_CTRL_ACT);
+	lat_val = pac193x_read_byte_data(data, PAC193X_CMD_CTRL_LAT);
+
+	return sprintf(buf,
+		       "%16s:%6s,%6s,%6s\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n",
+		       "", "set", "act", "latch",
+			   "sample_rate",(set_val >> 6) & 0x3, (act_val >> 6) & 0x3, (lat_val >> 6) & 0x3,
+			   "SLEEP", (set_val >> 5) & 0x1,(act_val >> 5) & 0x1, (lat_val >> 5) & 0x1,
+			   "SING", (set_val >> 4) & 0x1, (act_val >> 4) & 0x1, (lat_val >> 4) & 0x1,
+			   "ALERT_PIN", (set_val >> 3) & 0x1, (act_val >> 3) & 0x1, (lat_val >> 3) & 0x1,
+			   "ALERT_CC", (set_val >> 2) & 0x1, (act_val >> 2) & 0x1, (lat_val >> 2) & 0x1,
+			   "OVF ALERT", (set_val >> 1) & 0x1, (act_val >> 1) & 0x1, (lat_val >> 1) & 0x1,
+			   "OVF", (set_val >> 0) & 0x1, (act_val >> 0) & 0x1, (lat_val >> 0) & 0x1);
+}
+
+int pac193x_common_reg_set(struct device *dev, const char *buf, u8 commad)
+{
+	struct pac193x_data *data = dev_get_drvdata(dev);
+	unsigned long val;
+	int status;
+	int ret = 0;
+
+	status = kstrtoul(buf, 10, &val);
+	if (status < 0)
+		return status;
+	mutex_lock(&data->config_lock);
+	ret = i2c_smbus_write_byte_data(data->client, commad, (u8)val);
+	mutex_unlock(&data->config_lock);
+	return ret;
+}
+
+static ssize_t pac193x_ctrl_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	return pac193x_common_reg_set(dev, buf, PAC193X_CMD_CTRL);
+}
+
+DEVICE_ATTR(control, S_IWUSR | S_IRUGO, pac193x_ctrl_show, pac193x_ctrl_store);
+
+static ssize_t pac193x_acc_count_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct pac193x_data *data = dev_get_drvdata(dev);
+	int ret;
+	u32 cache = 0;
+	u8 *pcache = (u8 *)&cache;
+	u32 acc_cnt = 0;
+	mutex_lock(&data->config_lock);
+	ret = i2c_smbus_read_i2c_block_data(data->client, PAC193X_CMD_ACC_COUNT,
+					    PAC193X_ACC_COUNT_LEN, pcache);
+	mutex_unlock(&data->config_lock);
+
+	acc_cnt = ((cache & 0xff) << 16) | (((cache >> 8) & 0xff) << 8) |
+		  ((cache >> 16) & 0xff);
+	acc_cnt = acc_cnt & 0xffffff;
+
+	ret = sysfs_emit(buf, "%u\n", acc_cnt);
+	return ret;
+}
+
+DEVICE_ATTR(acc_count, 0400, pac193x_acc_count_show, NULL);
+
+static ssize_t pac193x_dis_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct pac193x_data *data = dev_get_drvdata(dev);
+	u8 set_val = 0, act_val = 0, lat_val = 0;
+
+	set_val = pac193x_read_byte_data(data, PAC193X_CMD_CHANNEL_SMBUS);
+	act_val = pac193x_read_byte_data(data, PAC193X_CMD_DIS_ACT);
+	lat_val = pac193x_read_byte_data(data, PAC193X_CMD_DIS_LAT);
+
+	return sprintf(buf,
+		       "%16s:%6s,%6s,%6s\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n",
+		       "", "set", "act", "latch",
+			   "CH1_OFF", (set_val >> 7) & 0x1, (act_val >> 7) & 0x1, (lat_val >> 7) & 0x1,
+			   "CH2_OFF", (set_val >> 6) & 0x1, (act_val >> 6) & 0x1, (lat_val >> 6) & 0x1,
+			   "CH3_OFF", (set_val >> 5) & 0x1, (act_val >> 5) & 0x1, (lat_val >> 5) & 0x1,
+			   "CH4_OFF", (set_val >> 4) & 0x1, (act_val >> 4) & 0x1, (lat_val >> 4) & 0x1,
+			   "TIMEOUT", (set_val >> 3) & 0x1, (act_val >> 3) & 0x1, (lat_val >> 3) & 0x1,
+			   "BYTE COUNT", (set_val >> 2) & 0x1, (act_val >> 2) & 0x1, (lat_val >> 2) & 0x1,
+			   "NO SKIP", (set_val >> 1) & 0x1, (act_val >> 1) & 0x1, (lat_val >> 1) & 0x1);
+}
+
+static ssize_t pac193x_dis_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	return pac193x_common_reg_set(dev, buf, PAC193X_CMD_CHANNEL_SMBUS);
+}
+
+DEVICE_ATTR(disable_chan_pmbus, S_IWUSR | S_IRUGO, pac193x_dis_show,
+	    pac193x_dis_store);
+
+static ssize_t pac193x_neg_pwr_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct pac193x_data *data = dev_get_drvdata(dev);
+	u8 set_val = 0, act_val = 0, lat_val = 0;
+
+	set_val = pac193x_read_byte_data(data, PAC193X_CMD_NEG_PWR);
+	act_val = pac193x_read_byte_data(data, PAC193X_CMD_NEG_PWR_ACT);
+	lat_val = pac193x_read_byte_data(data, PAC193X_CMD_NEG_PWR_LAT);
+
+	return sprintf(buf,
+		       "%16s:%6s,%6s,%6s\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n"
+		       "%16s:%6d,%6d,%6d\n",
+		       "", "set", "act", "latch",
+			   "CH1_BIDI", (set_val >> 7) & 0x1, (act_val >> 7) & 0x1, (lat_val >> 7) & 0x1,
+			   "CH2_BIDI", (set_val >> 6) & 0x1, (act_val >> 6) & 0x1, (lat_val >> 6) & 0x1,
+			   "CH3_BIDI", (set_val >> 5) & 0x1, (act_val >> 5) & 0x1, (lat_val >> 5) & 0x1,
+			   "CH4_BIDI", (set_val >> 4) & 0x1, (act_val >> 4) & 0x1, (lat_val >> 5) & 0x1,
+			   "CH1_BIDV", (set_val >> 3) & 0x1, (act_val >> 3) & 0x1, (lat_val >> 3) & 0x1,
+			   "CH2_BIDV", (set_val >> 2) & 0x1, (act_val >> 2) & 0x1, (lat_val >> 2) & 0x1,
+			   "CH3_BIDV", (set_val >> 1) & 0x1, (act_val >> 1) & 0x1, (lat_val >> 1) & 0x1,
+			   "CH4_BIDV", (set_val >> 0) & 0x1, (act_val >> 0) & 0x1, (lat_val >> 0) & 0x1);
+}
+
+static ssize_t pac193x_neg_pwr_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	return pac193x_common_reg_set(dev, buf, PAC193X_CMD_NEG_PWR);
+}
+
+DEVICE_ATTR(neg_pwr, S_IWUSR | S_IRUGO, pac193x_neg_pwr_show,
+	    pac193x_neg_pwr_store);
+
+static ssize_t pac193x_slow_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct pac193x_data *data = dev_get_drvdata(dev);
+	u8 set_val = 0;
+
+	set_val = pac193x_read_byte_data(data, PAC193X_CMD_SLOW);
+
+	return sprintf(buf,
+		       "SLOW:%d,SLOW-LH:%d,SLOW-HL:%d, R_RISE:%d,"
+		       "R_V_RISE:%d,R_FALL:%d,R_V_FALL:%d,POR:%d\n",
+		       (set_val >> 7) & 0x1, (set_val >> 6) & 0x1,
+		       (set_val >> 5) & 0x1, (set_val >> 4) & 0x1,
+		       (set_val >> 3) & 0x1, (set_val >> 2) & 0x1,
+		       (set_val >> 1) & 0x1, (set_val >> 0) & 0x1);
+}
+
+static ssize_t pac193x_slow_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	return pac193x_common_reg_set(dev, buf, PAC193X_CMD_SLOW);
+}
+
+DEVICE_ATTR(slow_ctrl, S_IWUSR | S_IRUGO, pac193x_slow_show,
+	    pac193x_slow_store);
+
+static ssize_t pac193x_version_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct pac193x_data *data = dev_get_drvdata(dev);
+	int ret;
+	u8 pid = 0, mid = 0, rid = 0;
+
+	pid = pac193x_read_byte_data(data, PAC193X_CMD_PID);
+	mid = pac193x_read_byte_data(data, PAC193X_CMD_MID);
+	rid = pac193x_read_byte_data(data, PAC193X_CMD_REVERSION_ID);
+
+	ret = sysfs_emit(buf, "PID:0x%x,MID:0x%x,RID:0x%x\n", pid, mid, rid);
+	return ret;
+}
+DEVICE_ATTR(pac193x_version, 0400, pac193x_version_show, NULL);
+
+static struct attribute *pac193x_attrs[] = {
+	&dev_attr_control.attr,
+	&dev_attr_acc_count.attr,
+	&dev_attr_neg_pwr.attr,
+	&dev_attr_disable_chan_pmbus.attr,
+	&dev_attr_slow_ctrl.attr,
+	&dev_attr_pac193x_version.attr,
+	&pac1934_refreshs[0].dev_attr.attr,
+	&pac1934_refreshs[1].dev_attr.attr,
+	&pac1934_refreshs[2].dev_attr.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(pac193x);
+
+static const struct hwmon_channel_info *pac1931_info[] = {
+	HWMON_CHANNEL_INFO(in, HWMON_I_INPUT | HWMON_I_AVERAGE,
+			    HWMON_I_INPUT | HWMON_I_AVERAGE),
+	HWMON_CHANNEL_INFO(curr, HWMON_C_INPUT | HWMON_C_AVERAGE),
+	HWMON_CHANNEL_INFO(power, HWMON_P_INPUT),
+	HWMON_CHANNEL_INFO(energy, HWMON_E_INPUT), NULL
+};
+static const struct hwmon_channel_info *pac1932_info[] = {
+	HWMON_CHANNEL_INFO(in, HWMON_I_INPUT | HWMON_I_AVERAGE,
+			   HWMON_I_INPUT | HWMON_I_AVERAGE,
+			   HWMON_I_INPUT | HWMON_I_AVERAGE),
+	HWMON_CHANNEL_INFO(curr, HWMON_C_INPUT | HWMON_C_AVERAGE,
+			   HWMON_C_INPUT | HWMON_C_AVERAGE),
+	HWMON_CHANNEL_INFO(power, HWMON_P_INPUT, HWMON_P_INPUT),
+	HWMON_CHANNEL_INFO(energy, HWMON_E_INPUT, HWMON_E_INPUT), NULL
+};
+static const struct hwmon_channel_info *pac1933_info[] = {
+	HWMON_CHANNEL_INFO(in, HWMON_I_INPUT | HWMON_I_AVERAGE,
+			   HWMON_I_INPUT | HWMON_I_AVERAGE,
+			   HWMON_I_INPUT | HWMON_I_AVERAGE,
+			   HWMON_I_INPUT | HWMON_I_AVERAGE),
+	HWMON_CHANNEL_INFO(curr, HWMON_C_INPUT | HWMON_C_AVERAGE,
+			   HWMON_C_INPUT | HWMON_C_AVERAGE,
+			   HWMON_C_INPUT | HWMON_C_AVERAGE),
+	HWMON_CHANNEL_INFO(power, HWMON_P_INPUT, HWMON_P_INPUT, HWMON_P_INPUT),
+	HWMON_CHANNEL_INFO(energy, HWMON_E_INPUT, HWMON_E_INPUT, HWMON_E_INPUT),
+	NULL
+};
+static const struct hwmon_channel_info *pac1934_info[] = {
+	HWMON_CHANNEL_INFO(in,
+			   HWMON_I_INPUT | HWMON_I_AVERAGE,
+			   HWMON_I_INPUT | HWMON_I_AVERAGE,
+			   HWMON_I_INPUT | HWMON_I_AVERAGE,
+			   HWMON_I_INPUT | HWMON_I_AVERAGE,
+			   HWMON_I_INPUT | HWMON_I_AVERAGE),
+	HWMON_CHANNEL_INFO(curr,
+			   HWMON_C_INPUT | HWMON_C_AVERAGE,
+			   HWMON_C_INPUT | HWMON_C_AVERAGE,
+			   HWMON_C_INPUT | HWMON_C_AVERAGE,
+			   HWMON_C_INPUT | HWMON_C_AVERAGE),
+	HWMON_CHANNEL_INFO(power, HWMON_P_INPUT, HWMON_P_INPUT, HWMON_P_INPUT,
+			   HWMON_P_INPUT),
+	HWMON_CHANNEL_INFO(energy, HWMON_E_INPUT, HWMON_E_INPUT, HWMON_E_INPUT,
+			   HWMON_E_INPUT),
+	NULL
+};
+
+static umode_t pac1934x_is_visible(const void *_data,
+				   enum hwmon_sensor_types type, u32 attr,
+				   int channel)
+{
+	switch (type) {
+	case hwmon_in:
+		switch (attr) {
+		case hwmon_in_input:
+		case hwmon_in_average:
+			if(channel == 0)
+			{
+				return 0;
+			}
+			else
+			{
+				return S_IRUGO;
+			}
+		}
+		break;
+	case hwmon_curr:
+		switch (attr) {
+		case hwmon_curr_input:
+		case hwmon_curr_average:
+			return S_IRUGO;
+		}
+		break;
+	case hwmon_power:
+		switch (attr) {
+		case hwmon_power_input:
+			return S_IRUGO;
+		}
+		break;
+	case hwmon_energy:
+		switch (attr) {
+		case hwmon_energy_input:
+			return S_IRUGO;
+		}
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int pac193x_read(struct device *dev, enum hwmon_sensor_types type,
+			u32 attr, int channel, long *val)
+{
+	switch (type) {
+	case hwmon_in:
+		switch (attr) {
+		case hwmon_in_input:
+			return pac193x_get_volt(dev, PAC193X_CMD_VBUS1, channel - 1,
+						val);
+		case hwmon_in_average:
+			return pac193x_get_volt(dev, PAC193X_CMD_VBUS1_AVG,
+						channel - 1, val);
+		}
+		break;
+	case hwmon_curr:
+		switch (attr) {
+		case hwmon_curr_input:
+			return pac193x_get_current(dev, PAC193X_CMD_VSENSE1,
+						   channel, val);
+		case hwmon_curr_average:
+			return pac193x_get_current(dev, PAC193X_CMD_VSENSE1_AVG,
+						   channel, val);
+		}
+		break;
+	case hwmon_power:
+		switch (attr) {
+		case hwmon_power_input:
+			return pac193x_get_power(dev, PAC193X_CMD_VPOWER1,
+						 channel, val);
+		}
+		break;
+	case hwmon_energy:
+		switch (attr) {
+		case hwmon_energy_input:
+			return pac193x_get_energy(dev, PAC193X_CMD_VPOWER1_ACC,
+						  channel, val);
+		}
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static const struct hwmon_ops pac193x_hwmon_ops = {
+	.is_visible = pac1934x_is_visible,
+	.read = pac193x_read,
+};
+
+static struct hwmon_chip_info pac193x_chip_info = {
+	.ops = &pac193x_hwmon_ops,
+	.info = NULL,
+};
+
+static void update_reg_data(struct work_struct *work)
+{
+	static u32 updata_cnt = 0;
+	struct pac193x_data *data;
+	int act_val = 0, ctrl_val = 0, slow_val = 0;
+	int num = 0;
+	bool is_neg = false;
+
+	data = container_of(work, struct pac193x_data, update_work.work);
+	if ((data->energy_acc_count == 0)||(updata_cnt < data->energy_acc_count)) {
+		pac193x_send_refresh_cmd(data, PAC193X_CMD_REFRESH_V);
+		updata_cnt++;
+	} else {
+		pac193x_send_refresh_cmd(data, PAC193X_CMD_REFRESH);
+		updata_cnt = 0;
+	}
+
+	act_val = pac193x_read_byte_data(data, PAC193X_CMD_NEG_PWR_ACT);
+
+	for (num = 0; num < PAC193X_MAX_CHAN_CNT; num++) {
+		is_neg = false;
+		if (0x1 == ((act_val >> num) & 0x1)) {
+			/* Vsource=32*Vbus/2^15 = Vbus/2^10=Vbus/1024  */
+			data->vbus_denominator[3 - num] = 1024;
+			is_neg = true;
+		} else {
+			/* Vsource=32*Vbus/2^16 = Vbus/2^10=Vbus/1024  */
+			data->vbus_denominator[3 - num] = 2048;
+		}
+
+		if (0x1 == ((act_val >> (num + 4)) & 0x1)) {
+			/* 2^15  */
+			data->vsense_denominator[3 - num] = 32768;
+			is_neg = true;
+		} else {
+			/*2^16 */
+			data->vsense_denominator[3 - num] = 65536;
+		}
+		if (true == is_neg) {
+			/* 2^28  */
+			data->vpower_denominator[3 - num] = 134217728;
+		} else {
+			/* 2^29  */
+			data->vpower_denominator[3 - num] = 268435456;
+		}
+	}
+
+	slow_val = pac193x_read_byte_data(data, PAC193X_CMD_SLOW);
+	ctrl_val = pac193x_read_byte_data(data, PAC193X_CMD_CTRL_ACT);
+	if ((0x1 == ((slow_val >> 7) & 0x1)) &&
+	    (0x0 == ((ctrl_val >> 3) & 0x1))) {
+		data->sample_rate = 8;
+	} else {
+		switch ((ctrl_val >> 6) & 0x3) {
+		case 0:
+			data->sample_rate = 1024;
+			break;
+		case 1:
+			data->sample_rate = 256;
+			break;
+		case 2:
+			data->sample_rate = 64;
+			break;
+		case 3:
+			data->sample_rate = 8;
+			break;
+		default:
+			break;
+		}
+	}
+	queue_delayed_work(data->update_workqueue, &data->update_work,
+			   msecs_to_jiffies(data->update_time_ms));
+}
+
+static int pac193x_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct pac193x_data *data;
+	struct device *hwmon_dev;
+	int ret = 0;
+	int num = 0;
+	enum PAC193X_CHAN_INDEX chan_index =
+		(enum PAC193X_CHAN_INDEX)of_device_get_match_data(&client->dev);
+
+	switch (chan_index) {
+	case pac1931_index:
+		pac193x_chip_info.info = pac1931_info;
+		break;
+	case pac1932_index:
+		pac193x_chip_info.info = pac1932_info;
+		break;
+	case pac1933_index:
+		pac193x_chip_info.info = pac1933_info;
+		break;
+	case pac1934_index:
+		pac193x_chip_info.info = pac1934_info;
+		break;
+	default:
+		break;
+	}
+
+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	for (num = 0; num < PAC193X_MAX_CHAN_CNT; num++) {
+		data->vbus_denominator[num] = 1;
+		data->vsense_denominator[num] = 1;
+		data->sense_resistances[num] = 1;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "update_time_ms",
+				   &data->update_time_ms);
+	if (0 != ret) {
+		dev_err(dev, "can not get update_time_ms:%d\n", ret);
+		data->update_time_ms = 100;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "energy_acc_count",
+				   &data->energy_acc_count);
+	if (0 != ret) {
+		dev_err(dev, "can not get energy_acc_count:%d\n", ret);
+		data->energy_acc_count = 0;
+	}
+	ret = of_property_read_u32_array(dev->of_node, "sense_resistances",
+					 data->sense_resistances,
+					 PAC193X_MAX_CHAN_CNT);
+	if (0 != ret) {
+		dev_err(dev, "can not get sense_resistances:%d\n", ret);
+	}
+
+	dev_info(dev,
+		"update_time:%d,energy_acc_count:%d,resistances:%d,%d,%d,%dmOhm\n",
+		data->update_time_ms, data->energy_acc_count,
+		data->sense_resistances[0], data->sense_resistances[1],
+		data->sense_resistances[2], data->sense_resistances[3]);
+	mutex_init(&data->config_lock);
+	data->client = client;
+	mutex_lock(&data->config_lock);
+	i2c_smbus_write_byte_data(data->client, PAC193X_CMD_CTRL, 0x8);
+	mutex_unlock(&data->config_lock);
+	pac193x_send_refresh_cmd(data, PAC193X_CMD_REFRESH);
+
+	hwmon_dev = devm_hwmon_device_register_with_info(
+		dev, client->name, data, &pac193x_chip_info, pac193x_groups);
+	if (IS_ERR(hwmon_dev))
+		return PTR_ERR(hwmon_dev);
+
+	data->update_workqueue = create_workqueue("update_workqueue");
+
+	INIT_DELAYED_WORK(&data->update_work, update_reg_data);
+	queue_delayed_work(data->update_workqueue, &data->update_work,
+			   msecs_to_jiffies(0));
+
+	return 0;
+}
+
+static const struct of_device_id __maybe_unused pac193x_of_match[] = {
+	{ .compatible = "microchip,pac1931", .data = (void *)pac1931_index },
+	{ .compatible = "microchip,pac1932", .data = (void *)pac1932_index },
+	{ .compatible = "microchip,pac1933", .data = (void *)pac1933_index },
+	{ .compatible = "microchip,pac1934", .data = (void *)pac1934_index },
+	{},
+};
+MODULE_DEVICE_TABLE(of, pac193x_of_match);
+
+static struct i2c_driver pac193x_driver = {
+	.driver = {
+		.name	= "pac193x",
+		.of_match_table = of_match_ptr(pac193x_of_match),
+	},
+	.probe = pac193x_probe,
+};
+
+module_i2c_driver(pac193x_driver);
+
+MODULE_AUTHOR("Yang Wei <yangwei1@eswincomputing.com");
+MODULE_DESCRIPTION("pac193x driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig
index 2b12b583ef4b..2556a8299744 100644
--- a/drivers/iommu/Kconfig
+++ b/drivers/iommu/Kconfig
@@ -7,6 +7,12 @@ config IOMMU_IOVA
 config IOMMU_API
 	bool
 
+config IOMMU_ESWIN
+	bool "IOMMU EIC7700 Support"
+	help
+	  Say Y here if you want to compile device drivers for IO Memory
+	  management implementation for EIC7700
+
 menuconfig IOMMU_SUPPORT
 	bool "IOMMU Hardware Support"
 	depends on MMU
@@ -28,7 +34,7 @@ config IOMMU_IO_PGTABLE
 config IOMMU_IO_PGTABLE_LPAE
 	bool "ARMv7/v8 Long Descriptor Format"
 	select IOMMU_IO_PGTABLE
-	depends on ARM || ARM64 || COMPILE_TEST
+	depends on ARM || ARM64 || RISCV || COMPILE_TEST
 	depends on !GENERIC_ATOMIC64	# for cmpxchg64()
 	help
 	  Enable support for the ARM long descriptor pagetable format.
@@ -389,7 +395,7 @@ config ARM_SMMU_QCOM_DEBUG
 
 config ARM_SMMU_V3
 	tristate "ARM Ltd. System MMU Version 3 (SMMUv3) Support"
-	depends on ARM64
+	depends on ARM64 || RISCV
 	select IOMMU_API
 	select IOMMU_IO_PGTABLE_LPAE
 	select GENERIC_MSI_IRQ
diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile
index 769e43d780ce..91c3ed52daf9 100644
--- a/drivers/iommu/Makefile
+++ b/drivers/iommu/Makefile
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-y += amd/ intel/ arm/ iommufd/
+obj-$(CONFIG_IOMMU_ESWIN) += eswin/
 obj-$(CONFIG_IOMMU_API) += iommu.o
 obj-$(CONFIG_IOMMU_API) += iommu-traces.o
 obj-$(CONFIG_IOMMU_API) += iommu-sysfs.o
diff --git a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
index bd0a596f9863..32a4039c9c2b 100644
--- a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
+++ b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.c
@@ -30,8 +30,24 @@
 #include "arm-smmu-v3.h"
 #include "../../dma-iommu.h"
 #include "../../iommu-sva.h"
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+#include <dt-bindings/memory/eic7700-sid.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
 
+#define ESWIN_SMMU_IRQ_CLEAR_REG	1
+
+/* smmu interrupt clear bits */
+#define TCU_U84_EVENT_Q_IRPT_NS_CLR_BIT     9
+#define TCU_U84_PRI_Q_IRPT_NS_CLR_BIT       10
+#define TCU_U84_GLOBAL_IRPT_NS_CLR_BIT      13
+#endif
+
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+static bool disable_bypass = false;
+#else
 static bool disable_bypass = true;
+#endif
 module_param(disable_bypass, bool, 0444);
 MODULE_PARM_DESC(disable_bypass,
 	"Disable bypass streams such that incoming transactions from devices that are not attached to an iommu domain will report an abort back to the device and will not be allowed to pass through the SMMU.");
@@ -1349,6 +1365,7 @@ static void arm_smmu_write_strtab_ent(struct arm_smmu_master *master, u32 sid,
 			STRTAB_STE_1_STRW_EL2 : STRTAB_STE_1_STRW_NSEL1;
 
 		BUG_ON(ste_live);
+
 		dst[1] = cpu_to_le64(
 			 FIELD_PREP(STRTAB_STE_1_S1DSS, STRTAB_STE_1_S1DSS_SSID0) |
 			 FIELD_PREP(STRTAB_STE_1_S1CIR, STRTAB_STE_1_S1C_CACHE_WBRA) |
@@ -1560,6 +1577,33 @@ static int arm_smmu_handle_evt(struct arm_smmu_device *smmu, u64 *evt)
 	return ret;
 }
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+static void eswin_smmu_irq_clear(struct arm_smmu_device *smmu, int clearbit)
+{
+	int bitmask;
+	bitmask = BIT(clearbit);
+
+	regmap_write(smmu->regmap, smmu->smmu_irq_clear_reg, bitmask);
+}
+
+static irqreturn_t eswin_smmu_irq_clear_handler(int irq, void *dev)
+{
+	struct arm_smmu_device *smmu = dev;
+
+	if (irq == smmu->evtq.q.irq) {
+			eswin_smmu_irq_clear(smmu, TCU_U84_EVENT_Q_IRPT_NS_CLR_BIT);
+	}
+	else if (irq == smmu->priq.q.irq) {
+			eswin_smmu_irq_clear(smmu, TCU_U84_PRI_Q_IRPT_NS_CLR_BIT);
+	}
+	else {
+		return IRQ_NONE;
+	}
+
+    return IRQ_WAKE_THREAD;
+}
+#endif
+
 static irqreturn_t arm_smmu_evtq_thread(int irq, void *dev)
 {
 	int i, ret;
@@ -1664,6 +1708,10 @@ static irqreturn_t arm_smmu_gerror_handler(int irq, void *dev)
 	u32 gerror, gerrorn, active;
 	struct arm_smmu_device *smmu = dev;
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	eswin_smmu_irq_clear(smmu, TCU_U84_GLOBAL_IRPT_NS_CLR_BIT);
+#endif
+
 	gerror = readl_relaxed(smmu->base + ARM_SMMU_GERROR);
 	gerrorn = readl_relaxed(smmu->base + ARM_SMMU_GERRORN);
 
@@ -2402,6 +2450,7 @@ static void arm_smmu_detach_dev(struct arm_smmu_master *master)
 
 	master->domain = NULL;
 	master->ats_enabled = false;
+
 	arm_smmu_install_ste_for_dev(master);
 }
 
@@ -2453,7 +2502,6 @@ static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)
 		ret = -EINVAL;
 		goto out_unlock;
 	}
-
 	master->domain = smmu_domain;
 
 	/*
@@ -2617,7 +2665,6 @@ static int arm_smmu_insert_master(struct arm_smmu_device *smmu,
 		}
 		if (ret)
 			break;
-
 		rb_link_node(&new_stream->node, parent_node, new_node);
 		rb_insert_color(&new_stream->node, &smmu->streams);
 	}
@@ -3205,10 +3252,17 @@ static void arm_smmu_setup_unique_irqs(struct arm_smmu_device *smmu)
 	/* Request interrupt lines */
 	irq = smmu->evtq.q.irq;
 	if (irq) {
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+		ret = devm_request_threaded_irq(smmu->dev, irq, eswin_smmu_irq_clear_handler,
+						arm_smmu_evtq_thread,
+						IRQF_ONESHOT,
+						"arm-smmu-v3-evtq", smmu);
+#else
 		ret = devm_request_threaded_irq(smmu->dev, irq, NULL,
 						arm_smmu_evtq_thread,
 						IRQF_ONESHOT,
 						"arm-smmu-v3-evtq", smmu);
+#endif
 		if (ret < 0)
 			dev_warn(smmu->dev, "failed to enable evtq irq\n");
 	} else {
@@ -3228,11 +3282,19 @@ static void arm_smmu_setup_unique_irqs(struct arm_smmu_device *smmu)
 	if (smmu->features & ARM_SMMU_FEAT_PRI) {
 		irq = smmu->priq.q.irq;
 		if (irq) {
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+			ret = devm_request_threaded_irq(smmu->dev, irq, eswin_smmu_irq_clear_handler,
+							arm_smmu_priq_thread,
+							IRQF_ONESHOT,
+							"arm-smmu-v3-priq",
+							smmu);
+#else
 			ret = devm_request_threaded_irq(smmu->dev, irq, NULL,
 							arm_smmu_priq_thread,
 							IRQF_ONESHOT,
 							"arm-smmu-v3-priq",
 							smmu);
+#endif
 			if (ret < 0)
 				dev_warn(smmu->dev,
 					 "failed to enable priq irq\n");
@@ -3523,8 +3585,10 @@ static int arm_smmu_device_hw_probe(struct arm_smmu_device *smmu)
 
 	if (reg & IDR0_HYP) {
 		smmu->features |= ARM_SMMU_FEAT_HYP;
+		#ifdef CONFIG_ARM64
 		if (cpus_have_cap(ARM64_HAS_VIRT_HOST_EXTN))
 			smmu->features |= ARM_SMMU_FEAT_E2H;
+		#endif
 	}
 
 	/*
@@ -3849,8 +3913,23 @@ static int arm_smmu_device_probe(struct platform_device *pdev)
 		smmu->page1 = smmu->base;
 	}
 
-	/* Interrupt lines */
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	/* eswin, syscon devie is used for clearing the smmu interrupt */
+	smmu->regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "eswin,syscfg");
+	if (IS_ERR(smmu->regmap)) {
+		dev_err(smmu->dev, "No syscfg phandle specified\n");
+		return PTR_ERR(smmu->regmap);
+	}
 
+	ret = of_property_read_u32_index(dev->of_node, "eswin,syscfg", ESWIN_SMMU_IRQ_CLEAR_REG,
+					&smmu->smmu_irq_clear_reg);
+	if (ret) {
+		dev_err(dev, "can't get SMMU irq clear reg offset (%d)\n", ret);
+		return ret;
+	}
+#endif
+
+	/* Interrupt lines */
 	irq = platform_get_irq_byname_optional(pdev, "combined");
 	if (irq > 0)
 		smmu->combined_irq = irq;
diff --git a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
index 9915850dd4db..36da241ec165 100644
--- a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
+++ b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3.h
@@ -682,6 +682,11 @@ struct arm_smmu_device {
 
 	struct rb_root			streams;
 	struct mutex			streams_mutex;
+
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	struct regmap *regmap;
+	int     smmu_irq_clear_reg;
+#endif
 };
 
 struct arm_smmu_stream {
diff --git a/drivers/iommu/eswin/Makefile b/drivers/iommu/eswin/Makefile
new file mode 100644
index 000000000000..d63610d53d4f
--- /dev/null
+++ b/drivers/iommu/eswin/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_IOMMU_ESWIN) += eic7700-sid.o
diff --git a/drivers/iommu/eswin/eic7700-sid.c b/drivers/iommu/eswin/eic7700-sid.c
new file mode 100644
index 000000000000..f45e3c1d793e
--- /dev/null
+++ b/drivers/iommu/eswin/eic7700-sid.c
@@ -0,0 +1,663 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2022 ESWIN.  All rights reserved.
+ * Author: Lin Min <linmin@eswin.com>
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/io.h>
+#include <linux/bitfield.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/regmap.h>
+#include <linux/iommu.h>
+#include <linux/mfd/syscon.h>
+#include <dt-bindings/memory/eic7700-sid.h>
+
+#define DYMN_CSR_EN_REG_OFFSET            0x0
+#define DYMN_CSR_GNT_REG_OFFSET           0x4
+
+#define MCPU_SP0_DYMN_CSR_EN_BIT    3
+#define MCPU_SP0_DYMN_CSR_GNT_BIT   3
+
+#define AWSMMUSID	GENMASK(31, 24) // The sid of write operation
+#define AWSMMUSSID	GENMASK(23, 16) // The ssid of write operation
+#define ARSMMUSID	GENMASK(15, 8)	// The sid of read operation
+#define ARSMMUSSID	GENMASK(7, 0)	// The ssid of read operation
+
+struct eic7700_sid_client {
+	const char *name;
+	unsigned int sid;
+	unsigned int reg_offset;
+};
+
+struct eic7700_sid_soc {
+	const struct eic7700_sid_client *clients;
+	unsigned int num_clients;
+};
+
+/* The syscon registers for tbu power up(down) must be configured so that
+    tcu can be aware of tbu up and down.
+
+ */
+struct tbu_reg_cfg_info {
+	unsigned int reg_offset;
+	unsigned int qreqn_pd_bit;
+	unsigned int qacceptn_pd_bit;
+};
+
+struct tbu_priv {
+	atomic_t refcount;
+	int nid;
+	const struct eic7700_tbu_client *tbu_client_p;
+	struct mutex tbu_priv_lock;
+};
+
+struct eic7700_tbu_client {
+	/* tbu_id: bit[3:0] is for major ID, bit[7:4] is for minor ID;
+	   For example, tbu of dsp3 is tbu7_3, the tbu_ID is 0x73. It measn tbu7_3
+	*/
+	u32 tbu_id;
+	struct tbu_reg_cfg_info tbu_reg_info;
+	int (*tbu_power_ctl_register) (int nid, struct tbu_priv *tbu_priv_p, bool is_powerUp);
+};
+
+struct eic7700_tbu_soc {
+	const struct eic7700_tbu_client *tbu_clients;
+	unsigned int num_tbuClients;
+};
+
+
+
+struct tbu_power_soc {
+	struct tbu_priv *tbu_priv_array;
+	unsigned int num_tbuClients;
+};
+
+struct eic7700_sid {
+	void __iomem *regs;
+	resource_size_t start;
+	const struct eic7700_sid_soc *soc;
+	struct mutex eswin_dynm_sid_cfg_en_lock;
+	struct tbu_power_soc *tbu_power_soc;
+	struct mutex tbu_reg_lock;
+};
+struct eic7700_sid *syscon_sid_cfg[MAX_NUMNODES] = {NULL};
+
+static int eic7700_tbu_power_ctl_register(int nid, struct tbu_priv *tbu_priv_p, bool is_powerUp);
+
+static int eic7700_tbu_powr_priv_init(struct tbu_power_soc **tbu_power_soc_pp, int nid);
+
+int eic7700_dynm_sid_enable(int nid)
+{
+	unsigned long reg_val;
+	struct eic7700_sid *mc = NULL;
+
+	if (nid == NUMA_NO_NODE) {
+	#ifdef CONFIG_NUMA
+		pr_err("%s:%d, NUMA_NO_NODE\n", __func__, __LINE__);
+		return -EFAULT;
+	#else
+		pr_info("%s:%d, NUMA_NO_NODE, single DIE\n", __func__, __LINE__);
+		nid = 0;
+	#endif
+	}
+
+	mc = syscon_sid_cfg[nid];
+	if (mc == NULL)
+		return -EFAULT;
+
+	mutex_lock(&mc->eswin_dynm_sid_cfg_en_lock);
+	reg_val = readl(mc->regs + DYMN_CSR_EN_REG_OFFSET);
+	set_bit(MCPU_SP0_DYMN_CSR_EN_BIT, &reg_val);
+	writel(reg_val, mc->regs + DYMN_CSR_EN_REG_OFFSET);
+
+	while(1) {
+		reg_val = readl(mc->regs + DYMN_CSR_GNT_REG_OFFSET) & (1 << MCPU_SP0_DYMN_CSR_GNT_BIT);
+		if (reg_val)
+			break;
+
+		msleep(10);
+	}
+	reg_val = readl(mc->regs + DYMN_CSR_EN_REG_OFFSET);
+	clear_bit(MCPU_SP0_DYMN_CSR_EN_BIT, &reg_val);
+	writel(reg_val, mc->regs + DYMN_CSR_EN_REG_OFFSET);
+	mutex_unlock(&mc->eswin_dynm_sid_cfg_en_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(eic7700_dynm_sid_enable);
+
+int eic7700_aon_sid_cfg(struct device *dev)
+{
+	int ret = 0;
+	struct regmap *regmap;
+	int aon_sid_reg;
+	u32 rdwr_sid_ssid;
+	u32 sid;
+	int i,sid_count;
+	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+	struct device_node *np_syscon;
+	int syscon_cell_size = 0;
+
+	/* not behind smmu, use the default reset value(0x0) of the reg as streamID*/
+	if (fwspec == NULL) {
+		dev_info(dev, "dev is not behind smmu, skip configuration of sid\n");
+		return 0;
+	}
+
+	regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "eswin,syscfg");
+	if (IS_ERR(regmap)) {
+		dev_err(dev, "No eswin,syscfg phandle specified\n");
+		return -1;
+	}
+
+	np_syscon = of_parse_phandle(dev->of_node, "eswin,syscfg", 0);
+	if (np_syscon) {
+		if (of_property_read_u32(np_syscon, "#syscon-cells", &syscon_cell_size)) {
+			of_node_put(np_syscon);
+			dev_err(dev, "failed to get #syscon-cells of sys_con\n");
+			return -1;
+		}
+		of_node_put(np_syscon);
+	}
+
+	sid_count = of_count_phandle_with_args(dev->of_node,
+					"eswin,syscfg", "#syscon-cells");
+
+	dev_dbg(dev, "sid_count=%d, fwspec->num_ids=%d, syscon_cell_size=%d\n",
+			sid_count, fwspec->num_ids, syscon_cell_size);
+
+	if (sid_count < 0) {
+		dev_err(dev, "failed to parse eswin,syscfg property!\n");
+		return -1;
+	}
+
+	if (fwspec->num_ids != sid_count) {
+		dev_err(dev, "num_ids(%d) is NOT equal to num of sid regs(%d)!\n",
+			fwspec->num_ids, sid_count);
+		return -1;
+	}
+
+	for (i = 0; i < sid_count; i++) {
+		sid = fwspec->ids[i];
+		ret = of_property_read_u32_index(dev->of_node, "eswin,syscfg", (syscon_cell_size + 1)*i+1,
+					&aon_sid_reg);
+		if (ret) {
+			dev_err(dev, "can't get sid cfg reg offset in sys_con(errno:%d)\n", ret);
+			return ret;
+		}
+
+		/* make the reading sid the same as writing sid, ssid is fixed to zero */
+		rdwr_sid_ssid  = FIELD_PREP(AWSMMUSID, sid);
+		rdwr_sid_ssid |= FIELD_PREP(ARSMMUSID, sid);
+		rdwr_sid_ssid |= FIELD_PREP(AWSMMUSSID, 0);
+		rdwr_sid_ssid |= FIELD_PREP(ARSMMUSSID, 0);
+		regmap_write(regmap, aon_sid_reg, rdwr_sid_ssid);
+
+		ret = eic7700_dynm_sid_enable(dev_to_node(dev));
+		if (ret < 0)
+			dev_err(dev, "failed to config streamID(%d) for %s!\n", sid, of_node_full_name(dev->of_node));
+		else
+			dev_info(dev, "success to config dma streamID(%d) for %s!\n", sid, of_node_full_name(dev->of_node));
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(eic7700_aon_sid_cfg);
+
+static int of_parse_syscon_nodes(struct device_node *np, int *nid_p)
+{
+	#ifdef CONFIG_NUMA
+	int nid;
+	int r;
+
+	r = of_property_read_u32(np, "numa-node-id", &nid);
+	if (r)
+		return -EINVAL;
+
+	pr_debug("Syscon on %u\n", nid);
+	if (nid >= MAX_NUMNODES) {
+		pr_warn("Node id %u exceeds maximum value\n", nid);
+		return -EINVAL;
+	}
+	else
+		*nid_p = nid;
+	#else
+		*nid_p = 0;
+	#endif
+
+	pr_debug("%s, nid = %d\n", __func__, *nid_p);
+
+	return 0;
+}
+
+#if defined(CONFIG_RISCV)
+static const struct eic7700_sid_client eic7700_sid_clients[] = {
+	{
+		.name = "scpu",
+		.sid = EIC7700_SID_SCPU,
+		.reg_offset = SCPU_SID_REG_OFFSET,
+	},
+	{
+		.name = "dma1",
+		.sid = EIC7700_SID_DMA1,
+		.reg_offset = DMA1_SID_REG_OFFSET,
+	},
+	//{
+	//	.name = "crypt",
+	//	.sid = EIC7700_SID_CRYPT,
+	//	.reg_offset = CRYPT_SID_REG_OFFSET,
+	//}
+};
+
+static const struct eic7700_sid_soc eic7700_sid_soc = {
+	.num_clients = ARRAY_SIZE(eic7700_sid_clients),
+	.clients = eic7700_sid_clients,
+};
+#endif
+
+static const struct of_device_id eic7700_sid_of_match[] = {
+	{ .compatible = "eswin,eic7700-scu-sys-con", .data = &eic7700_sid_soc },
+	{ /* sentinel */ }
+};
+
+static int __init eic7700_init_streamID(void)
+{
+	const struct of_device_id *match;
+	struct device_node *root, *child = NULL;
+	struct resource regs;
+	struct eic7700_sid *mc = NULL;
+	int nid;
+	int ret = 0;
+
+	root = of_find_node_by_name(NULL, "soc");
+	for_each_child_of_node(root, child) {
+		match = of_match_node(eic7700_sid_of_match, child);
+		if (match && of_node_get(child)) {
+			if (of_address_to_resource(child, 0, &regs) < 0) {
+				pr_err("failed to get scu register\n");
+				of_node_put(child);
+				ret = -ENXIO;
+				break;
+			}
+			if (of_parse_syscon_nodes(child, &nid) < 0) {
+				pr_err("failed to get numa-node-id\n");
+				of_node_put(child);
+				ret = -ENXIO;
+				break;
+			}
+
+			/* program scu sreamID related registers */
+			mc = kzalloc(sizeof(*mc), GFP_KERNEL);
+			if (!mc) {
+				of_node_put(child);
+				pr_err("failed to kzalloc\n");
+				ret = -ENOMEM;
+				break;
+			}
+
+			mc->soc = match->data;
+			mc->regs = ioremap(regs.start, resource_size(&regs));
+			if (IS_ERR(mc->regs)) {
+				pr_err("failed to ioremap scu reges\n");
+				of_node_put(child);
+				ret = PTR_ERR(mc->regs);
+				kfree(mc);
+				break;
+			}
+			mc->start = regs.start;
+			mutex_init(&mc->eswin_dynm_sid_cfg_en_lock);
+
+			if (eic7700_tbu_powr_priv_init(&mc->tbu_power_soc, nid)) {
+				pr_err("failed to kzalloc for tbu_power_priv_arry\n");
+				of_node_put(child);
+				iounmap(mc->regs);
+				kfree(mc);
+				ret = -ENOMEM;
+				WARN_ON(1);
+				break;
+			}
+			mutex_init(&mc->tbu_reg_lock);
+
+			syscon_sid_cfg[nid] = mc;
+			pr_debug("%s, syscon_sid_cfg[%d] addr is 0x%px\n", __func__, nid, syscon_sid_cfg[nid]);
+
+			of_node_put(child);
+		}
+	}
+	of_node_put(root);
+
+	return ret;
+}
+
+early_initcall(eic7700_init_streamID);
+
+
+
+static const struct eic7700_tbu_client eic7700_tbu_clients[] = {
+	{
+		.tbu_id = EIC7700_TBUID_0x0, // ISP, DW200 share the tbu0
+		.tbu_reg_info = {0x3d8, 7, 6},
+		.tbu_power_ctl_register = eic7700_tbu_power_ctl_register,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x10, // tbu1_0 is only for video decoder
+		.tbu_reg_info = {0x3d4, 31, 30},
+		.tbu_power_ctl_register = NULL,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x11, // tbu1_1 is only video encoder
+		.tbu_reg_info = {0x3d4, 23, 22},
+		.tbu_power_ctl_register = NULL,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x12, // tbu1_2 is only Jpeg encoder
+		.tbu_reg_info = {0x3d4, 7, 6},
+		.tbu_power_ctl_register = NULL,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x13, // tbu1_3 is only Jpeg decoder
+		.tbu_reg_info = {0x3d4, 15, 14},
+		.tbu_power_ctl_register = NULL,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x2, // Ethernet, sata, usb, dma0, emmc, sd, sdio share the tbu2
+		.tbu_reg_info = {0x3d8, 15, 14},
+		.tbu_power_ctl_register = eic7700_tbu_power_ctl_register,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x3, // tbu3 is only for pcie
+		.tbu_reg_info = {0x3d8, 23, 22},
+		.tbu_power_ctl_register = NULL,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x4, // scpu, crypto, lpcpu, dma1 share the tbu4
+		.tbu_reg_info = {0x3d8, 31, 30},
+		.tbu_power_ctl_register = eic7700_tbu_power_ctl_register,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x5, // tbu5 is only NPU
+		.tbu_reg_info = {0x3d0, 15, 14},
+		.tbu_power_ctl_register = NULL,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x70, // tbu7_0 is only dsp0
+		.tbu_reg_info = {0x3f8, 7, 6},
+		.tbu_power_ctl_register = NULL,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x71, // tbu7_1 is only dsp1
+		.tbu_reg_info = {0x3f8, 15, 14},
+		.tbu_power_ctl_register = NULL,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x72, // tbu7_2 is only dsp2
+		.tbu_reg_info = {0x3f8, 23, 22},
+		.tbu_power_ctl_register = NULL,
+	},
+	{
+		.tbu_id = EIC7700_TBUID_0x73, // tbu7_3 is only dsp3
+		.tbu_reg_info = {0x3f8, 31, 30},
+		.tbu_power_ctl_register = NULL,
+	},
+};
+
+static const struct eic7700_tbu_soc eic7700_tbu_soc = {
+	.num_tbuClients = ARRAY_SIZE(eic7700_tbu_clients),
+	.tbu_clients = eic7700_tbu_clients,
+};
+
+static int __do_eic7700_tbu_power_ctl(int nid, bool is_powerUp, const struct tbu_reg_cfg_info *tbu_reg_info_p)
+{
+	int ret = 0;
+	unsigned long reg_val;
+	struct eic7700_sid *mc = NULL;
+	int loop_cnt = 0;
+	mc = syscon_sid_cfg[nid];
+	if (mc == NULL)
+		return -EFAULT;
+
+	mutex_lock(&mc->tbu_reg_lock);
+	if (is_powerUp) {
+		reg_val = readl(mc->regs + tbu_reg_info_p->reg_offset);
+		set_bit(tbu_reg_info_p->qreqn_pd_bit, &reg_val);
+		writel(reg_val, mc->regs + tbu_reg_info_p->reg_offset);
+		pr_debug("reg_offset=0x%03x, tbu_val=0x%x\n",
+			tbu_reg_info_p->reg_offset, readl(mc->regs + tbu_reg_info_p->reg_offset));
+		pr_debug("%s, power up!\n", __func__);
+	}
+	else {
+		reg_val = readl(mc->regs + tbu_reg_info_p->reg_offset);
+		clear_bit(tbu_reg_info_p->qreqn_pd_bit, &reg_val);
+		writel(reg_val, mc->regs + tbu_reg_info_p->reg_offset);
+		do {
+			reg_val = readl(mc->regs + tbu_reg_info_p->reg_offset);
+			pr_debug("reg_offset=0x%03x, tbu_val=0x%lx, BIT(qacceptn_pd_bit)=0x%lx\n",
+				tbu_reg_info_p->reg_offset, reg_val, BIT(tbu_reg_info_p->qacceptn_pd_bit));
+			if ((reg_val & BIT(tbu_reg_info_p->qacceptn_pd_bit)) == 0) {
+				pr_debug("%s, power down!\n", __func__);
+				break;
+			}
+			mdelay(10);
+			loop_cnt++;
+			if (loop_cnt > 10) {
+				WARN_ON(1); // it should never happen.
+				break;
+			}
+		}while (1);
+
+		if(loop_cnt > 10) {
+			ret = -1;
+		}
+	}
+	mutex_unlock(&mc->tbu_reg_lock);
+
+	return ret;
+}
+
+#define do_eic7700_tbu_power_up(nid, tbu_reg_info_p)	__do_eic7700_tbu_power_ctl(nid, true, tbu_reg_info_p)
+#define do_eic7700_tbu_power_down(nid, tbu_reg_info_p)	__do_eic7700_tbu_power_ctl(nid, false, tbu_reg_info_p)
+
+static int tbu_power_down_ref_release(atomic_t *ref)
+{
+	int ret = 0;
+	struct tbu_priv *tbu_priv_p = container_of(ref, struct tbu_priv, refcount);
+	int nid = tbu_priv_p->nid;
+	const struct tbu_reg_cfg_info *tbu_reg_info_p = &tbu_priv_p->tbu_client_p->tbu_reg_info;
+
+	WARN_ON(!tbu_priv_p);
+	if (!tbu_priv_p)
+		return -1;
+
+	ret = do_eic7700_tbu_power_down(nid, tbu_reg_info_p);
+
+	return ret;
+}
+
+static int eic7700_tbu_power_ctl_register(int nid, struct tbu_priv *tbu_priv_p, bool is_powerUp)
+{
+	int ret = 0;
+	const struct eic7700_tbu_client *tbu_client_p = tbu_priv_p->tbu_client_p;
+	const struct tbu_reg_cfg_info *tbu_reg_info_p = &tbu_priv_p->tbu_client_p->tbu_reg_info;
+	unsigned int old_refcount;
+
+	mutex_lock(&tbu_priv_p->tbu_priv_lock);
+	old_refcount = atomic_read(&tbu_priv_p->refcount);
+
+	pr_debug("%s, nid=%d, is_powerUp=%d, tbu_priv_p addr is 0x%px\n",
+		__func__, nid, is_powerUp, tbu_priv_p);
+	if (is_powerUp == false) { //power down
+		if (unlikely(0 == old_refcount)) {
+			pr_debug("%s, tbu_id 0x%02x is down already!\n", __func__, tbu_client_p->tbu_id);
+			goto tbu_finish;
+		}
+
+		if (atomic_sub_return(1, &tbu_priv_p->refcount) == 0) {
+			ret = tbu_power_down_ref_release(&tbu_priv_p->refcount);
+		}
+		else {
+			pr_debug("Can't power down tbu 0x%02x, it's used by other modules right now!\n",
+				tbu_client_p->tbu_id);
+		}
+
+	}
+	else { //power up
+		if (0 == old_refcount) {
+			ret = do_eic7700_tbu_power_up(nid, tbu_reg_info_p);
+		}
+		else {
+			pr_debug("tbu 0x%02x is already power up!", tbu_client_p->tbu_id);
+		}
+		atomic_add(1, &tbu_priv_p->refcount);
+	}
+
+tbu_finish:
+	mutex_unlock(&tbu_priv_p->tbu_priv_lock);
+
+	return ret;
+
+}
+
+static int eic7700_tbu_powr_priv_init(struct tbu_power_soc **tbu_power_soc_pp, int nid)
+{
+	int ret = 0;
+	int i;
+	unsigned int num_tbuClients = eic7700_tbu_soc.num_tbuClients;
+	struct tbu_power_soc *tbu_power_soc_p;
+	struct tbu_priv *tbu_priv_p;
+	unsigned int alloc_size;
+
+	pr_debug("%s:%d\n", __func__, __LINE__);
+
+	tbu_power_soc_p = kzalloc(sizeof(struct tbu_power_soc), GFP_KERNEL);
+	if (!tbu_power_soc_p)
+		return -ENOMEM;
+	pr_debug("%s:%d, tbu_power_soc_p(0x%px)\n", __func__, __LINE__, tbu_power_soc_p);
+
+	alloc_size = num_tbuClients * sizeof(struct tbu_priv);
+	tbu_priv_p = kzalloc(alloc_size, GFP_KERNEL);
+	if (!tbu_priv_p) {
+		ret = -ENOMEM;
+		goto err_tbu_priv_p;
+	}
+	tbu_power_soc_p->tbu_priv_array = tbu_priv_p;
+	pr_debug("%s:%d, num_tbu=%d,sizeof(struct tbu_priv)=0x%lx, alloc_size=0x%x, tbu_priv_p=0x%px\n",
+		__func__, __LINE__, num_tbuClients, sizeof(struct tbu_priv), alloc_size, tbu_priv_p);
+
+	for (i = 0; i < eic7700_tbu_soc.num_tbuClients; i++) {
+		tbu_priv_p->nid = nid;
+		atomic_set(&tbu_priv_p->refcount, 0);
+		tbu_priv_p->tbu_client_p = &eic7700_tbu_soc.tbu_clients[i];
+		mutex_init(&tbu_priv_p->tbu_priv_lock);
+		pr_debug("%s, nid %d, tbu 0x%02x, tbu_priv_p(0x%px), sizeof(struct tbu_priv)=0x%lx\n", __func__, nid, tbu_priv_p->tbu_client_p->tbu_id, tbu_priv_p, sizeof(struct tbu_priv));
+		tbu_priv_p++;
+	}
+	tbu_power_soc_p->num_tbuClients = num_tbuClients;
+
+	*tbu_power_soc_pp = tbu_power_soc_p;
+
+	return 0;
+
+err_tbu_priv_p:
+	kfree(tbu_power_soc_p);
+
+	return ret;
+
+}
+
+static int eic7700_get_tbu_priv(int nid, u32 tbu_id, struct tbu_priv **tbu_priv_pp)
+{
+	int i;
+	struct eic7700_sid *mc = syscon_sid_cfg[nid];
+	struct tbu_power_soc *tbu_power_soc_p = mc->tbu_power_soc;
+	struct tbu_priv *tbu_priv_p = tbu_power_soc_p->tbu_priv_array;
+
+	pr_debug("%s,  syscon_sid_cfg[%d] addr is 0x%px, tbu_id=0x%02x, tbu_power_soc_p is 0x%px\n",
+		__func__, nid, syscon_sid_cfg[nid], tbu_id, tbu_power_soc_p);
+
+	for (i = 0; i < tbu_power_soc_p->num_tbuClients; i++) {
+		if (tbu_id == tbu_priv_p->tbu_client_p->tbu_id) {
+			*tbu_priv_pp = tbu_priv_p;
+			pr_debug("%s, found tbu_id 0x%02x, tbu_priv_array[%d] tbu_priv_p is 0x%px\n",
+				__func__, tbu_id, i, tbu_priv_p);
+			return 0;
+		}
+		tbu_priv_p++;
+	}
+
+	return -1;
+}
+
+/***********************************************************************************************
+   eic7700_tbu_power(struct device *dev, bool is_powerUp) is for powering up or down
+   the tbus of the device module which is under smmu.
+   Drivers should call eic7700_tbu_power(dev, true) when probing afer clk of the tbu is on,
+   and call call eic7700_tbu_power(dev, false) when removing driver before clk of the tbu is off.
+
+   Input:
+	struct device *dev	The struct device of the driver that calls this API.
+	bool is_powerUp		true: power up the tbus;  false: power down the tbus.
+   Return:
+	zero:		successfully power up/down
+	none zero:	faild to power up/down
+***********************************************************************************************/
+int eic7700_tbu_power(struct device *dev, bool is_powerUp)
+{
+	int ret = 0;
+	struct device_node *node = dev->of_node;
+	int nid = dev_to_node(dev);
+	u32 tbu_id;
+	const struct eic7700_tbu_client *tbu_client_p = NULL;
+	struct tbu_priv *tbu_priv_p;
+	struct property *prop;
+	const __be32 *cur;
+	int tbu_num = 0;
+
+	if (nid == NUMA_NO_NODE) {
+	#ifdef CONFIG_NUMA
+		pr_err("%s:%d, NUMA_NO_NODE\n", __func__, __LINE__);
+		return -EFAULT;
+	#else
+		pr_info("%s:%d, NUMA_NO_NODE, single DIE\n", __func__, __LINE__);
+		nid = 0;
+	#endif
+	}
+
+	pr_debug("%s called!\n", __func__);
+	of_property_for_each_u32(node, "tbus", prop, cur, tbu_id) {
+		pr_debug("tbus = <0x%02x>\n", tbu_id);
+		if (0 == eic7700_get_tbu_priv(nid, tbu_id, &tbu_priv_p)) {
+			tbu_client_p = tbu_priv_p->tbu_client_p;
+			if (tbu_client_p->tbu_power_ctl_register) {
+				ret = tbu_client_p->tbu_power_ctl_register(nid, tbu_priv_p, is_powerUp);
+				if (ret)
+					return ret;
+			}
+			else {
+				ret = __do_eic7700_tbu_power_ctl(nid, is_powerUp, &tbu_client_p->tbu_reg_info);
+				if (ret)
+					return ret;
+			}
+			tbu_num++;
+		}
+		else if (tbu_id == EIC7700_TBUID_0xF00) {
+			tbu_num++;
+		}
+		else {
+			pr_err("tbu power ctl failed!, Couldn't find tbu 0x%x\n", tbu_id);
+			return -1;
+		}
+	}
+
+	if (tbu_num == 0) {
+		pr_err("Err,tbu NOT defined in dts!!!!\n");
+		WARN_ON(1);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(eic7700_tbu_power);
diff --git a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig
index f7149d0f3d45..e2fcd11687cf 100644
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -30,7 +30,6 @@ config ARM_GIC_V2M
 
 config GIC_NON_BANKED
 	bool
-
 config ARM_GIC_V3
 	bool
 	select IRQ_DOMAIN_HIERARCHY
@@ -546,6 +545,25 @@ config SIFIVE_PLIC
 	select IRQ_DOMAIN_HIERARCHY
 	select GENERIC_IRQ_EFFECTIVE_AFF_MASK if SMP
 
+config RISCV_APLIC
+	bool
+	depends on RISCV
+	select IRQ_DOMAIN_HIERARCHY
+	select GENERIC_MSI_IRQ
+
+config RISCV_IMSIC
+	bool
+	depends on RISCV
+	select IRQ_DOMAIN_HIERARCHY
+	select GENERIC_MSI_IRQ
+
+config RISCV_IMSIC_PCI
+	bool
+	depends on RISCV_IMSIC
+	depends on PCI
+	depends on PCI_MSI
+	default RISCV_IMSIC
+
 config EXYNOS_IRQ_COMBINER
 	bool "Samsung Exynos IRQ combiner support" if COMPILE_TEST
 	depends on (ARCH_EXYNOS && ARM) || COMPILE_TEST
diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
index ffd945fe71aa..438b8e1a152c 100644
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -95,6 +95,8 @@ obj-$(CONFIG_QCOM_MPM)			+= irq-qcom-mpm.o
 obj-$(CONFIG_CSKY_MPINTC)		+= irq-csky-mpintc.o
 obj-$(CONFIG_CSKY_APB_INTC)		+= irq-csky-apb-intc.o
 obj-$(CONFIG_RISCV_INTC)		+= irq-riscv-intc.o
+obj-$(CONFIG_RISCV_APLIC)		+= irq-riscv-aplic.o
+obj-$(CONFIG_RISCV_IMSIC)		+= irq-riscv-imsic.o
 obj-$(CONFIG_SIFIVE_PLIC)		+= irq-sifive-plic.o
 obj-$(CONFIG_IMX_IRQSTEER)		+= irq-imx-irqsteer.o
 obj-$(CONFIG_IMX_INTMUX)		+= irq-imx-intmux.o
diff --git a/drivers/irqchip/irq-riscv-aplic.c b/drivers/irqchip/irq-riscv-aplic.c
new file mode 100644
index 000000000000..1b3c1f206071
--- /dev/null
+++ b/drivers/irqchip/irq-riscv-aplic.c
@@ -0,0 +1,699 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 Western Digital Corporation or its affiliates.
+ * Copyright (C) 2022 Ventana Micro Systems Inc.
+ */
+
+#include <linux/bitops.h>
+#include <linux/cpu.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqchip/riscv-aplic.h>
+#include <linux/irqchip/riscv-imsic.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/msi.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/smp.h>
+
+#define APLIC_DEFAULT_PRIORITY		1
+#define APLIC_DISABLE_IDELIVERY		0
+#define APLIC_ENABLE_IDELIVERY		1
+#define APLIC_DISABLE_ITHRESHOLD	1
+#define APLIC_ENABLE_ITHRESHOLD		0
+
+struct aplic_msicfg {
+	phys_addr_t		base_ppn;
+	u32			hhxs;
+	u32			hhxw;
+	u32			lhxs;
+	u32			lhxw;
+};
+
+struct aplic_idc {
+	unsigned int		hart_index;
+	void __iomem		*regs;
+	struct aplic_priv	*priv;
+};
+
+struct aplic_priv {
+	struct device		*dev;
+	u32			nr_irqs;
+	u32			nr_idcs;
+	void __iomem		*regs;
+	struct irq_domain	*irqdomain;
+	struct aplic_msicfg	msicfg;
+	struct cpumask		lmask;
+};
+
+static unsigned int aplic_idc_parent_irq;
+static DEFINE_PER_CPU(struct aplic_idc, aplic_idcs);
+
+static void aplic_irq_unmask(struct irq_data *d)
+{
+	struct aplic_priv *priv = irq_data_get_irq_chip_data(d);
+
+	writel(d->hwirq, priv->regs + APLIC_SETIENUM);
+
+	if (!priv->nr_idcs)
+		irq_chip_unmask_parent(d);
+}
+
+static void aplic_irq_mask(struct irq_data *d)
+{
+	struct aplic_priv *priv = irq_data_get_irq_chip_data(d);
+
+	writel(d->hwirq, priv->regs + APLIC_CLRIENUM);
+
+	if (!priv->nr_idcs)
+		irq_chip_mask_parent(d);
+}
+
+static int aplic_set_type(struct irq_data *d, unsigned int type)
+{
+	u32 val = 0;
+	void __iomem *sourcecfg;
+	struct aplic_priv *priv = irq_data_get_irq_chip_data(d);
+
+	switch (type) {
+	case IRQ_TYPE_NONE:
+		val = APLIC_SOURCECFG_SM_INACTIVE;
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		val = APLIC_SOURCECFG_SM_LEVEL_LOW;
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		val = APLIC_SOURCECFG_SM_LEVEL_HIGH;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		val = APLIC_SOURCECFG_SM_EDGE_FALL;
+		break;
+	case IRQ_TYPE_EDGE_RISING:
+		val = APLIC_SOURCECFG_SM_EDGE_RISE;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	sourcecfg = priv->regs + APLIC_SOURCECFG_BASE;
+	sourcecfg += (d->hwirq - 1) * sizeof(u32);
+	writel(val, sourcecfg);
+
+	return 0;
+}
+
+static void aplic_irq_eoi(struct irq_data *d)
+{
+	struct aplic_priv *priv = irq_data_get_irq_chip_data(d);
+	u32 reg_off, reg_mask;
+
+	/*
+	 * EOI handling only required only for level-triggered
+	 * interrupts in APLIC MSI mode.
+	 */
+
+	if (priv->nr_idcs)
+		return;
+
+	reg_off = APLIC_CLRIP_BASE + ((d->hwirq / APLIC_IRQBITS_PER_REG) * 4);
+	reg_mask = BIT(d->hwirq % APLIC_IRQBITS_PER_REG);
+	switch (irqd_get_trigger_type(d)) {
+	case IRQ_TYPE_LEVEL_LOW:
+		if (!(readl(priv->regs + reg_off) & reg_mask))
+			writel(d->hwirq, priv->regs + APLIC_SETIPNUM_LE);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		if (readl(priv->regs + reg_off) & reg_mask)
+			writel(d->hwirq, priv->regs + APLIC_SETIPNUM_LE);
+		break;
+	}
+}
+
+#ifdef CONFIG_SMP
+static int aplic_set_affinity(struct irq_data *d,
+			      const struct cpumask *mask_val, bool force)
+{
+	struct aplic_priv *priv = irq_data_get_irq_chip_data(d);
+	struct aplic_idc *idc;
+	unsigned int cpu, val;
+	struct cpumask amask;
+	void __iomem *target;
+
+	if (!priv->nr_idcs)
+		return irq_chip_set_affinity_parent(d, mask_val, force);
+
+	cpumask_and(&amask, &priv->lmask, mask_val);
+
+	if (force)
+		cpu = cpumask_first(&amask);
+	else
+		cpu = cpumask_any_and(&amask, cpu_online_mask);
+
+	if (cpu >= nr_cpu_ids)
+		return -EINVAL;
+
+	idc = per_cpu_ptr(&aplic_idcs, cpu);
+	target = priv->regs + APLIC_TARGET_BASE;
+	target += (d->hwirq - 1) * sizeof(u32);
+	val = idc->hart_index & APLIC_TARGET_HART_IDX_MASK;
+	val <<= APLIC_TARGET_HART_IDX_SHIFT;
+	val |= APLIC_DEFAULT_PRIORITY;
+	writel(val, target);
+
+	irq_data_update_effective_affinity(d, cpumask_of(cpu));
+
+	return IRQ_SET_MASK_OK_DONE;
+}
+#endif
+
+static struct irq_chip aplic_chip = {
+	.name		= "RISC-V APLIC",
+	.irq_mask	= aplic_irq_mask,
+	.irq_unmask	= aplic_irq_unmask,
+	.irq_set_type	= aplic_set_type,
+	.irq_eoi	= aplic_irq_eoi,
+#ifdef CONFIG_SMP
+	.irq_set_affinity = aplic_set_affinity,
+#endif
+	.flags		= IRQCHIP_SET_TYPE_MASKED |
+			  IRQCHIP_SKIP_SET_WAKE |
+			  IRQCHIP_MASK_ON_SUSPEND,
+};
+
+static int aplic_irqdomain_translate(struct irq_domain *d,
+				     struct irq_fwspec *fwspec,
+				     unsigned long *hwirq,
+				     unsigned int *type)
+{
+	if (WARN_ON(fwspec->param_count < 2))
+		return -EINVAL;
+	if (WARN_ON(!fwspec->param[0]))
+		return -EINVAL;
+
+	*hwirq = fwspec->param[0];
+	*type = fwspec->param[1] & IRQ_TYPE_SENSE_MASK;
+
+	WARN_ON(*type == IRQ_TYPE_NONE);
+
+	return 0;
+}
+
+static int aplic_irqdomain_msi_alloc(struct irq_domain *domain,
+				     unsigned int virq, unsigned int nr_irqs,
+				     void *arg)
+{
+	int i, ret;
+	unsigned int type;
+	irq_hw_number_t hwirq;
+	struct irq_fwspec *fwspec = arg;
+	struct aplic_priv *priv = platform_msi_get_host_data(domain);
+
+	ret = aplic_irqdomain_translate(domain, fwspec, &hwirq, &type);
+	if (ret)
+		return ret;
+
+	ret = platform_msi_device_domain_alloc(domain, virq, nr_irqs);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < nr_irqs; i++)
+		irq_domain_set_info(domain, virq + i, hwirq + i,
+				    &aplic_chip, priv, handle_fasteoi_irq,
+				    NULL, NULL);
+
+	return 0;
+}
+
+static const struct irq_domain_ops aplic_irqdomain_msi_ops = {
+	.translate	= aplic_irqdomain_translate,
+	.alloc		= aplic_irqdomain_msi_alloc,
+	.free		= platform_msi_device_domain_free,
+};
+
+static int aplic_irqdomain_idc_alloc(struct irq_domain *domain,
+				     unsigned int virq, unsigned int nr_irqs,
+				     void *arg)
+{
+	int i, ret;
+	unsigned int type;
+	irq_hw_number_t hwirq;
+	struct irq_fwspec *fwspec = arg;
+	struct aplic_priv *priv = domain->host_data;
+
+	ret = aplic_irqdomain_translate(domain, fwspec, &hwirq, &type);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < nr_irqs; i++) {
+		irq_domain_set_info(domain, virq + i, hwirq + i,
+				    &aplic_chip, priv, handle_fasteoi_irq,
+				    NULL, NULL);
+		irq_set_affinity(virq + i, &priv->lmask);
+	}
+
+	return 0;
+}
+
+static const struct irq_domain_ops aplic_irqdomain_idc_ops = {
+	.translate	= aplic_irqdomain_translate,
+	.alloc		= aplic_irqdomain_idc_alloc,
+	.free		= irq_domain_free_irqs_top,
+};
+
+static void aplic_init_hw_irqs(struct aplic_priv *priv)
+{
+	int i;
+
+	/* Disable all interrupts */
+	for (i = 0; i <= priv->nr_irqs; i += 32)
+		writel(-1U, priv->regs + APLIC_CLRIE_BASE +
+			    (i / 32) * sizeof(u32));
+
+	/* Set interrupt type and default priority for all interrupts */
+	for (i = 1; i <= priv->nr_irqs; i++) {
+		writel(0, priv->regs + APLIC_SOURCECFG_BASE +
+			  (i - 1) * sizeof(u32));
+		writel(APLIC_DEFAULT_PRIORITY,
+		       priv->regs + APLIC_TARGET_BASE +
+		       (i - 1) * sizeof(u32));
+	}
+
+	/* Clear APLIC domaincfg */
+	writel(0, priv->regs + APLIC_DOMAINCFG);
+}
+
+static void aplic_init_hw_global(struct aplic_priv *priv)
+{
+	u32 val;
+#ifdef CONFIG_RISCV_M_MODE
+	u32 valH;
+
+	if (!priv->nr_idcs) {
+		val = priv->msicfg.base_ppn;
+		valH = (priv->msicfg.base_ppn >> 32) &
+			APLIC_xMSICFGADDRH_BAPPN_MASK;
+		valH |= (priv->msicfg.lhxw & APLIC_xMSICFGADDRH_LHXW_MASK)
+			<< APLIC_xMSICFGADDRH_LHXW_SHIFT;
+		valH |= (priv->msicfg.hhxw & APLIC_xMSICFGADDRH_HHXW_MASK)
+			<< APLIC_xMSICFGADDRH_HHXW_SHIFT;
+		valH |= (priv->msicfg.lhxs & APLIC_xMSICFGADDRH_LHXS_MASK)
+			<< APLIC_xMSICFGADDRH_LHXS_SHIFT;
+		valH |= (priv->msicfg.hhxs & APLIC_xMSICFGADDRH_HHXS_MASK)
+			<< APLIC_xMSICFGADDRH_HHXS_SHIFT;
+		writel(val, priv->regs + APLIC_xMSICFGADDR);
+		writel(valH, priv->regs + APLIC_xMSICFGADDRH);
+	}
+#endif
+
+	/* Setup APLIC domaincfg register */
+	val = readl(priv->regs + APLIC_DOMAINCFG);
+	val |= APLIC_DOMAINCFG_IE;
+	if (!priv->nr_idcs)
+		val |= APLIC_DOMAINCFG_DM;
+	writel(val, priv->regs + APLIC_DOMAINCFG);
+	if (readl(priv->regs + APLIC_DOMAINCFG) != val)
+		dev_warn(priv->dev,
+			 "unable to write 0x%x in domaincfg\n", val);
+}
+
+static void aplic_msi_write_msg(struct msi_desc *desc, struct msi_msg *msg)
+{
+	unsigned int group_index, hart_index, guest_index, val;
+	struct device *dev = msi_desc_to_dev(desc);
+	struct aplic_priv *priv = dev_get_drvdata(dev);
+	struct irq_data *d = irq_get_irq_data(desc->irq);
+	struct aplic_msicfg *mc = &priv->msicfg;
+	phys_addr_t tppn, tbppn, msg_addr;
+	void __iomem *target;
+
+	/* For zeroed MSI, simply write zero into the target register */
+	if (!msg->address_hi && !msg->address_lo && !msg->data) {
+		target = priv->regs + APLIC_TARGET_BASE;
+		target += (d->hwirq - 1) * sizeof(u32);
+		writel(0, target);
+		return;
+	}
+
+	/* Sanity check on message data */
+	WARN_ON(msg->data > APLIC_TARGET_EIID_MASK);
+
+	/* Compute target MSI address */
+	msg_addr = (((u64)msg->address_hi) << 32) | msg->address_lo;
+	tppn = msg_addr >> APLIC_xMSICFGADDR_PPN_SHIFT;
+
+	/* Compute target HART Base PPN */
+	tbppn = tppn;
+	tbppn &= ~APLIC_xMSICFGADDR_PPN_HART(mc->lhxs);
+	tbppn &= ~APLIC_xMSICFGADDR_PPN_LHX(mc->lhxw, mc->lhxs);
+	tbppn &= ~APLIC_xMSICFGADDR_PPN_HHX(mc->hhxw, mc->hhxs);
+	WARN_ON(tbppn != mc->base_ppn);
+
+	/* Compute target group and hart indexes */
+	group_index = (tppn >> APLIC_xMSICFGADDR_PPN_HHX_SHIFT(mc->hhxs)) &
+		     APLIC_xMSICFGADDR_PPN_HHX_MASK(mc->hhxw);
+	hart_index = (tppn >> APLIC_xMSICFGADDR_PPN_LHX_SHIFT(mc->lhxs)) &
+		     APLIC_xMSICFGADDR_PPN_LHX_MASK(mc->lhxw);
+	hart_index |= (group_index << mc->lhxw);
+	WARN_ON(hart_index > APLIC_TARGET_HART_IDX_MASK);
+
+	/* Compute target guest index */
+	guest_index = tppn & APLIC_xMSICFGADDR_PPN_HART(mc->lhxs);
+	WARN_ON(guest_index > APLIC_TARGET_GUEST_IDX_MASK);
+
+	/* Update IRQ TARGET register */
+	target = priv->regs + APLIC_TARGET_BASE;
+	target += (d->hwirq - 1) * sizeof(u32);
+	val = (hart_index & APLIC_TARGET_HART_IDX_MASK)
+				<< APLIC_TARGET_HART_IDX_SHIFT;
+	val |= (guest_index & APLIC_TARGET_GUEST_IDX_MASK)
+				<< APLIC_TARGET_GUEST_IDX_SHIFT;
+	val |= (msg->data & APLIC_TARGET_EIID_MASK);
+	writel(val, target);
+}
+
+static int aplic_setup_msi(struct aplic_priv *priv)
+{
+	struct device *dev = priv->dev;
+	struct aplic_msicfg *mc = &priv->msicfg;
+	const struct imsic_global_config *imsic_global;
+
+	/*
+	 * The APLIC outgoing MSI config registers assume target MSI
+	 * controller to be RISC-V AIA IMSIC controller.
+	 */
+	imsic_global = imsic_get_global_config();
+	if (!imsic_global) {
+		dev_err(dev, "IMSIC global config not found\n");
+		return -ENODEV;
+	}
+
+	/* Find number of guest index bits (LHXS) */
+	mc->lhxs = imsic_global->guest_index_bits;
+	if (APLIC_xMSICFGADDRH_LHXS_MASK < mc->lhxs) {
+		dev_err(dev, "IMSIC guest index bits big for APLIC LHXS\n");
+		return -EINVAL;
+	}
+
+	/* Find number of HART index bits (LHXW) */
+	mc->lhxw = imsic_global->hart_index_bits;
+	if (APLIC_xMSICFGADDRH_LHXW_MASK < mc->lhxw) {
+		dev_err(dev, "IMSIC hart index bits big for APLIC LHXW\n");
+		return -EINVAL;
+	}
+
+	/* Find number of group index bits (HHXW) */
+	mc->hhxw = imsic_global->group_index_bits;
+	if (APLIC_xMSICFGADDRH_HHXW_MASK < mc->hhxw) {
+		dev_err(dev, "IMSIC group index bits big for APLIC HHXW\n");
+		return -EINVAL;
+	}
+
+	/* Find first bit position of group index (HHXS) */
+	mc->hhxs = imsic_global->group_index_shift;
+	if (mc->hhxs < (2 * APLIC_xMSICFGADDR_PPN_SHIFT)) {
+		dev_err(dev, "IMSIC group index shift should be >= %d\n",
+			(2 * APLIC_xMSICFGADDR_PPN_SHIFT));
+		return -EINVAL;
+	}
+	mc->hhxs -= (2 * APLIC_xMSICFGADDR_PPN_SHIFT);
+	if (APLIC_xMSICFGADDRH_HHXS_MASK < mc->hhxs) {
+		dev_err(dev, "IMSIC group index shift big for APLIC HHXS\n");
+		return -EINVAL;
+	}
+
+	/* Compute PPN base */
+	mc->base_ppn = imsic_global->base_addr >> APLIC_xMSICFGADDR_PPN_SHIFT;
+	mc->base_ppn &= ~APLIC_xMSICFGADDR_PPN_HART(mc->lhxs);
+	mc->base_ppn &= ~APLIC_xMSICFGADDR_PPN_LHX(mc->lhxw, mc->lhxs);
+	mc->base_ppn &= ~APLIC_xMSICFGADDR_PPN_HHX(mc->hhxw, mc->hhxs);
+
+	/* Use all possible CPUs as lmask */
+	cpumask_copy(&priv->lmask, cpu_possible_mask);
+
+	return 0;
+}
+
+/*
+ * To handle an APLIC IDC interrupts, we just read the CLAIMI register
+ * which will return highest priority pending interrupt and clear the
+ * pending bit of the interrupt. This process is repeated until CLAIMI
+ * register return zero value.
+ */
+static void aplic_idc_handle_irq(struct irq_desc *desc)
+{
+	struct aplic_idc *idc = this_cpu_ptr(&aplic_idcs);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	irq_hw_number_t hw_irq;
+	int irq;
+
+	chained_irq_enter(chip, desc);
+
+	while ((hw_irq = readl(idc->regs + APLIC_IDC_CLAIMI))) {
+		hw_irq = hw_irq >> APLIC_IDC_TOPI_ID_SHIFT;
+		irq = irq_find_mapping(idc->priv->irqdomain, hw_irq);
+
+		if (unlikely(irq <= 0))
+			pr_warn_ratelimited("hw_irq %lu mapping not found\n",
+					    hw_irq);
+		else
+			generic_handle_irq(irq);
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static void aplic_idc_set_delivery(struct aplic_idc *idc, bool en)
+{
+	u32 de = (en) ? APLIC_ENABLE_IDELIVERY : APLIC_DISABLE_IDELIVERY;
+	u32 th = (en) ? APLIC_ENABLE_ITHRESHOLD : APLIC_DISABLE_ITHRESHOLD;
+
+	/* Priority must be less than threshold for interrupt triggering */
+	writel(th, idc->regs + APLIC_IDC_ITHRESHOLD);
+
+	/* Delivery must be set to 1 for interrupt triggering */
+	writel(de, idc->regs + APLIC_IDC_IDELIVERY);
+}
+
+static int aplic_idc_dying_cpu(unsigned int cpu)
+{
+	if (aplic_idc_parent_irq)
+		disable_percpu_irq(aplic_idc_parent_irq);
+
+	return 0;
+}
+
+static int aplic_idc_starting_cpu(unsigned int cpu)
+{
+	if (aplic_idc_parent_irq)
+		enable_percpu_irq(aplic_idc_parent_irq,
+				  irq_get_trigger_type(aplic_idc_parent_irq));
+
+	return 0;
+}
+
+static int aplic_setup_idc(struct aplic_priv *priv)
+{
+	int i, j, rc, cpu, setup_count = 0;
+	struct device_node *node = priv->dev->of_node;
+	struct device *dev = priv->dev;
+	struct of_phandle_args parent;
+	struct irq_domain *domain;
+	unsigned long hartid;
+	struct aplic_idc *idc;
+	u32 val;
+
+	/* Setup per-CPU IDC and target CPU mask */
+	for (i = 0; i < priv->nr_idcs; i++) {
+		if (of_irq_parse_one(node, i, &parent)) {
+			dev_err(dev, "failed to parse parent for IDC%d.\n",
+				i);
+			return -EIO;
+		}
+
+		/* Skip IDCs which do not connect to external interrupts */
+		if (parent.args[0] != RV_IRQ_EXT)
+			continue;
+
+		rc = riscv_of_parent_hartid(parent.np, &hartid);
+		if (rc) {
+			dev_err(dev, "failed to parse hart ID for IDC%d.\n",
+				i);
+			return rc;
+		}
+
+		cpu = riscv_hartid_to_cpuid(hartid);
+		if (cpu < 0) {
+			dev_warn(dev, "invalid cpuid for IDC%d\n", i);
+			continue;
+		}
+
+		cpumask_set_cpu(cpu, &priv->lmask);
+
+		idc = per_cpu_ptr(&aplic_idcs, cpu);
+		WARN_ON(idc->priv);
+
+		idc->hart_index = i;
+		idc->regs = priv->regs + APLIC_IDC_BASE + i * APLIC_IDC_SIZE;
+		idc->priv = priv;
+
+		aplic_idc_set_delivery(idc, true);
+
+		/*
+		 * Boot cpu might not have APLIC hart_index = 0 so check
+		 * and update target registers of all interrupts.
+		 */
+		if (cpu == smp_processor_id() && idc->hart_index) {
+			val = idc->hart_index & APLIC_TARGET_HART_IDX_MASK;
+			val <<= APLIC_TARGET_HART_IDX_SHIFT;
+			val |= APLIC_DEFAULT_PRIORITY;
+			for (j = 1; j <= priv->nr_irqs; j++)
+				writel(val, priv->regs + APLIC_TARGET_BASE +
+					    (j - 1) * sizeof(u32));
+		}
+
+		setup_count++;
+	}
+
+	/* Find parent domain and register chained handler */
+	domain = irq_find_matching_fwnode(riscv_get_intc_hwnode(),
+					  DOMAIN_BUS_ANY);
+	if (!aplic_idc_parent_irq && domain) {
+		aplic_idc_parent_irq = irq_create_mapping(domain, RV_IRQ_EXT);
+		if (aplic_idc_parent_irq) {
+			irq_set_chained_handler(aplic_idc_parent_irq,
+						aplic_idc_handle_irq);
+
+			/*
+			 * Setup CPUHP notifier to enable IDC parent
+			 * interrupt on all CPUs
+			 */
+			cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,
+					  "irqchip/riscv/aplic:starting",
+					  aplic_idc_starting_cpu,
+					  aplic_idc_dying_cpu);
+		}
+	}
+
+	/* Fail if we were not able to setup IDC for any CPU */
+	return (setup_count) ? 0 : -ENODEV;
+}
+
+static int aplic_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct device *dev = &pdev->dev;
+	struct aplic_priv *priv;
+	struct resource *regs;
+	phys_addr_t pa;
+	int rc;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs) {
+		dev_err(dev, "cannot find registers resource\n");
+		return -ENOENT;
+	}
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, priv);
+	priv->dev = dev;
+
+	priv->regs = devm_ioremap(dev, regs->start, resource_size(regs));
+	if (WARN_ON(!priv->regs)) {
+		dev_err(dev, "failed ioremap registers\n");
+		return -EIO;
+	}
+
+	of_property_read_u32(node, "riscv,num-sources", &priv->nr_irqs);
+	if (!priv->nr_irqs) {
+		dev_err(dev, "failed to get number of interrupt sources\n");
+		return -EINVAL;
+	}
+
+	/* Setup initial state APLIC interrupts */
+	aplic_init_hw_irqs(priv);
+
+	/*
+	 * Setup IDCs or MSIs based on parent interrupts in DT node
+	 *
+	 * If "msi-parent" DT property is present then we ignore the
+	 * APLIC IDCs which forces the APLIC driver to use MSI mode.
+	 */
+	priv->nr_idcs = of_property_read_bool(node, "msi-parent") ?
+			0 : of_irq_count(node);
+	if (priv->nr_idcs)
+		rc = aplic_setup_idc(priv);
+	else
+		rc = aplic_setup_msi(priv);
+	if (rc)
+		return rc;
+
+	/* Setup global config and interrupt delivery */
+	aplic_init_hw_global(priv);
+
+	/* Create irq domain instance for the APLIC */
+	if (priv->nr_idcs)
+		priv->irqdomain = irq_domain_create_linear(
+						of_node_to_fwnode(node),
+						priv->nr_irqs + 1,
+						&aplic_irqdomain_idc_ops,
+						priv);
+	else
+		priv->irqdomain = platform_msi_create_device_domain(dev,
+						priv->nr_irqs + 1,
+						aplic_msi_write_msg,
+						&aplic_irqdomain_msi_ops,
+						priv);
+	if (!priv->irqdomain) {
+		dev_err(dev, "failed to add irq domain\n");
+		return -ENOMEM;
+	}
+
+	/* Advertise the interrupt controller */
+	if (priv->nr_idcs) {
+		dev_info(dev, "%d interrupts directly connected to %d CPUs\n",
+			 priv->nr_irqs, priv->nr_idcs);
+	} else {
+		pa = priv->msicfg.base_ppn << APLIC_xMSICFGADDR_PPN_SHIFT;
+		dev_info(dev, "%d interrupts forwared to MSI base %pa\n",
+			 priv->nr_irqs, &pa);
+	}
+
+	return 0;
+}
+
+static int aplic_remove(struct platform_device *pdev)
+{
+	struct aplic_priv *priv = platform_get_drvdata(pdev);
+
+	irq_domain_remove(priv->irqdomain);
+
+	return 0;
+}
+
+static const struct of_device_id aplic_match[] = {
+	{ .compatible = "riscv,aplic" },
+	{}
+};
+
+static struct platform_driver aplic_driver = {
+	.driver = {
+		.name		= "riscv-aplic",
+		.of_match_table	= aplic_match,
+	},
+	.probe = aplic_probe,
+	.remove = aplic_remove,
+};
+
+static int __init aplic_init(void)
+{
+	return platform_driver_register(&aplic_driver);
+}
+core_initcall(aplic_init);
diff --git a/drivers/irqchip/irq-riscv-imsic.c b/drivers/irqchip/irq-riscv-imsic.c
new file mode 100644
index 000000000000..4c16b66738d6
--- /dev/null
+++ b/drivers/irqchip/irq-riscv-imsic.c
@@ -0,0 +1,1174 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 Western Digital Corporation or its affiliates.
+ * Copyright (C) 2022 Ventana Micro Systems Inc.
+ */
+
+#define pr_fmt(fmt) "riscv-imsic: " fmt
+#include <linux/bitmap.h>
+#include <linux/cpu.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/iommu.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/irqchip/riscv-imsic.h>
+#include <linux/irqdomain.h>
+#include <linux/module.h>
+#include <linux/msi.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/smp.h>
+#include <asm/hwcap.h>
+
+#define IMSIC_DISABLE_EIDELIVERY	0
+#define IMSIC_ENABLE_EIDELIVERY		1
+#define IMSIC_DISABLE_EITHRESHOLD	1
+#define IMSIC_ENABLE_EITHRESHOLD	0
+
+#define imsic_csr_write(__c, __v)	\
+do {					\
+	csr_write(CSR_ISELECT, __c);	\
+	csr_write(CSR_IREG, __v);	\
+} while (0)
+
+#define imsic_csr_read(__c)		\
+({					\
+	unsigned long __v;		\
+	csr_write(CSR_ISELECT, __c);	\
+	__v = csr_read(CSR_IREG);	\
+	__v;				\
+})
+
+#define imsic_csr_set(__c, __v)		\
+do {					\
+	csr_write(CSR_ISELECT, __c);	\
+	csr_set(CSR_IREG, __v);		\
+} while (0)
+
+#define imsic_csr_clear(__c, __v)	\
+do {					\
+	csr_write(CSR_ISELECT, __c);	\
+	csr_clear(CSR_IREG, __v);	\
+} while (0)
+
+struct imsic_mmio {
+	phys_addr_t pa;
+	void __iomem *va;
+	unsigned long size;
+};
+
+struct imsic_priv {
+	/* Global configuration common for all HARTs */
+	struct imsic_global_config global;
+
+	/* MMIO regions */
+	u32 num_mmios;
+	struct imsic_mmio *mmios;
+
+	/* Global state of interrupt identities */
+	raw_spinlock_t ids_lock;
+	unsigned long *ids_used_bimap;
+	unsigned long *ids_enabled_bimap;
+	unsigned int *ids_target_cpu;
+
+	/* Mask for connected CPUs */
+	struct cpumask lmask;
+
+	/* IPI interrupt identity */
+	u32 ipi_id;
+	u32 ipi_lsync_id;
+
+	/* IRQ domains */
+	struct irq_domain *base_domain;
+	struct irq_domain *pci_domain;
+	struct irq_domain *plat_domain;
+};
+
+struct imsic_handler {
+	/* Local configuration for given HART */
+	struct imsic_local_config local;
+
+	/* Pointer to private context */
+	struct imsic_priv *priv;
+};
+
+static bool imsic_init_done;
+
+static int imsic_parent_irq;
+static DEFINE_PER_CPU(struct imsic_handler, imsic_handlers);
+
+const struct imsic_global_config *imsic_get_global_config(void)
+{
+	struct imsic_handler *handler = this_cpu_ptr(&imsic_handlers);
+
+	if (!handler || !handler->priv)
+		return NULL;
+
+	return &handler->priv->global;
+}
+EXPORT_SYMBOL_GPL(imsic_get_global_config);
+
+const struct imsic_local_config *imsic_get_local_config(unsigned int cpu)
+{
+	struct imsic_handler *handler = per_cpu_ptr(&imsic_handlers, cpu);
+
+	if (!handler || !handler->priv)
+		return NULL;
+
+	return &handler->local;
+}
+EXPORT_SYMBOL_GPL(imsic_get_local_config);
+
+static int imsic_cpu_page_phys(unsigned int cpu,
+			       unsigned int guest_index,
+			       phys_addr_t *out_msi_pa)
+{
+	struct imsic_handler *handler = per_cpu_ptr(&imsic_handlers, cpu);
+	struct imsic_global_config *global;
+	struct imsic_local_config *local;
+
+	if (!handler || !handler->priv)
+		return -ENODEV;
+	local = &handler->local;
+	global = &handler->priv->global;
+
+	if (BIT(global->guest_index_bits) <= guest_index)
+		return -EINVAL;
+
+	if (out_msi_pa)
+		*out_msi_pa = local->msi_pa +
+			      (guest_index * IMSIC_MMIO_PAGE_SZ);
+
+	return 0;
+}
+
+static int imsic_get_cpu(struct imsic_priv *priv,
+			 const struct cpumask *mask_val, bool force,
+			 unsigned int *out_target_cpu)
+{
+	struct cpumask amask;
+	unsigned int cpu;
+
+	cpumask_and(&amask, &priv->lmask, mask_val);
+
+	if (force)
+		cpu = cpumask_first(&amask);
+	else
+		cpu = cpumask_any_and(&amask, cpu_online_mask);
+
+	if (cpu >= nr_cpu_ids)
+		return -EINVAL;
+
+	if (out_target_cpu)
+		*out_target_cpu = cpu;
+
+	return 0;
+}
+
+static int imsic_get_cpu_msi_msg(unsigned int cpu, unsigned int id,
+				 struct msi_msg *msg)
+{
+	phys_addr_t msi_addr;
+	int err;
+
+	err = imsic_cpu_page_phys(cpu, 0, &msi_addr);
+	if (err)
+		return err;
+
+	msg->address_hi = upper_32_bits(msi_addr);
+	msg->address_lo = lower_32_bits(msi_addr);
+	msg->data = id;
+
+	return err;
+}
+
+static void imsic_id_set_target(struct imsic_priv *priv,
+				 unsigned int id, unsigned int target_cpu)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&priv->ids_lock, flags);
+	priv->ids_target_cpu[id] = target_cpu;
+	raw_spin_unlock_irqrestore(&priv->ids_lock, flags);
+}
+
+static unsigned int imsic_id_get_target(struct imsic_priv *priv,
+					unsigned int id)
+{
+	unsigned int ret;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&priv->ids_lock, flags);
+	ret = priv->ids_target_cpu[id];
+	raw_spin_unlock_irqrestore(&priv->ids_lock, flags);
+
+	return ret;
+}
+
+static void __imsic_eix_update(unsigned long base_id,
+			       unsigned long num_id, bool pend, bool val)
+{
+	unsigned long i, isel, ireg, flags;
+	unsigned long id = base_id, last_id = base_id + num_id;
+
+	while (id < last_id) {
+		isel = id / BITS_PER_LONG;
+		isel *= BITS_PER_LONG / IMSIC_EIPx_BITS;
+		isel += (pend) ? IMSIC_EIP0 : IMSIC_EIE0;
+
+		ireg = 0;
+		for (i = id & (__riscv_xlen - 1);
+		     (id < last_id) && (i < __riscv_xlen); i++) {
+			ireg |= BIT(i);
+			id++;
+		}
+
+		/*
+		 * The IMSIC EIEx and EIPx registers are indirectly
+		 * accessed via using ISELECT and IREG CSRs so we
+		 * save/restore local IRQ to ensure that we don't
+		 * get preempted while accessing IMSIC registers.
+		 */
+		local_irq_save(flags);
+		if (val)
+			imsic_csr_set(isel, ireg);
+		else
+			imsic_csr_clear(isel, ireg);
+		local_irq_restore(flags);
+	}
+}
+
+#define __imsic_id_enable(__id)		\
+	__imsic_eix_update((__id), 1, false, true)
+#define __imsic_id_disable(__id)	\
+	__imsic_eix_update((__id), 1, false, false)
+
+#ifdef CONFIG_SMP
+static void __imsic_id_smp_sync(struct imsic_priv *priv)
+{
+	struct imsic_handler *handler;
+	struct cpumask amask;
+	int cpu;
+
+	cpumask_and(&amask, &priv->lmask, cpu_online_mask);
+	for_each_cpu(cpu, &amask) {
+		if (cpu == smp_processor_id())
+			continue;
+
+		handler = per_cpu_ptr(&imsic_handlers, cpu);
+		if (!handler || !handler->priv || !handler->local.msi_va) {
+			pr_warn("CPU%d: handler not initialized\n", cpu);
+			continue;
+		}
+
+		writel(handler->priv->ipi_lsync_id, handler->local.msi_va);
+	}
+}
+#else
+#define __imsic_id_smp_sync(__priv)
+#endif
+
+static void imsic_id_enable(struct imsic_priv *priv, unsigned int id)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&priv->ids_lock, flags);
+	bitmap_set(priv->ids_enabled_bimap, id, 1);
+	__imsic_id_enable(id);
+	raw_spin_unlock_irqrestore(&priv->ids_lock, flags);
+
+	__imsic_id_smp_sync(priv);
+}
+
+static void imsic_id_disable(struct imsic_priv *priv, unsigned int id)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&priv->ids_lock, flags);
+	bitmap_clear(priv->ids_enabled_bimap, id, 1);
+	__imsic_id_disable(id);
+	raw_spin_unlock_irqrestore(&priv->ids_lock, flags);
+
+	__imsic_id_smp_sync(priv);
+}
+
+static void imsic_ids_local_sync(struct imsic_priv *priv)
+{
+	int i;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&priv->ids_lock, flags);
+	for (i = 1; i <= priv->global.nr_ids; i++) {
+		if (priv->ipi_id == i || priv->ipi_lsync_id == i)
+			continue;
+
+		if (test_bit(i, priv->ids_enabled_bimap))
+			__imsic_id_enable(i);
+		else
+			__imsic_id_disable(i);
+	}
+	raw_spin_unlock_irqrestore(&priv->ids_lock, flags);
+}
+
+static void imsic_ids_local_delivery(struct imsic_priv *priv, bool enable)
+{
+	if (enable) {
+		imsic_csr_write(IMSIC_EITHRESHOLD, IMSIC_ENABLE_EITHRESHOLD);
+		imsic_csr_write(IMSIC_EIDELIVERY, IMSIC_ENABLE_EIDELIVERY);
+	} else {
+		imsic_csr_write(IMSIC_EIDELIVERY, IMSIC_DISABLE_EIDELIVERY);
+		imsic_csr_write(IMSIC_EITHRESHOLD, IMSIC_DISABLE_EITHRESHOLD);
+	}
+}
+
+static int imsic_ids_alloc(struct imsic_priv *priv,
+			   unsigned int max_id, unsigned int order)
+{
+	int ret;
+	unsigned long flags;
+
+	if ((priv->global.nr_ids < max_id) ||
+	    (max_id < BIT(order)))
+		return -EINVAL;
+
+	raw_spin_lock_irqsave(&priv->ids_lock, flags);
+	ret = bitmap_find_free_region(priv->ids_used_bimap,
+				      max_id + 1, order);
+	raw_spin_unlock_irqrestore(&priv->ids_lock, flags);
+
+	return ret;
+}
+
+static void imsic_ids_free(struct imsic_priv *priv, unsigned int base_id,
+			   unsigned int order)
+{
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&priv->ids_lock, flags);
+	bitmap_release_region(priv->ids_used_bimap, base_id, order);
+	raw_spin_unlock_irqrestore(&priv->ids_lock, flags);
+}
+
+static int __init imsic_ids_init(struct imsic_priv *priv)
+{
+	int i;
+	struct imsic_global_config *global = &priv->global;
+
+	raw_spin_lock_init(&priv->ids_lock);
+
+	/* Allocate used bitmap */
+	priv->ids_used_bimap = kcalloc(BITS_TO_LONGS(global->nr_ids + 1),
+					sizeof(unsigned long), GFP_KERNEL);
+	if (!priv->ids_used_bimap)
+		return -ENOMEM;
+
+	/* Allocate enabled bitmap */
+	priv->ids_enabled_bimap = kcalloc(BITS_TO_LONGS(global->nr_ids + 1),
+					   sizeof(unsigned long), GFP_KERNEL);
+	if (!priv->ids_enabled_bimap) {
+		kfree(priv->ids_used_bimap);
+		return -ENOMEM;
+	}
+
+	/* Allocate target CPU array */
+	priv->ids_target_cpu = kcalloc(global->nr_ids + 1,
+				       sizeof(unsigned int), GFP_KERNEL);
+	if (!priv->ids_target_cpu) {
+		kfree(priv->ids_enabled_bimap);
+		kfree(priv->ids_used_bimap);
+		return -ENOMEM;
+	}
+	for (i = 0; i <= global->nr_ids; i++)
+		priv->ids_target_cpu[i] = UINT_MAX;
+
+	/* Reserve ID#0 because it is special and never implemented */
+	bitmap_set(priv->ids_used_bimap, 0, 1);
+
+	return 0;
+}
+
+static void __init imsic_ids_cleanup(struct imsic_priv *priv)
+{
+	kfree(priv->ids_target_cpu);
+	kfree(priv->ids_enabled_bimap);
+	kfree(priv->ids_used_bimap);
+}
+
+#ifdef CONFIG_SMP
+static void imsic_ipi_send(unsigned int cpu)
+{
+	struct imsic_handler *handler = per_cpu_ptr(&imsic_handlers, cpu);
+
+	if (!handler || !handler->priv || !handler->local.msi_va) {
+		pr_warn("CPU%d: handler not initialized\n", cpu);
+		return;
+	}
+
+	writel(handler->priv->ipi_id, handler->local.msi_va);
+}
+
+static void imsic_ipi_enable(struct imsic_priv *priv)
+{
+	__imsic_id_enable(priv->ipi_id);
+	__imsic_id_enable(priv->ipi_lsync_id);
+}
+
+static int __init imsic_ipi_domain_init(struct imsic_priv *priv)
+{
+	int virq;
+
+	/* Allocate interrupt identity for IPIs */
+	virq = imsic_ids_alloc(priv, priv->global.nr_ids, get_count_order(1));
+	if (virq < 0)
+		return virq;
+	priv->ipi_id = virq;
+
+	/* Create IMSIC IPI multiplexing */
+	virq = ipi_mux_create(BITS_PER_BYTE, imsic_ipi_send);
+	if (virq <= 0) {
+		imsic_ids_free(priv, priv->ipi_id, get_count_order(1));
+		return (virq < 0) ? virq : -ENOMEM;
+	}
+
+	/* Set vIRQ range */
+	riscv_ipi_set_virq_range(virq, BITS_PER_BYTE, true);
+
+	/* Allocate interrupt identity for local enable/disable sync */
+	virq = imsic_ids_alloc(priv, priv->global.nr_ids, get_count_order(1));
+	if (virq < 0) {
+		imsic_ids_free(priv, priv->ipi_id, get_count_order(1));
+		return virq;
+	}
+	priv->ipi_lsync_id = virq;
+
+	return 0;
+}
+
+static void __init imsic_ipi_domain_cleanup(struct imsic_priv *priv)
+{
+	imsic_ids_free(priv, priv->ipi_lsync_id, get_count_order(1));
+	if (priv->ipi_id)
+		imsic_ids_free(priv, priv->ipi_id, get_count_order(1));
+}
+#else
+static void imsic_ipi_enable(struct imsic_priv *priv)
+{
+}
+
+static int __init imsic_ipi_domain_init(struct imsic_priv *priv)
+{
+	/* Clear the IPI ids because we are not using IPIs */
+	priv->ipi_id = 0;
+	priv->ipi_lsync_id = 0;
+	return 0;
+}
+
+static void __init imsic_ipi_domain_cleanup(struct imsic_priv *priv)
+{
+}
+#endif
+
+static void imsic_irq_mask(struct irq_data *d)
+{
+	imsic_id_disable(irq_data_get_irq_chip_data(d), d->hwirq);
+}
+
+static void imsic_irq_unmask(struct irq_data *d)
+{
+	imsic_id_enable(irq_data_get_irq_chip_data(d), d->hwirq);
+}
+
+static void imsic_irq_compose_msi_msg(struct irq_data *d,
+				      struct msi_msg *msg)
+{
+	struct imsic_priv *priv = irq_data_get_irq_chip_data(d);
+	unsigned int cpu;
+	int err;
+
+	cpu = imsic_id_get_target(priv, d->hwirq);
+	WARN_ON(cpu == UINT_MAX);
+
+	err = imsic_get_cpu_msi_msg(cpu, d->hwirq, msg);
+	WARN_ON(err);
+
+	iommu_dma_compose_msi_msg(irq_data_get_msi_desc(d), msg);
+}
+
+#ifdef CONFIG_SMP
+static int imsic_irq_set_affinity(struct irq_data *d,
+				  const struct cpumask *mask_val,
+				  bool force)
+{
+	struct imsic_priv *priv = irq_data_get_irq_chip_data(d);
+	unsigned int target_cpu;
+	int rc;
+
+	rc = imsic_get_cpu(priv, mask_val, force, &target_cpu);
+	if (rc)
+		return rc;
+
+	imsic_id_set_target(priv, d->hwirq, target_cpu);
+	irq_data_update_effective_affinity(d, cpumask_of(target_cpu));
+
+	return IRQ_SET_MASK_OK;
+}
+#endif
+
+static struct irq_chip imsic_irq_base_chip = {
+	.name			= "RISC-V IMSIC-BASE",
+	.irq_mask		= imsic_irq_mask,
+	.irq_unmask		= imsic_irq_unmask,
+#ifdef CONFIG_SMP
+	.irq_set_affinity	= imsic_irq_set_affinity,
+#endif
+	.irq_compose_msi_msg	= imsic_irq_compose_msi_msg,
+	.flags			= IRQCHIP_SKIP_SET_WAKE |
+				  IRQCHIP_MASK_ON_SUSPEND,
+};
+
+static int imsic_irq_domain_alloc(struct irq_domain *domain,
+				  unsigned int virq,
+				  unsigned int nr_irqs,
+				  void *args)
+{
+	struct imsic_priv *priv = domain->host_data;
+	msi_alloc_info_t *info = args;
+	phys_addr_t msi_addr;
+	int i, hwirq, err = 0;
+	unsigned int cpu;
+
+	err = imsic_get_cpu(priv, &priv->lmask, false, &cpu);
+	if (err)
+		return err;
+
+	err = imsic_cpu_page_phys(cpu, 0, &msi_addr);
+	if (err)
+		return err;
+
+	hwirq = imsic_ids_alloc(priv, priv->global.nr_ids,
+				get_count_order(nr_irqs));
+	if (hwirq < 0)
+		return hwirq;
+
+	err = iommu_dma_prepare_msi(info->desc, msi_addr);
+	if (err)
+		goto fail;
+
+	for (i = 0; i < nr_irqs; i++) {
+		imsic_id_set_target(priv, hwirq + i, cpu);
+		irq_domain_set_info(domain, virq + i, hwirq + i,
+				    &imsic_irq_base_chip, priv,
+				    handle_simple_irq, NULL, NULL);
+		irq_set_noprobe(virq + i);
+		irq_set_affinity(virq + i, &priv->lmask);
+	}
+
+	return 0;
+
+fail:
+	imsic_ids_free(priv, hwirq, get_count_order(nr_irqs));
+	return err;
+}
+
+static void imsic_irq_domain_free(struct irq_domain *domain,
+				  unsigned int virq,
+				  unsigned int nr_irqs)
+{
+	struct irq_data *d = irq_domain_get_irq_data(domain, virq);
+	struct imsic_priv *priv = domain->host_data;
+
+	imsic_ids_free(priv, d->hwirq, get_count_order(nr_irqs));
+	irq_domain_free_irqs_parent(domain, virq, nr_irqs);
+}
+
+static const struct irq_domain_ops imsic_base_domain_ops = {
+	.alloc		= imsic_irq_domain_alloc,
+	.free		= imsic_irq_domain_free,
+};
+
+#ifdef CONFIG_RISCV_IMSIC_PCI
+
+static void imsic_pci_mask_irq(struct irq_data *d)
+{
+	pci_msi_mask_irq(d);
+	irq_chip_mask_parent(d);
+}
+
+static void imsic_pci_unmask_irq(struct irq_data *d)
+{
+	pci_msi_unmask_irq(d);
+	irq_chip_unmask_parent(d);
+}
+
+static struct irq_chip imsic_pci_irq_chip = {
+	.name			= "RISC-V IMSIC-PCI",
+	.irq_mask		= imsic_pci_mask_irq,
+	.irq_unmask		= imsic_pci_unmask_irq,
+	.irq_eoi		= irq_chip_eoi_parent,
+};
+
+static struct msi_domain_ops imsic_pci_domain_ops = {
+};
+
+static struct msi_domain_info imsic_pci_domain_info = {
+	.flags	= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
+		   MSI_FLAG_PCI_MSIX | MSI_FLAG_MULTI_PCI_MSI),
+	.ops	= &imsic_pci_domain_ops,
+	.chip	= &imsic_pci_irq_chip,
+};
+
+#endif
+
+static struct irq_chip imsic_plat_irq_chip = {
+	.name			= "RISC-V IMSIC-PLAT",
+};
+
+static struct msi_domain_ops imsic_plat_domain_ops = {
+};
+
+static struct msi_domain_info imsic_plat_domain_info = {
+	.flags	= (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS),
+	.ops	= &imsic_plat_domain_ops,
+	.chip	= &imsic_plat_irq_chip,
+};
+
+static int __init imsic_irq_domains_init(struct imsic_priv *priv,
+					 struct fwnode_handle *fwnode)
+{
+	/* Create Base IRQ domain */
+	priv->base_domain = irq_domain_create_tree(fwnode,
+						&imsic_base_domain_ops, priv);
+	if (!priv->base_domain) {
+		pr_err("Failed to create IMSIC base domain\n");
+		return -ENOMEM;
+	}
+	irq_domain_update_bus_token(priv->base_domain, DOMAIN_BUS_NEXUS);
+
+#ifdef CONFIG_RISCV_IMSIC_PCI
+	/* Create PCI MSI domain */
+	priv->pci_domain = pci_msi_create_irq_domain(fwnode,
+						&imsic_pci_domain_info,
+						priv->base_domain);
+	if (!priv->pci_domain) {
+		pr_err("Failed to create IMSIC PCI domain\n");
+		irq_domain_remove(priv->base_domain);
+		return -ENOMEM;
+	}
+#endif
+
+	/* Create Platform MSI domain */
+	priv->plat_domain = platform_msi_create_irq_domain(fwnode,
+						&imsic_plat_domain_info,
+						priv->base_domain);
+	if (!priv->plat_domain) {
+		pr_err("Failed to create IMSIC platform domain\n");
+		if (priv->pci_domain)
+			irq_domain_remove(priv->pci_domain);
+		irq_domain_remove(priv->base_domain);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/*
+ * To handle an interrupt, we read the TOPEI CSR and write zero in one
+ * instruction. If TOPEI CSR is non-zero then we translate TOPEI.ID to
+ * Linux interrupt number and let Linux IRQ subsystem handle it.
+ */
+static void imsic_handle_irq(struct irq_desc *desc)
+{
+	struct imsic_handler *handler = this_cpu_ptr(&imsic_handlers);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct imsic_priv *priv = handler->priv;
+	irq_hw_number_t hwirq;
+	int err;
+
+	WARN_ON_ONCE(!handler->priv);
+
+	chained_irq_enter(chip, desc);
+
+	while ((hwirq = csr_swap(CSR_TOPEI, 0))) {
+		hwirq = hwirq >> TOPEI_ID_SHIFT;
+
+		if (hwirq == priv->ipi_id) {
+#ifdef CONFIG_SMP
+			ipi_mux_process();
+#endif
+			continue;
+		} else if (hwirq == priv->ipi_lsync_id) {
+			imsic_ids_local_sync(priv);
+			continue;
+		}
+
+		err = generic_handle_domain_irq(priv->base_domain, hwirq);
+		if (unlikely(err))
+			pr_warn_ratelimited(
+				"hwirq %lu mapping not found\n", hwirq);
+	}
+
+	chained_irq_exit(chip, desc);
+}
+
+static int imsic_starting_cpu(unsigned int cpu)
+{
+	struct imsic_handler *handler = this_cpu_ptr(&imsic_handlers);
+	struct imsic_priv *priv = handler->priv;
+
+	/* Enable per-CPU parent interrupt */
+	if (imsic_parent_irq)
+		enable_percpu_irq(imsic_parent_irq,
+				  irq_get_trigger_type(imsic_parent_irq));
+	else
+		pr_warn("cpu%d: parent irq not available\n", cpu);
+
+	/* Enable IPIs */
+	imsic_ipi_enable(priv);
+
+	/*
+	 * Interrupts identities might have been enabled/disabled while
+	 * this CPU was not running so sync-up local enable/disable state.
+	 */
+	imsic_ids_local_sync(priv);
+
+	/* Locally enable interrupt delivery */
+	imsic_ids_local_delivery(priv, true);
+
+	return 0;
+}
+
+struct imsic_fwnode_ops {
+	u32 (*nr_parent_irq)(struct fwnode_handle *fwnode,
+			     void *fwopaque);
+	int (*parent_hartid)(struct fwnode_handle *fwnode,
+			     void *fwopaque, u32 index,
+			     unsigned long *out_hartid);
+	u32 (*nr_mmio)(struct fwnode_handle *fwnode, void *fwopaque);
+	int (*mmio_to_resource)(struct fwnode_handle *fwnode,
+				void *fwopaque, u32 index,
+				struct resource *res);
+	void __iomem *(*mmio_map)(struct fwnode_handle *fwnode,
+				  void *fwopaque, u32 index);
+	int (*read_u32)(struct fwnode_handle *fwnode,
+			void *fwopaque, const char *prop, u32 *out_val);
+	bool (*read_bool)(struct fwnode_handle *fwnode,
+			  void *fwopaque, const char *prop);
+};
+
+static int __init imsic_init(struct imsic_fwnode_ops *fwops,
+			     struct fwnode_handle *fwnode,
+			     void *fwopaque)
+{
+	struct resource res;
+	phys_addr_t base_addr;
+	int rc, nr_parent_irqs;
+	struct imsic_mmio *mmio;
+	struct imsic_priv *priv;
+	struct irq_domain *domain;
+	struct imsic_handler *handler;
+	struct imsic_global_config *global;
+	u32 i, tmp, nr_handlers = 0;
+
+	if (imsic_init_done) {
+		pr_err("%pfwP: already initialized hence ignoring\n",
+			fwnode);
+		return -ENODEV;
+	}
+
+	if (!riscv_isa_extension_available(NULL, SxAIA)) {
+		pr_err("%pfwP: AIA support not available\n", fwnode);
+		return -ENODEV;
+	}
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	global = &priv->global;
+
+	/* Find number of parent interrupts */
+	nr_parent_irqs = fwops->nr_parent_irq(fwnode, fwopaque);
+	if (!nr_parent_irqs) {
+		pr_err("%pfwP: no parent irqs available\n", fwnode);
+		return -EINVAL;
+	}
+
+	/* Find number of guest index bits in MSI address */
+	rc = fwops->read_u32(fwnode, fwopaque, "riscv,guest-index-bits",
+			     &global->guest_index_bits);
+	if (rc)
+		global->guest_index_bits = 0;
+	tmp = BITS_PER_LONG - IMSIC_MMIO_PAGE_SHIFT;
+	if (tmp < global->guest_index_bits) {
+		pr_err("%pfwP: guest index bits too big\n", fwnode);
+		return -EINVAL;
+	}
+
+	/* Find number of HART index bits */
+	rc = fwops->read_u32(fwnode, fwopaque, "riscv,hart-index-bits",
+			     &global->hart_index_bits);
+	if (rc) {
+		/* Assume default value */
+		global->hart_index_bits = __fls(nr_parent_irqs);
+		if (BIT(global->hart_index_bits) < nr_parent_irqs)
+			global->hart_index_bits++;
+	}
+	tmp = BITS_PER_LONG - IMSIC_MMIO_PAGE_SHIFT -
+	      global->guest_index_bits;
+	if (tmp < global->hart_index_bits) {
+		pr_err("%pfwP: HART index bits too big\n", fwnode);
+		return -EINVAL;
+	}
+
+	/* Find number of group index bits */
+	rc = fwops->read_u32(fwnode, fwopaque, "riscv,group-index-bits",
+			     &global->group_index_bits);
+	if (rc)
+		global->group_index_bits = 0;
+	tmp = BITS_PER_LONG - IMSIC_MMIO_PAGE_SHIFT -
+	      global->guest_index_bits - global->hart_index_bits;
+	if (tmp < global->group_index_bits) {
+		pr_err("%pfwP: group index bits too big\n", fwnode);
+		return -EINVAL;
+	}
+
+	/*
+	 * Find first bit position of group index.
+	 * If not specified assumed the default APLIC-IMSIC configuration.
+	 */
+	rc = fwops->read_u32(fwnode, fwopaque, "riscv,group-index-shift",
+			     &global->group_index_shift);
+	if (rc)
+		global->group_index_shift = IMSIC_MMIO_PAGE_SHIFT * 2;
+	tmp = global->group_index_bits + global->group_index_shift - 1;
+	if (tmp >= BITS_PER_LONG) {
+		pr_err("%pfwP: group index shift too big\n", fwnode);
+		return -EINVAL;
+	}
+
+	/* Find number of interrupt identities */
+	rc = fwops->read_u32(fwnode, fwopaque, "riscv,num-ids",
+			     &global->nr_ids);
+	if (rc) {
+		pr_err("%pfwP: number of interrupt identities not found\n",
+			fwnode);
+		return rc;
+	}
+	if ((global->nr_ids < IMSIC_MIN_ID) ||
+	    (global->nr_ids >= IMSIC_MAX_ID) ||
+	    ((global->nr_ids & IMSIC_MIN_ID) != IMSIC_MIN_ID)) {
+		pr_err("%pfwP: invalid number of interrupt identities\n",
+			fwnode);
+		return -EINVAL;
+	}
+
+	/* Find number of guest interrupt identities */
+	if (fwops->read_u32(fwnode, fwopaque, "riscv,num-guest-ids",
+			    &global->nr_guest_ids))
+		global->nr_guest_ids = global->nr_ids;
+	if ((global->nr_guest_ids < IMSIC_MIN_ID) ||
+	    (global->nr_guest_ids >= IMSIC_MAX_ID) ||
+	    ((global->nr_guest_ids & IMSIC_MIN_ID) != IMSIC_MIN_ID)) {
+		pr_err("%pfwP: invalid number of guest interrupt identities\n",
+			fwnode);
+		return -EINVAL;
+	}
+
+	/* Compute base address */
+	rc = fwops->mmio_to_resource(fwnode, fwopaque, 0, &res);
+	if (rc) {
+		pr_err("%pfwP: first MMIO resource not found\n", fwnode);
+		return -EINVAL;
+	}
+	global->base_addr = res.start;
+	global->base_addr &= ~(BIT(global->guest_index_bits +
+				   global->hart_index_bits +
+				   IMSIC_MMIO_PAGE_SHIFT) - 1);
+	global->base_addr &= ~((BIT(global->group_index_bits) - 1) <<
+			       global->group_index_shift);
+
+	/* Find number of MMIO register sets */
+	priv->num_mmios = fwops->nr_mmio(fwnode, fwopaque);
+
+	/* Allocate MMIO register sets */
+	priv->mmios = kcalloc(priv->num_mmios, sizeof(*mmio), GFP_KERNEL);
+	if (!priv->mmios) {
+		rc = -ENOMEM;
+		goto out_free_priv;
+	}
+
+	/* Parse and map MMIO register sets */
+	for (i = 0; i < priv->num_mmios; i++) {
+		mmio = &priv->mmios[i];
+		rc = fwops->mmio_to_resource(fwnode, fwopaque, i, &res);
+		if (rc) {
+			pr_err("%pfwP: unable to parse MMIO regset %d\n",
+				fwnode, i);
+			goto out_iounmap;
+		}
+		mmio->pa = res.start;
+		mmio->size = res.end - res.start + 1;
+
+		base_addr = mmio->pa;
+		base_addr &= ~(BIT(global->guest_index_bits +
+				   global->hart_index_bits +
+				   IMSIC_MMIO_PAGE_SHIFT) - 1);
+		base_addr &= ~((BIT(global->group_index_bits) - 1) <<
+			       global->group_index_shift);
+		if (base_addr != global->base_addr) {
+			rc = -EINVAL;
+			pr_err("%pfwP: address mismatch for regset %d\n",
+				fwnode, i);
+			goto out_iounmap;
+		}
+
+		mmio->va = fwops->mmio_map(fwnode, fwopaque, i);
+		if (!mmio->va) {
+			rc = -EIO;
+			pr_err("%pfwP: unable to map MMIO regset %d\n",
+				fwnode, i);
+			goto out_iounmap;
+		}
+	}
+
+	/* Initialize interrupt identity management */
+	rc = imsic_ids_init(priv);
+	if (rc) {
+		pr_err("%pfwP: failed to initialize interrupt management\n",
+		       fwnode);
+		goto out_iounmap;
+	}
+
+	/* Configure handlers for target CPUs */
+	for (i = 0; i < nr_parent_irqs; i++) {
+		unsigned long reloff, hartid;
+		int j, cpu;
+
+		rc = fwops->parent_hartid(fwnode, fwopaque, i, &hartid);
+		if (rc) {
+			pr_warn("%pfwP: hart ID for parent irq%d not found\n",
+				fwnode, i);
+			continue;
+		}
+
+		cpu = riscv_hartid_to_cpuid(hartid);
+		if (cpu < 0) {
+			pr_warn("%pfwP: invalid cpuid for parent irq%d\n",
+				fwnode, i);
+			continue;
+		}
+
+		/* Find MMIO location of MSI page */
+		mmio = NULL;
+		reloff = i * BIT(global->guest_index_bits) *
+			 IMSIC_MMIO_PAGE_SZ;
+		for (j = 0; priv->num_mmios; j++) {
+			if (reloff < priv->mmios[j].size) {
+				mmio = &priv->mmios[j];
+				break;
+			}
+
+			/*
+			 * MMIO region size may not be aligned to
+			 * BIT(global->guest_index_bits) * IMSIC_MMIO_PAGE_SZ
+			 * if holes are present.
+			 */
+			reloff -= ALIGN(priv->mmios[j].size,
+			BIT(global->guest_index_bits) * IMSIC_MMIO_PAGE_SZ);
+		}
+		if (!mmio) {
+			pr_warn("%pfwP: MMIO not found for parent irq%d\n",
+				fwnode, i);
+			continue;
+		}
+
+		handler = per_cpu_ptr(&imsic_handlers, cpu);
+		if (handler->priv) {
+			pr_warn("%pfwP: CPU%d handler already configured.\n",
+				fwnode, cpu);
+			goto done;
+		}
+
+		cpumask_set_cpu(cpu, &priv->lmask);
+		handler->local.msi_pa = mmio->pa + reloff;
+		handler->local.msi_va = mmio->va + reloff;
+		handler->priv = priv;
+
+done:
+		nr_handlers++;
+	}
+
+	/* If no CPU handlers found then can't take interrupts */
+	if (!nr_handlers) {
+		pr_err("%pfwP: No CPU handlers found\n", fwnode);
+		rc = -ENODEV;
+		goto out_ids_cleanup;
+	}
+
+	/* Find parent domain and register chained handler */
+	domain = irq_find_matching_fwnode(riscv_get_intc_hwnode(),
+					  DOMAIN_BUS_ANY);
+	if (!domain) {
+		pr_err("%pfwP: Failed to find INTC domain\n", fwnode);
+		rc = -ENOENT;
+		goto out_ids_cleanup;
+	}
+	imsic_parent_irq = irq_create_mapping(domain, RV_IRQ_EXT);
+	if (!imsic_parent_irq) {
+		pr_err("%pfwP: Failed to create INTC mapping\n", fwnode);
+		rc = -ENOENT;
+		goto out_ids_cleanup;
+	}
+	irq_set_chained_handler(imsic_parent_irq, imsic_handle_irq);
+
+	/* Initialize IPI domain */
+	rc = imsic_ipi_domain_init(priv);
+	if (rc) {
+		pr_err("%pfwP: Failed to initialize IPI domain\n", fwnode);
+		goto out_ids_cleanup;
+	}
+
+	/* Initialize IRQ and MSI domains */
+	rc = imsic_irq_domains_init(priv, fwnode);
+	if (rc) {
+		pr_err("%pfwP: Failed to initialize IRQ and MSI domains\n",
+		       fwnode);
+		goto out_ipi_domain_cleanup;
+	}
+
+	/*
+	 * Setup cpuhp state
+	 *
+	 * Don't disable per-CPU IMSIC file when CPU goes offline
+	 * because this affects IPI and the masking/unmasking of
+	 * virtual IPIs is done via generic IPI-Mux
+	 */
+	cpuhp_setup_state(CPUHP_AP_ONLINE_DYN,
+			  "irqchip/riscv/imsic:starting",
+			  imsic_starting_cpu, NULL);
+
+	/*
+	 * Only one IMSIC instance allowed in a platform for clean
+	 * implementation of SMP IRQ affinity and per-CPU IPIs.
+	 *
+	 * This means on a multi-socket (or multi-die) platform we
+	 * will have multiple MMIO regions for one IMSIC instance.
+	 */
+	imsic_init_done = true;
+
+	pr_info("%pfwP:  hart-index-bits: %d,  guest-index-bits: %d\n",
+		fwnode, global->hart_index_bits, global->guest_index_bits);
+	pr_info("%pfwP: group-index-bits: %d, group-index-shift: %d\n",
+		fwnode, global->group_index_bits, global->group_index_shift);
+	pr_info("%pfwP: mapped %d interrupts for %d CPUs at %pa\n",
+		fwnode, global->nr_ids, nr_handlers, &global->base_addr);
+	if (priv->ipi_lsync_id)
+		pr_info("%pfwP: enable/disable sync using interrupt %d\n",
+			fwnode, priv->ipi_lsync_id);
+	if (priv->ipi_id)
+		pr_info("%pfwP: providing IPIs using interrupt %d\n",
+			fwnode, priv->ipi_id);
+
+	return 0;
+
+out_ipi_domain_cleanup:
+	imsic_ipi_domain_cleanup(priv);
+out_ids_cleanup:
+	imsic_ids_cleanup(priv);
+out_iounmap:
+	for (i = 0; i < priv->num_mmios; i++) {
+		if (priv->mmios[i].va)
+			iounmap(priv->mmios[i].va);
+	}
+	kfree(priv->mmios);
+out_free_priv:
+	kfree(priv);
+	return rc;
+}
+
+static u32 __init imsic_dt_nr_parent_irq(struct fwnode_handle *fwnode,
+					 void *fwopaque)
+{
+	return of_irq_count(to_of_node(fwnode));
+}
+
+static int __init imsic_dt_parent_hartid(struct fwnode_handle *fwnode,
+					 void *fwopaque, u32 index,
+					 unsigned long *out_hartid)
+{
+	struct of_phandle_args parent;
+	int rc;
+
+	rc = of_irq_parse_one(to_of_node(fwnode), index, &parent);
+	if (rc)
+		return rc;
+
+	/*
+	 * Skip interrupts other than external interrupts for
+	 * current privilege level.
+	 */
+	if (parent.args[0] != RV_IRQ_EXT)
+		return -EINVAL;
+
+	return riscv_of_parent_hartid(parent.np, out_hartid);
+}
+
+static u32 __init imsic_dt_nr_mmio(struct fwnode_handle *fwnode,
+				   void *fwopaque)
+{
+	u32 ret = 0;
+	struct resource res;
+
+	while (!of_address_to_resource(to_of_node(fwnode), ret, &res))
+		ret++;
+
+	return ret;
+}
+
+static int __init imsic_mmio_to_resource(struct fwnode_handle *fwnode,
+					 void *fwopaque, u32 index,
+					 struct resource *res)
+{
+	return of_address_to_resource(to_of_node(fwnode), index, res);
+}
+
+static void __iomem __init *imsic_dt_mmio_map(struct fwnode_handle *fwnode,
+					      void *fwopaque, u32 index)
+{
+	return of_iomap(to_of_node(fwnode), index);
+}
+
+static int __init imsic_dt_read_u32(struct fwnode_handle *fwnode,
+				    void *fwopaque, const char *prop,
+				    u32 *out_val)
+{
+	return of_property_read_u32(to_of_node(fwnode), prop, out_val);
+}
+
+static bool __init imsic_dt_read_bool(struct fwnode_handle *fwnode,
+				      void *fwopaque, const char *prop)
+{
+	return of_property_read_bool(to_of_node(fwnode), prop);
+}
+
+static int __init imsic_dt_init(struct device_node *node,
+				struct device_node *parent)
+{
+	struct imsic_fwnode_ops ops = {
+		.nr_parent_irq = imsic_dt_nr_parent_irq,
+		.parent_hartid = imsic_dt_parent_hartid,
+		.nr_mmio = imsic_dt_nr_mmio,
+		.mmio_to_resource = imsic_mmio_to_resource,
+		.mmio_map = imsic_dt_mmio_map,
+		.read_u32 = imsic_dt_read_u32,
+		.read_bool = imsic_dt_read_bool,
+	};
+
+	return imsic_init(&ops, &node->fwnode, NULL);
+}
+IRQCHIP_DECLARE(riscv_imsic, "riscv,imsics", imsic_dt_init);
diff --git a/drivers/irqchip/irq-riscv-intc.c b/drivers/irqchip/irq-riscv-intc.c
index e8d01b14ccdd..a93a242435a3 100644
--- a/drivers/irqchip/irq-riscv-intc.c
+++ b/drivers/irqchip/irq-riscv-intc.c
@@ -17,6 +17,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/smp.h>
+#include <asm/hwcap.h>
 
 static struct irq_domain *intc_domain;
 
@@ -30,6 +31,15 @@ static asmlinkage void riscv_intc_irq(struct pt_regs *regs)
 	generic_handle_domain_irq(intc_domain, cause);
 }
 
+static asmlinkage void riscv_intc_aia_irq(struct pt_regs *regs)
+{
+	unsigned long topi;
+
+	while ((topi = csr_read(CSR_TOPI)))
+		generic_handle_domain_irq(intc_domain,
+					  topi >> TOPI_IID_SHIFT);
+}
+
 /*
  * On RISC-V systems local interrupts are masked or unmasked by writing
  * the SIE (Supervisor Interrupt Enable) CSR.  As CSRs can only be written
@@ -39,12 +49,18 @@ static asmlinkage void riscv_intc_irq(struct pt_regs *regs)
 
 static void riscv_intc_irq_mask(struct irq_data *d)
 {
-	csr_clear(CSR_IE, BIT(d->hwirq));
+	if (d->hwirq < BITS_PER_LONG)
+		csr_clear(CSR_IE, BIT(d->hwirq));
+	else
+		csr_clear(CSR_IEH, BIT(d->hwirq - BITS_PER_LONG));
 }
 
 static void riscv_intc_irq_unmask(struct irq_data *d)
 {
-	csr_set(CSR_IE, BIT(d->hwirq));
+	if (d->hwirq < BITS_PER_LONG)
+		csr_set(CSR_IE, BIT(d->hwirq));
+	else
+		csr_set(CSR_IEH, BIT(d->hwirq - BITS_PER_LONG));
 }
 
 static void riscv_intc_irq_eoi(struct irq_data *d)
@@ -115,16 +131,22 @@ static struct fwnode_handle *riscv_intc_hwnode(void)
 
 static int __init riscv_intc_init_common(struct fwnode_handle *fn)
 {
-	int rc;
+	int rc, nr_irqs = BITS_PER_LONG;
+
+	if (riscv_isa_extension_available(NULL, SxAIA) && BITS_PER_LONG == 32)
+		nr_irqs = nr_irqs * 2;
 
-	intc_domain = irq_domain_create_linear(fn, BITS_PER_LONG,
+	intc_domain = irq_domain_create_linear(fn, nr_irqs,
 					       &riscv_intc_domain_ops, NULL);
 	if (!intc_domain) {
 		pr_err("unable to add IRQ domain\n");
 		return -ENXIO;
 	}
 
-	rc = set_handle_irq(&riscv_intc_irq);
+	if (riscv_isa_extension_available(NULL, SxAIA))
+		rc = set_handle_irq(&riscv_intc_aia_irq);
+	else
+		rc = set_handle_irq(&riscv_intc_irq);
 	if (rc) {
 		pr_err("failed to set irq handler\n");
 		return rc;
@@ -132,7 +154,9 @@ static int __init riscv_intc_init_common(struct fwnode_handle *fn)
 
 	riscv_set_intc_hwnode_fn(riscv_intc_hwnode);
 
-	pr_info("%d local interrupts mapped\n", BITS_PER_LONG);
+	pr_info("%d local interrupts mapped%s\n",
+		nr_irqs, (riscv_isa_extension_available(NULL, SxAIA)) ?
+			 " using AIA" : "");
 
 	return 0;
 }
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index bc7e2ad37002..5aa588dba2d8 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -214,6 +214,34 @@ config MMC_SDHCI_OF_ESDHC
 
 	  If unsure, say N.
 
+config MMC_SDHCI_OF_ESWIN
+	tristate "SDHCI OF support for the Eswin SDHCI controllers"
+	depends on MMC_SDHCI_PLTFM
+	depends on OF
+	depends on COMMON_CLK
+	select MMC_CQHCI
+	help
+	  This selects the Eswin Secure Digital Host Controller Interface
+	  (SDHCI).
+	
+	  If you have a controller with this interface, say Y or M here.
+	
+	  If unsure, say N.
+
+config MMC_SDHCI_OF_SDIO_ESWIN
+	tristate "SDHCI OF SDIO support for the Eswin SDHCI controllers"
+	depends on MMC_SDHCI_PLTFM
+	depends on OF
+	depends on COMMON_CLK
+	select MMC_CQHCI
+	help
+	  This selects the Eswin Secure Digital Host Controller Interface
+	  (SDHCI-SDIO).
+	
+	  If you have a controller with this interface, say Y or M here.
+	
+	  If unsure, say N.
+
 config MMC_SDHCI_OF_HLWD
 	tristate "SDHCI OF support for the Nintendo Wii SDHCI controllers"
 	depends on MMC_SDHCI_PLTFM
diff --git a/drivers/mmc/host/Makefile b/drivers/mmc/host/Makefile
index a693fa3d3f1c..2c7167dfdaac 100644
--- a/drivers/mmc/host/Makefile
+++ b/drivers/mmc/host/Makefile
@@ -84,6 +84,10 @@ obj-$(CONFIG_MMC_SDHCI_OF_ARASAN)	+= sdhci-of-arasan.o
 obj-$(CONFIG_MMC_SDHCI_OF_ASPEED)	+= sdhci-of-aspeed.o
 obj-$(CONFIG_MMC_SDHCI_OF_AT91)		+= sdhci-of-at91.o
 obj-$(CONFIG_MMC_SDHCI_OF_ESDHC)	+= sdhci-of-esdhc.o
+eswin-sdhci-emmc-objs  := sdhci-of-eswin.o sdhci-eswin.o
+obj-$(CONFIG_MMC_SDHCI_OF_ESWIN)       += eswin-sdhci-emmc.o
+eswin-sdhci-sdio-objs  := sdhci-of-eswin-sdio.o sdhci-eswin.o
+obj-$(CONFIG_MMC_SDHCI_OF_SDIO_ESWIN)  += eswin-sdhci-sdio.o
 obj-$(CONFIG_MMC_SDHCI_OF_HLWD)		+= sdhci-of-hlwd.o
 obj-$(CONFIG_MMC_SDHCI_OF_DWCMSHC)	+= sdhci-of-dwcmshc.o
 obj-$(CONFIG_MMC_SDHCI_OF_SPARX5)	+= sdhci-of-sparx5.o
diff --git a/drivers/mmc/host/sdhci-eswin.c b/drivers/mmc/host/sdhci-eswin.c
new file mode 100644
index 000000000000..b941fa90f710
--- /dev/null
+++ b/drivers/mmc/host/sdhci-eswin.c
@@ -0,0 +1,301 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Emmc Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: liangshuang <liangshuang@eswin.com>
+ */
+#include <linux/delay.h>
+#include <linux/reset.h>
+#include "sdhci-eswin.h"
+
+static void eswin_mshc_coreclk_config(struct sdhci_host *host, uint16_t divisor,
+					unsigned int flag_sel)
+{
+	struct sdhci_pltfm_host *pltfm_host;
+	struct eswin_sdhci_data *eswin_sdhci;
+	u32 val = 0;
+	u32 delay = 0xfffff;
+
+	pltfm_host = sdhci_priv(host);
+	eswin_sdhci = sdhci_pltfm_priv(pltfm_host);
+
+	val = readl(eswin_sdhci->core_clk_reg);
+	val &= ~MSHC_CORE_CLK_ENABLE;
+	writel(val, eswin_sdhci->core_clk_reg);
+	while (delay--)
+		;
+	val &= ~(MSHC_CORE_CLK_FREQ_BIT_MASK << MSHC_CORE_CLK_FREQ_BIT_SHIFT);
+	val |= (divisor & MSHC_CORE_CLK_FREQ_BIT_MASK)
+	       << MSHC_CORE_CLK_FREQ_BIT_SHIFT;
+	val &= ~(MSHC_CORE_CLK_SEL_BIT);
+	val |= flag_sel;
+	writel(val, eswin_sdhci->core_clk_reg);
+
+	udelay(100);
+	val |= MSHC_CORE_CLK_ENABLE;
+	writel(val, eswin_sdhci->core_clk_reg);
+	mdelay(1);
+}
+
+static void eswin_mshc_coreclk_disable(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host;
+	struct eswin_sdhci_data *eswin_sdhci;
+	u32 val = 0;
+
+	pltfm_host = sdhci_priv(host);
+	eswin_sdhci = sdhci_pltfm_priv(pltfm_host);
+
+	val = readl(eswin_sdhci->core_clk_reg);
+	val &= ~MSHC_CORE_CLK_ENABLE;
+	writel(val, eswin_sdhci->core_clk_reg);
+}
+
+void eswin_sdhci_disable_card_clk(struct sdhci_host *host)
+{
+	unsigned int clk;
+
+	/* Reset SD Clock Enable */
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+	clk &= ~SDHCI_CLOCK_CARD_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+}
+
+void eswin_sdhci_enable_card_clk(struct sdhci_host *host)
+{
+	ktime_t timeout;
+	unsigned int clk;
+
+	clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+
+	clk |= SDHCI_CLOCK_INT_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+
+	/* Wait max 150 ms */
+	timeout = ktime_add_ms(ktime_get(), 150);
+	while (1) {
+		bool timedout = ktime_after(ktime_get(), timeout);
+		clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);
+		if (clk & SDHCI_CLOCK_INT_STABLE)
+			break;
+		if (timedout) {
+			pr_err("%s: Internal clock never stabilised.\n",
+					mmc_hostname(host->mmc));
+			return;
+		}
+		udelay(10);
+	}
+
+	clk |= SDHCI_CLOCK_CARD_EN;
+	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
+	mdelay(1);
+}
+
+void eswin_sdhci_set_core_clock(struct sdhci_host *host,
+				       unsigned int clock)
+{
+	unsigned int div, divide;
+	unsigned int flag_sel, max_clk;
+
+	if (clock == 0) {
+		eswin_mshc_coreclk_disable(host);
+		return;
+	}
+
+	if (SDHCI_CLK_208M % clock == 0) {
+		flag_sel = 1;
+		max_clk = SDHCI_CLK_208M;
+	} else {
+		flag_sel = 0;
+		max_clk = SDHCI_CLK_200M;
+	}
+
+	for (div = 1; div <= MAX_CORE_CLK_DIV; div++) {
+		if ((max_clk / div) <= clock)
+			break;
+	}
+	div--;
+
+	if (div == 0 || div == 1) {
+		divide = 2;
+	} else {
+		divide = (div + 1) * 2;
+	}
+	pr_debug("%s: clock:%d timing:%d\n", mmc_hostname(host->mmc), clock, host->timing);
+
+	eswin_sdhci_disable_card_clk(host);
+	eswin_mshc_coreclk_config(host, divide, flag_sel);
+	eswin_sdhci_enable_card_clk(host);
+	mdelay(2);
+}
+
+static void eswin_sdhci_set_clk_delays(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci = sdhci_pltfm_priv(pltfm_host);
+	struct eswin_sdhci_clk_data *clk_data = &eswin_sdhci->clk_data;
+
+	clk_set_phase(clk_data->sampleclk,
+			clk_data->clk_phase_in[host->timing]);
+	clk_set_phase(clk_data->sdcardclk,
+			clk_data->clk_phase_out[host->timing]);
+}
+
+static void eswin_sdhci_dt_read_clk_phase(struct device *dev,
+					struct eswin_sdhci_clk_data *clk_data,
+					unsigned int timing, const char *prop)
+{
+	struct device_node *np = dev->of_node;
+
+	int clk_phase[2] = { 0 };
+
+	/*
+	 * Read Tap Delay values from DT, if the DT does not contain the
+	 * Tap Values then use the pre-defined values.
+	 */
+	if (of_property_read_variable_u32_array(np, prop, &clk_phase[0], 2,
+						0)) {
+		dev_dbg(dev, "Using predefined clock phase for %s = %d %d\n",
+			prop, clk_data->clk_phase_in[timing],
+			clk_data->clk_phase_out[timing]);
+		return;
+	}
+
+	/* The values read are Input and Output Clock Delays in order */
+	clk_data->clk_phase_in[timing] = clk_phase[0];
+	clk_data->clk_phase_out[timing] = clk_phase[1];
+}
+
+/**
+ * eswin_dt_parse_clk_phases - Read Clock Delay values from DT
+ *
+ * @dev:        Pointer to our struct device.
+ * @clk_data:       Pointer to the Clock Data structure
+ *
+ * Called at initialization to parse the values of Clock Delays.
+ */
+void eswin_sdhci_dt_parse_clk_phases(struct device *dev,
+				struct eswin_sdhci_clk_data *clk_data)
+{
+	clk_data->set_clk_delays = eswin_sdhci_set_clk_delays;
+
+	eswin_sdhci_dt_read_clk_phase(dev, clk_data, MMC_TIMING_LEGACY,
+				      "clk-phase-legacy");
+	eswin_sdhci_dt_read_clk_phase(dev, clk_data, MMC_TIMING_MMC_HS,
+				      "clk-phase-mmc-hs");
+	eswin_sdhci_dt_read_clk_phase(dev, clk_data, MMC_TIMING_SD_HS,
+				      "clk-phase-sd-hs");
+	eswin_sdhci_dt_read_clk_phase(dev, clk_data, MMC_TIMING_UHS_SDR12,
+				      "clk-phase-uhs-sdr12");
+	eswin_sdhci_dt_read_clk_phase(dev, clk_data, MMC_TIMING_UHS_SDR25,
+				      "clk-phase-uhs-sdr25");
+	eswin_sdhci_dt_read_clk_phase(dev, clk_data, MMC_TIMING_UHS_SDR50,
+				      "clk-phase-uhs-sdr50");
+	eswin_sdhci_dt_read_clk_phase(dev, clk_data, MMC_TIMING_UHS_SDR104,
+				      "clk-phase-uhs-sdr104");
+	eswin_sdhci_dt_read_clk_phase(dev, clk_data, MMC_TIMING_UHS_DDR50,
+				      "clk-phase-uhs-ddr50");
+	eswin_sdhci_dt_read_clk_phase(dev, clk_data, MMC_TIMING_MMC_DDR52,
+				      "clk-phase-mmc-ddr52");
+	eswin_sdhci_dt_read_clk_phase(dev, clk_data, MMC_TIMING_MMC_HS200,
+				      "clk-phase-mmc-hs200");
+	eswin_sdhci_dt_read_clk_phase(dev, clk_data, MMC_TIMING_MMC_HS400,
+				      "clk-phase-mmc-hs400");
+}
+
+unsigned int eswin_convert_drive_impedance_ohm(struct platform_device *pdev,
+					     unsigned int dr_ohm)
+{
+	switch (dr_ohm) {
+	case 100:
+		return PHYCTRL_DR_100OHM;
+	case 66:
+		return PHYCTRL_DR_66OHM;
+	case 50:
+		return PHYCTRL_DR_50OHM;
+	case 40:
+		return PHYCTRL_DR_40OHM;
+	case 33:
+		return PHYCTRL_DR_33OHM;
+	}
+
+	dev_warn(&pdev->dev, "Invalid value %u for drive-impedance-ohm.\n",
+		 dr_ohm);
+	return PHYCTRL_DR_50OHM;
+}
+
+static void eswin_sdhci_do_reset(struct eswin_sdhci_data *eswin_sdhci)
+{
+	int ret;
+
+	ret = reset_control_assert(eswin_sdhci->txrx_rst);
+	WARN_ON(0 != ret);
+	ret = reset_control_assert(eswin_sdhci->phy_rst);
+	WARN_ON(0 != ret);
+	ret = reset_control_assert(eswin_sdhci->prstn);
+	WARN_ON(0 != ret);
+	ret = reset_control_assert(eswin_sdhci->arstn);
+	WARN_ON(0 != ret);
+
+	mdelay(2);
+
+	ret = reset_control_deassert(eswin_sdhci->txrx_rst);
+	WARN_ON(0 != ret);
+	ret = reset_control_deassert(eswin_sdhci->phy_rst);
+	WARN_ON(0 != ret);
+	ret = reset_control_deassert(eswin_sdhci->prstn);
+	WARN_ON(0 != ret);
+	ret = reset_control_deassert(eswin_sdhci->arstn);
+	WARN_ON(0 != ret);
+}
+
+int eswin_sdhci_reset_init(struct device *dev,
+				 struct eswin_sdhci_data *eswin_sdhci)
+{
+	int ret = 0;
+	eswin_sdhci->txrx_rst = devm_reset_control_get_optional(dev, "txrx_rst");
+	if (IS_ERR_OR_NULL(eswin_sdhci->txrx_rst)) {
+		dev_err_probe(dev, PTR_ERR(eswin_sdhci->txrx_rst),
+			      "txrx_rst reset not found.\n");
+		return -EFAULT;
+	}
+
+	eswin_sdhci->phy_rst = devm_reset_control_get_optional(dev, "phy_rst");
+	if (IS_ERR_OR_NULL(eswin_sdhci->phy_rst)) {
+		dev_err_probe(dev, PTR_ERR(eswin_sdhci->phy_rst),
+			      "phy_rst reset not found.\n");
+		return -EFAULT;
+	}
+
+	eswin_sdhci->prstn = devm_reset_control_get_optional(dev, "prstn");
+	if (IS_ERR_OR_NULL(eswin_sdhci->prstn)) {
+		dev_err_probe(dev, PTR_ERR(eswin_sdhci->prstn),
+			      "prstn reset not found.\n");
+		return -EFAULT;
+	}
+
+	eswin_sdhci->arstn = devm_reset_control_get_optional(dev, "arstn");
+	if (IS_ERR_OR_NULL(eswin_sdhci->arstn)) {
+		dev_err_probe(dev, PTR_ERR(eswin_sdhci->arstn),
+			      "arstn reset not found.\n");
+		return -EFAULT;
+	}
+	eswin_sdhci_do_reset(eswin_sdhci);
+
+	return ret;
+}
diff --git a/drivers/mmc/host/sdhci-eswin.h b/drivers/mmc/host/sdhci-eswin.h
new file mode 100644
index 000000000000..5274766f0501
--- /dev/null
+++ b/drivers/mmc/host/sdhci-eswin.h
@@ -0,0 +1,237 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN SDHCI Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: liangshuang <liangshuang@eswin.com>
+ */
+#ifndef _DRIVERS_MMC_SDHCI_ESWIN_H
+#define _DRIVERS_MMC_SDHCI_ESWIN_H
+
+#include <linux/reset.h>
+#include <linux/clk-provider.h>
+#include "sdhci-pltfm.h"
+
+#define MSHC_CARD_CLK_STABLE BIT(28)
+#define MSHC_INT_BCLK_STABLE BIT(16)
+#define MSHC_INT_ACLK_STABLE BIT(8)
+#define MSHC_INT_TMCLK_STABLE BIT(0)
+#define MSHC_INT_CLK_STABLE                             \
+	(MSHC_CARD_CLK_STABLE | MSHC_INT_ACLK_STABLE | \
+	 MSHC_INT_BCLK_STABLE | MSHC_INT_TMCLK_STABLE)
+#define MSHC_HOST_VAL_STABLE BIT(0)
+#define EMMC0_CARD_DETECT BIT(9)
+#define EMMC0_CARD_WRITE_PROT BIT(8)
+
+#define MSHC_CORE_CLK_ENABLE BIT(16)
+#define MSHC_CORE_CLK_FREQ_BIT_SHIFT 4
+#define MSHC_CORE_CLK_FREQ_BIT_MASK 0xfffu
+#define MSHC_CORE_CLK_SEL_BIT BIT(0)
+
+/* Controller does not have CD wired and will not function normally without */
+#define SDHCI_ESWIN_QUIRK_FORCE_CDTEST BIT(0)
+/* Controller immediately reports SDHCI_CLOCK_INT_STABLE after enabling the
+ * internal clock even when the clock isn't stable */
+#define SDHCI_ESWIN_QUIRK_CLOCK_UNSTABLE BIT(1)
+
+#define ESWIN_SDHCI_CTRL_HS400 0x0007 // Non-standard, for eswin,these bits are 0x7
+
+#define SDHCI_CLK_208M   208000000
+#define SDHCI_CLK_200M   200000000
+
+#define AWSMMUSID GENMASK(31, 24)  // The sid of write operation
+#define AWSMMUSSID GENMASK(23, 16)  // The ssid of write operation
+#define ARSMMUSID GENMASK(15, 8)  // The sid of read operation
+#define ARSMMUSSID GENMASK(7, 0)  // The ssid of read operation
+
+/* DWC_mshc_map/DWC_mshc_phy_block register */
+#define DWC_MSHC_PTR_PHY_R 0x300
+#define PHY_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x00)
+#define PHY_CMDPAD_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x04)
+#define PHY_DATAPAD_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x06)
+#define PHY_CLKPAD_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x08)
+#define PHY_STBPAD_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x0a)
+#define PHY_RSTNPAD_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x0c)
+#define PHY_PADTEST_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x0e)
+#define PHY_PADTEST_OUT_R (DWC_MSHC_PTR_PHY_R + 0x10)
+#define PHY_PADTEST_IN_R (DWC_MSHC_PTR_PHY_R + 0x12)
+#define PHY_PRBS_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x18)
+#define PHY_PHYLBK_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x1a)
+#define PHY_COMMDL_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x1c)
+#define PHY_SDCLKDL_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x1d)
+#define PHY_SDCLKDL_DC_R (DWC_MSHC_PTR_PHY_R + 0x1e)
+#define PHY_SMPLDL_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x20)
+#define PHY_ATDL_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x21)
+#define PHY_DLL_CTRL_R (DWC_MSHC_PTR_PHY_R + 0x24)
+#define PHY_DLL_CNFG1_R (DWC_MSHC_PTR_PHY_R + 0x25)
+#define PHY_DLL_CNFG2_R (DWC_MSHC_PTR_PHY_R + 0x26)
+#define PHY_DLLDL_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x28)
+#define PHY_DLL_OFFST_R (DWC_MSHC_PTR_PHY_R + 0x29)
+#define PHY_DLLMST_TSTDC_R (DWC_MSHC_PTR_PHY_R + 0x2a)
+#define PHY_DLLBT_CNFG_R (DWC_MSHC_PTR_PHY_R + 0x2c)
+#define PHY_DLL_STATUS_R (DWC_MSHC_PTR_PHY_R + 0x2e)
+#define PHY_DLLDBG_MLKDC_R (DWC_MSHC_PTR_PHY_R + 0x30)
+#define PHY_DLLDBG_SLKDC_R (DWC_MSHC_PTR_PHY_R + 0x32)
+
+#define ENABLE 1
+#define DISABLE 0
+/* strength definition */
+#define PHYCTRL_DR_33OHM 0xee
+#define PHYCTRL_DR_40OHM 0xcc
+#define PHYCTRL_DR_50OHM 0x88
+#define PHYCTRL_DR_66OHM 0x44
+#define PHYCTRL_DR_100OHM 0x00
+
+#define PHY_PAD_MAX_DRIVE_STRENGTH 0xf
+#define PHY_CLK_MAX_DELAY_MASK 0x7f
+#define PHY_PAD_SP_DRIVE_SHIF 16
+#define PHY_PAD_SN_DRIVE_SHIF 20
+
+#define PHY_RSTN BIT(0)
+#define PHY_UPDATE_DELAY_CODE BIT(4)
+
+#define VENDOR_EMMC_CTRL_R 0x52c
+#define EMMC_CRAD_PRESENT BIT(0)
+#define EMMC_RST_N_OE BIT(3)
+#define EMMC_RST_N  BIT(2)
+
+#define PHY_SLEW_0 0x0
+#define PHY_SLEW_1 0x1
+#define PHY_SLEW_2 0x2
+#define PHY_SLEW_3 0x3
+#define PHY_TX_SLEW_CTRL_P_BIT_SHIFT 5
+#define PHY_TX_SLEW_CTRL_N_BIT_SHIFT 9
+
+#define PHY_PULL_BIT_SHIF 0x3
+#define PHY_PULL_DISABLED 0x0
+#define PHY_PULL_UP 0x1
+#define PHY_PULL_DOWN 0x2
+#define PHY_PULL_MASK 0x3
+
+#define PHY_PAD_RXSEL_0 0x0
+#define PHY_PAD_RXSEL_1 0x1
+
+#define VENDOR_AT_CTRL_R 0x540
+#define LATENCY_LT_BIT_OFFSET 19
+#define LATENCY_LT_MASK 0x3
+
+#define LATENCY_LT_1 0x0
+#define LATENCY_LT_2 0x1
+#define LATENCY_LT_3 0x2
+#define LATENCY_LT_4 0x3
+#define SW_TUNE_ENABLE BIT(4)
+
+#define VENDOR_AT_SATA_R 0x544
+#define MAX_PHASE_CODE 0xff
+
+#define DLL_ENABEL BIT(0)
+#define DLL_LOCK_STS BIT(0)
+#define DLL_ERROR_STS BIT(1)
+#define PHY_DELAY_CODE_MASK 0x7f
+#define PHY_DELAY_CODE_MAX 0x7f
+
+#define MAX_CORE_CLK_DIV 0xfff
+
+/**
+ * struct eswin_sdhci_clk_ops - Clock Operations for eswin SD controller
+ *
+ * @sdcardclk_ops:  The output clock related operations
+ * @sampleclk_ops:  The sample clock related operations
+ */
+struct eswin_sdhci_clk_ops {
+	const struct clk_ops *sdcardclk_ops;
+	const struct clk_ops *sampleclk_ops;
+};
+
+/**
+ * struct eswin_sdhci_clk_data - ESWIN Controller Clock Data.
+ *
+ * @sdcardclk_hw:   Struct for the clock we might provide to a PHY.
+ * @sdcardclk:      Pointer to normal 'struct clock' for sdcardclk_hw.
+ * @sampleclk_hw:   Struct for the clock we might provide to a PHY.
+ * @sampleclk:      Pointer to normal 'struct clock' for sampleclk_hw.
+ * @clk_phase_in:   Array of Input Clock Phase Delays for all speed modes
+ * @clk_phase_out:  Array of Output Clock Phase Delays for all speed modes
+ * @set_clk_delays: Function pointer for setting Clock Delays
+ * @clk_of_data:    Platform specific runtime clock data storage pointer
+ */
+struct eswin_sdhci_clk_data {
+	struct clk_hw sdcardclk_hw;
+	struct clk *sdcardclk;
+	struct clk_hw sampleclk_hw;
+	struct clk *sampleclk;
+	int clk_phase_in[MMC_TIMING_MMC_HS400 + 1];
+	int clk_phase_out[MMC_TIMING_MMC_HS400 + 1];
+	void (*set_clk_delays)(struct sdhci_host *host);
+	void *clk_of_data;
+};
+
+struct eswin_sdhci_phy_data {
+	unsigned int drive_impedance;
+	unsigned int enable_strobe_pulldown;
+	unsigned int enable_data_pullup;
+	unsigned int enable_cmd_pullup;
+	unsigned int delay_code;
+};
+
+/**
+ * struct eswin_sdhci_data - ESWIN Controller Data
+ *
+ * @host:       Pointer to the main SDHCI host structure.
+ * @clk_ahb:        Pointer to the AHB clock
+ * @has_cqe:        True if controller has command queuing engine.
+ * @clk_data:       Struct for the ESWIN Controller Clock Data.
+ * @clk_ops:        Struct for the ESWIN Controller Clock Operations.
+ * @soc_ctl_base:   Pointer to regmap for syscon for soc_ctl registers.
+ * @soc_ctl_map:    Map to get offsets into soc_ctl registers.
+ * @quirks:     ESWIN deviations from spec.
+ * @phy:        ESWIN sdhci phy configs.
+ * @private:    private for spec driver.
+ */
+struct eswin_sdhci_data {
+	struct sdhci_host *host;
+	struct clk *clk_ahb;
+	bool has_cqe;
+	struct eswin_sdhci_clk_data clk_data;
+	const struct eswin_sdhci_clk_ops *clk_ops;
+	unsigned int quirks;
+	void __iomem *core_clk_reg;
+	struct reset_control *txrx_rst;
+	struct reset_control *phy_rst;
+	struct reset_control *prstn;
+	struct reset_control *arstn;
+	struct eswin_sdhci_phy_data phy;
+	unsigned long private[] ____cacheline_aligned;
+};
+
+struct eswin_sdhci_of_data {
+	const struct sdhci_pltfm_data *pdata;
+	const struct eswin_sdhci_clk_ops *clk_ops;
+};
+
+void eswin_sdhci_set_core_clock(struct sdhci_host *host,
+				       unsigned int clock);
+void eswin_sdhci_disable_card_clk(struct sdhci_host *host);
+void eswin_sdhci_enable_card_clk(struct sdhci_host *host);
+void eswin_sdhci_dt_parse_clk_phases(struct device *dev,
+				struct eswin_sdhci_clk_data *clk_data);
+unsigned int eswin_convert_drive_impedance_ohm(struct platform_device *pdev,
+					     unsigned int dr_ohm);
+int eswin_sdhci_reset_init(struct device *dev,
+				 struct eswin_sdhci_data *eswin_sdhci);
+
+#endif /* _DRIVERS_MMC_SDHCI_ESWIN_H */
diff --git a/drivers/mmc/host/sdhci-of-eswin-sdio.c b/drivers/mmc/host/sdhci-of-eswin-sdio.c
new file mode 100644
index 000000000000..c69e5f10f240
--- /dev/null
+++ b/drivers/mmc/host/sdhci-of-eswin-sdio.c
@@ -0,0 +1,1079 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN sdio Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: liangshuang <liangshuang@eswin.com>
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/phy/phy.h>
+#include <linux/regmap.h>
+#include <linux/of.h>
+#include <linux/reset.h>
+#include "cqhci.h"
+#include "sdhci-pltfm.h"
+
+#include <linux/eic7700-sid-cfg.h>
+#include <linux/bitfield.h>
+#include <linux/iommu.h>
+#include "sdhci-eswin.h"
+
+
+#define ESWIN_SDHCI_SD_CQE_BASE_ADDR 0x180
+#define ESWIN_SDHCI_SD0_INT_STATUS 0x608
+#define ESWIN_SDHCI_SD0_PWR_CTRL 0x60c
+#define ESWIN_SDHCI_SD1_INT_STATUS 0x708
+#define ESWIN_SDHCI_SD1_PWR_CTRL 0x70c
+
+#define DELAY_RANGE_THRESHOLD   20
+
+struct eswin_sdio_private {
+	int phase_code;
+	unsigned int enable_sw_tuning;
+};
+
+static inline void *sdhci_sdio_priv(struct eswin_sdhci_data *sdio)
+{
+	return sdio->private;
+}
+
+static void eswin_sdhci_sdio_set_clock(struct sdhci_host *host,
+				       unsigned int clock)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci_sdio =
+		sdhci_pltfm_priv(pltfm_host);
+	struct eswin_sdhci_clk_data *clk_data =
+		&eswin_sdhci_sdio->clk_data;
+
+	/* Set the Input and Output Clock Phase Delays */
+	if (clk_data->set_clk_delays) {
+		clk_data->set_clk_delays(host);
+	}
+
+	eswin_sdhci_set_core_clock(host, clock);
+	sdhci_set_clock(host, clock);
+
+	if (eswin_sdhci_sdio->quirks & SDHCI_ESWIN_QUIRK_CLOCK_UNSTABLE)
+		/*
+                 * Some controllers immediately report SDHCI_CLOCK_INT_STABLE
+                 * after enabling the clock even though the clock is not
+                 * stable. Trying to use a clock without waiting here results
+                 * in EILSEQ while detecting some older/slower cards. The
+                 * chosen delay is the maximum delay from sdhci_set_clock.
+                 */
+		msleep(20);
+}
+
+static void eswin_sdhci_sdio_config_phy_delay(struct sdhci_host *host,
+					      int delay)
+{
+	delay &= PHY_CLK_MAX_DELAY_MASK;
+
+	/*phy clk delay line config*/
+	sdhci_writeb(host, PHY_UPDATE_DELAY_CODE, PHY_SDCLKDL_CNFG_R);
+	sdhci_writeb(host, delay, PHY_SDCLKDL_DC_R);
+	sdhci_writeb(host, 0x0, PHY_SDCLKDL_CNFG_R);
+}
+
+static void eswin_sdhci_sdio_config_phy(struct sdhci_host *host)
+{
+	unsigned int val = 0;
+	unsigned int drv = 0;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci =
+		sdhci_pltfm_priv(pltfm_host);
+	struct eswin_sdhci_phy_data *phy = &eswin_sdhci->phy;
+
+	drv = phy->drive_impedance << PHY_PAD_SP_DRIVE_SHIF;
+	pr_debug("%s: phy drv=0x%x \n",mmc_hostname(host->mmc), drv);
+
+	eswin_sdhci_disable_card_clk(host);
+
+	/* reset phy,config phy's pad */
+	sdhci_writel(host, drv | (~PHY_RSTN), PHY_CNFG_R);
+	/*CMDPAD_CNFS*/
+	val = (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_P_BIT_SHIFT) |
+	      (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_N_BIT_SHIFT) |
+	      (phy->enable_cmd_pullup << PHY_PULL_BIT_SHIF) | PHY_PAD_RXSEL_1;
+	sdhci_writew(host, val, PHY_CMDPAD_CNFG_R);
+	pr_debug("%s: phy cmd=0x%x\n",mmc_hostname(host->mmc), val);
+
+	/*DATA PAD CNFG*/
+	val = (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_P_BIT_SHIFT) |
+	      (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_N_BIT_SHIFT) |
+	      (phy->enable_data_pullup << PHY_PULL_BIT_SHIF) | PHY_PAD_RXSEL_1;
+	sdhci_writew(host, val, PHY_DATAPAD_CNFG_R);
+	pr_debug("%s: phy data=0x%x\n",mmc_hostname(host->mmc), val);
+
+	/*Clock PAD Setting*/
+	val = (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_P_BIT_SHIFT) |
+	      (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_N_BIT_SHIFT) | PHY_PAD_RXSEL_0;
+	sdhci_writew(host, val, PHY_CLKPAD_CNFG_R);
+	pr_debug("%s: phy clk=0x%x\n",mmc_hostname(host->mmc), val);
+	mdelay(2);
+
+	/*PHY RSTN PAD setting*/
+	val = (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_P_BIT_SHIFT) |
+	      (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_N_BIT_SHIFT) |
+	      (PHY_PULL_UP << PHY_PULL_BIT_SHIF) | PHY_PAD_RXSEL_1;
+	sdhci_writew(host, val, PHY_RSTNPAD_CNFG_R);
+
+	sdhci_writel(host, drv | PHY_RSTN, PHY_CNFG_R);
+
+	eswin_sdhci_sdio_config_phy_delay(host, phy->delay_code);
+
+	eswin_sdhci_enable_card_clk(host);
+}
+
+static void eswin_sdhci_sdio_reset(struct sdhci_host *host, u8 mask)
+{
+	u8 ctrl;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci_sdio =
+		sdhci_pltfm_priv(pltfm_host);
+
+	/* Disable signal and interrupts before resetting the phy.
+	 * Doing this avoids ISR to serve any undesired interrupts during
+	 * reset and avoid producing the fake register dump during probe.
+	 */
+	sdhci_writel(host, 0, SDHCI_INT_ENABLE);
+	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
+	sdhci_reset(host, mask);
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+
+	if (eswin_sdhci_sdio->quirks & SDHCI_ESWIN_QUIRK_FORCE_CDTEST) {
+		ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+		ctrl |= SDHCI_CTRL_CDTEST_INS | SDHCI_CTRL_CDTEST_EN;
+		sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+	}
+	if (mask == SDHCI_RESET_ALL) {	// after reset all,the phy`s config will be clear.
+		eswin_sdhci_sdio_config_phy(host);
+	}
+}
+
+static int eswin_sdhci_sdio_delay_tuning(struct sdhci_host *host, u32 opcode)
+{
+	int ret;
+	int delay = -1;
+	int i = 0;
+	int delay_min = -1;
+	int delay_max = -1;
+	int delay_range = -1;
+
+	int cmd_error = 0;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci =
+		sdhci_pltfm_priv(pltfm_host);
+
+	for (i = 0; i <= PHY_DELAY_CODE_MAX; i++) {
+		eswin_sdhci_disable_card_clk(host);
+		eswin_sdhci_sdio_config_phy_delay(host, i);
+		eswin_sdhci_enable_card_clk(host);
+		ret = mmc_send_tuning(host->mmc, opcode, &cmd_error);
+		if (ret) {
+			host->ops->reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);
+			udelay(200);
+			if (delay_min != -1 && delay_max != -1) {
+				if (delay_max - delay_min > delay_range) {
+					delay_range = delay_max - delay_min;
+					delay = (delay_min + delay_max) / 2;
+					if (delay_range > DELAY_RANGE_THRESHOLD)
+						break;
+				}
+				delay_min = -1;
+				delay_max = -1;
+			}
+		} else {
+			if (delay_min == -1) {
+				delay_min = i;
+				continue;
+			} else {
+				delay_max = i;
+				continue;
+			}
+		}
+	}
+	if (delay == -1) {
+		pr_err("%s: delay code tuning failed!\n",
+		       mmc_hostname(host->mmc));
+		eswin_sdhci_disable_card_clk(host);
+		eswin_sdhci_sdio_config_phy_delay(host,
+						  eswin_sdhci->phy.delay_code);
+		eswin_sdhci_enable_card_clk(host);
+
+		return ret;
+	}
+
+	pr_info("%s: set delay:0x%x\n", mmc_hostname(host->mmc), delay);
+	eswin_sdhci_disable_card_clk(host);
+	eswin_sdhci_sdio_config_phy_delay(host, delay);
+	eswin_sdhci_enable_card_clk(host);
+
+	return 0;
+}
+
+static int eswin_sdhci_sdio_phase_code_tuning(struct sdhci_host *host,
+					      u32 opcode)
+{
+	int cmd_error = 0;
+	int ret = 0;
+	int phase_code = 0;
+	int code_min = -1;
+	int code_max = -1;
+
+	for (phase_code = 0; phase_code <= MAX_PHASE_CODE; phase_code++) {
+		eswin_sdhci_disable_card_clk(host);
+		sdhci_writew(host, phase_code, VENDOR_AT_SATA_R);
+		eswin_sdhci_enable_card_clk(host);
+
+		ret = mmc_send_tuning(host->mmc, opcode, &cmd_error);
+		if (ret) {
+			host->ops->reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);
+			udelay(200);
+			if (code_min != -1 && code_max != -1)
+				break;
+		} else {
+			if (code_min == -1) {
+				code_min = phase_code;
+				continue;
+			} else {
+				code_max = phase_code;
+				continue;
+			}
+		}
+	}
+	if (code_min == -1 && code_max == -1) {
+		pr_err("%s: phase code tuning failed!\n",
+		       mmc_hostname(host->mmc));
+		eswin_sdhci_disable_card_clk(host);
+		sdhci_writew(host, 0, VENDOR_AT_SATA_R);
+		eswin_sdhci_enable_card_clk(host);
+		return -EIO;
+	}
+
+	phase_code = (code_min + code_max) / 2;
+	pr_info("%s: set phase_code:0x%x\n", mmc_hostname(host->mmc), phase_code);
+
+	eswin_sdhci_disable_card_clk(host);
+	sdhci_writew(host, phase_code, VENDOR_AT_SATA_R);
+	eswin_sdhci_enable_card_clk(host);
+
+	return 0;
+}
+
+static int eswin_sdhci_sdio_executing_tuning(struct sdhci_host *host,
+					     u32 opcode)
+{
+	u32 ctrl;
+	u32 val;
+	int ret = 0;
+	struct sdhci_pltfm_host *pltfm_host;
+	struct eswin_sdhci_data *eswin_sdhci_sdio;
+	struct eswin_sdio_private *eswin_sdio_priv;
+
+	pltfm_host = sdhci_priv(host);
+	eswin_sdhci_sdio = sdhci_pltfm_priv(pltfm_host);
+	eswin_sdio_priv = sdhci_sdio_priv(eswin_sdhci_sdio);
+
+	if (!eswin_sdio_priv->enable_sw_tuning) {
+		if (eswin_sdio_priv->phase_code != -1) {
+			eswin_sdhci_disable_card_clk(host);
+			sdhci_writew(host, eswin_sdio_priv->phase_code, VENDOR_AT_SATA_R);
+			eswin_sdhci_enable_card_clk(host);
+		}
+		return 0;
+	}
+
+	eswin_sdhci_disable_card_clk(host);
+
+	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl &= ~SDHCI_CTRL_TUNED_CLK;
+	sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
+
+	val = sdhci_readl(host, VENDOR_AT_CTRL_R);
+	val |= SW_TUNE_ENABLE;
+	sdhci_writew(host, val, VENDOR_AT_CTRL_R);
+	sdhci_writew(host, 0, VENDOR_AT_SATA_R);
+
+	eswin_sdhci_enable_card_clk(host);
+
+	sdhci_writew(host, 0x0, SDHCI_CMD_DATA);
+
+	ret = eswin_sdhci_sdio_delay_tuning(host, opcode);
+	if (ret < 0) {
+		return ret;
+	}
+
+	ret = eswin_sdhci_sdio_phase_code_tuning(host, opcode);
+	if (ret < 0) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static u32 eswin_sdhci_sdio_cqhci_irq(struct sdhci_host *host, u32 intmask)
+{
+	int cmd_error = 0;
+	int data_error = 0;
+
+	if (!sdhci_cqe_irq(host, intmask, &cmd_error, &data_error))
+		return intmask;
+
+	cqhci_irq(host->mmc, intmask, cmd_error, data_error);
+
+	return 0;
+}
+
+static void eswin_sdhci_sdio_dumpregs(struct mmc_host *mmc)
+{
+	sdhci_dumpregs(mmc_priv(mmc));
+}
+
+static void eswin_sdhci_sdio_cqe_enable(struct mmc_host *mmc)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHCI_PRESENT_STATE);
+	while (reg & SDHCI_DATA_AVAILABLE) {
+		sdhci_readl(host, SDHCI_BUFFER);
+		reg = sdhci_readl(host, SDHCI_PRESENT_STATE);
+	}
+
+	sdhci_cqe_enable(mmc);
+}
+
+static const struct cqhci_host_ops eswin_sdhci_sdio_cqhci_ops = {
+	.enable = eswin_sdhci_sdio_cqe_enable,
+	.disable = sdhci_cqe_disable,
+	.dumpregs = eswin_sdhci_sdio_dumpregs,
+};
+
+static const struct sdhci_ops eswin_sdhci_sdio_cqe_ops = {
+	.set_clock = eswin_sdhci_sdio_set_clock,
+	.get_max_clock = sdhci_pltfm_clk_get_max_clock,
+	.get_timeout_clock = sdhci_pltfm_clk_get_max_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.reset = eswin_sdhci_sdio_reset,
+	.set_uhs_signaling = sdhci_set_uhs_signaling,
+	.set_power = sdhci_set_power_and_bus_voltage,
+	.irq = eswin_sdhci_sdio_cqhci_irq,
+	.platform_execute_tuning = eswin_sdhci_sdio_executing_tuning,
+
+};
+
+static const struct sdhci_pltfm_data eswin_sdhci_sdio_cqe_pdata = {
+	.ops = &eswin_sdhci_sdio_cqe_ops,
+	.quirks = SDHCI_QUIRK_BROKEN_CQE | SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+		   SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN,
+};
+
+#ifdef CONFIG_PM_SLEEP
+/**
+ * eswin_sdhci_sdio_suspend- Suspend method for the driver
+ * @dev:        Address of the device structure
+ *
+ * Put the device in a low power state.
+ *
+ * Return: 0 on success and error value on error
+ */
+static int eswin_sdhci_sdio_suspend(struct device *dev)
+{
+	struct sdhci_host *host = dev_get_drvdata(dev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci_sdio =
+		sdhci_pltfm_priv(pltfm_host);
+	int ret;
+
+	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+		mmc_retune_needed(host->mmc);
+
+	if (eswin_sdhci_sdio->has_cqe) {
+		ret = cqhci_suspend(host->mmc);
+		if (ret)
+			return ret;
+	}
+
+	ret = sdhci_suspend_host(host);
+	if (ret)
+		return ret;
+
+	clk_disable(pltfm_host->clk);
+	clk_disable(eswin_sdhci_sdio->clk_ahb);
+
+	return 0;
+}
+
+/**
+ * eswin_sdhci_sdio_resume- Resume method for the driver
+ * @dev:        Address of the device structure
+ *
+ * Resume operation after suspend
+ *
+ * Return: 0 on success and error value on error
+ */
+static int eswin_sdhci_sdio_resume(struct device *dev)
+{
+	struct sdhci_host *host = dev_get_drvdata(dev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci_sdio =
+		sdhci_pltfm_priv(pltfm_host);
+	int ret;
+
+	ret = clk_enable(eswin_sdhci_sdio->clk_ahb);
+	if (ret) {
+		dev_err(dev, "Cannot enable AHB clock.\n");
+		return ret;
+	}
+
+	ret = clk_enable(pltfm_host->clk);
+	if (ret) {
+		dev_err(dev, "Cannot enable SD clock.\n");
+		return ret;
+	}
+
+	ret = sdhci_resume_host(host);
+	if (ret) {
+		dev_err(dev, "Cannot resume host.\n");
+		return ret;
+	}
+
+	if (eswin_sdhci_sdio->has_cqe)
+		return cqhci_resume(host->mmc);
+
+	return 0;
+}
+#endif /* ! CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(eswin_sdhci_sdio_dev_pm_ops, eswin_sdhci_sdio_suspend,
+			 eswin_sdhci_sdio_resume);
+
+/**
+ * eswin_sdhci_sdio_sdcardclk_recalc_rate- Return the card clock rate
+ *
+ * @hw:                 Pointer to the hardware clock structure.
+ * @parent_rate:                The parent rate (should be rate of clk_xin).
+ *
+ * Return the current actual rate of the SD card clock.  This can be used
+ * to communicate with out PHY.
+ *
+ * Return: The card clock rate.
+ */
+static unsigned long
+eswin_sdhci_sdio_sdcardclk_recalc_rate(struct clk_hw *hw,
+				       unsigned long parent_rate)
+{
+	struct eswin_sdhci_clk_data *clk_data = container_of(
+		hw, struct eswin_sdhci_clk_data, sdcardclk_hw);
+	struct eswin_sdhci_data *eswin_sdhci_sdio =
+		container_of(clk_data, struct eswin_sdhci_data, clk_data);
+	struct sdhci_host *host = eswin_sdhci_sdio->host;
+
+	return host->mmc->actual_clock;
+}
+
+static const struct clk_ops eswin_sdio_sdcardclk_ops = {
+	.recalc_rate = eswin_sdhci_sdio_sdcardclk_recalc_rate,
+};
+
+/**
+ * eswin_sdhci_sdio_sampleclk_recalc_rate- Return the sampling clock rate
+ *
+ * @hw:                 Pointer to the hardware clock structure.
+ * @parent_rate:                The parent rate (should be rate of clk_xin).
+ *
+ * Return the current actual rate of the sampling clock.  This can be used
+ * to communicate with out PHY.
+ *
+ * Return: The sample clock rate.
+ */
+static unsigned long
+eswin_sdhci_sdio_sampleclk_recalc_rate(struct clk_hw *hw,
+				       unsigned long parent_rate)
+{
+	struct eswin_sdhci_clk_data *clk_data = container_of(
+		hw, struct eswin_sdhci_clk_data, sampleclk_hw);
+	struct eswin_sdhci_data *eswin_sdhci_sdio =
+		container_of(clk_data, struct eswin_sdhci_data, clk_data);
+	struct sdhci_host *host = eswin_sdhci_sdio->host;
+
+	return host->mmc->actual_clock;
+}
+
+static const struct clk_ops eswin_sdio_sampleclk_ops = {
+	.recalc_rate = eswin_sdhci_sdio_sampleclk_recalc_rate,
+};
+
+static const struct eswin_sdhci_clk_ops eswin_sdio_clk_ops = {
+	.sdcardclk_ops = &eswin_sdio_sdcardclk_ops,
+	.sampleclk_ops = &eswin_sdio_sampleclk_ops,
+};
+
+static struct eswin_sdhci_of_data eswin_sdhci_fu800_sdio_data = {
+	.pdata = &eswin_sdhci_sdio_cqe_pdata,
+	.clk_ops = &eswin_sdio_clk_ops,
+};
+
+static const struct of_device_id eswin_sdhci_sdio_of_match[] = {
+	/* SoC-specific compatible strings*/
+	{
+		.compatible = "eswin,sdhci-sdio",
+		.data = &eswin_sdhci_fu800_sdio_data,
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, eswin_sdhci_sdio_of_match);
+
+/**
+ * eswin_sdhci_sdio_register_sdcardclk- Register the sdcardclk for a PHY to use
+ *
+ * @sdhci_arasan:       Our private data structure.
+ * @clk_xin:            Pointer to the functional clock
+ * @dev:                Pointer to our struct device.
+ *
+ * Some PHY devices need to know what the actual card clock is.  In order for
+ * them to find out, we'll provide a clock through the common clock framework
+ * for them to query.
+ *
+ * Return: 0 on success and error value on error
+ */
+static int eswin_sdhci_sdio_register_sdcardclk(
+	struct eswin_sdhci_data *eswin_sdhci_sdio, struct clk *clk_xin,
+	struct device *dev)
+{
+	struct eswin_sdhci_clk_data *clk_data =
+		&eswin_sdhci_sdio->clk_data;
+	struct device_node *np = dev->of_node;
+	struct clk_init_data sdcardclk_init;
+	const char *parent_clk_name;
+	int ret;
+
+	ret = of_property_read_string_index(np, "clock-output-names", 0,
+					    &sdcardclk_init.name);
+	if (ret) {
+		dev_err(dev, "DT has #clock-cells but no clock-output-names\n");
+		return ret;
+	}
+
+	parent_clk_name = __clk_get_name(clk_xin);
+	sdcardclk_init.parent_names = &parent_clk_name;
+	sdcardclk_init.num_parents = 1;
+	sdcardclk_init.flags = CLK_GET_RATE_NOCACHE;
+	sdcardclk_init.ops = eswin_sdhci_sdio->clk_ops->sdcardclk_ops;
+
+	clk_data->sdcardclk_hw.init = &sdcardclk_init;
+	clk_data->sdcardclk = devm_clk_register(dev, &clk_data->sdcardclk_hw);
+	if (IS_ERR(clk_data->sdcardclk))
+		return PTR_ERR(clk_data->sdcardclk);
+	clk_data->sdcardclk_hw.init = NULL;
+
+	ret = of_clk_add_provider(np, of_clk_src_simple_get,
+				  clk_data->sdcardclk);
+	if (ret)
+		dev_err(dev, "Failed to add sdcard clock provider\n");
+
+	return ret;
+}
+
+/**
+ * eswin_sdhci_sdio_register_sampleclk - Register the sampleclk for a PHY to use
+ *
+ * @sdhci_arasan:       Our private data structure.
+ * @clk_xin:            Pointer to the functional clock
+ * @dev:                Pointer to our struct device.
+ *
+ * Some PHY devices need to know what the actual card clock is.  In order for
+ * them to find out, we'll provide a clock through the common clock framework
+ * for them to query.
+ *
+ * Return: 0 on success and error value on error
+ */
+static int eswin_sdhci_sdio_register_sampleclk(
+	struct eswin_sdhci_data *eswin_sdhci_sdio, struct clk *clk_xin,
+	struct device *dev)
+{
+	struct eswin_sdhci_clk_data *clk_data =
+		&eswin_sdhci_sdio->clk_data;
+	struct device_node *np = dev->of_node;
+	struct clk_init_data sampleclk_init;
+	const char *parent_clk_name;
+	int ret;
+
+	ret = of_property_read_string_index(np, "clock-output-names", 1,
+					    &sampleclk_init.name);
+	if (ret) {
+		dev_err(dev, "DT has #clock-cells but no clock-output-names\n");
+		return ret;
+	}
+
+	parent_clk_name = __clk_get_name(clk_xin);
+	sampleclk_init.parent_names = &parent_clk_name;
+	sampleclk_init.num_parents = 1;
+	sampleclk_init.flags = CLK_GET_RATE_NOCACHE;
+	sampleclk_init.ops = eswin_sdhci_sdio->clk_ops->sampleclk_ops;
+
+	clk_data->sampleclk_hw.init = &sampleclk_init;
+	clk_data->sampleclk = devm_clk_register(dev, &clk_data->sampleclk_hw);
+	if (IS_ERR(clk_data->sampleclk))
+		return PTR_ERR(clk_data->sampleclk);
+	clk_data->sampleclk_hw.init = NULL;
+
+	ret = of_clk_add_provider(np, of_clk_src_simple_get,
+				  clk_data->sampleclk);
+	if (ret)
+		dev_err(dev, "Failed to add sample clock provider\n");
+
+	return ret;
+}
+
+/**
+ * eswin_sdhci_sdio_unregister_sdclk- Undoes sdhci_arasan_register_sdclk()
+ *
+ * @dev:                Pointer to our struct device.
+ *
+ * Should be called any time we're exiting and sdhci_arasan_register_sdclk()
+ * returned success.
+ */
+static void eswin_sdhci_sdio_unregister_sdclk(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+
+	if (!of_find_property(np, "#clock-cells", NULL))
+		return;
+
+	of_clk_del_provider(dev->of_node);
+}
+
+/**
+ * eswin_sdhci_sdio_register_sdclk- Register the sdcardclk for a PHY to use
+ *
+ * @eswin_sdhci_sdio:   Our private data structure.
+ * @clk_xin:            Pointer to the functional clock
+ * @dev:                Pointer to our struct device.
+ *
+ * Some PHY devices need to know what the actual card clock is.  In order for
+ * them to find out, we'll provide a clock through the common clock framework
+ * for them to query.
+ *
+ * Note: without seriously re-architecting SDHCI's clock code and testing on
+ * all platforms, there's no way to create a totally beautiful clock here
+ * with all clock ops implemented.      Instead, we'll just create a clock that can
+ * be queried and set the CLK_GET_RATE_NOCACHE attribute to tell common clock
+ * framework that we're doing things behind its back.  This should be sufficient
+ * to create nice clean device tree bindings and later (if needed) we can try
+ * re-architecting SDHCI if we see some benefit to it.
+ *
+ * Return: 0 on success and error value on error
+ */
+static int
+eswin_sdhci_sdio_register_sdclk(struct eswin_sdhci_data *eswin_sdhci_sdio,
+				struct clk *clk_xin, struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	u32 num_clks = 0;
+	int ret;
+
+	/* Providing a clock to the PHY is optional; no error if missing */
+	if (of_property_read_u32(np, "#clock-cells", &num_clks) < 0)
+		return 0;
+
+	ret = eswin_sdhci_sdio_register_sdcardclk(eswin_sdhci_sdio, clk_xin,
+						  dev);
+	if (ret)
+		return ret;
+
+	if (num_clks) {
+		ret = eswin_sdhci_sdio_register_sampleclk(eswin_sdhci_sdio,
+							  clk_xin, dev);
+		if (ret) {
+			eswin_sdhci_sdio_unregister_sdclk(dev);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int
+eswin_sdhci_sdio_add_host(struct eswin_sdhci_data *eswin_sdhci_sdio)
+{
+	struct sdhci_host *host = eswin_sdhci_sdio->host;
+	struct cqhci_host *cq_host;
+	bool dma64;
+	int ret;
+
+	if (!eswin_sdhci_sdio->has_cqe)
+		return sdhci_add_host(host);
+
+	ret = sdhci_setup_host(host);
+	if (ret)
+		return ret;
+
+	cq_host = devm_kzalloc(host->mmc->parent, sizeof(*cq_host), GFP_KERNEL);
+	if (!cq_host) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	cq_host->mmio = host->ioaddr + ESWIN_SDHCI_SD_CQE_BASE_ADDR;
+	cq_host->ops = &eswin_sdhci_sdio_cqhci_ops;
+
+	dma64 = host->flags & SDHCI_USE_64_BIT_DMA;
+	if (dma64)
+		cq_host->caps |= CQHCI_TASK_DESC_SZ_128;
+
+	ret = cqhci_init(cq_host, host->mmc, dma64);
+	if (ret)
+		goto cleanup;
+
+	ret = __sdhci_add_host(host);
+	if (ret)
+		goto cleanup;
+
+	return 0;
+
+cleanup:
+	sdhci_cleanup_host(host);
+	return ret;
+}
+
+static int eswin_sdhci_sdio_sid_cfg(struct device *dev)
+{
+	int ret;
+	struct regmap *regmap;
+	int hsp_mmu_sdio_reg;
+	u32 rdwr_sid_ssid;
+	u32 sid;
+	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+
+	/* not behind smmu, use the default reset value(0x0) of the reg as streamID*/
+	if (fwspec == NULL) {
+		dev_dbg(dev,
+			"dev is not behind smmu, skip configuration of sid\n");
+		return 0;
+	}
+	sid = fwspec->ids[0];
+
+	regmap = syscon_regmap_lookup_by_phandle(dev->of_node,
+						 "eswin,hsp_sp_csr");
+	if (IS_ERR(regmap)) {
+		dev_dbg(dev, "No hsp_sp_csr phandle specified\n");
+		return 0;
+	}
+
+	ret = of_property_read_u32_index(dev->of_node, "eswin,hsp_sp_csr", 1,
+					 &hsp_mmu_sdio_reg);
+	if (ret) {
+		dev_err(dev, "can't get sdio sid cfg reg offset (%d)\n", ret);
+		return ret;
+	}
+
+	/* make the reading sid the same as writing sid, ssid is fixed to zero */
+	rdwr_sid_ssid = FIELD_PREP(AWSMMUSID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(ARSMMUSID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(AWSMMUSSID, 0);
+	rdwr_sid_ssid |= FIELD_PREP(ARSMMUSSID, 0);
+	regmap_write(regmap, hsp_mmu_sdio_reg, rdwr_sid_ssid);
+
+	ret = eic7700_dynm_sid_enable(dev_to_node(dev));
+	if (ret < 0)
+		dev_err(dev, "failed to config sdio streamID(%d)!\n", sid);
+	else
+		dev_dbg(dev, "success to config sdio streamID(%d)!\n", sid);
+
+	return ret;
+}
+
+static int eswin_sdhci_sdio_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct clk *clk_xin;
+	struct clk *clk_spll2_fout3;
+	struct clk *clk_mux;
+	struct sdhci_host *host;
+	struct sdhci_pltfm_host *pltfm_host;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node;
+	struct eswin_sdhci_data *eswin_sdhci_sdio;
+	struct eswin_sdio_private *eswin_sdio_priv;
+	struct regmap *regmap;
+	const struct eswin_sdhci_of_data *data;
+	unsigned int sdio_id = 0;
+	unsigned int val = 0;
+
+	data = of_device_get_match_data(dev);
+	host = sdhci_pltfm_init(pdev, data->pdata, sizeof(*eswin_sdhci_sdio) + sizeof(*eswin_sdio_priv));
+
+	if (IS_ERR(host))
+		return PTR_ERR(host);
+
+	pltfm_host = sdhci_priv(host);
+	eswin_sdhci_sdio = sdhci_pltfm_priv(pltfm_host);
+	eswin_sdhci_sdio->host = host;
+	eswin_sdhci_sdio->has_cqe = false;
+	eswin_sdio_priv = sdhci_sdio_priv(eswin_sdhci_sdio);
+
+	ret = of_property_read_u32(dev->of_node, "core-clk-reg", &val);
+	if (ret) {
+		dev_err(dev, "get core clk reg failed.\n");
+		goto err_pltfm_free;
+	}
+
+	eswin_sdhci_sdio->core_clk_reg = ioremap(val, 0x4);
+	if (!eswin_sdhci_sdio->core_clk_reg) {
+		dev_err(dev, "ioremap core clk reg failed.\n");
+		goto err_pltfm_free;
+	}
+
+	ret = of_property_read_u32(dev->of_node, "sdio-id", &sdio_id);
+	if (ret) {
+		dev_err(dev, "get sdio-id failed.\n");
+		goto err_pltfm_free;
+	}
+
+	sdhci_get_of_property(pdev);
+
+	eswin_sdhci_sdio->clk_ops = data->clk_ops;
+	eswin_sdhci_sdio->clk_ahb = devm_clk_get(dev, "clk_ahb");
+	if (IS_ERR(eswin_sdhci_sdio->clk_ahb)) {
+		ret = dev_err_probe(dev, PTR_ERR(eswin_sdhci_sdio->clk_ahb),
+				    "clk_ahb clock not found.\n");
+		goto err_pltfm_free;
+	}
+
+	clk_xin = devm_clk_get(dev, "clk_xin");
+	if (IS_ERR(clk_xin)) {
+		ret = dev_err_probe(dev, PTR_ERR(clk_xin),
+				    "clk_xin clock not found.\n");
+		goto err_pltfm_free;
+	}
+
+	clk_spll2_fout3 = devm_clk_get(dev, "clk_spll2_fout3");
+
+	if (IS_ERR(clk_spll2_fout3)) {
+		ret = dev_err_probe(dev, PTR_ERR(clk_spll2_fout3),
+				    "clk_spll2_fout3 clock not found.\n");
+		goto err_pltfm_free;
+	}
+
+	if (of_device_is_compatible(np, "eswin,sdhci-sdio")) {
+		clk_mux = devm_clk_get(dev, "clk_mux1_1");
+		if (IS_ERR(clk_mux)) {
+			ret = dev_err_probe(dev, PTR_ERR(clk_mux),
+					    "clk_mux1_1 clock not found.\n");
+			goto err_pltfm_free;
+		}
+		/*switch the core clk source*/
+		clk_set_parent(clk_mux, clk_spll2_fout3);
+	}
+
+	ret = clk_prepare_enable(eswin_sdhci_sdio->clk_ahb);
+	if (ret) {
+		dev_err(dev, "Unable to enable AHB clock.\n");
+		goto err_pltfm_free;
+	}
+	/* If clock-frequency property is set, use the provided value */
+	if (pltfm_host->clock && pltfm_host->clock != clk_get_rate(clk_xin)) {
+		ret = clk_set_rate(clk_xin, pltfm_host->clock);
+		if (ret) {
+			dev_err(&pdev->dev, "Failed to set SD clock rate\n");
+			goto clk_dis_ahb;
+		}
+	}
+
+	ret = clk_prepare_enable(clk_xin);
+	if (ret) {
+		dev_err(dev, "Unable to enable SD clock.\n");
+		goto clk_dis_ahb;
+	}
+
+	pltfm_host->clk = clk_xin;
+	ret = eswin_sdhci_sdio_register_sdclk(eswin_sdhci_sdio, clk_xin, dev);
+	if (ret)
+		goto clk_disable_all;
+
+	ret = eswin_sdhci_reset_init(dev, eswin_sdhci_sdio);
+	if (ret < 0) {
+		dev_err(dev, "failed to reset\n");
+		goto clk_disable_all;
+	}
+
+	regmap = syscon_regmap_lookup_by_phandle(dev->of_node,
+						 "eswin,hsp_sp_csr");
+	if (IS_ERR(regmap)) {
+		dev_dbg(dev, "No hsp_sp_csr phandle specified\n");
+		return 0;
+	}
+
+	if (sdio_id == 0) {
+		regmap_write(regmap, ESWIN_SDHCI_SD0_INT_STATUS,
+			     MSHC_INT_CLK_STABLE);
+		regmap_write(regmap, ESWIN_SDHCI_SD0_PWR_CTRL, MSHC_HOST_VAL_STABLE);
+	} else {
+		regmap_write(regmap, ESWIN_SDHCI_SD1_INT_STATUS,
+			     MSHC_INT_CLK_STABLE);
+		regmap_write(regmap, ESWIN_SDHCI_SD1_PWR_CTRL, MSHC_HOST_VAL_STABLE);
+	}
+
+	ret = eswin_sdhci_sdio_sid_cfg(dev);
+	if (ret < 0) {
+		dev_err(dev, "failed to use smmu\n");
+		goto clk_disable_all;
+	}
+
+	if (!of_property_read_u32(dev->of_node, "delay_code", &val)) {
+		eswin_sdhci_sdio->phy.delay_code = val;
+	}
+
+	if (!of_property_read_u32(dev->of_node, "drive-impedance-ohm", &val))
+		eswin_sdhci_sdio->phy.drive_impedance =
+			eswin_convert_drive_impedance_ohm(pdev, val);
+
+	if (of_property_read_bool(dev->of_node, "enable-cmd-pullup"))
+		eswin_sdhci_sdio->phy.enable_cmd_pullup = ENABLE;
+	else
+		eswin_sdhci_sdio->phy.enable_cmd_pullup = DISABLE;
+
+	if (of_property_read_bool(dev->of_node, "enable-data-pullup"))
+		eswin_sdhci_sdio->phy.enable_data_pullup = ENABLE;
+	else
+		eswin_sdhci_sdio->phy.enable_data_pullup = DISABLE;
+
+	if (of_property_read_bool(dev->of_node, "enable_sw_tuning"))
+		eswin_sdio_priv->enable_sw_tuning = ENABLE;
+	else
+		eswin_sdio_priv->enable_sw_tuning = DISABLE;
+
+	if (!of_property_read_u32(dev->of_node, "phase_code", &val)) {
+		eswin_sdio_priv->phase_code = val;
+	} else {
+		eswin_sdio_priv->phase_code = -1;
+	}
+
+	eswin_sdhci_dt_parse_clk_phases(dev, &eswin_sdhci_sdio->clk_data);
+	ret = mmc_of_parse(host->mmc);
+	if (ret) {
+		ret = dev_err_probe(dev, ret, "parsing dt failed.\n");
+		goto unreg_clk;
+	}
+
+	eic7700_tbu_power(&pdev->dev, true);
+
+	ret = eswin_sdhci_sdio_add_host(eswin_sdhci_sdio);
+	if (ret)
+		goto unreg_clk;
+
+	return 0;
+
+unreg_clk:
+	eswin_sdhci_sdio_unregister_sdclk(dev);
+clk_disable_all:
+	clk_disable_unprepare(clk_xin);
+clk_dis_ahb:
+	clk_disable_unprepare(eswin_sdhci_sdio->clk_ahb);
+err_pltfm_free:
+	if (eswin_sdhci_sdio->core_clk_reg)
+		iounmap(eswin_sdhci_sdio->core_clk_reg);
+
+	sdhci_pltfm_free(pdev);
+	return ret;
+}
+
+static int eswin_sdhci_sdio_remove(struct platform_device *pdev)
+{
+	int ret;
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci_sdio =
+		sdhci_pltfm_priv(pltfm_host);
+	struct clk *clk_ahb = eswin_sdhci_sdio->clk_ahb;
+	void __iomem *core_clk_reg = eswin_sdhci_sdio->core_clk_reg;
+
+	sdhci_pltfm_remove(pdev);
+	eic7700_tbu_power(&pdev->dev, false);
+
+	if (eswin_sdhci_sdio->txrx_rst) {
+		ret = reset_control_assert(eswin_sdhci_sdio->txrx_rst);
+		WARN_ON(0 != ret);
+	}
+
+	if (eswin_sdhci_sdio->phy_rst) {
+		ret = reset_control_assert(eswin_sdhci_sdio->phy_rst);
+		WARN_ON(0 != ret);
+	}
+
+	if (eswin_sdhci_sdio->prstn) {
+		ret = reset_control_assert(eswin_sdhci_sdio->prstn);
+		WARN_ON(0 != ret);
+	}
+
+	if (eswin_sdhci_sdio->arstn) {
+		ret = reset_control_assert(eswin_sdhci_sdio->arstn);
+		WARN_ON(0 != ret);
+	}
+
+	eswin_sdhci_sdio_unregister_sdclk(&pdev->dev);
+	clk_disable_unprepare(clk_ahb);
+	iounmap(core_clk_reg);
+
+	return 0;
+}
+
+static struct platform_driver eswin_sdhci_sdio_driver = {
+	.driver = {
+		.name = "eswin-sdhci-sdio",
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+		.of_match_table = eswin_sdhci_sdio_of_match,
+		.pm = &eswin_sdhci_sdio_dev_pm_ops,
+	},
+	.probe = eswin_sdhci_sdio_probe,
+	.remove = eswin_sdhci_sdio_remove,
+};
+
+static __init int eswin_sdhci_sdio_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&eswin_sdhci_sdio_driver);
+	if (ret) {
+		pr_err("%s: failed to register platform driver\n",
+			__func__);
+	}
+
+	return ret;
+}
+
+static void __exit eswin_sdhci_sdio_exit(void)
+{
+	platform_driver_unregister(&eswin_sdhci_sdio_driver);
+}
+
+/*Cause EMMC is often used as a system disk(mmc0), we need the SD driver to run later than the EMMC driver*/
+late_initcall(eswin_sdhci_sdio_init);
+module_exit(eswin_sdhci_sdio_exit);
+
+MODULE_DESCRIPTION("Driver for the Eswin SDHCI Controller");
+MODULE_AUTHOR("Eswin");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mmc/host/sdhci-of-eswin.c b/drivers/mmc/host/sdhci-of-eswin.c
new file mode 100644
index 000000000000..008b243dff32
--- /dev/null
+++ b/drivers/mmc/host/sdhci-of-eswin.c
@@ -0,0 +1,1104 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Emmc Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: liangshuang <liangshuang@eswin.com>
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/phy/phy.h>
+#include <linux/regmap.h>
+#include <linux/of.h>
+#include "cqhci.h"
+#include "sdhci-pltfm.h"
+#include <linux/reset.h>
+#include <linux/iommu.h>
+#include <linux/bitfield.h>
+#include <linux/regmap.h>
+#include <linux/eic7700-sid-cfg.h>
+#include "sdhci-eswin.h"
+
+#define SDHCI_EMMC0_INT_STATUS 0x508
+#define SDHCI_EMMC0_PWR_CLEAR 0x50c
+
+//EMMC_DWC_MSHC_CRYPTO_CFG_PTR 8 -- parameter
+#define eswin_sdhci_VENDOR_REGISTER_BASEADDR 0x800
+#define eswin_sdhci_VENDOR_EMMC_CTRL_REGISTER 0x2c
+#define VENDOR_ENHANCED_STROBE BIT(8)
+
+#define eswin_sdhci_CQE_BASE_ADDR eswin_sdhci_VENDOR_REGISTER_BASEADDR
+
+/* Controller does not have CD wired and will not function normally without */
+#define eswin_sdhci_QUIRK_FORCE_CDTEST BIT(0)
+/* Controller immediately reports SDHCI_CLOCK_INT_STABLE after enabling the
+ * internal clock even when the clock isn't stable */
+#define eswin_sdhci_QUIRK_CLOCK_UNSTABLE BIT(1)
+
+/*
+ * On some SoCs the syscon area has a feature where the upper 16-bits of
+ * each 32-bit register act as a write mask for the lower 16-bits.  This allows
+ * atomic updates of the register without locking.  This macro is used on SoCs
+ * that have that feature.
+ */
+#define HIWORD_UPDATE(val, mask, shift) \
+	((val) << (shift) | (mask) << ((shift) + 16))
+
+#define ESWIN_EMMC_CORE_CLK_REG 0x51828160
+
+static void eswin_sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci = sdhci_pltfm_priv(pltfm_host);
+	struct eswin_sdhci_clk_data *clk_data = &eswin_sdhci->clk_data;
+
+	/* Set the Input and Output Clock Phase Delays */
+	if (clk_data->set_clk_delays)
+		clk_data->set_clk_delays(host);
+
+	eswin_sdhci_set_core_clock(host, clock);
+	sdhci_set_clock(host, clock);
+
+	/*
+	 * Some controllers immediately report SDHCI_CLOCK_INT_STABLE
+	 * after enabling the clock even though the clock is not
+	 * stable. Trying to use a clock without waiting here results
+	 * in EILSEQ while detecting some older/slower cards. The
+	 * chosen delay is the maximum delay from sdhci_set_clock.
+	 */
+	if (eswin_sdhci->quirks & SDHCI_ESWIN_QUIRK_CLOCK_UNSTABLE)
+		msleep(20);
+}
+
+#if !defined(__FPGA) && !defined(__ZEBU)
+static void eswin_sdhci_hs400_enhanced_strobe(struct mmc_host *mmc,
+					      struct mmc_ios *ios)
+{
+	u32 vendor;
+	struct sdhci_host *host = mmc_priv(mmc);
+
+	vendor = sdhci_readl(host, eswin_sdhci_VENDOR_EMMC_CTRL_REGISTER);
+	if (ios->enhanced_strobe)
+		vendor |= VENDOR_ENHANCED_STROBE;
+	else
+		vendor &= ~VENDOR_ENHANCED_STROBE;
+
+	sdhci_writel(host, vendor, eswin_sdhci_VENDOR_EMMC_CTRL_REGISTER);
+}
+#endif
+
+static void eswin_sdhci_config_phy_delay(struct sdhci_host *host, int delay)
+{
+	delay &= PHY_CLK_MAX_DELAY_MASK;
+
+	/*phy clk delay line config*/
+	sdhci_writeb(host, PHY_UPDATE_DELAY_CODE, PHY_SDCLKDL_CNFG_R);
+	sdhci_writeb(host, delay, PHY_SDCLKDL_DC_R);
+	sdhci_writeb(host, 0x0, PHY_SDCLKDL_CNFG_R);
+}
+
+static void eswin_sdhci_config_phy(struct sdhci_host *host)
+{
+	unsigned int val = 0;
+	unsigned int drv = 0;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci = sdhci_pltfm_priv(pltfm_host);
+	struct eswin_sdhci_phy_data *phy = &eswin_sdhci->phy;
+
+	drv = phy->drive_impedance << PHY_PAD_SP_DRIVE_SHIF;
+
+	pr_debug("%s: phy drv=0x%x\n", mmc_hostname(host->mmc), drv);
+
+	val = sdhci_readw(host, VENDOR_EMMC_CTRL_R);
+	val |= EMMC_CRAD_PRESENT;  // emmc card
+	sdhci_writew(host, val, VENDOR_EMMC_CTRL_R);
+
+	eswin_sdhci_disable_card_clk(host);
+
+	/* reset phy,config phy's pad */
+	sdhci_writel(host, drv | (~PHY_RSTN), PHY_CNFG_R);
+	/*CMDPAD_CNFS*/
+	val = (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_P_BIT_SHIFT) |
+		(PHY_SLEW_2 << PHY_TX_SLEW_CTRL_N_BIT_SHIFT) |
+		(phy->enable_cmd_pullup << PHY_PULL_BIT_SHIF) | PHY_PAD_RXSEL_1;
+	sdhci_writew(host, val, PHY_CMDPAD_CNFG_R);
+	pr_debug("%s: phy cmd=0x%x\n", mmc_hostname(host->mmc), val);
+
+	/*DATA PAD CNFG*/
+	val = (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_P_BIT_SHIFT) |
+		(PHY_SLEW_2 << PHY_TX_SLEW_CTRL_N_BIT_SHIFT) |
+		(phy->enable_data_pullup << PHY_PULL_BIT_SHIF) | PHY_PAD_RXSEL_1;
+	sdhci_writew(host, val, PHY_DATAPAD_CNFG_R);
+	pr_debug("%s: phy data=0x%x\n", mmc_hostname(host->mmc), val);
+
+	/*Clock PAD Setting*/
+	val = (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_P_BIT_SHIFT) |
+		(PHY_SLEW_2 << PHY_TX_SLEW_CTRL_N_BIT_SHIFT) | PHY_PAD_RXSEL_0;
+	sdhci_writew(host, val, PHY_CLKPAD_CNFG_R);
+	pr_debug("%s: phy clk=0x%x\n", mmc_hostname(host->mmc), val);
+
+	/*PHY strobe PAD setting*/
+	val = (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_P_BIT_SHIFT) |
+		(PHY_SLEW_2 << PHY_TX_SLEW_CTRL_N_BIT_SHIFT) |
+		((phy->enable_strobe_pulldown * PHY_PULL_DOWN) << PHY_PULL_BIT_SHIF) |
+		PHY_PAD_RXSEL_1;
+	sdhci_writew(host, val, PHY_STBPAD_CNFG_R);
+	pr_debug("%s: phy strobe=0x%x\n", mmc_hostname(host->mmc), val);
+	mdelay(2);
+
+	/*PHY RSTN PAD setting*/
+	val = (PHY_SLEW_2 << PHY_TX_SLEW_CTRL_P_BIT_SHIFT) |
+		(PHY_SLEW_2 << PHY_TX_SLEW_CTRL_N_BIT_SHIFT) |
+		(PHY_PULL_UP << PHY_PULL_BIT_SHIF) | PHY_PAD_RXSEL_1;
+	sdhci_writew(host, val, PHY_RSTNPAD_CNFG_R);
+	pr_debug("%s: phy rstn=0x%x\n", mmc_hostname(host->mmc), val);
+
+	sdhci_writel(host, drv | PHY_RSTN, PHY_CNFG_R);
+
+	eswin_sdhci_config_phy_delay(host, phy->delay_code);
+
+	eswin_sdhci_enable_card_clk(host);
+}
+
+static void eswin_sdhci_reset(struct sdhci_host *host, u8 mask)
+{
+	u8 ctrl;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci = sdhci_pltfm_priv(pltfm_host);
+
+	/* Disable signal and interrupts before resetting the phy.
+	 * Doing this avoids ISR to serve any undesired interrupts during
+	 * reset and avoid producing the fake register dump during probe.
+	 */
+	sdhci_writel(host, 0, SDHCI_INT_ENABLE);
+	sdhci_writel(host, 0, SDHCI_SIGNAL_ENABLE);
+	sdhci_reset(host, mask);
+	sdhci_writel(host, host->ier, SDHCI_INT_ENABLE);
+	sdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);
+
+	if (eswin_sdhci->quirks & SDHCI_ESWIN_QUIRK_FORCE_CDTEST) {
+		ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
+		ctrl |= SDHCI_CTRL_CDTEST_INS | SDHCI_CTRL_CDTEST_EN;
+		sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
+	}
+
+	if (mask == SDHCI_RESET_ALL) { // after reset all,the phy`s config will be clear.
+		eswin_sdhci_config_phy(host);
+	}
+}
+
+static u32 eswin_sdhci_cqhci_irq(struct sdhci_host *host, u32 intmask)
+{
+	int cmd_error = 0;
+	int data_error = 0;
+
+	if (!sdhci_cqe_irq(host, intmask, &cmd_error, &data_error))
+		return intmask;
+
+	cqhci_irq(host->mmc, intmask, cmd_error, data_error);
+
+	return 0;
+}
+
+static void eswin_sdhci_dumpregs(struct mmc_host *mmc)
+{
+	sdhci_dumpregs(mmc_priv(mmc));
+}
+
+static void eswin_sdhci_cqe_enable(struct mmc_host *mmc)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+	u32 reg;
+
+	reg = sdhci_readl(host, SDHCI_PRESENT_STATE);
+	while (reg & SDHCI_DATA_AVAILABLE) {
+		sdhci_readl(host, SDHCI_BUFFER);
+		reg = sdhci_readl(host, SDHCI_PRESENT_STATE);
+	}
+
+	sdhci_cqe_enable(mmc);
+}
+
+static int eswin_sdhci_delay_tuning(struct sdhci_host *host, u32 opcode)
+{
+	int ret;
+	int delay = 0;
+	int i = 0;
+	int delay_min = -1;
+	int delay_max = -1;
+	int cmd_error = 0;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci = sdhci_pltfm_priv(pltfm_host);
+
+	for (i = 0; i <= PHY_DELAY_CODE_MAX; i++) {
+		eswin_sdhci_disable_card_clk(host);
+		eswin_sdhci_config_phy_delay(host, i);
+		eswin_sdhci_enable_card_clk(host);
+		ret = mmc_send_tuning(host->mmc, opcode, &cmd_error);
+		if (ret) {
+			host->ops->reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);
+			udelay(200);
+			if (delay_min != -1 && delay_max != -1)
+				break;
+		} else {
+			if (delay_min == -1) {
+				delay_min = i;
+				continue;
+			} else {
+				delay_max = i;
+				continue;
+			}
+		}
+	}
+	if (delay_min == -1 && delay_max == -1) {
+		pr_err("%s: delay code tuning failed!\n",
+					mmc_hostname(host->mmc));
+		eswin_sdhci_disable_card_clk(host);
+		eswin_sdhci_config_phy_delay(host, eswin_sdhci->phy.delay_code);
+		eswin_sdhci_enable_card_clk(host);
+
+		return ret;
+	}
+
+	delay = (delay_min + delay_max) / 2;
+	pr_info("%s: set delay:0x%x\n", mmc_hostname(host->mmc), delay);
+	eswin_sdhci_disable_card_clk(host);
+	eswin_sdhci_config_phy_delay(host, delay);
+	eswin_sdhci_enable_card_clk(host);
+
+	return 0;
+}
+
+static int eswin_sdhci_phase_code_tuning(struct sdhci_host *host, u32 opcode)
+{
+	int cmd_error = 0;
+	int ret = 0;
+	int phase_code = 0;
+	int code_min = -1;
+	int code_max = -1;
+
+	for (phase_code = 0; phase_code <= MAX_PHASE_CODE; phase_code++) {
+		eswin_sdhci_disable_card_clk(host);
+		sdhci_writew(host, phase_code, VENDOR_AT_SATA_R);
+		eswin_sdhci_enable_card_clk(host);
+
+		ret = mmc_send_tuning(host->mmc, opcode, &cmd_error);
+		if (ret) {
+			host->ops->reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);
+			udelay(200);
+			if (code_min != -1 && code_max != -1)
+				break;
+		} else {
+			if (code_min == -1) {
+				code_min = phase_code;
+				continue;
+			} else {
+				code_max = phase_code;
+				continue;
+			}
+		}
+	}
+	if (code_min == -1 && code_max == -1) {
+		pr_err("%s: phase code tuning failed!\n",
+					mmc_hostname(host->mmc));
+		eswin_sdhci_disable_card_clk(host);
+		sdhci_writew(host, 0, VENDOR_AT_SATA_R);
+		eswin_sdhci_enable_card_clk(host);
+		return -EIO;
+	}
+
+	phase_code = (code_min + code_max) / 2;
+	pr_info("%s: set phase_code:0x%x\n", mmc_hostname(host->mmc), phase_code);
+
+	eswin_sdhci_disable_card_clk(host);
+	sdhci_writew(host, phase_code, VENDOR_AT_SATA_R);
+	eswin_sdhci_enable_card_clk(host);
+
+	return 0;
+}
+
+static int eswin_sdhci_executing_tuning(struct sdhci_host *host, u32 opcode)
+{
+	u32 ctrl;
+	u32 val;
+	int ret = 0;
+
+	eswin_sdhci_disable_card_clk(host);
+
+	ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	ctrl &= ~SDHCI_CTRL_TUNED_CLK;
+	sdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);
+
+	val = sdhci_readl(host, VENDOR_AT_CTRL_R);
+	val |= SW_TUNE_ENABLE;
+	sdhci_writew(host, val, VENDOR_AT_CTRL_R);
+	sdhci_writew(host, 0, VENDOR_AT_SATA_R);
+
+	eswin_sdhci_enable_card_clk(host);
+
+	sdhci_writew(host, 0x0, SDHCI_CMD_DATA);
+
+	ret = eswin_sdhci_delay_tuning(host, opcode);
+	if (ret < 0) {
+		return ret;
+	}
+	ret = eswin_sdhci_phase_code_tuning(host, opcode);
+	if (ret < 0) {
+		return ret;
+	}
+
+	return 0;
+}
+
+void eswin_sdhci_set_uhs_signaling(struct sdhci_host *host, unsigned timing)
+{
+	u32 val;
+	u32 status;
+	u32 timeout = 0;
+	u16 ctrl_2;
+
+	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+	/* Select Bus Speed Mode for host */
+	ctrl_2 &= ~SDHCI_CTRL_UHS_MASK;
+	if ((timing == MMC_TIMING_MMC_HS200) ||
+	    (timing == MMC_TIMING_UHS_SDR104))
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR104;
+	else if (timing == MMC_TIMING_UHS_SDR12)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR12;
+	else if (timing == MMC_TIMING_UHS_SDR25)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR25;
+	else if (timing == MMC_TIMING_UHS_SDR50)
+		ctrl_2 |= SDHCI_CTRL_UHS_SDR50;
+	else if ((timing == MMC_TIMING_UHS_DDR50) ||
+		 (timing == MMC_TIMING_MMC_DDR52))
+		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
+	else if (timing == MMC_TIMING_MMC_HS400)
+		ctrl_2 |= ESWIN_SDHCI_CTRL_HS400; /* Non-standard */
+	sdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);
+
+
+	/*
+	 * here need make dll locked when in hs400 at 200MHz
+	 */
+	if ((timing == MMC_TIMING_MMC_HS400) && (host->clock == 200000000)) {
+		eswin_sdhci_disable_card_clk(host);
+
+		val = sdhci_readl(host, VENDOR_AT_CTRL_R);
+		val &= ~(LATENCY_LT_MASK << LATENCY_LT_BIT_OFFSET);
+		val |= (LATENCY_LT_3 << LATENCY_LT_MASK);
+		sdhci_writel(host, val, VENDOR_AT_CTRL_R);
+
+		sdhci_writeb(host, 0x23, PHY_DLL_CNFG1_R);
+		sdhci_writeb(host, 0x02, PHY_DLL_CNFG2_R);
+		sdhci_writeb(host, 0x60, PHY_DLLDL_CNFG_R);
+		sdhci_writeb(host, 0x00, PHY_DLL_OFFST_R);
+		sdhci_writew(host, 0xffff, PHY_DLLBT_CNFG_R);
+
+		eswin_sdhci_enable_card_clk(host);
+		sdhci_writeb(host, DLL_ENABEL, PHY_DLL_CTRL_R);
+		udelay(100);
+
+		while (1) {
+			status = sdhci_readb(host, PHY_DLL_STATUS_R);
+			if (status & DLL_LOCK_STS) {
+				pr_debug("%s: locked status:0x%x\n", mmc_hostname(host->mmc), status);
+				break;
+			}
+			timeout++;
+			udelay(100);
+			if (timeout > 10000) {
+				pr_err("%s: DLL lock failed!status:0x%x\n",
+					mmc_hostname(host->mmc), status);
+				return;
+			}
+		}
+
+		status = sdhci_readb(host, PHY_DLL_STATUS_R);
+		if (status & DLL_ERROR_STS) {
+			pr_err("%s: DLL lock failed!err_status:0x%x\n",
+				mmc_hostname(host->mmc), status);
+		} else {
+			pr_debug("%s: DLL lock is success\n", mmc_hostname(host->mmc));
+		}
+	}
+}
+
+static const struct cqhci_host_ops eswin_sdhci_cqhci_ops = {
+	.enable = eswin_sdhci_cqe_enable,
+	.disable = sdhci_cqe_disable,
+	.dumpregs = eswin_sdhci_dumpregs,
+};
+
+static const struct sdhci_ops eswin_sdhci_cqe_ops = {
+	.set_clock = eswin_sdhci_set_clock,
+	.get_max_clock = sdhci_pltfm_clk_get_max_clock,
+	.get_timeout_clock = sdhci_pltfm_clk_get_max_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.reset = eswin_sdhci_reset,
+	.set_uhs_signaling = eswin_sdhci_set_uhs_signaling,
+	.set_power = sdhci_set_power_and_bus_voltage,
+	.irq = eswin_sdhci_cqhci_irq,
+	.platform_execute_tuning = eswin_sdhci_executing_tuning,
+};
+
+static const struct sdhci_pltfm_data eswin_sdhci_cqe_pdata = {
+	.ops = &eswin_sdhci_cqe_ops,
+	.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+#if defined(__DISABLE_HS200)
+		SDHCI_QUIRK2_BROKEN_HS200 |
+#endif
+		SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN,
+};
+
+#ifdef CONFIG_PM_SLEEP
+/**
+ * eswin_sdhci_suspend - Suspend method for the driver
+ * @dev:    Address of the device structure
+ *
+ * Put the device in a low power state.
+ *
+ * Return: 0 on success and error value on error
+ */
+static int eswin_sdhci_suspend(struct device *dev)
+{
+	struct sdhci_host *host = dev_get_drvdata(dev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci = sdhci_pltfm_priv(pltfm_host);
+	int ret;
+
+	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+		mmc_retune_needed(host->mmc);
+
+	if (eswin_sdhci->has_cqe) {
+		ret = cqhci_suspend(host->mmc);
+		if (ret)
+			return ret;
+	}
+
+	ret = sdhci_suspend_host(host);
+	if (ret)
+		return ret;
+
+	clk_disable(pltfm_host->clk);
+	clk_disable(eswin_sdhci->clk_ahb);
+
+	return 0;
+}
+
+/**
+ * eswin_sdhci_resume - Resume method for the driver
+ * @dev:    Address of the device structure
+ *
+ * Resume operation after suspend
+ *
+ * Return: 0 on success and error value on error
+ */
+static int eswin_sdhci_resume(struct device *dev)
+{
+	struct sdhci_host *host = dev_get_drvdata(dev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci = sdhci_pltfm_priv(pltfm_host);
+	int ret;
+
+	ret = clk_enable(eswin_sdhci->clk_ahb);
+	if (ret) {
+		dev_err(dev, "Cannot enable AHB clock.\n");
+		return ret;
+	}
+
+	ret = clk_enable(pltfm_host->clk);
+	if (ret) {
+		dev_err(dev, "Cannot enable SD clock.\n");
+		return ret;
+	}
+
+	ret = sdhci_resume_host(host);
+	if (ret) {
+		dev_err(dev, "Cannot resume host.\n");
+		return ret;
+	}
+
+	if (eswin_sdhci->has_cqe)
+		return cqhci_resume(host->mmc);
+
+	return 0;
+}
+#endif /* ! CONFIG_PM_SLEEP */
+
+static SIMPLE_DEV_PM_OPS(eswin_sdhci_dev_pm_ops, eswin_sdhci_suspend,
+			 eswin_sdhci_resume);
+
+/**
+ * eswin_sdhci_sdcardclk_recalc_rate - Return the card clock rate
+ *
+ * @hw:         Pointer to the hardware clock structure.
+ * @parent_rate:        The parent rate (should be rate of clk_xin).
+ *
+ * Return the current actual rate of the SD card clock.  This can be used
+ * to communicate with out PHY.
+ *
+ * Return: The card clock rate.
+ */
+static unsigned long
+eswin_sdhci_sdcardclk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct eswin_sdhci_clk_data *clk_data =
+		container_of(hw, struct eswin_sdhci_clk_data, sdcardclk_hw);
+	struct eswin_sdhci_data *eswin_sdhci =
+		container_of(clk_data, struct eswin_sdhci_data, clk_data);
+	struct sdhci_host *host = eswin_sdhci->host;
+
+	return host->mmc->actual_clock;
+}
+
+static const struct clk_ops eswin_sdcardclk_ops = {
+	.recalc_rate = eswin_sdhci_sdcardclk_recalc_rate,
+};
+
+/**
+ * eswin_sdhci_sampleclk_recalc_rate - Return the sampling clock rate
+ *
+ * @hw:         Pointer to the hardware clock structure.
+ * @parent_rate:        The parent rate (should be rate of clk_xin).
+ *
+ * Return the current actual rate of the sampling clock.  This can be used
+ * to communicate with out PHY.
+ *
+ * Return: The sample clock rate.
+ */
+static unsigned long
+eswin_sdhci_sampleclk_recalc_rate(struct clk_hw *hw, unsigned long parent_rate)
+{
+	struct eswin_sdhci_clk_data *clk_data =
+		container_of(hw, struct eswin_sdhci_clk_data, sampleclk_hw);
+	struct eswin_sdhci_data *eswin_sdhci =
+		container_of(clk_data, struct eswin_sdhci_data, clk_data);
+	struct sdhci_host *host = eswin_sdhci->host;
+
+	return host->mmc->actual_clock;
+}
+
+static const struct clk_ops eswin_sampleclk_ops = {
+	.recalc_rate = eswin_sdhci_sampleclk_recalc_rate,
+};
+
+static const struct eswin_sdhci_clk_ops eswin_clk_ops = {
+	.sdcardclk_ops = &eswin_sdcardclk_ops,
+	.sampleclk_ops = &eswin_sampleclk_ops,
+};
+
+static struct eswin_sdhci_of_data eswin_sdhci_fu800_data = {
+	.pdata = &eswin_sdhci_cqe_pdata,
+	.clk_ops = &eswin_clk_ops,
+};
+
+static const struct of_device_id eswin_sdhci_of_match[] = {
+	{
+		.compatible = "eswin,emmc-sdhci-5.1",
+		.data = &eswin_sdhci_fu800_data,
+	},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, eswin_sdhci_of_match);
+
+/**
+ * eswin_sdhci_register_sdcardclk - Register the sdcardclk for a PHY to use
+ *
+ * @eswin_sdhci:    Our private data structure.
+ * @clk_xin:        Pointer to the functional clock
+ * @dev:        Pointer to our struct device.
+ *
+ * Some PHY devices need to know what the actual card clock is.  In order for
+ * them to find out, we'll provide a clock through the common clock framework
+ * for them to query.
+ *
+ * Return: 0 on success and error value on error
+ */
+static int eswin_sdhci_register_sdcardclk(struct eswin_sdhci_data *eswin_sdhci,
+									struct clk *clk_xin, struct device *dev)
+{
+	struct eswin_sdhci_clk_data *clk_data = &eswin_sdhci->clk_data;
+	struct device_node *np = dev->of_node;
+	struct clk_init_data sdcardclk_init;
+	const char *parent_clk_name;
+	int ret;
+
+	ret = of_property_read_string_index(np, "clock-output-names", 0,
+						&sdcardclk_init.name);
+	if (ret) {
+		dev_err(dev, "DT has #clock-cells but no clock-output-names\n");
+		return ret;
+	}
+
+	parent_clk_name = __clk_get_name(clk_xin);
+	sdcardclk_init.parent_names = &parent_clk_name;
+	sdcardclk_init.num_parents = 1;
+	sdcardclk_init.flags = CLK_GET_RATE_NOCACHE;
+	sdcardclk_init.ops = eswin_sdhci->clk_ops->sdcardclk_ops;
+
+	clk_data->sdcardclk_hw.init = &sdcardclk_init;
+	clk_data->sdcardclk = devm_clk_register(dev, &clk_data->sdcardclk_hw);
+	if (IS_ERR(clk_data->sdcardclk))
+		return PTR_ERR(clk_data->sdcardclk);
+	clk_data->sdcardclk_hw.init = NULL;
+
+	ret = of_clk_add_provider(np, of_clk_src_simple_get,
+							clk_data->sdcardclk);
+	if (ret)
+		dev_err(dev, "Failed to add sdcard clock provider\n");
+
+	return ret;
+}
+
+/**
+ * eswin_sdhci_register_sampleclk - Register the sampleclk for a PHY to use
+ *
+ * @eswin_sdhci:    Our private data structure.
+ * @clk_xin:        Pointer to the functional clock
+ * @dev:        Pointer to our struct device.
+ *
+ * Some PHY devices need to know what the actual card clock is.  In order for
+ * them to find out, we'll provide a clock through the common clock framework
+ * for them to query.
+ *
+ * Return: 0 on success and error value on error
+ */
+static int eswin_sdhci_register_sampleclk(struct eswin_sdhci_data *eswin_sdhci,
+						struct clk *clk_xin, struct device *dev)
+{
+	struct eswin_sdhci_clk_data *clk_data = &eswin_sdhci->clk_data;
+	struct device_node *np = dev->of_node;
+	struct clk_init_data sampleclk_init;
+	const char *parent_clk_name;
+	int ret;
+
+	ret = of_property_read_string_index(np, "clock-output-names", 1,
+						&sampleclk_init.name);
+	if (ret) {
+		dev_err(dev, "DT has #clock-cells but no clock-output-names\n");
+		return ret;
+	}
+
+	parent_clk_name = __clk_get_name(clk_xin);
+	sampleclk_init.parent_names = &parent_clk_name;
+	sampleclk_init.num_parents = 1;
+	sampleclk_init.flags = CLK_GET_RATE_NOCACHE;
+	sampleclk_init.ops = eswin_sdhci->clk_ops->sampleclk_ops;
+
+	clk_data->sampleclk_hw.init = &sampleclk_init;
+	clk_data->sampleclk = devm_clk_register(dev, &clk_data->sampleclk_hw);
+	if (IS_ERR(clk_data->sampleclk))
+		return PTR_ERR(clk_data->sampleclk);
+	clk_data->sampleclk_hw.init = NULL;
+
+	ret = of_clk_add_provider(np, of_clk_src_simple_get,
+				  clk_data->sampleclk);
+	if (ret)
+		dev_err(dev, "Failed to add sample clock provider\n");
+
+	return ret;
+}
+
+/**
+ * eswin_sdhci_unregister_sdclk - Undoes eswin_sdhci_register_sdclk()
+ *
+ * @dev:        Pointer to our struct device.
+ *
+ * Should be called any time we're exiting and eswin_sdhci_register_sdclk()
+ * returned success.
+ */
+static void eswin_sdhci_unregister_sdclk(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+
+	if (!of_find_property(np, "#clock-cells", NULL))
+		return;
+
+	of_clk_del_provider(dev->of_node);
+}
+
+/**
+ * eswin_sdhci_register_sdclk - Register the sdcardclk for a PHY to use
+ *
+ * @eswin_sdhci:    Our private data structure.
+ * @clk_xin:        Pointer to the functional clock
+ * @dev:        Pointer to our struct device.
+ *
+ * Some PHY devices need to know what the actual card clock is.  In order for
+ * them to find out, we'll provide a clock through the common clock framework
+ * for them to query.
+ *
+ * Note: without seriously re-architecting SDHCI's clock code and testing on
+ * all platforms, there's no way to create a totally beautiful clock here
+ * with all clock ops implemented.  Instead, we'll just create a clock that can
+ * be queried and set the CLK_GET_RATE_NOCACHE attribute to tell common clock
+ * framework that we're doing things behind its back.  This should be sufficient
+ * to create nice clean device tree bindings and later (if needed) we can try
+ * re-architecting SDHCI if we see some benefit to it.
+ *
+ * Return: 0 on success and error value on error
+ */
+static int eswin_sdhci_register_sdclk(struct eswin_sdhci_data *eswin_sdhci,
+				      struct clk *clk_xin, struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	u32 num_clks = 0;
+	int ret;
+
+	/* Providing a clock to the PHY is optional; no error if missing */
+	if (of_property_read_u32(np, "#clock-cells", &num_clks) < 0)
+		return 0;
+
+	ret = eswin_sdhci_register_sdcardclk(eswin_sdhci, clk_xin, dev);
+	if (ret)
+		return ret;
+
+	if (num_clks) {
+		ret = eswin_sdhci_register_sampleclk(eswin_sdhci, clk_xin, dev);
+		if (ret) {
+			eswin_sdhci_unregister_sdclk(dev);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int eswin_sdhci_add_host(struct eswin_sdhci_data *eswin_sdhci)
+{
+	struct sdhci_host *host = eswin_sdhci->host;
+	struct cqhci_host *cq_host;
+	bool dma64;
+	int ret;
+
+	if (!eswin_sdhci->has_cqe)
+		return sdhci_add_host(host);
+
+	ret = sdhci_setup_host(host);
+	if (ret)
+		return ret;
+
+	cq_host = devm_kzalloc(host->mmc->parent, sizeof(*cq_host), GFP_KERNEL);
+	if (!cq_host) {
+		ret = -ENOMEM;
+		goto cleanup;
+	}
+
+	cq_host->mmio = host->ioaddr + eswin_sdhci_CQE_BASE_ADDR;
+	cq_host->ops = &eswin_sdhci_cqhci_ops;
+
+	dma64 = host->flags & SDHCI_USE_64_BIT_DMA;
+	if (dma64)
+		cq_host->caps |= CQHCI_TASK_DESC_SZ_128;
+
+	ret = cqhci_init(cq_host, host->mmc, dma64);
+	if (ret)
+		goto cleanup;
+
+	ret = __sdhci_add_host(host);
+	if (ret)
+		goto cleanup;
+
+	return 0;
+
+cleanup:
+	sdhci_cleanup_host(host);
+	return ret;
+}
+
+static int eswin_emmc_sid_cfg(struct device *dev)
+{
+	int ret;
+	struct regmap *regmap;
+	int hsp_mmu_emmc_reg;
+	u32 rdwr_sid_ssid;
+	u32 sid;
+	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+
+	/* not behind smmu, use the default reset value(0x0) of the reg as streamID*/
+	if (fwspec == NULL) {
+		dev_dbg(dev,
+			"dev is not behind smmu, skip configuration of sid\n");
+		return 0;
+	}
+	sid = fwspec->ids[0];
+
+	regmap = syscon_regmap_lookup_by_phandle(dev->of_node,
+						 "eswin,hsp_sp_csr");
+	if (IS_ERR(regmap)) {
+		dev_dbg(dev, "No hsp_sp_csr phandle specified\n");
+		return 0;
+	}
+
+	ret = of_property_read_u32_index(dev->of_node, "eswin,hsp_sp_csr", 1,
+					 &hsp_mmu_emmc_reg);
+	if (ret) {
+		dev_err(dev, "can't get emmc sid cfg reg offset (%d)\n", ret);
+		return ret;
+	}
+
+	/* make the reading sid the same as writing sid, ssid is fixed to zero */
+	rdwr_sid_ssid = FIELD_PREP(AWSMMUSID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(ARSMMUSID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(AWSMMUSSID, 0);
+	rdwr_sid_ssid |= FIELD_PREP(ARSMMUSSID, 0);
+	regmap_write(regmap, hsp_mmu_emmc_reg, rdwr_sid_ssid);
+
+	ret = eic7700_dynm_sid_enable(dev_to_node(dev));
+	if (ret < 0)
+		dev_err(dev, "failed to config emmc streamID(%d)!\n", sid);
+	else
+		dev_dbg(dev, "success to config emmc streamID(%d)!\n", sid);
+
+	return ret;
+}
+
+static int eswin_sdhci_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct clk *clk_xin;
+	struct sdhci_host *host;
+	struct sdhci_pltfm_host *pltfm_host;
+	struct device *dev = &pdev->dev;
+	struct eswin_sdhci_data *eswin_sdhci;
+	const struct eswin_sdhci_of_data *data;
+	struct regmap *regmap;
+	unsigned int val = 0;
+
+	data = of_device_get_match_data(dev);
+	host = sdhci_pltfm_init(pdev, data->pdata, sizeof(*eswin_sdhci));
+	if (IS_ERR(host))
+		return PTR_ERR(host);
+
+	pltfm_host = sdhci_priv(host);
+	eswin_sdhci = sdhci_pltfm_priv(pltfm_host);
+	eswin_sdhci->host = host;
+	eswin_sdhci->clk_ops = data->clk_ops;
+
+	eswin_sdhci->core_clk_reg = ioremap(ESWIN_EMMC_CORE_CLK_REG, 0x4);
+	if (!eswin_sdhci->core_clk_reg) {
+		dev_err(dev, "ioremap core clk reg failed.\n");
+		goto err_pltfm_free;
+	}
+
+	eswin_sdhci->clk_ahb = devm_clk_get(dev, "clk_ahb");
+	if (IS_ERR(eswin_sdhci->clk_ahb)) {
+		ret = dev_err_probe(dev, PTR_ERR(eswin_sdhci->clk_ahb),
+				    "clk_ahb clock not found.\n");
+		goto err_pltfm_free;
+	}
+
+	clk_xin = devm_clk_get(dev, "clk_xin");
+	if (IS_ERR(clk_xin)) {
+		ret = dev_err_probe(dev, PTR_ERR(clk_xin),
+				    "clk_xin clock not found.\n");
+		goto err_pltfm_free;
+	}
+
+	ret = clk_prepare_enable(eswin_sdhci->clk_ahb);
+	if (ret) {
+		dev_err(dev, "Unable to enable AHB clock.\n");
+		goto err_pltfm_free;
+	}
+
+	ret = clk_prepare_enable(clk_xin);
+	if (ret) {
+		dev_err(dev, "Unable to enable SD clock.\n");
+		goto clk_dis_ahb;
+	}
+
+	ret = eswin_sdhci_reset_init(dev, eswin_sdhci);
+	if (ret < 0) {
+		dev_err(dev, "failed to reset\n");
+		goto clk_disable_all;
+	}
+
+	eic7700_tbu_power(dev, true);
+
+	regmap = syscon_regmap_lookup_by_phandle(dev->of_node,
+						 "eswin,hsp_sp_csr");
+	if (IS_ERR(regmap)) {
+		dev_dbg(dev, "No hsp_sp_csr phandle specified\n");
+		goto clk_disable_all;
+	}
+
+	regmap_write(regmap, SDHCI_EMMC0_INT_STATUS, MSHC_INT_CLK_STABLE);
+	regmap_write(regmap, SDHCI_EMMC0_PWR_CLEAR, MSHC_HOST_VAL_STABLE);
+
+	/* smmu */
+	eswin_emmc_sid_cfg(dev);
+
+	if (!of_property_read_u32(dev->of_node, "delay_code", &val)) {
+		eswin_sdhci->phy.delay_code = val;
+	}
+
+	if (!of_property_read_u32(dev->of_node, "drive-impedance-ohm", &val))
+		eswin_sdhci->phy.drive_impedance =
+			eswin_convert_drive_impedance_ohm(pdev, val);
+
+	if (of_property_read_bool(dev->of_node, "enable-cmd-pullup"))
+		eswin_sdhci->phy.enable_cmd_pullup = ENABLE;
+	else
+		eswin_sdhci->phy.enable_cmd_pullup = DISABLE;
+
+	if (of_property_read_bool(dev->of_node, "enable-data-pullup"))
+		eswin_sdhci->phy.enable_data_pullup = ENABLE;
+	else
+		eswin_sdhci->phy.enable_data_pullup = DISABLE;
+
+	if (of_property_read_bool(dev->of_node, "enable-strobe-pulldown"))
+		eswin_sdhci->phy.enable_strobe_pulldown = ENABLE;
+	else
+		eswin_sdhci->phy.enable_strobe_pulldown = DISABLE;
+
+	sdhci_get_of_property(pdev);
+
+	pltfm_host->clk = clk_xin;
+
+	ret = eswin_sdhci_register_sdclk(eswin_sdhci, clk_xin, dev);
+	if (ret)
+		goto clk_disable_all;
+
+	eswin_sdhci_dt_parse_clk_phases(dev, &eswin_sdhci->clk_data);
+
+	ret = mmc_of_parse(host->mmc);
+	if (ret) {
+		ret = dev_err_probe(dev, ret, "parsing dt failed.\n");
+		goto unreg_clk;
+	}
+
+#if !defined(__FPGA) && !defined(__ZEBU)
+	if (of_device_is_compatible(dev->of_node, "eswin,sdhci-5.1")) {
+		host->mmc_host_ops.hs400_enhanced_strobe =
+			eswin_sdhci_hs400_enhanced_strobe;
+		eswin_sdhci->has_cqe = true;
+		host->mmc->caps2 |= MMC_CAP2_CQE;
+
+		if (!of_property_read_bool(dev->of_node, "disable-cqe-dcmd"))
+			host->mmc->caps2 |= MMC_CAP2_CQE_DCMD;
+	}
+#endif
+
+#if !defined(__ADMA3_DISABLE)
+	sdhci_enable_v4_mode(eswin_sdhci->host);
+#endif
+
+	ret = eswin_sdhci_add_host(eswin_sdhci);
+	if (ret)
+		goto unreg_clk;
+
+	return 0;
+
+unreg_clk:
+	eswin_sdhci_unregister_sdclk(dev);
+clk_disable_all:
+	clk_disable_unprepare(clk_xin);
+clk_dis_ahb:
+	clk_disable_unprepare(eswin_sdhci->clk_ahb);
+err_pltfm_free:
+	if (eswin_sdhci->core_clk_reg)
+		iounmap(eswin_sdhci->core_clk_reg);
+	sdhci_pltfm_free(pdev);
+	return ret;
+}
+
+static int eswin_sdhci_remove(struct platform_device *pdev)
+{
+	int ret;
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct eswin_sdhci_data *eswin_sdhci = sdhci_pltfm_priv(pltfm_host);
+	struct clk *clk_ahb = eswin_sdhci->clk_ahb;
+	void __iomem *core_clk_reg = eswin_sdhci->core_clk_reg;
+
+	sdhci_pltfm_remove(pdev);
+	eic7700_tbu_power(&pdev->dev, false);
+
+	if (eswin_sdhci->txrx_rst) {
+		ret = reset_control_assert(eswin_sdhci->txrx_rst);
+		WARN_ON(0 != ret);
+	}
+
+	if (eswin_sdhci->phy_rst) {
+		ret = reset_control_assert(eswin_sdhci->phy_rst);
+		WARN_ON(0 != ret);
+	}
+
+	if (eswin_sdhci->prstn) {
+		ret = reset_control_assert(eswin_sdhci->prstn);
+		WARN_ON(0 != ret);
+	}
+
+	if (eswin_sdhci->arstn) {
+		ret = reset_control_assert(eswin_sdhci->arstn);
+		WARN_ON(0 != ret);
+	}
+	eswin_sdhci_unregister_sdclk(&pdev->dev);
+	clk_disable_unprepare(clk_ahb);
+	iounmap(core_clk_reg);
+
+	return 0;
+}
+
+static void emmc_hard_reset(struct sdhci_host *host)
+{
+	unsigned int val;
+
+	val = sdhci_readw(host, VENDOR_EMMC_CTRL_R);
+	val |= EMMC_RST_N_OE;
+	sdhci_writew(host, val, VENDOR_EMMC_CTRL_R);
+	val &= ~EMMC_RST_N;
+	sdhci_writew(host, val, VENDOR_EMMC_CTRL_R);
+	mdelay(20);
+	val |= EMMC_RST_N;
+	sdhci_writew(host, val, VENDOR_EMMC_CTRL_R);
+}
+
+static void eswin_sdhci_shutdown(struct platform_device *pdev)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+
+	if (!host)
+		return;
+
+	emmc_hard_reset(host);
+	host->ops->reset(host, SDHCI_RESET_ALL);
+	platform_set_drvdata(pdev, NULL);
+}
+
+static struct platform_driver eswin_sdhci_driver =
+{
+	.driver = {
+		.name = "sdhci-eswin",
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+		.of_match_table = eswin_sdhci_of_match,
+		.pm = &eswin_sdhci_dev_pm_ops,
+	},
+	.probe = eswin_sdhci_probe,
+	.remove = eswin_sdhci_remove,
+	.shutdown = eswin_sdhci_shutdown,
+};
+
+module_platform_driver(eswin_sdhci_driver);
+
+MODULE_DESCRIPTION("Driver for the ESWIN SDHCI Controller");
+MODULE_AUTHOR("liangshuang@eswin.com");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/ethernet/stmicro/stmmac/Kconfig b/drivers/net/ethernet/stmicro/stmmac/Kconfig
index 25f2d42de406..555268970c7d 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
+++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
@@ -66,6 +66,14 @@ config DWMAC_ANARION
 
 	  This selects the Anarion SoC glue layer support for the stmmac driver.
 
+config DWMAC_EIC7700
+	tristate "Support for Eswin EIC77xx ethernet driver"
+	select CRC32
+	select MII
+	depends on OF && HAS_DMA
+	help
+	  Support for Eswin EIC7700 ethernet driver.
+
 config DWMAC_INGENIC
 	tristate "Ingenic MAC support"
 	default MACH_INGENIC
diff --git a/drivers/net/ethernet/stmicro/stmmac/Makefile b/drivers/net/ethernet/stmicro/stmmac/Makefile
index 5b57aee19267..9ea190bf6752 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Makefile
+++ b/drivers/net/ethernet/stmicro/stmmac/Makefile
@@ -14,6 +14,7 @@ stmmac-$(CONFIG_STMMAC_SELFTESTS) += stmmac_selftests.o
 # Ordering matters. Generic driver must be last.
 obj-$(CONFIG_STMMAC_PLATFORM)	+= stmmac-platform.o
 obj-$(CONFIG_DWMAC_ANARION)	+= dwmac-anarion.o
+obj-$(CONFIG_DWMAC_EIC7700) += dwmac-eic7700.o
 obj-$(CONFIG_DWMAC_INGENIC)	+= dwmac-ingenic.o
 obj-$(CONFIG_DWMAC_IPQ806X)	+= dwmac-ipq806x.o
 obj-$(CONFIG_DWMAC_LPC18XX)	+= dwmac-lpc18xx.o
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-eic7700.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-eic7700.c
new file mode 100644
index 000000000000..1e8ce3a13d17
--- /dev/null
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-eic7700.c
@@ -0,0 +1,597 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Eswin DWC Ethernet linux driver
+ */
+
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/ethtool.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_net.h>
+#include <linux/mfd/syscon.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/stmmac.h>
+#include <linux/iommu.h>
+#include "stmmac_platform.h"
+#include "dwmac4.h"
+#include <linux/mfd/syscon.h>
+#include <linux/bitfield.h>
+#include <linux/regmap.h>
+#include <linux/eic7700-sid-cfg.h>
+#include <linux/gpio/consumer.h>
+
+/* eth_phy_ctrl_offset eth0:0x100; eth1:0x200 */
+#define ETH_TX_CLK_SEL          BIT(16)
+#define ETH_PHY_INTF_SELI       BIT(0)
+
+/* eth_axi_lp_ctrl_offset eth0:0x108; eth1:0x208 */
+#define ETH_CSYSREQ_VAL         BIT(0)
+
+/* hsp_aclk_ctrl_offset (0x148) */
+#define HSP_ACLK_CLKEN           BIT(31)
+#define HSP_ACLK_DIVSOR          (0x2 << 4)
+
+/* hsp_cfg_ctrl_offset (0x14c) */
+#define HSP_CFG_CLKEN            BIT(31)
+#define SCU_HSP_PCLK_EN          BIT(30)
+#define HSP_CFG_CTRL_REGSET      (HSP_CFG_CLKEN | SCU_HSP_PCLK_EN)
+
+/* RTL8211F PHY Configurations for LEDs */
+#define PHY_ADDR                 0
+#define PHY_PAGE_SWITCH_REG      31
+#define PHY_LED_CFG_REG          16
+#define PHY_LED_PAGE_CFG         0xd04
+
+#define AWSMMUSID   GENMASK(31, 24) // The sid of write operation
+#define AWSMMUSSID  GENMASK(23, 16) // The ssid of write operation
+#define ARSMMUSID   GENMASK(15, 8)  // The sid of read operation
+#define ARSMMUSSID  GENMASK(7, 0)   // The ssid of read operation
+
+struct dwc_qos_priv {
+	struct device *dev;
+	int dev_id;
+	struct regmap *crg_regmap;
+	struct regmap *hsp_regmap;
+	struct reset_control *rst;
+	struct clk *clk_app;
+	struct clk *clk_csr;
+	struct clk *clk_tx;
+	struct regmap *rgmii_sel;
+	struct gpio_desc *phy_reset;
+	struct stmmac_priv *stmpriv;
+	int phyled_cfgs[3];
+};
+
+static int dwc_eth_dwmac_config_dt(struct platform_device *pdev,
+				   struct plat_stmmacenet_data *plat_dat)
+{
+	struct device *dev = &pdev->dev;
+	u32 burst_map = 0;
+	u32 bit_index = 0;
+	u32 a_index = 0;
+
+	if (!plat_dat->axi) {
+		plat_dat->axi = kzalloc(sizeof(struct stmmac_axi), GFP_KERNEL);
+
+		if (!plat_dat->axi)
+			return -ENOMEM;
+	}
+
+	plat_dat->axi->axi_lpi_en = device_property_read_bool(dev,
+							      "snps,en-lpi");
+	if (device_property_read_u32(dev, "snps,write-requests",
+				     &plat_dat->axi->axi_wr_osr_lmt)) {
+		/**
+		 * Since the register has a reset value of 1, if property
+		 * is missing, default to 1.
+		 */
+		plat_dat->axi->axi_wr_osr_lmt = 1;
+	} else {
+		/**
+		 * If property exists, to keep the behavior from dwc_eth_qos,
+		 * subtract one after parsing.
+		 */
+		plat_dat->axi->axi_wr_osr_lmt--;
+	}
+
+	if (device_property_read_u32(dev, "snps,read-requests",
+				     &plat_dat->axi->axi_rd_osr_lmt)) {
+		/**
+		 * Since the register has a reset value of 1, if property
+		 * is missing, default to 1.
+		 */
+		plat_dat->axi->axi_rd_osr_lmt = 1;
+	} else {
+		/**
+		 * If property exists, to keep the behavior from dwc_eth_qos,
+		 * subtract one after parsing.
+		 */
+		plat_dat->axi->axi_rd_osr_lmt--;
+	}
+	device_property_read_u32(dev, "snps,burst-map", &burst_map);
+
+	/* converts burst-map bitmask to burst array */
+	for (bit_index = 0; bit_index < 7; bit_index++) {
+		if (burst_map & (1 << bit_index)) {
+			switch (bit_index) {
+			case 0:
+			plat_dat->axi->axi_blen[a_index] = 4; break;
+			case 1:
+			plat_dat->axi->axi_blen[a_index] = 8; break;
+			case 2:
+			plat_dat->axi->axi_blen[a_index] = 16; break;
+			case 3:
+			plat_dat->axi->axi_blen[a_index] = 32; break;
+			case 4:
+			plat_dat->axi->axi_blen[a_index] = 64; break;
+			case 5:
+			plat_dat->axi->axi_blen[a_index] = 128; break;
+			case 6:
+			plat_dat->axi->axi_blen[a_index] = 256; break;
+			default:
+			break;
+			}
+			a_index++;
+		}
+	}
+
+	/* dwc-qos needs GMAC4, AAL, TSO and PMT */
+	plat_dat->has_gmac4 = 1;
+	plat_dat->dma_cfg->aal = 1;
+	plat_dat->flags |= STMMAC_FLAG_TSO_EN;
+	plat_dat->pmt = 1;
+
+	return 0;
+}
+
+static int eswin_eth_sid_cfg(struct device *dev)
+{
+	int ret;
+	struct regmap *regmap;
+	int hsp_mmu_eth_reg;
+	u32 rdwr_sid_ssid;
+	u32 sid;
+	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+
+	/* not behind smmu, use the default reset value(0x0) of the reg as streamID*/
+	if (fwspec == NULL) {
+		dev_dbg(dev, "dev is not behind smmu, skip configuration of sid\n");
+		return 0;
+	}
+	sid = fwspec->ids[0];
+
+	regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "eswin,hsp_sp_csr");
+	if (IS_ERR(regmap)) {
+		dev_dbg(dev, "No hsp_sp_csr phandle specified\n");
+		return 0;
+	}
+
+	ret = of_property_read_u32_index(dev->of_node, "eswin,hsp_sp_csr", 1,
+				&hsp_mmu_eth_reg);
+	if (ret) {
+		dev_err(dev, "can't get eth sid cfg reg offset (%d)\n", ret);
+		return ret;
+	}
+
+	/* make the reading sid the same as writing sid, ssid is fixed to zero */
+	rdwr_sid_ssid  = FIELD_PREP(AWSMMUSID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(ARSMMUSID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(AWSMMUSSID, 0);
+	rdwr_sid_ssid |= FIELD_PREP(ARSMMUSSID, 0);
+	regmap_write(regmap, hsp_mmu_eth_reg, rdwr_sid_ssid);
+
+	ret = eic7700_dynm_sid_enable(dev_to_node(dev));
+	if (ret < 0)
+		dev_err(dev, "failed to config eth streamID(%d)!\n", sid);
+	else
+		dev_dbg(dev, "success to config eth streamID(%d)!\n", sid);
+
+	return ret;
+}
+
+static void dwc_qos_fix_speed(void *priv, unsigned int speed, unsigned int mode)
+{
+	unsigned long rate = 125000000;
+	int err, data = 0;
+	struct dwc_qos_priv *dwc_priv = (struct dwc_qos_priv *)priv;
+
+	switch (speed) {
+	case SPEED_1000:
+		rate = 125000000;
+
+		if (dwc_priv->dev_id == 0) {
+			regmap_write(dwc_priv->hsp_regmap, 0x118, 0x800c8023);
+			regmap_write(dwc_priv->hsp_regmap, 0x11c, 0x0c0c0c0c);
+			regmap_write(dwc_priv->hsp_regmap, 0x114, 0x23232323);
+		} else {
+			regmap_write(dwc_priv->hsp_regmap, 0x218, 0x80268025);
+			regmap_write(dwc_priv->hsp_regmap, 0x21c, 0x26262626);
+			regmap_write(dwc_priv->hsp_regmap, 0x214, 0x25252525);
+		}
+
+		if (dwc_priv->stmpriv) {
+			data = mdiobus_read(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_PAGE_SWITCH_REG);
+			mdiobus_write(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_PAGE_SWITCH_REG, PHY_LED_PAGE_CFG);
+			mdiobus_write(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_LED_CFG_REG, dwc_priv->phyled_cfgs[0]);
+			mdiobus_write(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_PAGE_SWITCH_REG, data);
+		}
+
+		break;
+	case SPEED_100:
+		rate = 25000000;
+
+		if (dwc_priv->dev_id == 0) {
+			regmap_write(dwc_priv->hsp_regmap, 0x118, 0x803f8050);
+			regmap_write(dwc_priv->hsp_regmap, 0x11c, 0x3f3f3f3f);
+			regmap_write(dwc_priv->hsp_regmap, 0x114, 0x50505050);
+		} else {
+			regmap_write(dwc_priv->hsp_regmap, 0x218, 0x80588048);
+			regmap_write(dwc_priv->hsp_regmap, 0x21c, 0x58585858);
+			regmap_write(dwc_priv->hsp_regmap, 0x214, 0x48484848);
+		}
+
+		if (dwc_priv->stmpriv) {
+			data = mdiobus_read(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_PAGE_SWITCH_REG);
+			mdiobus_write(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_PAGE_SWITCH_REG, PHY_LED_PAGE_CFG);
+			mdiobus_write(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_LED_CFG_REG, dwc_priv->phyled_cfgs[1]);
+			mdiobus_write(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_PAGE_SWITCH_REG, data);
+		}
+
+		break;
+	case SPEED_10:
+		rate = 2500000;
+
+		if (dwc_priv->dev_id == 0) {
+			regmap_write(dwc_priv->hsp_regmap, 0x118, 0x0);
+			regmap_write(dwc_priv->hsp_regmap, 0x11c, 0x0);
+			regmap_write(dwc_priv->hsp_regmap, 0x114, 0x0);
+		} else {
+			regmap_write(dwc_priv->hsp_regmap, 0x218, 0x0);
+			regmap_write(dwc_priv->hsp_regmap, 0x21c, 0x0);
+			regmap_write(dwc_priv->hsp_regmap, 0x214, 0x0);
+		}
+
+		if (dwc_priv->stmpriv) {
+			data = mdiobus_read(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_PAGE_SWITCH_REG);
+			mdiobus_write(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_PAGE_SWITCH_REG, PHY_LED_PAGE_CFG);
+			mdiobus_write(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_LED_CFG_REG, dwc_priv->phyled_cfgs[2]);
+			mdiobus_write(dwc_priv->stmpriv->mii, PHY_ADDR, PHY_PAGE_SWITCH_REG, data);
+		}
+
+		break;
+	default:
+		dev_err(dwc_priv->dev, "invalid speed %u\n", speed);
+		break;
+	}
+
+	err = clk_set_rate(dwc_priv->clk_tx, rate);
+	if (err < 0)
+	{
+		dev_err(dwc_priv->dev, "failed to set TX rate: %d\n", err);
+	}
+}
+
+static int dwc_qos_probe(struct platform_device *pdev,
+			 struct plat_stmmacenet_data *plat_dat,
+			 struct stmmac_resources *stmmac_res)
+{
+	struct dwc_qos_priv *dwc_priv;
+	int ret;
+	int err;
+	u32 hsp_aclk_ctrl_offset;
+	u32 hsp_aclk_ctrl_regset;
+	u32 hsp_cfg_ctrl_offset;
+	u32 eth_axi_lp_ctrl_offset;
+	u32 eth_phy_ctrl_offset;
+	u32 eth_phy_ctrl_regset;
+	u32 rgmiisel_offset;
+	u32 rgmiisel_regset;
+
+	dwc_priv = devm_kzalloc(&pdev->dev, sizeof(*dwc_priv), GFP_KERNEL);
+	if (!dwc_priv)
+		return -ENOMEM;
+
+	if (device_property_read_u32(&pdev->dev, "id", &dwc_priv->dev_id)) {
+		dev_err(&pdev->dev, "Can not read device id!\n");
+		return -EINVAL;
+	}
+
+	dwc_priv->dev = &pdev->dev;
+	dwc_priv->phy_reset = devm_gpiod_get(&pdev->dev, "rst", GPIOD_OUT_LOW);
+	if (IS_ERR(dwc_priv->phy_reset)) {
+		dev_err(&pdev->dev, "Reset gpio not specified\n");
+		return -EINVAL;
+	}
+
+	gpiod_set_value(dwc_priv->phy_reset, 0);
+
+	dwc_priv->rgmii_sel = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, "eswin,rgmiisel");
+	if (IS_ERR(dwc_priv->rgmii_sel)){
+		dev_dbg(&pdev->dev, "rgmiisel not specified\n");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32_index(pdev->dev.of_node, "eswin,led-cfgs", 0, &dwc_priv->phyled_cfgs[0]);
+	if (ret) {
+		dev_warn(&pdev->dev, "can't get led cfgs for 1Gbps mode (%d)\n", ret);
+	}
+
+	ret = of_property_read_u32_index(pdev->dev.of_node, "eswin,led-cfgs", 1, &dwc_priv->phyled_cfgs[1]);
+	if (ret) {
+		dev_warn(&pdev->dev, "can't get led cfgs for 100Mbps mode (%d)\n", ret);
+	}
+
+	ret = of_property_read_u32_index(pdev->dev.of_node, "eswin,led-cfgs", 2, &dwc_priv->phyled_cfgs[2]);
+	if (ret) {
+		dev_warn(&pdev->dev, "can't get led cfgs for 10Mbps mode (%d)\n", ret);
+	}
+
+	ret = of_property_read_u32_index(pdev->dev.of_node, "eswin,rgmiisel", 1, &rgmiisel_offset);
+	if (ret) {
+		dev_err(&pdev->dev, "can't get rgmiisel_offset (%d)\n", ret);
+		return ret;
+	}
+
+	ret = of_property_read_u32_index(pdev->dev.of_node, "eswin,rgmiisel", 2, &rgmiisel_regset);
+	if (ret) {
+		dev_err(&pdev->dev, "can't get rgmiisel_regset (%d)\n", ret);
+		return ret;
+	}
+
+	regmap_write(dwc_priv->rgmii_sel, rgmiisel_offset, rgmiisel_regset);
+
+	dwc_priv->crg_regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, "eswin,syscrg_csr");
+	if (IS_ERR(dwc_priv->crg_regmap)){
+		dev_dbg(&pdev->dev, "No syscrg_csr phandle specified\n");
+		return 0;
+	}
+
+	ret = of_property_read_u32_index(pdev->dev.of_node, "eswin,syscrg_csr", 1,
+                                    &hsp_aclk_ctrl_offset);
+	if (ret) {
+		dev_err(&pdev->dev, "can't get hsp_aclk_ctrl_offset (%d)\n", ret);
+		return ret;
+	}
+	regmap_read(dwc_priv->crg_regmap, hsp_aclk_ctrl_offset, &hsp_aclk_ctrl_regset);
+	hsp_aclk_ctrl_regset |= (HSP_ACLK_CLKEN | HSP_ACLK_DIVSOR);
+	regmap_write(dwc_priv->crg_regmap, hsp_aclk_ctrl_offset, hsp_aclk_ctrl_regset);
+
+	ret = of_property_read_u32_index(pdev->dev.of_node, "eswin,syscrg_csr", 2,
+                                    &hsp_cfg_ctrl_offset);
+	if (ret) {
+		dev_err(&pdev->dev, "can't get hsp_cfg_ctrl_offset (%d)\n", ret);
+		return ret;
+	}
+	regmap_write(dwc_priv->crg_regmap, hsp_cfg_ctrl_offset, HSP_CFG_CTRL_REGSET);
+
+	dwc_priv->hsp_regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, "eswin,hsp_sp_csr");
+	if (IS_ERR(dwc_priv->hsp_regmap)){
+		dev_dbg(&pdev->dev, "No hsp_sp_csr phandle specified\n");
+		return 0;
+	}
+
+	ret = of_property_read_u32_index(pdev->dev.of_node, "eswin,hsp_sp_csr", 2,
+                                    &eth_phy_ctrl_offset);
+	if (ret) {
+		dev_err(&pdev->dev, "can't get eth_phy_ctrl_offset (%d)\n", ret);
+		return ret;
+	}
+	regmap_read(dwc_priv->hsp_regmap, eth_phy_ctrl_offset, &eth_phy_ctrl_regset);
+	eth_phy_ctrl_regset |= (ETH_TX_CLK_SEL | ETH_PHY_INTF_SELI);
+	regmap_write(dwc_priv->hsp_regmap, eth_phy_ctrl_offset, eth_phy_ctrl_regset);
+
+	ret = of_property_read_u32_index(pdev->dev.of_node, "eswin,hsp_sp_csr", 3,
+                                    &eth_axi_lp_ctrl_offset);
+	if (ret) {
+		dev_err(&pdev->dev, "can't get eth_axi_lp_ctrl_offset (%d)\n", ret);
+		return ret;
+	}
+	regmap_write(dwc_priv->hsp_regmap, eth_axi_lp_ctrl_offset, ETH_CSYSREQ_VAL);
+
+	dwc_priv->clk_app = devm_clk_get(&pdev->dev, "app");
+	if (IS_ERR(dwc_priv->clk_app)) {
+		dev_err(&pdev->dev, "app clock not found.\n");
+		return PTR_ERR(dwc_priv->clk_app);
+	}
+
+	err = clk_prepare_enable(dwc_priv->clk_app);
+	if (err < 0) {
+		dev_err(&pdev->dev, "failed to enable app clock: %d\n",
+			err);
+		return err;
+	}
+
+	dwc_priv->clk_csr = devm_clk_get(&pdev->dev, "csr");
+	if (IS_ERR(dwc_priv->clk_csr)) {
+		dev_err(&pdev->dev, "csr clock not found.\n");
+		return PTR_ERR(dwc_priv->clk_csr);
+	}
+
+	err = clk_prepare_enable(dwc_priv->clk_csr);
+	if (err < 0) {
+		dev_err(&pdev->dev, "failed to enable csr clock: %d\n",
+            err);
+		return err;
+	}
+
+	dwc_priv->clk_tx = devm_clk_get(&pdev->dev, "tx");
+	if (IS_ERR(plat_dat->pclk)) {
+		dev_err(&pdev->dev, "tx clock not found.\n");
+		return PTR_ERR(dwc_priv->clk_tx);
+	}
+
+	err = clk_prepare_enable(dwc_priv->clk_tx);
+	if (err < 0) {
+		dev_err(&pdev->dev, "failed to enable tx clock: %d\n",
+            err);
+		return err;
+	}
+	dwc_priv->rst = devm_reset_control_get_optional_exclusive(&pdev->dev, "ethrst");
+	if (IS_ERR(dwc_priv->rst)) {
+		return PTR_ERR(dwc_priv->rst);
+	}
+
+	ret = reset_control_assert(dwc_priv->rst);
+	WARN_ON(0 != ret);
+	ret = reset_control_deassert(dwc_priv->rst);
+	WARN_ON(0 != ret);
+
+	ret = eic7700_tbu_power(&pdev->dev, true);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to power on tbu\n");
+		return ret;
+	}
+
+	plat_dat->fix_mac_speed = dwc_qos_fix_speed;
+	plat_dat->bsp_priv = dwc_priv;
+	plat_dat->phy_addr = PHY_ADDR;
+
+	return 0;
+}
+
+static int dwc_qos_remove(struct platform_device *pdev)
+{
+	int ret;
+	struct dwc_qos_priv *dwc_priv = get_stmmac_bsp_priv(&pdev->dev);
+
+	ret = eic7700_tbu_power(&pdev->dev, false);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to power down tbu\n");
+		return ret;
+	}
+
+	reset_control_assert(dwc_priv->rst);
+	clk_disable_unprepare(dwc_priv->clk_tx);
+	clk_disable_unprepare(dwc_priv->clk_csr);
+	clk_disable_unprepare(dwc_priv->clk_app);
+
+	devm_gpiod_put(&pdev->dev, dwc_priv->phy_reset);
+
+	return 0;
+}
+
+struct dwc_eth_dwmac_data {
+	int (*probe)(struct platform_device *pdev,
+		     struct plat_stmmacenet_data *data,
+		     struct stmmac_resources *res);
+	int (*remove)(struct platform_device *pdev);
+};
+
+static const struct dwc_eth_dwmac_data dwc_qos_data = {
+	.probe = dwc_qos_probe,
+	.remove = dwc_qos_remove,
+};
+
+static int dwc_eth_dwmac_probe(struct platform_device *pdev)
+{
+	const struct dwc_eth_dwmac_data *data;
+	struct plat_stmmacenet_data *plat_dat;
+	struct stmmac_resources stmmac_res;
+	struct net_device *ndev = NULL;
+	struct stmmac_priv *stmpriv = NULL;
+	struct dwc_qos_priv *dwc_priv = NULL;
+	int ret;
+
+	data = device_get_match_data(&pdev->dev);
+
+	memset(&stmmac_res, 0, sizeof(struct stmmac_resources));
+
+	/**
+	 * Since stmmac_platform supports name IRQ only, basic platform
+	 * resource initialization is done in the glue logic.
+	 */
+	stmmac_res.irq = platform_get_irq(pdev, 0);
+	if (stmmac_res.irq < 0)
+		return stmmac_res.irq;
+	stmmac_res.wol_irq = stmmac_res.irq;
+	stmmac_res.addr = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(stmmac_res.addr))
+		return PTR_ERR(stmmac_res.addr);
+
+	plat_dat = stmmac_probe_config_dt(pdev, stmmac_res.mac);
+	if (IS_ERR(plat_dat))
+		return PTR_ERR(plat_dat);
+
+	ret = data->probe(pdev, plat_dat, &stmmac_res);
+	if (ret < 0) {
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "failed to probe subdriver: %d\n",
+				ret);
+
+		goto remove_config;
+	}
+
+	ret = dwc_eth_dwmac_config_dt(pdev, plat_dat);
+	if (ret)
+		goto remove;
+
+    ret =  eswin_eth_sid_cfg(&pdev->dev);
+	if (ret)
+		goto remove;
+
+	ret = stmmac_dvr_probe(&pdev->dev, plat_dat, &stmmac_res);
+	if (ret)
+		goto remove;
+
+	ndev = dev_get_drvdata(&pdev->dev);
+	stmpriv = netdev_priv(ndev);
+	dwc_priv = (struct dwc_qos_priv *)plat_dat->bsp_priv;
+	dwc_priv->stmpriv = stmpriv;
+
+	return ret;
+
+remove:
+	data->remove(pdev);
+remove_config:
+	stmmac_remove_config_dt(pdev, plat_dat);
+
+	return ret;
+}
+
+static int dwc_eth_dwmac_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct stmmac_priv *priv = netdev_priv(ndev);
+	const struct dwc_eth_dwmac_data *data;
+	int err;
+
+	data = device_get_match_data(&pdev->dev);
+
+	stmmac_dvr_remove(&pdev->dev);
+
+	err = data->remove(pdev);
+	if (err < 0)
+		dev_err(&pdev->dev, "failed to remove subdriver: %d\n", err);
+
+	stmmac_remove_config_dt(pdev, priv->plat);
+
+	return err;
+}
+
+static const struct of_device_id dwc_eth_dwmac_match[] = {
+	{ .compatible = "eswin,eic7700-qos-eth", .data = &dwc_qos_data },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, dwc_eth_dwmac_match);
+
+static struct platform_driver eic7700_eth_dwmac_driver = {
+	.probe  = dwc_eth_dwmac_probe,
+	.remove = dwc_eth_dwmac_remove,
+	.driver = {
+		.name           = "eic7700-eth-dwmac",
+		.pm             = &stmmac_pltfr_pm_ops,
+		.of_match_table = dwc_eth_dwmac_match,
+	},
+};
+module_platform_driver(eic7700_eth_dwmac_driver);
+
+MODULE_AUTHOR("Eswin");
+MODULE_DESCRIPTION("Eswin eic7700 qos ethernet driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c
index 7cb0548d17a3..21ba5a8e7c24 100644
--- a/drivers/net/virtio_net.c
+++ b/drivers/net/virtio_net.c
@@ -4438,11 +4438,13 @@ static int virtnet_probe(struct virtio_device *vdev)
 			dev->features |= dev->hw_features & NETIF_F_ALL_TSO;
 		/* (!csum && gso) case will be fixed by register_netdev() */
 	}
-	if (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_CSUM))
+	if (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_CSUM)) {
 		dev->features |= NETIF_F_RXCSUM;
-	if (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO4) ||
-	    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6))
-		dev->features |= NETIF_F_GRO_HW;
+		/* This dependency is enforced by netdev_fix_features */
+		if (virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO4) ||
+		    virtio_has_feature(vdev, VIRTIO_NET_F_GUEST_TSO6))
+			dev->features |= NETIF_F_GRO_HW;
+	}
 	if (virtio_has_feature(vdev, VIRTIO_NET_F_CTRL_GUEST_OFFLOADS))
 		dev->hw_features |= NETIF_F_GRO_HW;
 
diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index bf502ba8da95..06869436db8e 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -1169,6 +1169,7 @@ int __init early_init_dt_scan_chosen(char *cmdline)
 	early_init_dt_check_for_initrd(node);
 	early_init_dt_check_for_elfcorehdr(node);
 
+#ifndef CONFIG_RISCV_COVE_GUEST
 	rng_seed = of_get_flat_dt_prop(node, "rng-seed", &l);
 	if (rng_seed && l > 0) {
 		add_bootloader_randomness(rng_seed, l);
@@ -1180,6 +1181,7 @@ int __init early_init_dt_scan_chosen(char *cmdline)
 		of_fdt_crc32 = crc32_be(~0, initial_boot_params,
 				fdt_totalsize(initial_boot_params));
 	}
+#endif
 
 	/* Retrieve command line */
 	p = of_get_flat_dt_prop(node, "bootargs", &l);
diff --git a/drivers/pci/controller/dwc/Kconfig b/drivers/pci/controller/dwc/Kconfig
index ab96da43e0c2..09f44434f854 100644
--- a/drivers/pci/controller/dwc/Kconfig
+++ b/drivers/pci/controller/dwc/Kconfig
@@ -415,4 +415,12 @@ config PCIE_VISCONTI_HOST
 	  Say Y here if you want PCIe controller support on Toshiba Visconti SoC.
 	  This driver supports TMPV7708 SoC.
 
+config PCIE_ESWIN
+	tristate "ESWIN PCIe host controller"
+	depends on PCI_MSI
+	depends on SOC_SIFIVE || COMPILE_TEST
+	select PCIE_DW_HOST
+	help
+	  Say Y here if you want PCIe controller support for the ESWIN.
+
 endmenu
diff --git a/drivers/pci/controller/dwc/Makefile b/drivers/pci/controller/dwc/Makefile
index bf5c311875a1..927459a28dc7 100644
--- a/drivers/pci/controller/dwc/Makefile
+++ b/drivers/pci/controller/dwc/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_PCIE_TEGRA194) += pcie-tegra194.o
 obj-$(CONFIG_PCIE_UNIPHIER) += pcie-uniphier.o
 obj-$(CONFIG_PCIE_UNIPHIER_EP) += pcie-uniphier-ep.o
 obj-$(CONFIG_PCIE_VISCONTI_HOST) += pcie-visconti.o
+obj-$(CONFIG_PCIE_ESWIN) += pcie-eswin.o
 
 # The following drivers are for devices that use the generic ACPI
 # pci_root.c driver but don't support standard ECAM config access.
diff --git a/drivers/pci/controller/dwc/pcie-eswin.c b/drivers/pci/controller/dwc/pcie-eswin.c
new file mode 100644
index 000000000000..6d142f2287d3
--- /dev/null
+++ b/drivers/pci/controller/dwc/pcie-eswin.c
@@ -0,0 +1,436 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN PCIe root complex driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: Yu Ning <ningyu@eswincomputing.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/kernel.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/resource.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/reset.h>
+#include <linux/eic7700-sid-cfg.h>
+#include <linux/gpio/consumer.h>
+#include <linux/property.h>
+#include "pcie-designware.h"
+
+#define _writel_relaxed(v, p) 	writel_relaxed(v, p)
+#define to_eswin_pcie(x)	dev_get_drvdata((x)->dev)
+
+struct eswin_pcie {
+	struct dw_pcie pci;
+	void __iomem *mgmt_base;
+	struct gpio_desc *reset;
+	struct clk *pcie_aux;
+	struct clk *pcie_cfg;
+	struct clk *pcie_cr;
+	struct clk *pcie_aclk;
+	struct reset_control *powerup_rst;
+	struct reset_control *cfg_rst;
+	struct reset_control *perst;
+	int gen_x;
+	int lane_x;
+};
+
+#define PCIEMGMT_ACLK_CTRL		0x170
+#define PCIEMGMT_ACLK_CLKEN		BIT(31)
+#define PCIEMGMT_XTAL_SEL		BIT(20)
+#define PCIEMGMT_DIVSOR		0xf0
+
+#define PCIEMGMT_CFG_CTRL		0x174
+#define PCIEMGMT_CFG_CLKEN		BIT(31)
+#define PCIEMGMT_AUX_CLKEN		BIT(1)
+#define PCIEMGMT_CR_CLKEN		BIT(0)
+
+#define PCIEMGMT_RST_CTRL		0x420
+#define PCIEMGMT_PERST_N		BIT(2)
+#define PCIEMGMT_POWERUP_RST_N	BIT(1)
+#define PCIEMGMT_CFG_RST_N		BIT(0)
+
+#define PCIE_PM_SEL_AUX_CLK		BIT(16)
+
+#define PCIEMGMT_APP_HOLD_PHY_RST	BIT(6)
+#define PCIEMGMT_APP_LTSSM_ENABLE	BIT(5)
+#define PCIEMGMT_DEVICE_TYPE_MASK	0xf
+
+#define PCIEMGMT_LINKUP_STATE_VALIDATE  ((0x11<<2)|0x3)
+#define PCIEMGMT_LINKUP_STATE_MASK      0xff
+
+static void eswin_pcie_shutdown(struct platform_device *pdev)
+{
+	struct eswin_pcie *pcie = platform_get_drvdata(pdev);
+
+	/* Bring down link, so bootloader gets clean state in case of reboot */
+	reset_control_assert(pcie->perst);
+}
+
+static int eswin_pcie_start_link(struct dw_pcie *pci)
+{
+	struct device *dev = pci->dev;
+	struct eswin_pcie *pcie = dev_get_drvdata(dev);
+	u32 val;
+
+	/* Enable LTSSM */
+	val = readl_relaxed(pcie->mgmt_base);
+	val |= PCIEMGMT_APP_LTSSM_ENABLE;
+	_writel_relaxed(val, pcie->mgmt_base);
+	return 0;
+}
+
+static int eswin_pcie_link_up(struct dw_pcie *pci)
+{
+	struct device *dev = pci->dev;
+	struct eswin_pcie *pcie = dev_get_drvdata(dev);
+	u32 val;
+
+	val = readl_relaxed(pcie->mgmt_base + 0x100);
+	if ((val & PCIEMGMT_LINKUP_STATE_MASK) == PCIEMGMT_LINKUP_STATE_VALIDATE)
+		return 1;
+	else
+		return 0;
+}
+
+static int eswin_pcie_clk_enable(struct eswin_pcie *pcie)
+{
+	int ret;
+
+	ret = clk_prepare_enable(pcie->pcie_cr);
+	if (ret) {
+		pr_err("PCIe: failed to enable cr clk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(pcie->pcie_aclk);
+	if (ret) {
+		pr_err("PCIe: failed to enable aclk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(pcie->pcie_cfg);
+	if (ret) {
+		pr_err("PCIe: failed to enable cfg_clk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(pcie->pcie_aux);
+	if (ret) {
+		pr_err("PCIe: failed to enable aux_clk: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int eswin_pcie_clk_disable(struct eswin_pcie *eswin_pcie)
+{
+	clk_disable_unprepare(eswin_pcie->pcie_aux);
+	clk_disable_unprepare(eswin_pcie->pcie_cfg);
+	clk_disable_unprepare(eswin_pcie->pcie_cr);
+	clk_disable_unprepare(eswin_pcie->pcie_aclk);
+
+	return 0;
+}
+
+static int eswin_pcie_power_on(struct eswin_pcie *pcie)
+{
+	int ret = 0;
+
+	/* pciet_cfg_rstn */
+	ret = reset_control_reset(pcie->cfg_rst);
+	WARN_ON(0 != ret);
+
+	/* pciet_powerup_rstn */
+	ret = reset_control_reset(pcie->powerup_rst);
+	WARN_ON(0 != ret);
+
+	return ret;
+}
+
+static int eswin_pcie_power_off(struct eswin_pcie *eswin_pcie)
+{
+	reset_control_assert(eswin_pcie->perst);
+
+	reset_control_assert(eswin_pcie->powerup_rst);
+
+	reset_control_assert(eswin_pcie->cfg_rst);
+
+	return 0;
+}
+
+/* TODO: Check socket gpio number in actual board and
+ *       change if necessary
+ */
+int eswin_evb_socket_power_on(struct device *dev)
+{
+	int err_desc=0;
+	struct gpio_desc *gpio;
+	gpio = devm_gpiod_get(dev, "pci-socket", GPIOD_OUT_LOW);
+	err_desc = IS_ERR(gpio);
+
+	if (err_desc) {
+		pr_err("No power control gpio found, maybe not needed\n");
+		return 0;
+	}
+
+	gpiod_set_value(gpio,1);
+
+	return err_desc;
+}
+
+static int eswin_pcie_host_init(struct dw_pcie_rp *pp)
+{
+	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+	struct eswin_pcie *pcie = to_eswin_pcie(pci);
+	int ret;
+	u32 val;
+
+	/* pciet_aux_clken, pcie_cfg_clken */
+	ret = eswin_pcie_clk_enable(pcie);
+	if (ret)
+		return ret;
+
+	ret = eswin_pcie_power_on(pcie);
+	if (ret)
+		return ret;
+
+	ret = eic7700_tbu_power(pcie->pci.dev, true);
+	if (ret)
+		return ret;
+
+	/* set device type : rc */
+	val = readl_relaxed(pcie->mgmt_base);
+	val &= 0xfffffff0;
+	_writel_relaxed(val|0x4, pcie->mgmt_base);
+
+	ret = reset_control_assert(pcie->perst);
+	WARN_ON(0 != ret);
+
+	eswin_evb_socket_power_on(pcie->pci.dev);
+	msleep(100);
+	ret = reset_control_deassert(pcie->perst);
+	WARN_ON(0 != ret);
+
+	/* app_hold_phy_rst */
+	val = readl_relaxed(pcie->mgmt_base);
+	val &= ~(0x40);
+	_writel_relaxed(val, pcie->mgmt_base);
+
+	/* wait pm_sel_aux_clk to 0 */
+	while (1) {
+		val = readl_relaxed(pcie->mgmt_base + 0x100);
+		if (!(val & PCIE_PM_SEL_AUX_CLK)) {
+			break;
+		}
+		msleep(1);
+	}
+
+	/* TODO: All hardcoded values such as register addresses and the values written to then
+	 *        to be replaced with macros.
+	 */
+	/* config eswin vendor id and EIC7700 device id */
+	dw_pcie_writel_dbi(pci, 0, 0x20301fe1);
+
+	if (pcie->gen_x == 3) {
+		/* GEN3 */
+		dw_pcie_writel_dbi(pci, 0xa0, 0x00010003);
+
+		/* LINK_CAPABILITIES_REG : PCIE_CAP_BASE + 0xc */
+		val = dw_pcie_readl_dbi(pci, 0x7c);
+		val &= 0xfffffff0;
+		/* GEN3 */
+		val |= 0x3;
+		dw_pcie_writel_dbi(pci, 0x7c, val);
+	} else if (pcie->gen_x == 2) {
+		/* GEN2 */
+		dw_pcie_writel_dbi(pci, 0xa0, 0x00010002);
+
+		/* LINK_CAPABILITIES_REG : PCIE_CAP_BASE + 0xc */
+		val = dw_pcie_readl_dbi(pci, 0x7c);
+		val &= 0xfffffff0;
+		val |= 0x2;
+		dw_pcie_writel_dbi(pci, 0x7c, val);
+	}else {
+		/* GEN1 */
+		dw_pcie_writel_dbi(pci, 0xa0, 0x00010001);
+
+		/* LINK_CAPABILITIES_REG : PCIE_CAP_BASE + 0xc */
+		val = dw_pcie_readl_dbi(pci, 0x7c);
+		val &= 0xfffffff0;
+		val |= 0x1;
+		dw_pcie_writel_dbi(pci, 0x7c, val);
+	}
+
+	/* LINK_CAPABILITIES_REG : PCIE_CAP_BASE + 0xc : laneX */
+	val = dw_pcie_readl_dbi(pci, 0x7c);
+	val &= 0xfffffc0f;
+	if (pcie->lane_x == 4) {
+		val |= 0x40;
+	} else if (pcie->lane_x == 2) {
+		val |= 0x20;
+	} else {
+		val |= 0x10;
+	}
+
+	dw_pcie_writel_dbi(pci, 0x7c, val);
+
+	/* lane fix config, real driver NOT need, default x4 */
+	val = dw_pcie_readl_dbi(pci, 0x8c0);
+	val &= 0xffffff80;
+	if (pcie->lane_x == 4) {
+		val |= 0x44;
+	} else if (pcie->lane_x == 2) {
+		val |= 0x42;
+	} else {
+		val |= 0x41;
+	}
+	dw_pcie_writel_dbi(pci, 0x8c0, val);
+
+	/* config msix table size to 0 in RC mode because our RC not support msix */
+	val = dw_pcie_readl_dbi(pci, 0xb0);
+	val &= ~(0x7ff<<16);
+	dw_pcie_writel_dbi(pci, 0xb0, val);
+
+	/*  config support 32 msi vectors */
+	dw_pcie_writel_dbi(pci, 0x50, 0x018a7005);
+
+	return 0;
+}
+
+static const struct dw_pcie_host_ops eswin_pcie_host_ops = {
+	.host_init = eswin_pcie_host_init,
+};
+
+static const struct dw_pcie_ops dw_pcie_ops = {
+	.start_link = eswin_pcie_start_link,
+	.link_up = eswin_pcie_link_up,
+};
+
+static int __exit eswin_pcie_remove(struct platform_device *pdev)
+{
+	struct eswin_pcie *pcie = platform_get_drvdata(pdev);
+
+	dw_pcie_host_deinit(&pcie->pci.pp);
+
+	eic7700_tbu_power(&pdev->dev, false);
+	eswin_pcie_power_off(pcie);
+	eswin_pcie_clk_disable(pcie);
+
+	return 0;
+}
+
+static int eswin_pcie_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct dw_pcie *pci;
+	struct eswin_pcie *pcie;
+
+	pcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);
+	if (!pcie)
+		return -ENOMEM;
+	pci = &pcie->pci;
+	pci->dev = dev;
+	pci->ops = &dw_pcie_ops;
+	pci->pp.ops = &eswin_pcie_host_ops;
+
+	/* SiFive specific region: mgmt */
+	pcie->mgmt_base = devm_platform_ioremap_resource_byname(pdev, "mgmt");
+	if (IS_ERR(pcie->mgmt_base))
+		return PTR_ERR(pcie->mgmt_base);
+
+	/* Fetch clocks */
+	pcie->pcie_aux = devm_clk_get(dev, "pcie_aux_clk");
+	if (IS_ERR(pcie->pcie_aux)) {
+		dev_err(dev, "pcie_aux clock source missing or invalid\n");
+		return PTR_ERR(pcie->pcie_aux);
+	}
+
+	pcie->pcie_cfg = devm_clk_get(dev, "pcie_cfg_clk");
+	if (IS_ERR(pcie->pcie_cfg)) {
+		dev_err(dev, "pcie_cfg_clk clock source missing or invalid\n");
+		return PTR_ERR(pcie->pcie_cfg);
+	}
+
+	pcie->pcie_cr = devm_clk_get(dev, "pcie_cr_clk");
+	if (IS_ERR(pcie->pcie_cr)) {
+		dev_err(dev, "pcie_cr_clk clock source missing or invalid\n");
+		return PTR_ERR(pcie->pcie_cr);
+	}
+
+	pcie->pcie_aclk = devm_clk_get(dev, "pcie_aclk");
+	if (IS_ERR(pcie->pcie_aclk)) {
+		dev_err(dev, "pcie_aclk clock source missing or invalid\n");
+		return PTR_ERR(pcie->pcie_aclk);
+	}
+
+	/* Fetch reset */
+	pcie->powerup_rst = devm_reset_control_get_optional(&pdev->dev, "pcie_powerup");
+	if (IS_ERR_OR_NULL(pcie->powerup_rst)) {
+		dev_err_probe(dev, PTR_ERR(pcie->powerup_rst), "unable to get powerup reset\n");
+	}
+
+	pcie->cfg_rst = devm_reset_control_get_optional(&pdev->dev, "pcie_cfg");
+	if (IS_ERR_OR_NULL(pcie->cfg_rst)) {
+		dev_err_probe(dev, PTR_ERR(pcie->cfg_rst), "unable to get cfg reset\n");
+	}
+
+	pcie->perst = devm_reset_control_get_optional(&pdev->dev, "pcie_pwren");
+	if (IS_ERR_OR_NULL(pcie->perst)) {
+		dev_err_probe(dev, PTR_ERR(pcie->perst), "unable to get perst\n");
+	}
+
+	device_property_read_u32(&pdev->dev, "gen-x", &pcie->gen_x);
+	device_property_read_u32(&pdev->dev, "lane-x", &pcie->lane_x);
+
+	platform_set_drvdata(pdev, pcie);
+
+	return dw_pcie_host_init(&pci->pp);
+}
+
+static const struct of_device_id eswin_pcie_of_match[] = {
+	{ .compatible = "eswin,eic7700-pcie", },
+	{},
+};
+
+static struct platform_driver eswin_pcie_driver = {
+	.driver = {
+		   .name = "eswin-pcie",
+		   .of_match_table = eswin_pcie_of_match,
+		   .suppress_bind_attrs = true,
+	},
+	.probe = eswin_pcie_probe,
+	.remove = __exit_p(eswin_pcie_remove),
+	.shutdown = eswin_pcie_shutdown,
+};
+
+module_platform_driver(eswin_pcie_driver);
+
+MODULE_DEVICE_TABLE(of, eswin_pcie_of_match);
+MODULE_DESCRIPTION("PCIe host controller driver for ESWIN EIC77xx SoCs");
+MODULE_AUTHOR("Ning Yu <ningyu@eswincomputing.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig
index 7dfb7190580e..fc0f01e31bcc 100644
--- a/drivers/pinctrl/Kconfig
+++ b/drivers/pinctrl/Kconfig
@@ -195,6 +195,16 @@ config PINCTRL_EQUILIBRIUM
 	  desired pin functions, configure GPIO attributes for LGM SoC pins.
 	  Pin muxing and pin config settings are retrieved from device tree.
 
+config PINCTRL_EIC7700
+	tristate "EIC7700 PINCTRL driver"
+	select GENERIC_PINCONF
+	select PINMUX
+	select PINCONF
+	select GENERIC_PINCTRL_GROUPS
+	select GENERIC_PINMUX_FUNCTIONS
+	help
+	  say Y here to add pinctrl eic7700 driver
+
 config PINCTRL_GEMINI
 	bool
 	depends on ARCH_GEMINI
diff --git a/drivers/pinctrl/Makefile b/drivers/pinctrl/Makefile
index dd6cda270294..3e51b32bd161 100644
--- a/drivers/pinctrl/Makefile
+++ b/drivers/pinctrl/Makefile
@@ -22,6 +22,7 @@ obj-$(CONFIG_PINCTRL_DA850_PUPD) += pinctrl-da850-pupd.o
 obj-$(CONFIG_PINCTRL_DA9062)	+= pinctrl-da9062.o
 obj-$(CONFIG_PINCTRL_DIGICOLOR)	+= pinctrl-digicolor.o
 obj-$(CONFIG_PINCTRL_EQUILIBRIUM)   += pinctrl-equilibrium.o
+obj-$(CONFIG_PINCTRL_EIC7700)  += pinctrl-eic7700.o
 obj-$(CONFIG_PINCTRL_GEMINI)	+= pinctrl-gemini.o
 obj-$(CONFIG_PINCTRL_INGENIC)	+= pinctrl-ingenic.o
 obj-$(CONFIG_PINCTRL_K210)	+= pinctrl-k210.o
diff --git a/drivers/pinctrl/pinctrl-eic7700.c b/drivers/pinctrl/pinctrl-eic7700.c
new file mode 100644
index 000000000000..8db8b8d1877a
--- /dev/null
+++ b/drivers/pinctrl/pinctrl-eic7700.c
@@ -0,0 +1,1360 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Pinctrl Controller Platform Device Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: Yulin Lu <luyulin@eswincomputing.com>
+ */
+#include <linux/io.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+#include <linux/regmap.h>
+#include "pinctrl-utils.h"
+#include "core.h"
+
+#define ESWIN_MIO_NUM 164
+
+#define ESWIN_PINCONF_IE	   BIT(0)
+#define ESWIN_PINCONF_PULLUP   BIT(1)
+#define ESWIN_PINCONF_PULLDOWN BIT(2)
+#define ESWIN_PINCONF_DRIVER_STRENGTH_MASK  0xf  // 0111 1000
+#define ESWIN_PINCONF_DRIVER_SHIFT 3
+#define ESWIN_PINCONF_SMT BIT(7)
+
+struct eswin_function_desc {
+	const char *name;
+	const char * const *groups;
+	int ngroups;
+	u32 mux_val;
+	u32 mux_mask;
+};
+
+struct eswin_group_desc{
+	const char *name;
+	const unsigned int *pins;
+	const unsigned int npins;
+
+};
+
+struct eswin_pinctrl {
+	struct pinctrl_dev *pctrl;
+	void __iomem		*base;
+	const struct eswin_group_desc *groups;
+	unsigned int ngroups;
+	const struct eswin_function_desc *funcs;
+	unsigned int nfuncs;
+};
+
+static const struct pinctrl_pin_desc eswin_pins[] = {
+
+	PINCTRL_PIN(0, "CHIP_MODE"),
+	PINCTRL_PIN(1, "MODE_SET0"),
+	PINCTRL_PIN(2, "MODE_SET1"),
+	PINCTRL_PIN(3, "MODE_SET2"),
+	PINCTRL_PIN(4, "MODE_SET3"),
+	PINCTRL_PIN(5, "XIN"),
+	PINCTRL_PIN(6, "RTC_XIN"),
+	PINCTRL_PIN(7, "RST_OUT_N"),
+	PINCTRL_PIN(8,"KEY_RESET_N"),
+	PINCTRL_PIN(9,"RST_IN_N"),
+	PINCTRL_PIN(10,"POR_IN_N"),
+	PINCTRL_PIN(11,"POR_OUT_N"),
+	PINCTRL_PIN(12,"GPIO0"),
+	PINCTRL_PIN(13,"POR_SEL"),
+	PINCTRL_PIN(14,"JTAG0_TCK"),
+	PINCTRL_PIN(15,"JTAG0_TMS"),
+	PINCTRL_PIN(16,"JTAG0_TDI"),
+	PINCTRL_PIN(17,"JTAG0_TDO"),
+	PINCTRL_PIN(18,"JTAG0_TRST"),
+	PINCTRL_PIN(19,"SPI2_CS0_N"),
+	PINCTRL_PIN(20,"JTAG1_TCK"),
+	PINCTRL_PIN(21,"JTAG1_TMS"),
+	PINCTRL_PIN(22,"JTAG1_TDI"),
+	PINCTRL_PIN(23,"JTAG1_TDO"),
+	PINCTRL_PIN(24,"JTAG1_TRST"),
+	PINCTRL_PIN(25,"SPI2_CS1_N"),
+	PINCTRL_PIN(26,"PCIE_CLKREQ_N"),
+	PINCTRL_PIN(27,"PCIE_WAKE_N"),
+	PINCTRL_PIN(28,"PCIE_PERST_N"),
+	PINCTRL_PIN(29,"HDMI_SCL"),
+	PINCTRL_PIN(30,"HDMI_SDA"),
+	PINCTRL_PIN(31,"HDMI_CEC"),
+	PINCTRL_PIN(32,"JTAG2_TRST"),
+	PINCTRL_PIN(33,"RGMII0_CLK_125"),
+	PINCTRL_PIN(34,"RGMII0_TXEN"),
+	PINCTRL_PIN(35,"RGMII0_TXCLK"),
+	PINCTRL_PIN(36,"RGMII0_TXD0"),
+	PINCTRL_PIN(37,"RGMII0_TXD1"),
+	PINCTRL_PIN(38,"RGMII0_TXD2"),
+	PINCTRL_PIN(39,"RGMII0_TXD3"),
+	PINCTRL_PIN(40,"I2S0_BCLK"),
+	PINCTRL_PIN(41,"I2S0_WCLK"),
+	PINCTRL_PIN(42,"I2S0_SDI"),
+	PINCTRL_PIN(43,"I2S0_SDO"),
+	PINCTRL_PIN(44,"I2S_MCLK"),
+	PINCTRL_PIN(45,"RGMII0_RXCLK"),
+	PINCTRL_PIN(46,"RGMII0_RXDV"),
+	PINCTRL_PIN(47,"RGMII0_RXD0"),
+	PINCTRL_PIN(48,"RGMII0_RXD1"),
+	PINCTRL_PIN(49,"RGMII0_RXD2"),
+	PINCTRL_PIN(50,"RGMII0_RXD3"),
+	PINCTRL_PIN(51,"I2S2_BCLK"),
+	PINCTRL_PIN(52,"I2S2_WCLK"),
+	PINCTRL_PIN(53,"I2S2_SDI"),
+	PINCTRL_PIN(54,"I2S2_SDO"),
+	PINCTRL_PIN(55,"GPIO27"),
+	PINCTRL_PIN(56,"GPIO28"),
+	PINCTRL_PIN(57,"GPIO29"),
+	PINCTRL_PIN(58,"RGMII0_MDC"),
+	PINCTRL_PIN(59,"RGMII0_MDIO"),
+	PINCTRL_PIN(60,"RGMII0_INTB"),
+	PINCTRL_PIN(61,"RGMII1_CLK_125"),
+	PINCTRL_PIN(62,"RGMII1_TXEN"),
+	PINCTRL_PIN(63,"RGMII1_TXCLK"),
+	PINCTRL_PIN(64,"RGMII1_TXD0"),
+	PINCTRL_PIN(65,"RGMII1_TXD1"),
+	PINCTRL_PIN(66,"RGMII1_TXD2"),
+	PINCTRL_PIN(67,"RGMII1_TXD3"),
+	PINCTRL_PIN(68,"I2S1_BCLK"),
+	PINCTRL_PIN(69,"I2S1_WCLK"),
+	PINCTRL_PIN(70,"I2S1_SDI"),
+	PINCTRL_PIN(71,"I2S1_SDO"),
+	PINCTRL_PIN(72,"GPIO34"),
+	PINCTRL_PIN(73,"RGMII1_RXCLK"),
+	PINCTRL_PIN(74,"RGMII1_RXDV"),
+	PINCTRL_PIN(75,"RGMII1_RXD0"),
+	PINCTRL_PIN(76,"RGMII1_RXD1"),
+	PINCTRL_PIN(77,"RGMII1_RXD2"),
+	PINCTRL_PIN(78,"RGMII1_RXD3"),
+	PINCTRL_PIN(79,"SPI1_CS0_N"),
+	PINCTRL_PIN(80,"SPI1_CLK"),
+	PINCTRL_PIN(81,"SPI1_D0"),
+	PINCTRL_PIN(82,"SPI1_D1"),
+	PINCTRL_PIN(83,"SPI1_D2"),
+	PINCTRL_PIN(84,"SPI1_D3"),
+	PINCTRL_PIN(85,"SPI1_CS1_N"),
+	PINCTRL_PIN(86,"RGMII1_MDC"),
+	PINCTRL_PIN(87,"RGMII1_MDIO"),
+	PINCTRL_PIN(88,"RGMII1_INTB"),
+	PINCTRL_PIN(89,"USB0_PWREN"),
+	PINCTRL_PIN(90,"USB1_PWREN"),
+	PINCTRL_PIN(91,"I2C0_SCL"),
+	PINCTRL_PIN(92,"I2C0_SDA"),
+	PINCTRL_PIN(93,"I2C1_SCL"),
+	PINCTRL_PIN(94,"I2C1_SDA"),
+	PINCTRL_PIN(95,"I2C2_SCL"),
+	PINCTRL_PIN(96,"I2C2_SDA"),
+	PINCTRL_PIN(97,"I2C3_SCL"),
+	PINCTRL_PIN(98,"I2C3_SDA"),
+	PINCTRL_PIN(99,"I2C4_SCL"),
+	PINCTRL_PIN(100,"I2C4_SDA"),
+	PINCTRL_PIN(101,"I2C5_SCL"),
+	PINCTRL_PIN(102,"I2C5_SDA"),
+	PINCTRL_PIN(103,"UART0_TX"),
+	PINCTRL_PIN(104,"UART0_RX"),
+	PINCTRL_PIN(105,"UART1_TX"),
+	PINCTRL_PIN(106,"UART1_RX"),
+	PINCTRL_PIN(107,"UART1_CTS"),
+	PINCTRL_PIN(108,"UART1_RTS"),
+	PINCTRL_PIN(109,"UART2_TX"),
+	PINCTRL_PIN(110,"UART2_RX"),
+	PINCTRL_PIN(111,"JTAG2_TCK"),
+	PINCTRL_PIN(112,"JTAG2_TMS"),
+	PINCTRL_PIN(113,"JTAG2_TDI"),
+	PINCTRL_PIN(114,"JTAG2_TDO"),
+	PINCTRL_PIN(115,"FAN_PWM"),
+	PINCTRL_PIN(116,"FAN_TACH"),
+	PINCTRL_PIN(117,"MIPI_CSI0_XVS"),
+	PINCTRL_PIN(118,"MIPI_CSI0_XHS"),
+	PINCTRL_PIN(119,"MIPI_CSI0_MCLK"),
+	PINCTRL_PIN(120,"MIPI_CSI1_XVS"),
+	PINCTRL_PIN(121,"MIPI_CSI1_XHS"),
+	PINCTRL_PIN(122,"MIPI_CSI1_MCLK"),
+	PINCTRL_PIN(123,"MIPI_CSI2_XVS"),
+	PINCTRL_PIN(124,"MIPI_CSI2_XHS"),
+	PINCTRL_PIN(125,"MIPI_CSI2_MCLK"),
+	PINCTRL_PIN(126,"MIPI_CSI3_XVS"),
+	PINCTRL_PIN(127,"MIPI_CSI3_XHS"),
+	PINCTRL_PIN(128,"MIPI_CSI3_MCLK"),
+	PINCTRL_PIN(129,"MIPI_CSI4_XVS"),
+	PINCTRL_PIN(130,"MIPI_CSI4_XHS"),
+	PINCTRL_PIN(131,"MIPI_CSI4_MCLK"),
+	PINCTRL_PIN(132,"MIPI_CSI5_XVS"),
+	PINCTRL_PIN(133,"MIPI_CSI5_XHS"),
+	PINCTRL_PIN(134,"MIPI_CSI5_MCLK"),
+	PINCTRL_PIN(135,"SPI3_CS_N"),
+	PINCTRL_PIN(136,"SPI3_CLK"),
+	PINCTRL_PIN(137,"SPI3_DI"),
+	PINCTRL_PIN(138,"SPI3_DO"),
+	PINCTRL_PIN(139,"GPIO92"),
+	PINCTRL_PIN(140,"GPIO93"),
+	PINCTRL_PIN(141,"S_MODE"),
+	PINCTRL_PIN(142,"GPIO95"),
+	PINCTRL_PIN(143,"SPI0_CS_N"),
+	PINCTRL_PIN(144,"SPI0_CLK"),
+	PINCTRL_PIN(145,"SPI0_D0"),
+	PINCTRL_PIN(146,"SPI0_D1"),
+	PINCTRL_PIN(147,"SPI0_D2"),
+	PINCTRL_PIN(148,"SPI0_D3"),
+	PINCTRL_PIN(149,"I2C10_SCL"),
+	PINCTRL_PIN(150,"I2C10_SDA"),
+	PINCTRL_PIN(151,"I2C11_SCL"),
+	PINCTRL_PIN(152,"I2C11_SDA"),
+	PINCTRL_PIN(153,"GPIO106"),
+	PINCTRL_PIN(154,"BOOT_SEL0"),
+	PINCTRL_PIN(155,"BOOT_SEL1"),
+	PINCTRL_PIN(156,"BOOT_SEL2"),
+	PINCTRL_PIN(157,"BOOT_SEL3"),
+	PINCTRL_PIN(158,"GPIO111"),
+	PINCTRL_PIN(159,"D2D_SERDES_STATUS_IN"),
+	PINCTRL_PIN(160,"D2D_SERDES_STATUS_OUT"),
+	PINCTRL_PIN(161,"LPDDR_REF_CLK"),
+
+};
+
+#define ESWIN_PINCTRL_GRP(_name) \
+	{ \
+		.name = #_name "_group", \
+		.pins = _name ## _pins, \
+		.npins = ARRAY_SIZE(_name ## _pins), \
+	}
+
+//func0
+static const char * const sdio0_group[] = {"sdio0_group"};
+static const char * const sdio1_group[] = {"sdio1_group"};
+static const char * const por_sel_group[] = {"por_sel_group"};
+static const char * const jtag0_group[] = {"jtag0_group"};
+static const char * const jtag1_group[] = {"jtag1_group"};
+static const char * const spi2_cs_group[] = {"spi2_cs_group"};
+static const char * const pcie_group[] = {"pcie_group"};
+static const char * const hdmi_group[] = {"hdmi_group"};
+static const char * const jtag2_group[] = {"jtag2_group"};
+static const char * const rgmii0_group[] = {"rgmii0_group"};
+static const char * const i2s0_group[] = {"i2s0_group"};
+static const char * const i2s1_group[] = {"i2s1_group"};
+static const char * const i2s2_group[] = {"i2s2_group"};
+static const char * const por_time_sel0_group[] = {"por_time_sel0_group"};
+static const char * const por_time_sel1_group[] = {"por_time_sel1_group"};
+static const char * const rgmii1_group[] = {"rgmii1_group"};
+static const char * const spi1_group[] = {"spi1_group"};
+static const char * const usb0_pwren_group[] = {"usb0_pwren_group"};
+static const char * const usb1_pwren_group[] = {"usb1_pwren_group"};
+static const char * const i2c0_group[] = {"i2c0_group"};
+static const char * const i2c1_group[] = {"i2c1_group"};
+static const char * const i2c2_group[] = {"i2c2_group"};
+static const char * const i2c3_group[] = {"i2c3_group"};
+static const char * const i2c4_group[] = {"i2c4_group"};
+static const char * const i2c5_group[] = {"i2c5_group"};
+static const char * const uart0_group[] = {"uart0_group"};
+static const char * const uart1_group[] = {"uart1_group"};
+static const char * const uart2_group[] = {"uart2_group"};
+
+static const char * const pwm0_group[] = {"pwm0_group"};
+static const char * const fan_tach_group[] = {"fan_tach_group"};
+static const char * const mipi_csi0_group[] = {"mipi_csi0_group"};
+static const char * const mipi_csi1_group[] = {"mipi_csi1_group"};
+static const char * const mipi_csi2_group[] = {"mipi_csi2_group"};
+static const char * const mipi_csi3_group[] = {"mipi_csi3_group"};
+static const char * const mipi_csi4_group[] = {"mipi_csi4_group"};
+static const char * const mipi_csi5_group[] = {"mipi_csi5_group"};
+static const char * const spi3_group[] = {"spi3_group"};
+static const char * const i2c8_group[] = {"i2c8_group"};
+static const char * const s_mode_group[] = {"s_mode_group"};
+static const char * const pinmux_ddr_refclk_sel_group[] = {"pinmux_ddr_refclk_sel_group"};
+static const char * const spi0_group[] = {"spi0_group"};
+static const char * const i2c10_group[] = {"i2c10_group"};
+static const char * const i2c11_group[] = {"i2c11_group"};
+static const char * const boot_sel_group[] = {"boot_sel_group"};
+static const char * const lpddr_ref_clk_group[] = {"lpddr_ref_clk_group"};
+
+//func1
+static const char * const spi2_clk_group[] = {"spi2_clk_group"};
+static const char * const spi2_d0_group[] = {"spi2_d0_group"};
+static const char * const spi2_d1_d2_d3_group[] = {"spi2_d1_d2_d3_group"};
+
+static const char * const sata_act_led_group[] = {"sata_act_led_group"};
+static const char * const emmc_led_control_group[] = {"emmc_led_control_group"};
+static const char * const sd0_led_control_group[] = {"sd0_led_control_group"};
+static const char * const i2c9_group[] = {"i2c9_group"};
+static const char * const sd1_led_control_group[] = {"sd1_led_control_group"};
+static const char * const pwm1_group[] = {"pwm1_group"};
+static const char * const pwm2_group[] = {"pwm2_group"};
+static const char * const i2c6_group[] = {"i2c6_group"};
+static const char * const i2c7_group[] = {"i2c7_group"};
+static const char * const mipi_csi_xtrig_group[] = {"mipi_csi_xtrig_group"};
+
+//gpio
+static const char * const gpio0_group[] = {"gpio0_group"};
+static const char * const gpio1_group[] = {"gpio1_group"};
+static const char * const gpio2_group[] = {"gpio2_group"};
+static const char * const gpio3_group[] = {"gpio3_group"};
+static const char * const gpio4_group[] = {"gpio4_group"};
+static const char * const gpio5_group[] = {"gpio5_group"};
+static const char * const gpio6_group[] = {"gpio6_group"};
+static const char * const gpio7_group[] = {"gpio7_group"};
+static const char * const gpio8_group[] = {"gpio8_group"};
+static const char * const gpio9_group[] = {"gpio9_group"};
+static const char * const gpio10_group[] = {"gpio10_group"};
+static const char * const gpio11_group[] = {"gpio11_group"};
+static const char * const gpio12_group[] = {"gpio12_group"};
+static const char * const gpio13_group[] = {"gpio13_group"};
+static const char * const gpio14_group[] = {"gpio14_group"};
+static const char * const gpio15_group[] = {"gpio15_group"};
+static const char * const gpio16_group[] = {"gpio16_group"};
+static const char * const gpio17_group[] = {"gpio17_group"};
+static const char * const gpio18_group[] = {"gpio18_group"};
+static const char * const gpio19_group[] = {"gpio19_group"};
+static const char * const gpio20_group[] = {"gpio20_group"};
+static const char * const gpio21_group[] = {"gpio21_group"};
+static const char * const gpio22_group[] = {"gpio22_group"};
+static const char * const gpio23_group[] = {"gpio23_group"};
+static const char * const gpio24_group[] = {"gpio24_group"};
+static const char * const gpio25_group[] = {"gpio25_group"};
+static const char * const gpio26_group[] = {"gpio26_group"};
+static const char * const gpio27_group[] = {"gpio27_group"};
+static const char * const gpio28_group[] = {"gpio28_group"};
+static const char * const gpio29_group[] = {"gpio29_group"};
+static const char * const gpio30_group[] = {"gpio30_group"};
+static const char * const gpio31_group[] = {"gpio31_group"};
+static const char * const gpio32_group[] = {"gpio32_group"};
+static const char * const gpio33_group[] = {"gpio33_group"};
+static const char * const gpio34_group[] = {"gpio34_group"};
+static const char * const gpio35_group[] = {"gpio35_group"};
+static const char * const gpio36_group[] = {"gpio36_group"};
+static const char * const gpio37_group[] = {"gpio37_group"};
+static const char * const gpio38_group[] = {"gpio38_group"};
+static const char * const gpio39_group[] = {"gpio39_group"};
+static const char * const gpio40_group[] = {"gpio40_group"};
+static const char * const gpio41_group[] = {"gpio41_group"};
+static const char * const gpio42_group[] = {"gpio42_group"};
+static const char * const gpio43_group[] = {"gpio43_group"};
+static const char * const gpio44_group[] = {"gpio44_group"};
+static const char * const gpio45_group[] = {"gpio45_group"};
+static const char * const gpio46_group[] = {"gpio46_group"};
+static const char * const gpio47_group[] = {"gpio47_group"};
+static const char * const gpio48_group[] = {"gpio48_group"};
+static const char * const gpio49_group[] = {"gpio49_group"};
+
+static const char * const gpio50_group[] = {"gpio50_group"};
+static const char * const gpio51_group[] = {"gpio51_group"};
+static const char * const gpio52_group[] = {"gpio52_group"};
+static const char * const gpio53_group[] = {"gpio53_group"};
+static const char * const gpio54_group[] = {"gpio54_group"};
+static const char * const gpio55_group[] = {"gpio55_group"};
+static const char * const gpio56_group[] = {"gpio56_group"};
+static const char * const gpio57_group[] = {"gpio57_group"};
+static const char * const gpio58_group[] = {"gpio58_group"};
+static const char * const gpio59_group[] = {"gpio59_group"};
+
+static const char * const gpio60_group[] = {"gpio60_group"};
+static const char * const gpio61_group[] = {"gpio61_group"};
+static const char * const gpio62_group[] = {"gpio62_group"};
+static const char * const gpio63_group[] = {"gpio63_group"};
+static const char * const gpio64_group[] = {"gpio64_group"};
+static const char * const gpio65_group[] = {"gpio65_group"};
+static const char * const gpio66_group[] = {"gpio66_group"};
+static const char * const gpio67_group[] = {"gpio67_group"};
+static const char * const gpio68_group[] = {"gpio68_group"};
+static const char * const gpio69_group[] = {"gpio69_group"};
+
+static const char * const gpio70_group[] = {"gpio70_group"};
+static const char * const gpio71_group[] = {"gpio71_group"};
+static const char * const gpio72_group[] = {"gpio72_group"};
+static const char * const gpio73_group[] = {"gpio73_group"};
+static const char * const gpio74_group[] = {"gpio74_group"};
+static const char * const gpio75_group[] = {"gpio75_group"};
+static const char * const gpio76_group[] = {"gpio76_group"};
+static const char * const gpio77_group[] = {"gpio77_group"};
+static const char * const gpio78_group[] = {"gpio78_group"};
+static const char * const gpio79_group[] = {"gpio79_group"};
+
+static const char * const gpio80_group[] = {"gpio80_group"};
+static const char * const gpio81_group[] = {"gpio81_group"};
+static const char * const gpio82_group[] = {"gpio82_group"};
+static const char * const gpio83_group[] = {"gpio83_group"};
+static const char * const gpio84_group[] = {"gpio84_group"};
+static const char * const gpio85_group[] = {"gpio85_group"};
+static const char * const gpio86_group[] = {"gpio86_group"};
+static const char * const gpio87_group[] = {"gpio87_group"};
+static const char * const gpio88_group[] = {"gpio88_group"};
+static const char * const gpio89_group[] = {"gpio89_group"};
+
+static const char * const gpio90_group[] = {"gpio90_group"};
+static const char * const gpio91_group[] = {"gpio91_group"};
+static const char * const gpio92_group[] = {"gpio92_group"};
+static const char * const gpio93_group[] = {"gpio93_group"};
+static const char * const gpio94_group[] = {"gpio94_group"};
+static const char * const gpio95_group[] = {"gpio95_group"};
+static const char * const gpio96_group[] = {"gpio96_group"};
+static const char * const gpio97_group[] = {"gpio97_group"};
+static const char * const gpio98_group[] = {"gpio98_group"};
+static const char * const gpio99_group[] = {"gpio99_group"};
+
+static const char * const gpio100_group[] = {"gpio100_group"};
+static const char * const gpio101_group[] = {"gpio101_group"};
+static const char * const gpio102_group[] = {"gpio102_group"};
+static const char * const gpio103_group[] = {"gpio103_group"};
+static const char * const gpio104_group[] = {"gpio104_group"};
+static const char * const gpio105_group[] = {"gpio105_group"};
+static const char * const gpio106_group[] = {"gpio106_group"};
+static const char * const gpio107_group[] = {"gpio107_group"};
+static const char * const gpio108_group[] = {"gpio108_group"};
+static const char * const gpio109_group[] = {"gpio109_group"};
+static const char * const gpio110_group[] = {"gpio110_group"};
+static const char * const gpio111_group[] = {"gpio111_group"};
+
+//func3
+static const char * const uart4_group[] = {"uart4_group"};
+static const char * const uart3_group[] = {"uart3_group"};
+
+//func6
+static const char * const csi_mon_out_group[] = {"csi_mon_out_group"};
+static const char * const csi_ocla_clk_group[] = {"csi_ocla_clk_group"};
+static const char * const csi_mon_out_valid_group[] = {"csi_mon_out_valid_group"};
+static const char * const csi_parity_error_group[] = {"csi_parity_error_group"};
+static const char * const csi_dtb_out_group[] = {"csi_dtb_out_group"};
+static const char * const csi_phy_sel_group[] = {"csi_phy_sel_group"};
+static const char * const vc_g2d0_debug_out_group[] = {"vc_g2d0_debug_out_group"};
+static const char * const vc_g2d1_debug_out_group[] = {"vc_g2d1_debug_out_group"};
+static const char * const sata_mpll_clk_group[] = {"sata_mpll_clk_group"};
+static const char * const sata_ref_repeat_clk_m_group[] = {"sata_ref_repeat_clk_m_group"};
+static const char * const sata_ref_repeat_clk_p_group[] = {"sata_ref_repeat_clk_p_group"};
+
+//func0
+static const unsigned int sdio0_pins[] = {1,2};
+static const unsigned int sdio1_pins[] = {3,4};
+static const unsigned int por_sel_pins[] = {13};
+static const unsigned int jtag0_pins[] = {14,15,16,17};
+static const unsigned int jtag1_pins[] = {20,21,22,23};
+static const unsigned int spi2_cs_pins[] = {19,25};
+static const unsigned int pcie_pins[] = {26,27,28};
+static const unsigned int hdmi_pins[] = {29,30,31};
+static const unsigned int jtag2_pins[] = {32,111,112,113,114};
+static const unsigned int rgmii0_pins[] = {33,34,35,36,37,38,39,45,46,47,48,49,50,58,59,60};
+static const unsigned int i2s0_pins[] = {40,41,42,43,44};
+static const unsigned int i2s1_pins[] = {68,69,70,71,44};
+static const unsigned int i2s2_pins[] = {51,52,53,54,44};
+static const unsigned int por_time_sel0_pins[] = {57};
+static const unsigned int por_time_sel1_pins[] = {72};
+static const unsigned int rgmii1_pins[] = {61,62,63,64,65,66,67,73,74,75,76,77,78,86,87,88};
+static const unsigned int spi1_pins[] = {79,80,81,82,83,84,85};
+static const unsigned int usb0_pwren_pins[] = {89};
+static const unsigned int usb1_pwren_pins[] = {90};
+static const unsigned int i2c0_pins[] = {91,92};
+static const unsigned int i2c1_pins[] = {93,94};
+static const unsigned int i2c2_pins[] = {95,96};
+static const unsigned int i2c3_pins[] = {97,98};
+static const unsigned int i2c4_pins[] = {99,100};
+static const unsigned int i2c5_pins[] = {101,102};
+static const unsigned int uart0_pins[] = {103,104};
+static const unsigned int uart1_pins[] = {105,106,107,108};
+static const unsigned int uart2_pins[] = {109,110};
+static const unsigned int pwm0_pins[] = {115};
+static const unsigned int fan_tach_pins[] = {116};
+static const unsigned int mipi_csi0_pins[] = {117,118,119};
+static const unsigned int mipi_csi1_pins[] = {120,121,122};
+static const unsigned int mipi_csi2_pins[] = {123,124,125};
+static const unsigned int mipi_csi3_pins[] = {126,127,128};
+static const unsigned int mipi_csi4_pins[] = {129,130,131};
+static const unsigned int mipi_csi5_pins[] = {132,133,134};
+static const unsigned int spi3_pins[] = {135,136,137,138};
+static const unsigned int i2c8_pins[] = {139,140};
+static const unsigned int s_mode_pins[] = {141};
+static const unsigned int pinmux_ddr_refclk_sel_pins[] = {142};
+static const unsigned int spi0_pins[] = {143,144,145,146,147,148};
+static const unsigned int i2c10_pins[] = {149,150};
+static const unsigned int i2c11_pins[] = {151,152};
+static const unsigned int boot_sel_pins[] = {154,155,156,157};
+static const unsigned int lpddr_ref_clk_pins[] = {158};
+
+//func1
+static const unsigned int spi2_clk_pins[] = {14};
+static const unsigned int spi2_d0_pins[] = {15};
+static const unsigned int spi2_d1_d2_d3_pins[] = {16,17,18};
+
+static const unsigned int sata_act_led_pins[] = {55};
+static const unsigned int emmc_led_control_pins[] = {57};
+static const unsigned int sd0_led_control_pins[] = {72};
+static const unsigned int i2c9_pins[] = {81,82};
+static const unsigned int sd1_led_control_pins[] = {83};
+static const unsigned int pwm1_pins[] = {84};
+static const unsigned int pwm2_pins[] = {85};
+static const unsigned int i2c6_pins[] = {107,108};
+static const unsigned int i2c7_pins[] = {109,110};
+static const unsigned int mipi_csi_xtrig_pins[] = {139,140};
+
+//gpio
+static const unsigned int gpio0_pins[] = {12};
+static const unsigned int gpio1_pins[] = {14};
+static const unsigned int gpio2_pins[] = {15};
+static const unsigned int gpio3_pins[] = {16};
+static const unsigned int gpio4_pins[] = {17};
+static const unsigned int gpio5_pins[] = {18};
+static const unsigned int gpio6_pins[] = {19};
+static const unsigned int gpio7_pins[] = {20};
+static const unsigned int gpio8_pins[] = {21};
+static const unsigned int gpio9_pins[] = {22};
+
+static const unsigned int gpio10_pins[] = {23};
+static const unsigned int gpio11_pins[] = {24};
+static const unsigned int gpio12_pins[] = {25};
+static const unsigned int gpio13_pins[] = {1};
+static const unsigned int gpio14_pins[] = {2};
+static const unsigned int gpio15_pins[] = {3};
+static const unsigned int gpio16_pins[] = {4};
+static const unsigned int gpio17_pins[] = {32};
+static const unsigned int gpio18_pins[] = {40};
+static const unsigned int gpio19_pins[] = {41};
+
+static const unsigned int gpio20_pins[] = {42};
+static const unsigned int gpio21_pins[] = {43};
+static const unsigned int gpio22_pins[] = {44};
+static const unsigned int gpio23_pins[] = {51};
+static const unsigned int gpio24_pins[] = {52};
+static const unsigned int gpio25_pins[] = {53};
+static const unsigned int gpio26_pins[] = {54};
+static const unsigned int gpio27_pins[] = {55};
+static const unsigned int gpio28_pins[] = {56};
+static const unsigned int gpio29_pins[] = {57};
+
+static const unsigned int gpio30_pins[] = {68};
+static const unsigned int gpio31_pins[] = {69};
+static const unsigned int gpio32_pins[] = {70};
+static const unsigned int gpio33_pins[] = {71};
+static const unsigned int gpio34_pins[] = {72};
+static const unsigned int gpio35_pins[] = {79};
+static const unsigned int gpio36_pins[] = {80};
+static const unsigned int gpio37_pins[] = {81};
+static const unsigned int gpio38_pins[] = {82};
+static const unsigned int gpio39_pins[] = {83};
+
+static const unsigned int gpio40_pins[] = {84};
+static const unsigned int gpio41_pins[] = {85};
+static const unsigned int gpio42_pins[] = {89};
+static const unsigned int gpio43_pins[] = {90};
+static const unsigned int gpio44_pins[] = {91};
+static const unsigned int gpio45_pins[] = {92};
+static const unsigned int gpio46_pins[] = {93};
+static const unsigned int gpio47_pins[] = {94};
+static const unsigned int gpio48_pins[] = {95};
+static const unsigned int gpio49_pins[] = {96};
+
+static const unsigned int gpio50_pins[] = {97};
+static const unsigned int gpio51_pins[] = {98};
+static const unsigned int gpio52_pins[] = {99};
+static const unsigned int gpio53_pins[] = {100};
+static const unsigned int gpio54_pins[] = {101};
+static const unsigned int gpio55_pins[] = {102};
+static const unsigned int gpio56_pins[] = {103};
+static const unsigned int gpio57_pins[] = {104};
+static const unsigned int gpio58_pins[] = {105};
+static const unsigned int gpio59_pins[] = {106};
+
+static const unsigned int gpio60_pins[] = {107};
+static const unsigned int gpio61_pins[] = {108};
+static const unsigned int gpio62_pins[] = {109};
+static const unsigned int gpio63_pins[] = {110};
+static const unsigned int gpio64_pins[] = {111};
+static const unsigned int gpio65_pins[] = {112};
+static const unsigned int gpio66_pins[] = {113};
+static const unsigned int gpio67_pins[] = {114};
+static const unsigned int gpio68_pins[] = {115};
+static const unsigned int gpio69_pins[] = {116};
+
+static const unsigned int gpio70_pins[] = {117};
+static const unsigned int gpio71_pins[] = {118};
+static const unsigned int gpio72_pins[] = {119};
+static const unsigned int gpio73_pins[] = {120};
+static const unsigned int gpio74_pins[] = {121};
+static const unsigned int gpio75_pins[] = {122};
+static const unsigned int gpio76_pins[] = {123};
+static const unsigned int gpio77_pins[] = {124};
+static const unsigned int gpio78_pins[] = {125};
+static const unsigned int gpio79_pins[] = {126};
+
+static const unsigned int gpio80_pins[] = {127};
+static const unsigned int gpio81_pins[] = {128};
+static const unsigned int gpio82_pins[] = {129};
+static const unsigned int gpio83_pins[] = {130};
+static const unsigned int gpio84_pins[] = {131};
+static const unsigned int gpio85_pins[] = {132};
+static const unsigned int gpio86_pins[] = {133};
+static const unsigned int gpio87_pins[] = {134};
+static const unsigned int gpio88_pins[] = {135};
+static const unsigned int gpio89_pins[] = {136};
+
+static const unsigned int gpio90_pins[] = {137};
+static const unsigned int gpio91_pins[] = {138};
+static const unsigned int gpio92_pins[] = {139};
+static const unsigned int gpio93_pins[] = {140};
+static const unsigned int gpio94_pins[] = {141};
+static const unsigned int gpio95_pins[] = {142};
+static const unsigned int gpio96_pins[] = {143};
+static const unsigned int gpio97_pins[] = {144};
+static const unsigned int gpio98_pins[] = {145};
+static const unsigned int gpio99_pins[] = {146};
+
+static const unsigned int gpio100_pins[] = {147};
+static const unsigned int gpio101_pins[] = {148};
+static const unsigned int gpio102_pins[] = {149};
+static const unsigned int gpio103_pins[] = {150};
+static const unsigned int gpio104_pins[] = {151};
+static const unsigned int gpio105_pins[] = {152};
+static const unsigned int gpio106_pins[] = {153};
+static const unsigned int gpio107_pins[] = {154};
+static const unsigned int gpio108_pins[] = {155};
+static const unsigned int gpio109_pins[] = {156};
+static const unsigned int gpio110_pins[] = {157};
+static const unsigned int gpio111_pins[] = {158};
+
+//func3
+static const unsigned int uart4_pins[] = {81,82};
+static const unsigned int uart3_pins[] = {139,140};
+
+//func6
+static const unsigned int csi_mon_out_pins[] = {32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55};
+static const unsigned int csi_ocla_clk_pins[] = {96};
+static const unsigned int csi_mon_out_valid_pins[] = {97};
+static const unsigned int csi_parity_error_pins[] = {98};
+static const unsigned int csi_dtb_out_pins[] = {99,100,101,102,129,130,131,132};
+static const unsigned int csi_phy_sel_pins[] = {133,134,109};
+static const unsigned int vc_g2d0_debug_out_pins[] = {110,111,112,113,114,115,116,117};
+static const unsigned int vc_g2d1_debug_out_pins[] = {118,119,120,121,122,123,124,125};
+static const unsigned int sata_mpll_clk_pins[] = {126};
+static const unsigned int sata_ref_repeat_clk_m_pins[] = {127};
+static const unsigned int sata_ref_repeat_clk_p_pins[] = {128};
+
+static const struct eswin_group_desc eswin_pinctrl_groups[] =
+{
+	//func0
+	ESWIN_PINCTRL_GRP(sdio0),
+	ESWIN_PINCTRL_GRP(sdio1),
+	ESWIN_PINCTRL_GRP(por_sel),
+	ESWIN_PINCTRL_GRP(jtag0),
+	ESWIN_PINCTRL_GRP(jtag1),
+	ESWIN_PINCTRL_GRP(spi2_cs),
+	ESWIN_PINCTRL_GRP(pcie),
+	ESWIN_PINCTRL_GRP(hdmi),
+	ESWIN_PINCTRL_GRP(jtag2),
+	ESWIN_PINCTRL_GRP(rgmii0),
+	ESWIN_PINCTRL_GRP(i2s0),
+	ESWIN_PINCTRL_GRP(i2s1),
+	ESWIN_PINCTRL_GRP(i2s2),
+	ESWIN_PINCTRL_GRP(por_time_sel0),
+	ESWIN_PINCTRL_GRP(por_time_sel1),
+	ESWIN_PINCTRL_GRP(rgmii1),
+	ESWIN_PINCTRL_GRP(spi1),
+	ESWIN_PINCTRL_GRP(usb0_pwren),
+	ESWIN_PINCTRL_GRP(usb1_pwren),
+	ESWIN_PINCTRL_GRP(i2c0),
+	ESWIN_PINCTRL_GRP(i2c1),
+	ESWIN_PINCTRL_GRP(i2c2),
+	ESWIN_PINCTRL_GRP(i2c3),
+	ESWIN_PINCTRL_GRP(i2c4),
+	ESWIN_PINCTRL_GRP(i2c5),
+	ESWIN_PINCTRL_GRP(uart0),
+	ESWIN_PINCTRL_GRP(uart1),
+	ESWIN_PINCTRL_GRP(uart2),
+	ESWIN_PINCTRL_GRP(pwm0),
+	ESWIN_PINCTRL_GRP(fan_tach),
+	ESWIN_PINCTRL_GRP(mipi_csi0),
+	ESWIN_PINCTRL_GRP(mipi_csi1),
+	ESWIN_PINCTRL_GRP(mipi_csi2),
+	ESWIN_PINCTRL_GRP(mipi_csi3),
+	ESWIN_PINCTRL_GRP(mipi_csi4),
+	ESWIN_PINCTRL_GRP(mipi_csi5),
+	ESWIN_PINCTRL_GRP(spi3),
+	ESWIN_PINCTRL_GRP(i2c8),
+	ESWIN_PINCTRL_GRP(s_mode),
+	ESWIN_PINCTRL_GRP(pinmux_ddr_refclk_sel),
+	ESWIN_PINCTRL_GRP(spi0),
+	ESWIN_PINCTRL_GRP(i2c10),
+	ESWIN_PINCTRL_GRP(i2c11),
+	ESWIN_PINCTRL_GRP(boot_sel),
+	ESWIN_PINCTRL_GRP(lpddr_ref_clk),
+
+	//func1
+	ESWIN_PINCTRL_GRP(spi2_clk),
+	ESWIN_PINCTRL_GRP(spi2_d0),
+	ESWIN_PINCTRL_GRP(spi2_d1_d2_d3),
+
+	ESWIN_PINCTRL_GRP(sata_act_led),
+	ESWIN_PINCTRL_GRP(emmc_led_control),
+	ESWIN_PINCTRL_GRP(sd0_led_control),
+	ESWIN_PINCTRL_GRP(i2c9),
+	ESWIN_PINCTRL_GRP(sd1_led_control),
+	ESWIN_PINCTRL_GRP(pwm1),
+	ESWIN_PINCTRL_GRP(pwm2),
+	ESWIN_PINCTRL_GRP(i2c6),
+	ESWIN_PINCTRL_GRP(i2c7),
+	ESWIN_PINCTRL_GRP(mipi_csi_xtrig),
+
+	//gpio
+	ESWIN_PINCTRL_GRP(gpio0),
+	ESWIN_PINCTRL_GRP(gpio1),
+	ESWIN_PINCTRL_GRP(gpio2),
+	ESWIN_PINCTRL_GRP(gpio3),
+	ESWIN_PINCTRL_GRP(gpio4),
+	ESWIN_PINCTRL_GRP(gpio5),
+	ESWIN_PINCTRL_GRP(gpio6),
+	ESWIN_PINCTRL_GRP(gpio7),
+	ESWIN_PINCTRL_GRP(gpio8),
+	ESWIN_PINCTRL_GRP(gpio9),
+	ESWIN_PINCTRL_GRP(gpio10),
+	ESWIN_PINCTRL_GRP(gpio11),
+	ESWIN_PINCTRL_GRP(gpio12),
+	ESWIN_PINCTRL_GRP(gpio13),
+	ESWIN_PINCTRL_GRP(gpio14),
+	ESWIN_PINCTRL_GRP(gpio15),
+	ESWIN_PINCTRL_GRP(gpio16),
+	ESWIN_PINCTRL_GRP(gpio17),
+	ESWIN_PINCTRL_GRP(gpio18),
+	ESWIN_PINCTRL_GRP(gpio19),
+	ESWIN_PINCTRL_GRP(gpio20),
+	ESWIN_PINCTRL_GRP(gpio21),
+	ESWIN_PINCTRL_GRP(gpio22),
+	ESWIN_PINCTRL_GRP(gpio23),
+	ESWIN_PINCTRL_GRP(gpio24),
+	ESWIN_PINCTRL_GRP(gpio25),
+	ESWIN_PINCTRL_GRP(gpio26),
+	ESWIN_PINCTRL_GRP(gpio27),
+	ESWIN_PINCTRL_GRP(gpio28),
+	ESWIN_PINCTRL_GRP(gpio29),
+	ESWIN_PINCTRL_GRP(gpio30),
+	ESWIN_PINCTRL_GRP(gpio31),
+	ESWIN_PINCTRL_GRP(gpio32),
+	ESWIN_PINCTRL_GRP(gpio33),
+	ESWIN_PINCTRL_GRP(gpio34),
+	ESWIN_PINCTRL_GRP(gpio35),
+	ESWIN_PINCTRL_GRP(gpio36),
+	ESWIN_PINCTRL_GRP(gpio37),
+	ESWIN_PINCTRL_GRP(gpio38),
+	ESWIN_PINCTRL_GRP(gpio39),
+	ESWIN_PINCTRL_GRP(gpio40),
+	ESWIN_PINCTRL_GRP(gpio41),
+	ESWIN_PINCTRL_GRP(gpio42),
+	ESWIN_PINCTRL_GRP(gpio43),
+	ESWIN_PINCTRL_GRP(gpio44),
+	ESWIN_PINCTRL_GRP(gpio45),
+	ESWIN_PINCTRL_GRP(gpio46),
+	ESWIN_PINCTRL_GRP(gpio47),
+	ESWIN_PINCTRL_GRP(gpio48),
+	ESWIN_PINCTRL_GRP(gpio49),
+
+	ESWIN_PINCTRL_GRP(gpio50),
+	ESWIN_PINCTRL_GRP(gpio51),
+	ESWIN_PINCTRL_GRP(gpio52),
+	ESWIN_PINCTRL_GRP(gpio53),
+	ESWIN_PINCTRL_GRP(gpio54),
+	ESWIN_PINCTRL_GRP(gpio55),
+	ESWIN_PINCTRL_GRP(gpio56),
+	ESWIN_PINCTRL_GRP(gpio57),
+	ESWIN_PINCTRL_GRP(gpio58),
+	ESWIN_PINCTRL_GRP(gpio59),
+
+	ESWIN_PINCTRL_GRP(gpio60),
+	ESWIN_PINCTRL_GRP(gpio61),
+	ESWIN_PINCTRL_GRP(gpio62),
+	ESWIN_PINCTRL_GRP(gpio63),
+	ESWIN_PINCTRL_GRP(gpio64),
+	ESWIN_PINCTRL_GRP(gpio65),
+	ESWIN_PINCTRL_GRP(gpio66),
+	ESWIN_PINCTRL_GRP(gpio67),
+	ESWIN_PINCTRL_GRP(gpio68),
+	ESWIN_PINCTRL_GRP(gpio69),
+
+	ESWIN_PINCTRL_GRP(gpio70),
+	ESWIN_PINCTRL_GRP(gpio71),
+	ESWIN_PINCTRL_GRP(gpio72),
+	ESWIN_PINCTRL_GRP(gpio73),
+	ESWIN_PINCTRL_GRP(gpio74),
+	ESWIN_PINCTRL_GRP(gpio75),
+	ESWIN_PINCTRL_GRP(gpio76),
+	ESWIN_PINCTRL_GRP(gpio77),
+	ESWIN_PINCTRL_GRP(gpio78),
+	ESWIN_PINCTRL_GRP(gpio79),
+
+	ESWIN_PINCTRL_GRP(gpio80),
+	ESWIN_PINCTRL_GRP(gpio81),
+	ESWIN_PINCTRL_GRP(gpio82),
+	ESWIN_PINCTRL_GRP(gpio83),
+	ESWIN_PINCTRL_GRP(gpio84),
+	ESWIN_PINCTRL_GRP(gpio85),
+	ESWIN_PINCTRL_GRP(gpio86),
+	ESWIN_PINCTRL_GRP(gpio87),
+	ESWIN_PINCTRL_GRP(gpio88),
+	ESWIN_PINCTRL_GRP(gpio89),
+
+	ESWIN_PINCTRL_GRP(gpio90),
+	ESWIN_PINCTRL_GRP(gpio91),
+	ESWIN_PINCTRL_GRP(gpio92),
+	ESWIN_PINCTRL_GRP(gpio93),
+	ESWIN_PINCTRL_GRP(gpio94),
+	ESWIN_PINCTRL_GRP(gpio95),
+	ESWIN_PINCTRL_GRP(gpio96),
+	ESWIN_PINCTRL_GRP(gpio97),
+	ESWIN_PINCTRL_GRP(gpio98),
+	ESWIN_PINCTRL_GRP(gpio99),
+
+	ESWIN_PINCTRL_GRP(gpio100),
+	ESWIN_PINCTRL_GRP(gpio101),
+	ESWIN_PINCTRL_GRP(gpio102),
+	ESWIN_PINCTRL_GRP(gpio103),
+	ESWIN_PINCTRL_GRP(gpio104),
+	ESWIN_PINCTRL_GRP(gpio105),
+	ESWIN_PINCTRL_GRP(gpio106),
+	ESWIN_PINCTRL_GRP(gpio107),
+	ESWIN_PINCTRL_GRP(gpio108),
+	ESWIN_PINCTRL_GRP(gpio109),
+	ESWIN_PINCTRL_GRP(gpio110),
+	ESWIN_PINCTRL_GRP(gpio111),
+
+	//func3
+	ESWIN_PINCTRL_GRP(uart4),
+	ESWIN_PINCTRL_GRP(uart3),
+
+	//func6
+	ESWIN_PINCTRL_GRP(csi_mon_out),
+	ESWIN_PINCTRL_GRP(csi_ocla_clk),
+	ESWIN_PINCTRL_GRP(csi_mon_out_valid),
+	ESWIN_PINCTRL_GRP(csi_parity_error),
+	ESWIN_PINCTRL_GRP(csi_dtb_out),
+	ESWIN_PINCTRL_GRP(csi_phy_sel),
+	ESWIN_PINCTRL_GRP(vc_g2d0_debug_out),
+	ESWIN_PINCTRL_GRP(vc_g2d1_debug_out),
+	ESWIN_PINCTRL_GRP(sata_mpll_clk),
+	ESWIN_PINCTRL_GRP(sata_ref_repeat_clk_m),
+	ESWIN_PINCTRL_GRP(sata_ref_repeat_clk_p),
+};
+
+#define ESWIN_PINMUX_FUNCTION(_func_name, _mux_val, _mask)\
+	{				   \
+		.name = #_func_name"_func",			 \
+		.groups = _func_name##_group,	  \
+		.ngroups = ARRAY_SIZE(_func_name##_group),  \
+		.mux_val = _mux_val,			\
+		.mux_mask = _mask,		  \
+	}
+
+#define ESWIN_PINMUX_SHIFT  16
+#define ESWIN_PINMUX_MASK   (0x07 << ESWIN_PINMUX_SHIFT)
+
+static const struct eswin_function_desc eswin_pinmux_functions[] = {
+
+	//func0
+	ESWIN_PINMUX_FUNCTION(sdio0, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(sdio1, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(por_sel, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(jtag0, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(jtag1, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(spi2_cs, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(pcie, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(hdmi, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(jtag2, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(rgmii0, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2s0, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2s1, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2s2, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(por_time_sel0, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(por_time_sel1, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(rgmii1, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(spi1, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(usb0_pwren, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(usb1_pwren, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c0, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c1, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c2, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c3, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c4, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c5, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(uart0, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(uart1, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(uart2, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(pwm0, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(fan_tach, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(mipi_csi0, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(mipi_csi1, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(mipi_csi2, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(mipi_csi3, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(mipi_csi4, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(mipi_csi5, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(spi3, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c8, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(s_mode, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(pinmux_ddr_refclk_sel, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(spi0, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c10, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c11, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(boot_sel, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(lpddr_ref_clk, 0, ESWIN_PINMUX_MASK),
+
+	//func1
+	ESWIN_PINMUX_FUNCTION(spi2_clk, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(spi2_d0, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(spi2_d1_d2_d3, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(sata_act_led, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(emmc_led_control, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(sd0_led_control, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c9, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(sd1_led_control, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(pwm1, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(pwm2, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c6, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(i2c7, 1, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(mipi_csi_xtrig, 1, ESWIN_PINMUX_MASK),
+
+	//gpio
+	ESWIN_PINMUX_FUNCTION(gpio0, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio1, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio2, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio3, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio4, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio5, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio6, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio7, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio8, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio9, 2, ESWIN_PINMUX_MASK),
+
+	ESWIN_PINMUX_FUNCTION(gpio10, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio11, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio12, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio13, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio14, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio15, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio16, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio17, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio18, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio19, 2, ESWIN_PINMUX_MASK),
+
+	ESWIN_PINMUX_FUNCTION(gpio20, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio21, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio22, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio23, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio24, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio25, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio26, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio27, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio28, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio29, 2, ESWIN_PINMUX_MASK),
+
+	ESWIN_PINMUX_FUNCTION(gpio30, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio31, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio32, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio33, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio34, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio35, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio36, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio37, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio38, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio39, 2, ESWIN_PINMUX_MASK),
+
+	ESWIN_PINMUX_FUNCTION(gpio40, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio41, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio42, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio43, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio44, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio45, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio46, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio47, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio48, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio49, 2, ESWIN_PINMUX_MASK),
+
+	ESWIN_PINMUX_FUNCTION(gpio50, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio51, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio52, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio53, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio54, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio55, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio56, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio57, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio58, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio59, 2, ESWIN_PINMUX_MASK),
+
+	ESWIN_PINMUX_FUNCTION(gpio60, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio61, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio62, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio63, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio64, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio65, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio66, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio67, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio68, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio69, 2, ESWIN_PINMUX_MASK),
+
+	ESWIN_PINMUX_FUNCTION(gpio70, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio71, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio72, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio73, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio74, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio75, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio76, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio77, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio78, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio79, 2, ESWIN_PINMUX_MASK),
+
+	ESWIN_PINMUX_FUNCTION(gpio80, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio81, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio82, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio83, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio84, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio85, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio86, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio87, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio88, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio89, 2, ESWIN_PINMUX_MASK),
+
+	ESWIN_PINMUX_FUNCTION(gpio90, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio91, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio92, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio93, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio94, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio95, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio96, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio97, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio98, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio99, 2, ESWIN_PINMUX_MASK),
+
+	ESWIN_PINMUX_FUNCTION(gpio100, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio101, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio102, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio103, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio104, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio105, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio106, 0, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio107, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio108, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio109, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio110, 2, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(gpio111, 0, ESWIN_PINMUX_MASK),
+
+	//func3
+	ESWIN_PINMUX_FUNCTION(uart4, 3, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(uart3, 3, ESWIN_PINMUX_MASK),
+
+	//func6
+	ESWIN_PINMUX_FUNCTION(csi_mon_out, 6, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(csi_ocla_clk, 6, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(csi_mon_out_valid, 6, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(csi_parity_error, 6, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(csi_dtb_out, 6, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(csi_phy_sel, 6, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(vc_g2d0_debug_out, 6, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(vc_g2d1_debug_out, 6, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(sata_mpll_clk, 6, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(sata_ref_repeat_clk_m, 6, ESWIN_PINMUX_MASK),
+	ESWIN_PINMUX_FUNCTION(sata_ref_repeat_clk_p, 6, ESWIN_PINMUX_MASK),
+};
+
+/* pinctrl */
+static int eswin_pctrl_get_groups_count(struct pinctrl_dev *pctldev)
+{
+	struct eswin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
+	return pctrl->ngroups;
+}
+
+static const char *eswin_pctrl_get_group_name(struct pinctrl_dev *pctldev,
+						 unsigned int selector)
+{
+	struct eswin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
+	return pctrl->groups[selector].name;
+}
+
+static int eswin_pctrl_get_group_pins(struct pinctrl_dev *pctldev,
+					 unsigned int selector,
+					 const unsigned int **pins,
+					 unsigned int *num_pins)
+{
+	struct eswin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
+	*pins = pctrl->groups[selector].pins;
+	*num_pins = pctrl->groups[selector].npins;
+	return 0;
+}
+
+static const struct pinctrl_ops eswin_pinctrl_ops = {
+	.get_groups_count = eswin_pctrl_get_groups_count,
+	.get_group_name = eswin_pctrl_get_group_name,
+	.get_group_pins = eswin_pctrl_get_group_pins,
+	.dt_node_to_map = pinconf_generic_dt_node_to_map_all,
+	.dt_free_map = pinctrl_utils_free_map,
+};
+
+/* pinmux */
+static int eswin_pmux_get_functions_count(struct pinctrl_dev *pctldev)
+{
+	struct eswin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
+
+	return pctrl->nfuncs;
+}
+
+static const char *eswin_pmux_get_function_name(struct pinctrl_dev *pctldev,
+						   unsigned int selector)
+{
+	struct eswin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
+
+	return pctrl->funcs[selector].name;
+}
+
+static int eswin_pmux_get_function_groups(struct pinctrl_dev *pctldev,
+					 unsigned int selector,
+					 const char * const **groups,
+					 unsigned * const num_groups)
+{
+	struct eswin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
+	*groups = pctrl->funcs[selector].groups;
+	*num_groups = pctrl->funcs[selector].ngroups;
+	return 0;
+}
+
+static int eswin_pinmux_set_mux(struct pinctrl_dev *pctldev,
+				   unsigned int function,
+				   unsigned int  group)
+{
+	int i ;
+	struct eswin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
+	const struct eswin_group_desc *pgrp = &pctrl->groups[group];
+	const struct eswin_function_desc *func = &pctrl->funcs[function];
+
+	for(i = 0 ;i< pgrp->npins;i++){
+		u32 reg ;
+		unsigned int pin = pgrp->pins[i];
+		reg = readl(pctrl->base + 4*pin);
+		reg &= ~ESWIN_PINMUX_MASK;
+		reg |= (func->mux_val << ESWIN_PINMUX_SHIFT);
+		writel(reg,pctrl->base + 4*pin);
+	}
+	return 0;
+}
+
+static const struct pinmux_ops eswin_pinmux_ops = {
+	.get_functions_count = eswin_pmux_get_functions_count,
+	.get_function_name = eswin_pmux_get_function_name,
+	.get_function_groups = eswin_pmux_get_function_groups,
+	.set_mux = eswin_pinmux_set_mux,
+};
+
+/* pinconfig */
+static int eswin_pinconf_cfg_get(struct pinctrl_dev *pctldev,
+		   unsigned pin,
+			  unsigned long *config)
+{
+	u32 reg=0;
+	int ret=0;
+	unsigned int arg = 0;
+	unsigned int param = pinconf_to_config_param(*config);
+	struct eswin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
+
+	if (pin >= ESWIN_MIO_NUM){
+		return -ENOTSUPP;
+	}
+	reg = readl(pctrl->base + 4*pin);
+	if (ret)
+		return -EIO;
+
+	switch (param) {
+	case PIN_CONFIG_BIAS_PULL_UP:
+	if (!(arg=(reg & ESWIN_PINCONF_PULLUP))){
+		return -EINVAL;}
+		break;
+	case PIN_CONFIG_BIAS_PULL_DOWN:
+	if (!(arg = (reg & ESWIN_PINCONF_PULLDOWN))){
+		return -EINVAL;}
+		break;
+	case PIN_CONFIG_DRIVE_STRENGTH:
+	arg = (reg & (ESWIN_PINCONF_DRIVER_STRENGTH_MASK
+						   <<ESWIN_PINCONF_DRIVER_SHIFT));
+		break;
+	case PIN_CONFIG_INPUT_ENABLE:
+	if (!(arg = (reg & ESWIN_PINCONF_IE))){
+		return -EINVAL;}
+	break;
+	case PIN_CONFIG_INPUT_SCHMITT:
+	if (!(arg = (reg & ESWIN_PINCONF_SMT))){
+		return -EINVAL;}
+	break;
+	default:
+	return -ENOTSUPP;
+	}
+	*config = pinconf_to_config_packed(param, arg);
+	return 0;
+}
+
+int eswin_pinconf_cfg_set(struct pinctrl_dev *pctldev,
+			unsigned pin,
+			unsigned long *configs,
+			unsigned num_configs)
+{
+	int i=0, ret=0;
+	u32 reg = 0;
+	struct eswin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
+
+	if (pin >= ESWIN_MIO_NUM)
+		return -ENOTSUPP;
+	reg = readl(pctrl->base + 4*pin);
+
+	if (ret)
+		return -EIO;
+
+	for (i = 0; i < num_configs; i++) {
+		unsigned int param = pinconf_to_config_param(configs[i]);
+		unsigned int arg = pinconf_to_config_argument(configs[i]);
+
+		switch (param) {
+			case PIN_CONFIG_INPUT_ENABLE:
+				reg &=~ESWIN_PINCONF_IE;
+				reg |= (arg<<0);
+				break;
+			case PIN_CONFIG_BIAS_PULL_UP:
+				reg &=~ESWIN_PINCONF_PULLUP;
+				reg |= (arg<<1);
+				break;
+			case PIN_CONFIG_BIAS_PULL_DOWN:
+				reg &=~ESWIN_PINCONF_PULLDOWN;
+				reg |= (arg<<2);
+				break;
+			case PIN_CONFIG_DRIVE_STRENGTH:
+				reg &= ~(ESWIN_PINCONF_DRIVER_STRENGTH_MASK<<3);
+				reg |= (arg<<3);
+				break;
+			case PIN_CONFIG_INPUT_SCHMITT:
+				reg &= ~ESWIN_PINCONF_SMT;
+				reg |= (arg<<7);
+				break;
+			default:
+				dev_warn(pctldev->dev,
+					"unsupported configuration parameter '%u'\n",
+					param);
+				continue;
+		}
+
+
+	}
+		writel(reg,pctrl->base + 4*pin);
+
+	if (ret)
+		return -EIO;
+	return 0;
+}
+
+static int eswin_pinconf_group_set(struct pinctrl_dev *pctldev,
+			unsigned selector,
+			unsigned long *configs,
+			unsigned num_configs)
+
+{
+	int i=0, ret=0;
+	struct eswin_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
+	const struct eswin_group_desc *pgrp = &pctrl->groups[selector];
+
+	for (i = 0; i < pgrp->npins; i++) {
+		ret = eswin_pinconf_cfg_set(pctldev, pgrp->pins[i], configs,
+					 num_configs);
+	if (ret)
+		  return ret;
+	}
+	return 0;
+}
+
+static const struct pinconf_ops eswin_pinconf_ops = {
+	.is_generic = true,
+	.pin_config_get = eswin_pinconf_cfg_get,
+	.pin_config_set = eswin_pinconf_cfg_set,
+	.pin_config_group_set = eswin_pinconf_group_set,
+};
+
+static struct pinctrl_desc eswin_desc = {
+	.name = "eswin_pinctrl",
+	.pins = eswin_pins,
+	.npins = ARRAY_SIZE(eswin_pins),
+	.pctlops = &eswin_pinctrl_ops,
+	.pmxops = &eswin_pinmux_ops,
+	.confops = &eswin_pinconf_ops,
+	.owner = THIS_MODULE,
+};
+
+static int eswin_pinctrl_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct eswin_pinctrl *pctrl;
+	pctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);
+	if (!pctrl)
+		return -ENOMEM;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+	pctrl->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(pctrl->base))
+		return PTR_ERR(pctrl->base);
+
+	pctrl->groups = eswin_pinctrl_groups;
+	pctrl->ngroups = ARRAY_SIZE(eswin_pinctrl_groups);
+	pctrl->funcs = eswin_pinmux_functions;
+	pctrl->nfuncs = ARRAY_SIZE(eswin_pinmux_functions);
+
+	pctrl->pctrl = devm_pinctrl_register(&pdev->dev, &eswin_desc, pctrl);
+	if (IS_ERR(pctrl->pctrl)){
+		return PTR_ERR(pctrl->pctrl);
+	}
+
+	platform_set_drvdata(pdev, pctrl);
+
+	dev_info(&pdev->dev, "eswin pinctrl initialized\n");
+
+	return 0;
+}
+
+static int eswin_pinctrl_remove(struct platform_device *platform_dev)
+{
+	struct eswin_pinctrl *eswin_pinctrl_ptr = platform_get_drvdata(platform_dev);
+	pinctrl_unregister(eswin_pinctrl_ptr->pctrl);
+	return 0;
+}
+
+static const struct of_device_id eswin_pinctrl_of_match[] = {
+	{ .compatible = "eswin,eic7700-pinctrl" },
+	{ }
+};
+
+static struct platform_driver eswin_pinctrl_driver = {
+	.driver = {
+		.name = "eswin-pinctrl",
+		.of_match_table = eswin_pinctrl_of_match,
+	},
+	.probe = eswin_pinctrl_probe,
+	.remove = eswin_pinctrl_remove,
+};
+
+static int __init eswin_pinctrl_init(void)
+{
+	return platform_driver_register(&eswin_pinctrl_driver);
+}
+postcore_initcall(eswin_pinctrl_init);
+
+static void __exit eswin_pinctrl_exit(void)
+{
+	platform_driver_unregister(&eswin_pinctrl_driver);
+}
+module_exit(eswin_pinctrl_exit);
+
+MODULE_DESCRIPTION("ESWIN Pinctrl Controller Platform Device Drivers");
+MODULE_AUTHOR("luyulin@eswincomputing.com");
+MODULE_LICENSE("GPL");
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index 8ebcddf91f7b..a7c9ac6c7870 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -205,6 +205,12 @@ config PWM_EP93XX
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-ep93xx.
 
+config PWM_ESWIN
+	tristate "ESWIN PWM support"
+	help
+	  Generic PWM framework driver for the PWM controller found on
+	  ESWIN SoCs.
+
 config PWM_FSL_FTM
 	tristate "Freescale FlexTimer Module (FTM) PWM support"
 	depends on HAS_IOMEM
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index c822389c2a24..f3619959f508 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_PWM_CRC)		+= pwm-crc.o
 obj-$(CONFIG_PWM_CROS_EC)	+= pwm-cros-ec.o
 obj-$(CONFIG_PWM_DWC)		+= pwm-dwc.o
 obj-$(CONFIG_PWM_EP93XX)	+= pwm-ep93xx.o
+obj-$(CONFIG_PWM_ESWIN)	+= pwm-eswin.o
 obj-$(CONFIG_PWM_FSL_FTM)	+= pwm-fsl-ftm.o
 obj-$(CONFIG_PWM_HIBVT)		+= pwm-hibvt.o
 obj-$(CONFIG_PWM_IMG)		+= pwm-img.o
diff --git a/drivers/pwm/pwm-eswin.c b/drivers/pwm/pwm-eswin.c
new file mode 100644
index 000000000000..1d15a3e06c8b
--- /dev/null
+++ b/drivers/pwm/pwm-eswin.c
@@ -0,0 +1,326 @@
+/*
+ * Copyright (c) 2022, ESWIN, Inc.
+ * Author: zhangchunyun@eswincomputing.com
+ */
+
+#include <linux/bitops.h>
+#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/pm_runtime.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/time.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/pinctrl/pinmux.h>
+#include <linux/pinctrl/pinconf.h>
+#include <linux/pinctrl/pinconf-generic.h>
+
+#define ESWIN_TIM_LD_CNT(n)   ((n) * 0x14)
+#define ESWIN_TIM_LD_CNT2(n)  (((n) * 4) + 0xb0)
+#define ESWIN_TIM_CUR_VAL(n)  (((n) * 0x14) + 0x04)
+#define ESWIN_TIM_CTRL(n)     (((n) * 0x14) + 0x08)
+#define ESWIN_TIM_EOI(n)      (((n) * 0x14) + 0x0c)
+#define ESWIN_TIM_INT_STS(n)  (((n) * 0x14) + 0x10)
+
+#define ESWIN_TIMERS_INT_STS  0xa0
+#define ESWIN_TIMERS_EOI      0xa4
+#define ESWIN_TIMERS_RAW_INT_STS  0xa8
+#define ESWIN_TIMERS_COMP_VERSION 0xac
+
+#define ESWIN_TIMERS_TOTAL    8
+#define NSEC_TO_SEC	1000000000
+
+/* Timer Control Register */
+#define ESWIN_TIM_CTRL_EN     BIT(0)
+#define ESWIN_TIM_CTRL_MODE   BIT(1)
+#define ESWIN_TIM_CTRL_MODE_FREE  (0 << 1)
+#define ESWIN_TIM_CTRL_MODE_USER  (1 << 1)
+#define ESWIN_TIM_CTRL_INT_MASK   BIT(2)
+#define ESWIN_TIM_CTRL_PWM    BIT(3)
+
+struct eswin_pwm_ctx {
+	u32 cnt;
+	u32 cnt2;
+	u32 ctrl;
+};
+
+struct eswin_pwm {
+	struct pwm_chip chip;
+	void __iomem *base;
+	struct clk *clk;
+	struct clk *pclk;
+	struct eswin_pwm_ctx ctx[ESWIN_TIMERS_TOTAL];
+	struct reset_control * pwm_rst;
+	u32 clk_period_ns;
+};
+
+#define to_eswin_pwm(p)   (container_of((p), struct eswin_pwm, chip))
+
+static inline u32 eswin_pwm_readl(struct eswin_pwm *eswin, u32 offset)
+{
+	return readl(eswin->base + offset);
+}
+
+static inline void eswin_pwm_writel(struct eswin_pwm *eswin, u32 value, u32 offset)
+{
+	writel(value, eswin->base + offset);
+}
+
+static void __eswin_pwm_set_enable(struct eswin_pwm *eswin, int pwm, int enabled)
+{
+	u32 reg;
+
+	reg = eswin_pwm_readl(eswin, ESWIN_TIM_CTRL(pwm));
+
+	if (enabled)
+		reg |= ESWIN_TIM_CTRL_EN;
+	else
+		reg &= ~ESWIN_TIM_CTRL_EN;
+
+	eswin_pwm_writel(eswin, reg, ESWIN_TIM_CTRL(pwm));
+	reg = eswin_pwm_readl(eswin, ESWIN_TIM_CTRL(pwm));
+}
+
+static int __eswin_pwm_configure_timer(struct eswin_pwm *eswin,
+       struct pwm_device *pwm,
+       const struct pwm_state *state)
+{
+	u64 tmp;
+	u32 ctrl;
+	u32 high;
+	u32 low;
+
+	/*
+	¦* Calculate width of low and high period in terms of input clock
+	¦* periods and check are the result within HW limits between 1 and
+	¦* 2^32 periods.
+	¦*/
+
+	tmp = DIV_ROUND_CLOSEST_ULL(state->duty_cycle, eswin->clk_period_ns);
+	if (tmp < 1 || tmp > (1ULL << 32))
+              return -ERANGE;
+	high = tmp - 1;
+
+	tmp = DIV_ROUND_CLOSEST_ULL(state->period - state->duty_cycle,
+         eswin->clk_period_ns);
+	if (tmp < 1 || tmp > (1ULL << 32))
+        return -ERANGE;
+	low = tmp - 1;
+	/*
+	¦* Specification says timer usage flow is to disable timer, then
+	¦* program it followed by enable. It also says Load Count is loaded
+	¦* into timer after it is enabled - either after a disable or
+	¦* a reset. Based on measurements it happens also without disable
+	¦* whenever Load Count is updated. But follow the specification.
+	¦*/
+	__eswin_pwm_set_enable(eswin, pwm->hwpwm, false);
+
+	/*
+	¦* Write Load Count and Load Count 2 registers. Former defines the
+	¦* width of low period and latter the width of high period in terms
+	¦* multiple of input clock periods:
+	¦* Width = ((Count + 1) * input clock period).
+	¦*/
+	eswin_pwm_writel(eswin, low, ESWIN_TIM_LD_CNT(pwm->hwpwm));
+	eswin_pwm_writel(eswin, high, ESWIN_TIM_LD_CNT2(pwm->hwpwm));
+
+	/*
+	¦* Set user-defined mode, timer reloads from Load Count registers
+	¦* when it counts down to 0.
+	¦* Set PWM mode, it makes output to toggle and width of low and high
+	¦* periods are set by Load Count registers.
+	¦*/
+	ctrl = ESWIN_TIM_CTRL_MODE_USER | ESWIN_TIM_CTRL_PWM;
+	eswin_pwm_writel(eswin, ctrl, ESWIN_TIM_CTRL(pwm->hwpwm));
+
+	/*
+	¦* Enable timer. Output starts from low period.
+	¦*/
+	__eswin_pwm_set_enable(eswin, pwm->hwpwm, state->enabled);
+
+	return 0;
+}
+
+static int eswin_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
+	const struct pwm_state *state)
+{
+	struct eswin_pwm *eswin = to_eswin_pwm(chip);
+	struct pwm_state curstate;
+	int ret = 0;
+
+	ret = clk_enable(eswin->pclk);
+
+	ret = clk_enable(eswin->clk);
+
+	pwm_get_state(pwm, &curstate);
+
+	__eswin_pwm_configure_timer(eswin, pwm, state);
+
+	return 0;
+}
+
+static int eswin_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,
+	struct pwm_state *state)
+{
+	struct eswin_pwm *eswin = to_eswin_pwm(chip);
+	u64 duty, period;
+
+	pm_runtime_get_sync(chip->dev);
+
+	state->enabled = !!(eswin_pwm_readl(eswin,
+		ESWIN_TIM_CTRL(pwm->hwpwm)) & ESWIN_TIM_CTRL_EN);
+
+	duty = eswin_pwm_readl(eswin, ESWIN_TIM_LD_CNT(pwm->hwpwm));
+	duty += 1;
+	duty *= eswin->clk_period_ns;
+	state->duty_cycle = duty;
+
+	period = eswin_pwm_readl(eswin, ESWIN_TIM_LD_CNT2(pwm->hwpwm));
+	period += 1;
+	period *= eswin->clk_period_ns;
+	period += duty;
+	state->period = period;
+
+	state->polarity = PWM_POLARITY_INVERSED;
+
+	pm_runtime_put_sync(chip->dev);
+
+	return 0;
+}
+
+
+static const struct pwm_ops eswin_pwm_ops = {
+	.get_state = eswin_pwm_get_state,
+	.apply = eswin_pwm_apply,
+	.owner = THIS_MODULE,
+};
+
+static const struct of_device_id eswin_pwm_dt_ids[] = {
+	{ .compatible = "eswin,pwm-eswin", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, eswin_pwm_dt_ids);
+
+static int eswin_pwm_probe(struct platform_device *pdev)
+{
+	struct eswin_pwm *pc;
+	int ret, count;
+	struct resource *res;
+	int clk_rate;
+
+	pc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);
+	if (!pc)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENODEV;
+
+	pc->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(pc->base))
+		return PTR_ERR(pc->base);
+
+	pc->clk = devm_clk_get(&pdev->dev, "pwm");
+	if (IS_ERR(pc->clk)) {
+		pc->clk = devm_clk_get(&pdev->dev, "pclk");
+        if (IS_ERR(pc->clk))
+			return dev_err_probe(&pdev->dev, PTR_ERR(pc->clk),
+                    "Can't get PWM clk\n");
+	}
+
+	count = of_count_phandle_with_args(pdev->dev.of_node,
+                      "clocks", "#clock-cells");
+	if (count == 2)
+		pc->pclk = devm_clk_get(&pdev->dev, "pclk");
+	else
+		pc->pclk = pc->clk;
+
+	if (IS_ERR(pc->pclk)) {
+		ret = PTR_ERR(pc->pclk);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Can't get APB clk: %d\n", ret);
+		return ret;
+	}
+
+	clk_rate = clk_get_rate(pc->pclk);
+	pc->clk_period_ns = DIV_ROUND_CLOSEST_ULL(NSEC_TO_SEC, clk_rate);
+
+	/* pwm reset init */
+	pc->pwm_rst = devm_reset_control_get_optional(&pdev->dev, "pwmrst");
+	if(IS_ERR_OR_NULL(pc->pwm_rst)) {
+		dev_err(&pdev->dev, "Failed to get pwmrst reset handle\n");
+		return -EFAULT;
+	}
+
+	ret = clk_prepare_enable(pc->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't prepare enable PWM clk: %d\n", ret);
+		return ret;
+	}
+
+	ret = clk_prepare_enable(pc->pclk);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't prepare enable APB clk: %d\n", ret);
+		goto err_clk;
+	}
+
+	/* reset pwm */
+	ret = reset_control_assert(pc->pwm_rst);
+	WARN_ON(0 != ret);
+	ret = reset_control_deassert(pc->pwm_rst);
+	WARN_ON(0 != ret);
+
+	platform_set_drvdata(pdev, pc);
+
+	pc->chip.dev = &pdev->dev;
+	pc->chip.ops = &eswin_pwm_ops;
+	pc->chip.npwm = 3;
+
+	ret = pwmchip_add(&pc->chip);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "pwmchip_add() failed: %d\n", ret);
+		goto err_pclk;
+	}
+
+	return 0;
+
+err_pclk:
+    clk_disable_unprepare(pc->pclk);
+err_clk:
+    clk_disable_unprepare(pc->clk);
+
+	return ret;
+}
+
+static int eswin_pwm_remove(struct platform_device *pdev)
+{
+	struct eswin_pwm *pc = platform_get_drvdata(pdev);
+
+	pwmchip_remove(&pc->chip);
+
+	clk_disable_unprepare(pc->pclk);
+	clk_disable_unprepare(pc->clk);
+
+	return 0;
+}
+
+static struct platform_driver eswin_pwm_driver = {
+	.driver = {
+		.name = "eswin-pwm",
+		.of_match_table = eswin_pwm_dt_ids,
+	},
+	.probe = eswin_pwm_probe,
+	.remove = eswin_pwm_remove,
+};
+module_platform_driver(eswin_pwm_driver);
+
+MODULE_DESCRIPTION("eswin SoC PWM driver");
+MODULE_AUTHOR("zhangchunyun@eswincomputing.com");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index ccd59ddd7610..f84d0a674eb7 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -66,6 +66,12 @@ config RESET_BRCMSTB_RESCAL
 	  This enables the RESCAL reset controller for SATA, PCIe0, or PCIe1 on
 	  BCM7216.
 
+config RESET_ESWIN_EIC7700
+	tristate "Eswin EIC7700 Reset Driver"
+	default n
+	help
+	  This enables the reset controller driver for Eswin EIC7700 SoCs.
+
 config RESET_HSDK
 	bool "Synopsys HSDK Reset Driver"
 	depends on HAS_IOMEM
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index 8270da8a4baa..d4d4dfe96c65 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -11,6 +11,7 @@ obj-$(CONFIG_RESET_BCM6345) += reset-bcm6345.o
 obj-$(CONFIG_RESET_BERLIN) += reset-berlin.o
 obj-$(CONFIG_RESET_BRCMSTB) += reset-brcmstb.o
 obj-$(CONFIG_RESET_BRCMSTB_RESCAL) += reset-brcmstb-rescal.o
+obj-$(CONFIG_RESET_ESWIN_EIC7700) += reset-eswin.o
 obj-$(CONFIG_RESET_HSDK) += reset-hsdk.o
 obj-$(CONFIG_RESET_IMX7) += reset-imx7.o
 obj-$(CONFIG_RESET_INTEL_GW) += reset-intel-gw.o
diff --git a/drivers/reset/reset-eswin.c b/drivers/reset/reset-eswin.c
new file mode 100755
index 000000000000..8bd01ac89203
--- /dev/null
+++ b/drivers/reset/reset-eswin.c
@@ -0,0 +1,257 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Reset Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+
+#define SYSCRG_CLEAR_BOOT_INFO_OFFSET    (0x30C)
+#define CLEAR_BOOT_FLAG_BIT              BIT_ULL(0)
+#define SYSCRG_RESET_OFFSET              (0x400)
+
+/**
+ * struct eswin_reset_data - reset controller information structure
+ * @rcdev: reset controller entity
+ * @dev: reset controller device pointer
+ * @idr: idr structure for mapping ids to reset control structures
+ */
+struct eswin_reset_data {
+	struct reset_controller_dev rcdev;
+	struct device *dev;
+	struct idr idr;
+	struct regmap *regmap;
+};
+
+/**
+ * struct eswin_reset_control - reset control structure
+ * @dev_id: SoC-specific device identifier
+ * @reset_bit: reset mask to use for toggling reset
+ */
+struct eswin_reset_control {
+	u32 dev_id;
+	u32 reset_bit;
+};
+
+#define to_eswin_reset_data(p)	\
+	container_of((p), struct eswin_reset_data, rcdev)
+
+/**
+ * eswin_reset_set() - program a device's reset
+ * @rcdev: reset controller entity
+ * @id: ID of the reset to toggle
+ * @assert: boolean flag to indicate assert or deassert
+ *
+ * This is a common internal function used to assert or deassert a device's
+ * reset by clear and set the reset bit. The device's reset is asserted if the
+ * @assert argument is true, or deasserted if @assert argument is false.
+ *
+ * Return: 0 for successful request, else a corresponding error value
+ */
+static int eswin_reset_set(struct reset_controller_dev *rcdev,
+			    unsigned long id, bool assert)
+{
+	struct eswin_reset_data *data = to_eswin_reset_data(rcdev);
+	struct eswin_reset_control *control;
+	int ret;
+
+	control = idr_find(&data->idr, id);
+
+	dev_dbg(rcdev->dev, "dev_id 0x%x reset_bit 0x%x assert 0x%x\r\n",
+		control->dev_id, control->reset_bit, assert);
+
+	if (!control)
+		return -EINVAL;
+
+	if (assert) {
+		ret = regmap_clear_bits(data->regmap, SYSCRG_RESET_OFFSET + control->dev_id * sizeof(u32),
+			control->reset_bit);
+	} else {
+		ret = regmap_set_bits(data->regmap, SYSCRG_RESET_OFFSET + control->dev_id * sizeof(u32),
+			control->reset_bit);
+	}
+
+	return ret;
+}
+
+static int eswin_reset_reset(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	int ret;
+
+	ret = eswin_reset_set(rcdev, id, true);
+	if (0 != ret) {
+		return ret;
+	}
+	usleep_range(10, 15);
+	ret = eswin_reset_set(rcdev, id, false);
+	if (0 != ret) {
+		return ret;
+	}
+
+	return 0;
+}
+
+static int eswin_reset_assert(struct reset_controller_dev *rcdev,
+			      unsigned long id)
+{
+	return eswin_reset_set(rcdev, id, true);
+}
+
+static int eswin_reset_deassert(struct reset_controller_dev *rcdev,
+				unsigned long id)
+{
+	return eswin_reset_set(rcdev, id, false);
+}
+
+static const struct reset_control_ops eswin_reset_ops = {
+	.reset		= eswin_reset_reset,
+	.assert		= eswin_reset_assert,
+	.deassert	= eswin_reset_deassert,
+};
+
+static int eswin_reset_of_xlate_lookup_id(int id, void *p, void *data)
+{
+	struct of_phandle_args *reset_spec = (struct of_phandle_args *)data;
+	struct eswin_reset_control *slot_control = (struct eswin_reset_control *)p;
+
+	if (reset_spec->args[0] == slot_control->dev_id
+		&& reset_spec->args[1] == slot_control->reset_bit) {
+			return id;
+	} else {
+		return 0;
+	}
+}
+
+/**
+ * eswin_reset_of_xlate() - translate a set of OF arguments to a reset ID
+ * @rcdev: reset controller entity
+ * @reset_spec: OF reset argument specifier
+ *
+ * This function performs the translation of the reset argument specifier
+ * values defined in a reset consumer device node. The function allocates a
+ * reset control structure for that device reset, and will be used by the
+ * driver for performing any reset functions on that reset. An idr structure
+ * is allocated and used to map to the reset control structure. This idr
+ * is used by the driver to do reset lookups.
+ *
+ * Return: 0 for successful request, else a corresponding error value
+ */
+static int eswin_reset_of_xlate(struct reset_controller_dev *rcdev,
+				 const struct of_phandle_args *reset_spec)
+{
+	struct eswin_reset_data *data = to_eswin_reset_data(rcdev);
+	struct eswin_reset_control *control;
+	int ret;
+
+	if (WARN_ON(reset_spec->args_count != rcdev->of_reset_n_cells))
+		return -EINVAL;
+
+	ret = idr_for_each(&data->idr, eswin_reset_of_xlate_lookup_id, (void *)reset_spec);
+	if (0 != ret) {
+		return ret;
+	}
+
+	control = devm_kzalloc(data->dev, sizeof(*control), GFP_KERNEL);
+	if (!control)
+		return -ENOMEM;
+
+	control->dev_id = reset_spec->args[0];
+	control->reset_bit = reset_spec->args[1];
+
+	return idr_alloc(&data->idr, control, 0, 0, GFP_KERNEL);
+}
+
+static const struct of_device_id eswin_reset_dt_ids[] = {
+	 { .compatible = "eswin,eic7700-reset", },
+	 { /* sentinel */ },
+};
+
+static int eswin_reset_probe(struct platform_device *pdev)
+{
+	struct eswin_reset_data *data;
+	struct device *parent;
+
+	parent = pdev->dev.parent;
+	if (!parent) {
+		dev_err(&pdev->dev, "no parent\n");
+		return -ENODEV;
+	}
+
+	data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->regmap = syscon_node_to_regmap(parent->of_node);
+	if (IS_ERR(data->regmap)) {
+		dev_err(&pdev->dev, "failed to get parent regmap\n");
+		return PTR_ERR(data->regmap);
+	}
+
+	platform_set_drvdata(pdev, data);
+
+	data->rcdev.owner = THIS_MODULE;
+	data->rcdev.ops = &eswin_reset_ops;
+	data->rcdev.of_node = pdev->dev.of_node;
+	data->rcdev.of_reset_n_cells = 2;
+	data->rcdev.of_xlate = eswin_reset_of_xlate;
+	data->rcdev.dev = &pdev->dev;
+	data->dev = &pdev->dev;
+	idr_init(&data->idr);
+
+	/*clear boot flag so u84 and scpu could be reseted by software*/
+	regmap_set_bits(data->regmap, SYSCRG_CLEAR_BOOT_INFO_OFFSET, CLEAR_BOOT_FLAG_BIT);
+	msleep(50);
+
+	platform_set_drvdata(pdev, data);
+
+	return devm_reset_controller_register(&pdev->dev, &data->rcdev);
+}
+
+static int eswin_reset_remove(struct platform_device *pdev)
+{
+	struct eswin_reset_data *data = platform_get_drvdata(pdev);
+
+	idr_destroy(&data->idr);
+
+	return 0;
+}
+
+static struct platform_driver eswin_reset_driver = {
+	.probe	= eswin_reset_probe,
+	.remove = eswin_reset_remove,
+	.driver = {
+		.name		= "eswin-reset",
+		.of_match_table	= eswin_reset_dt_ids,
+	},
+};
+
+static int __init eic7700_reset_init(void)
+{
+	return platform_driver_register(&eswin_reset_driver);
+}
+arch_initcall(eic7700_reset_init);
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index d7502433c78a..5b417410b631 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -306,6 +306,15 @@ config RTC_DRV_DS1672
 	  This driver can also be built as a module. If so, the module
 	  will be called rtc-ds1672.
 
+config RTC_DRV_ESWIN
+	tristate "eswin EIC7700 RTC"
+	help
+	  If you say yes here you get support for the eswin EIC7700 real time
+	  clock.
+
+	  This driver can also be built as a module, if so, the module
+	  will be called "rtc-eswin".
+
 config RTC_DRV_HYM8563
 	tristate "Haoyu Microelectronics HYM8563"
 	depends on OF
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index fd209883ee2e..9a53a6b92990 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -65,6 +65,7 @@ obj-$(CONFIG_RTC_DRV_DS3232)	+= rtc-ds3232.o
 obj-$(CONFIG_RTC_DRV_EFI)	+= rtc-efi.o
 obj-$(CONFIG_RTC_DRV_EM3027)	+= rtc-em3027.o
 obj-$(CONFIG_RTC_DRV_EP93XX)	+= rtc-ep93xx.o
+obj-$(CONFIG_RTC_DRV_ESWIN)	+= rtc-eswin.o
 obj-$(CONFIG_RTC_DRV_FM3130)	+= rtc-fm3130.o
 obj-$(CONFIG_RTC_DRV_FSL_FTM_ALARM)	+= rtc-fsl-ftm-alarm.o
 obj-$(CONFIG_RTC_DRV_FTRTC010)	+= rtc-ftrtc010.o
diff --git a/drivers/rtc/rtc-eswin.c b/drivers/rtc/rtc-eswin.c
new file mode 100644
index 000000000000..e83f43baa60d
--- /dev/null
+++ b/drivers/rtc/rtc-eswin.c
@@ -0,0 +1,322 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN rtc driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Author: zhangpengcheng@eswincomputing.com
+ */
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/rtc.h>
+#include <linux/reset.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
+
+#define RTC_INT_TO_U84  0xffff9fff
+/* RTC CSR Registers */
+#define RTC_CCVR        0x00
+#define RTC_CMR         0x04
+#define RTC_CLR         0x08
+#define RTC_CCR         0x0C
+#define RTC_CCR_IE      BIT(0)
+#define RTC_CCR_MASK    BIT(1)
+#define RTC_CCR_EN      BIT(2)
+#define RTC_CCR_WEN     BIT(3)
+#define RTC_CCR_PEN     BIT(4)
+#define RTC_STAT        0x10
+#define RTC_STAT_BIT    BIT(0)
+#define RTC_RSTAT       0x14
+#define RTC_EOI         0x18
+#define RTC_VER         0x1C
+#define RTC_CPSR        0x20
+#define RTC_CPCVR       0x24
+
+struct eswin_rtc_dev {
+	struct rtc_device *rtc;
+	struct device *dev;
+	unsigned long alarm_time;
+	void __iomem *csr_base;
+	struct clk *clk;
+	unsigned int irq_wake;
+	struct reset_control *rst_rtc;
+};
+
+static int eswin_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	struct eswin_rtc_dev *pdata = dev_get_drvdata(dev);
+	rtc_time64_to_tm(readl(pdata->csr_base + RTC_CCVR), tm);
+	return rtc_valid_tm(tm);
+}
+
+static int eswin_rtc_set_time(struct device *dev, struct rtc_time *tm)
+{
+	struct eswin_rtc_dev *pdata = dev_get_drvdata(dev);
+	unsigned long tr;
+
+	tr = rtc_tm_to_time64(tm);
+	writel(tr, pdata->csr_base + RTC_CLR);
+	readl(pdata->csr_base + RTC_CLR); /* Force a barrier */
+
+	return 0;
+}
+
+static int eswin_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct eswin_rtc_dev *pdata = dev_get_drvdata(dev);
+	rtc_time64_to_tm(pdata->alarm_time, &alrm->time);
+	alrm->enabled = readl(pdata->csr_base + RTC_CCR) & RTC_CCR_IE;
+
+	return 0;
+}
+
+static int eswin_rtc_alarm_irq_enable(struct device *dev, u32 enabled)
+{
+	struct eswin_rtc_dev *pdata = dev_get_drvdata(dev);
+	u32 ccr;
+
+	ccr = readl(pdata->csr_base + RTC_CCR);
+	if (enabled) {
+		ccr &= ~RTC_CCR_MASK;
+		ccr |= RTC_CCR_IE;
+	} else {
+		ccr &= ~RTC_CCR_IE;
+		ccr |= RTC_CCR_MASK;
+	}
+	writel(ccr, pdata->csr_base + RTC_CCR);
+
+	return 0;
+}
+
+static int eswin_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)
+{
+	struct eswin_rtc_dev *pdata = dev_get_drvdata(dev);
+	unsigned long rtc_time;
+	unsigned long alarm_time;
+	rtc_time = readl(pdata->csr_base + RTC_CCVR);
+	alarm_time = rtc_tm_to_time64(&alrm->time);
+
+	pdata->alarm_time = alarm_time;
+	writel((u32) pdata->alarm_time, pdata->csr_base + RTC_CMR);
+
+	eswin_rtc_alarm_irq_enable(dev, alrm->enabled);
+
+	return 0;
+}
+
+static const struct rtc_class_ops eswin_rtc_ops = {
+	.read_time  = eswin_rtc_read_time,
+	.set_time   = eswin_rtc_set_time,
+	.read_alarm = eswin_rtc_read_alarm,
+	.set_alarm  = eswin_rtc_set_alarm,
+	.alarm_irq_enable = eswin_rtc_alarm_irq_enable,
+};
+
+static irqreturn_t eswin_rtc_interrupt(int irq, void *id)
+{
+	struct eswin_rtc_dev *pdata = (struct eswin_rtc_dev *) id;
+	/* Check if interrupt asserted */
+	if (!(readl(pdata->csr_base + RTC_STAT) & RTC_STAT_BIT))
+		return IRQ_NONE;
+
+	/* Clear interrupt */
+	readl(pdata->csr_base + RTC_EOI);
+
+	rtc_update_irq(pdata->rtc, 1, RTC_IRQF | RTC_AF);
+
+	return IRQ_HANDLED;
+}
+
+static int eswin_rtc_probe(struct platform_device *pdev)
+{
+	struct eswin_rtc_dev *pdata;
+	struct resource *res;
+	int ret;
+	int irq;
+	unsigned int reg_val;
+	unsigned int int_off;
+	unsigned int clk_freq;
+	struct regmap *regmap;
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, pdata);
+	pdata->dev = &pdev->dev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pdata->csr_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(pdata->csr_base))
+		return PTR_ERR(pdata->csr_base);
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0) {
+		dev_err(&pdev->dev, "No IRQ resource\n");
+		return irq;
+	}
+	ret = devm_request_irq(&pdev->dev, irq, eswin_rtc_interrupt, 0,
+                   dev_name(&pdev->dev), pdata);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not request IRQ\n");
+		return ret;
+	}
+
+	/* update RTC interrupt to u84 */
+	regmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, "eswin,syscfg");
+	if (IS_ERR(regmap)) {
+		dev_err(&pdev->dev, "No syscfg phandle specified\n");
+		return PTR_ERR(regmap);
+	}
+
+	ret = of_property_read_u32_index(pdev->dev.of_node, "eswin,syscfg", 1, &int_off);
+	if (ret) {
+		dev_err(&pdev->dev, "No rtc interrupt offset found\n");
+		return -1;
+	}
+	regmap_read(regmap, int_off, &reg_val);
+	reg_val &= (RTC_INT_TO_U84);
+	regmap_write(regmap, int_off, reg_val);
+
+	ret = of_property_read_u32(pdev->dev.of_node, "clock-frequency", &clk_freq);
+	if (ret) {
+		dev_err(&pdev->dev, "No rtc clock-frequency found\n");
+	}
+	/* rtc reset init*/
+	pdata->rst_rtc = devm_reset_control_get_optional(&pdev->dev, "rtcrst");
+	if (IS_ERR_OR_NULL(pdata->rst_rtc)) {
+		dev_err(&pdev->dev, "Failed to get rtcrst reset handle\n");
+		return -EFAULT;
+	}
+
+	/* get RTC clock */
+	pdata->clk = devm_clk_get(&pdev->dev, "rtcclk");
+	if (IS_ERR(pdata->clk)) {
+		dev_err(&pdev->dev, "Couldn't get the clock for RTC\n");
+		return -ENODEV;
+	}
+	/* Enable the clock */
+	clk_prepare_enable(pdata->clk);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable RTC clock: %d\n", ret);
+		return -ENODEV;
+	}
+	/* reset rtc */
+	ret = reset_control_assert(pdata->rst_rtc);
+	WARN_ON(0 != ret);
+	ret = reset_control_deassert(pdata->rst_rtc);
+	WARN_ON(0 != ret);
+
+	/* Turn on the clock and the crystal */
+	reg_val = readl(pdata->csr_base + RTC_CCR);
+	writel(RTC_CCR_EN | reg_val, pdata->csr_base + RTC_CCR);
+
+	/* Turn on the prescaler and set the value */
+	writel(clk_freq, pdata->csr_base + RTC_CPSR);
+	reg_val = readl(pdata->csr_base + RTC_CCR);
+	writel(RTC_CCR_PEN | reg_val, pdata->csr_base + RTC_CCR);
+
+	device_init_wakeup(&pdev->dev, 1);
+
+	pdata->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,
+                     &eswin_rtc_ops, THIS_MODULE);
+	if (IS_ERR(pdata->rtc)) {
+		clk_disable_unprepare(pdata->clk);
+		return PTR_ERR(pdata->rtc);
+	}
+
+	return 0;
+}
+
+static int eswin_rtc_remove(struct platform_device *pdev)
+{
+	struct eswin_rtc_dev *pdata = platform_get_drvdata(pdev);
+
+	eswin_rtc_alarm_irq_enable(&pdev->dev, 0);
+	device_init_wakeup(&pdev->dev, 0);
+	clk_disable_unprepare(pdata->clk);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int eswin_rtc_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct eswin_rtc_dev *pdata = platform_get_drvdata(pdev);
+	int irq;
+
+	irq = platform_get_irq(pdev, 0);
+	if (device_may_wakeup(&pdev->dev)) {
+		if (!enable_irq_wake(irq))
+			pdata->irq_wake = 1;
+	} else {
+		eswin_rtc_alarm_irq_enable(dev, 0);
+		clk_disable(pdata->clk);
+	}
+
+	return 0;
+}
+
+static int eswin_rtc_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct eswin_rtc_dev *pdata = platform_get_drvdata(pdev);
+	int irq;
+
+	irq = platform_get_irq(pdev, 0);
+	if (device_may_wakeup(&pdev->dev)) {
+		if (pdata->irq_wake) {
+			disable_irq_wake(irq);
+			pdata->irq_wake = 0;
+		}
+	} else {
+		clk_enable(pdata->clk);
+		eswin_rtc_alarm_irq_enable(dev, 1);
+	}
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(eswin_rtc_pm_ops, eswin_rtc_suspend, eswin_rtc_resume);
+
+#ifdef CONFIG_OF
+static const struct of_device_id eswin_rtc_of_match[] = {
+	{.compatible = "eswin,eic7700-rtc" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, eswin_rtc_of_match);
+#endif
+
+static struct platform_driver eswin_rtc_driver = {
+	.probe      = eswin_rtc_probe,
+	.remove     = eswin_rtc_remove,
+	.driver     = {
+		.name   = "eswin-rtc",
+		.pm = &eswin_rtc_pm_ops,
+		.of_match_table = of_match_ptr(eswin_rtc_of_match),
+	},
+};
+
+module_platform_driver(eswin_rtc_driver);
+
+MODULE_DESCRIPTION("eswin eic7700 RTC driver");
+MODULE_AUTHOR("zhangpengcheng@eswin.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/sifive/sifive_ccache.c b/drivers/soc/sifive/sifive_ccache.c
index 3684f5b40a80..928ab5dcd3c3 100644
--- a/drivers/soc/sifive/sifive_ccache.c
+++ b/drivers/soc/sifive/sifive_ccache.c
@@ -8,13 +8,16 @@
 
 #define pr_fmt(fmt) "CCACHE: " fmt
 
+#include <linux/align.h>
 #include <linux/debugfs.h>
 #include <linux/interrupt.h>
 #include <linux/of_irq.h>
 #include <linux/of_address.h>
 #include <linux/device.h>
 #include <linux/bitfield.h>
+#include <asm/cacheflush.h>
 #include <asm/cacheinfo.h>
+#include <asm/dma-noncoherent.h>
 #include <soc/sifive/sifive_ccache.h>
 
 #define SIFIVE_CCACHE_DIRECCFIX_LOW 0x100
@@ -44,6 +47,10 @@
 
 #define SIFIVE_CCACHE_MAX_ECCINTR 4
 
+#define SIFIVE_CCACHE_FLUSH64 0x200
+#define SIFIVE_CCACHE_FLUSH32 0x240
+#define SIFIVE_CCACHE_LINE_SIZE 64
+
 static void __iomem *ccache_base;
 static int g_irq[SIFIVE_CCACHE_MAX_ECCINTR];
 static struct riscv_cacheinfo_ops ccache_cache_ops;
@@ -56,6 +63,10 @@ enum {
 	DIR_UNCORR,
 };
 
+enum {
+	QUIRK_NONSTANDARD_CACHE_OPS = BIT(0),
+};
+
 #ifdef CONFIG_DEBUG_FS
 static struct dentry *sifive_test;
 
@@ -107,11 +118,41 @@ static const struct of_device_id sifive_ccache_ids[] = {
 	{ .compatible = "sifive,fu540-c000-ccache" },
 	{ .compatible = "sifive,fu740-c000-ccache" },
 	{ .compatible = "sifive,ccache0" },
+	{ .compatible = "sifive,eic7700",
+	  .data = (void *)(QUIRK_NONSTANDARD_CACHE_OPS) },
 	{ /* end of table */ }
 };
 
 static ATOMIC_NOTIFIER_HEAD(ccache_err_chain);
 
+#ifdef CONFIG_RISCV_NONSTANDARD_CACHE_OPS
+static void ccache_flush_range(phys_addr_t start, size_t len)
+{
+	phys_addr_t end = start + len;
+	phys_addr_t line;
+
+	if (!len)
+	    return;
+
+	mb();
+	for (line = ALIGN_DOWN(start, SIFIVE_CCACHE_LINE_SIZE); line < end;
+		line += SIFIVE_CCACHE_LINE_SIZE) {
+#ifdef CONFIG_32BIT
+		writel(line >> 4, ccache_base + SIFIVE_CCACHE_FLUSH32);
+#else
+		writeq(line, ccache_base + SIFIVE_CCACHE_FLUSH64);
+#endif
+		mb();
+	}
+}
+
+static const struct riscv_nonstd_cache_ops ccache_mgmt_ops __initconst = {
+	.wback = &ccache_flush_range,
+	.inv = &ccache_flush_range,
+	.wback_inv = &ccache_flush_range,
+};
+#endif /* CONFIG_RISCV_NONSTANDARD_CACHE_OPS */
+
 int register_sifive_ccache_error_notifier(struct notifier_block *nb)
 {
 	return atomic_notifier_chain_register(&ccache_err_chain, nb);
@@ -210,11 +251,18 @@ static int __init sifive_ccache_init(void)
 	struct device_node *np;
 	struct resource res;
 	int i, rc, intr_num;
+	const struct of_device_id *match;
+	unsigned long quirks;
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	unsigned int config, ways;
+#endif
 
-	np = of_find_matching_node(NULL, sifive_ccache_ids);
+	np = of_find_matching_node_and_match(NULL, sifive_ccache_ids, &match);
 	if (!np)
 		return -ENODEV;
 
+	quirks = (uintptr_t)match->data;
+
 	if (of_address_to_resource(np, 0, &res)) {
 		rc = -ENODEV;
 		goto err_node_put;
@@ -249,6 +297,20 @@ static int __init sifive_ccache_init(void)
 	}
 	of_node_put(np);
 
+#ifdef CONFIG_SOC_SIFIVE_EIC7700
+	config = readl(ccache_base + SIFIVE_CCACHE_CONFIG);
+	ways = (config >> 8) & 0xff;
+	writel(ways-1, ccache_base + SIFIVE_CCACHE_WAYENABLE);
+#endif
+
+#ifdef CONFIG_RISCV_NONSTANDARD_CACHE_OPS
+	if (quirks & QUIRK_NONSTANDARD_CACHE_OPS) {
+			riscv_cbom_block_size = SIFIVE_CCACHE_LINE_SIZE;
+			riscv_noncoherent_supported();
+			riscv_noncoherent_register_cache_ops(&ccache_mgmt_ops);
+	}
+#endif
+
 	ccache_config_read();
 
 	ccache_cache_ops.get_priv_group = ccache_get_priv_group;
@@ -269,4 +331,4 @@ static int __init sifive_ccache_init(void)
 	return rc;
 }
 
-device_initcall(sifive_ccache_init);
+arch_initcall(sifive_ccache_init);
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 3ce0fd5df8e9..07e874de0ebf 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -360,6 +360,12 @@ config SPI_EP93XX
 	  This enables using the Cirrus EP93xx SPI controller in master
 	  mode.
 
+config SPI_ESWIN_BOOTSPI
+	tristate "Eswin Computing Boot SPI controller"
+	help
+	  This enables using the Eswin Computing Boot SPI controller in master
+	  mode.
+
 config SPI_FALCON
 	bool "Falcon SPI controller support"
 	depends on SOC_FALCON
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 6af54842b9fa..0dc6ae53485b 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -50,6 +50,7 @@ obj-$(CONFIG_SPI_DW_BT1)		+= spi-dw-bt1.o
 obj-$(CONFIG_SPI_DW_MMIO)		+= spi-dw-mmio.o
 obj-$(CONFIG_SPI_DW_PCI)		+= spi-dw-pci.o
 obj-$(CONFIG_SPI_EP93XX)		+= spi-ep93xx.o
+obj-$(CONFIG_SPI_ESWIN_BOOTSPI)	+= spi-eswin-bootspi.o
 obj-$(CONFIG_SPI_FALCON)		+= spi-falcon.o
 obj-$(CONFIG_SPI_FSI)			+= spi-fsi.o
 obj-$(CONFIG_SPI_FSL_CPM)		+= spi-fsl-cpm.o
diff --git a/drivers/spi/spi-eswin-bootspi.c b/drivers/spi/spi-eswin-bootspi.c
new file mode 100644
index 000000000000..c8fbc1b3fc91
--- /dev/null
+++ b/drivers/spi/spi-eswin-bootspi.c
@@ -0,0 +1,658 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN BootSpi Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/bitfield.h>
+#include <linux/interrupt.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/mod_devicetable.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi-mem.h>
+#include <linux/mtd/spi-nor.h>
+
+/* Register offsets */
+#define ES_SPI_CSR_00			0x00	/*WRITE_STATUS_REG_TIME*/
+#define ES_SPI_CSR_01			0x04	/*SPI_BUS_MODE*/
+#define ES_SPI_CSR_02			0x08	/*ERASE_COUNTER_TAP*/
+#define ES_SPI_CSR_03			0x0c	/*DMA_EN_HCLK_STATUS*/
+#define ES_SPI_CSR_04			0x10	/*FAST_READ_CONTROL*/
+#define ES_SPI_CSR_05			0x14	/*SPI_FLASH_WR_NUM*/
+#define ES_SPI_CSR_06			0x18	/*SPI_FLASH_COMMAND*/
+#define ES_SPI_CSR_07			0x1c	/*INTERRUPT_CONTROL*/
+#define ES_SPI_CSR_08			0x20	/*DMA_REQUEST_TAP*/
+#define ES_SPI_CSR_09			0x24	/*SPI_FLASH_WR_ADDRESS*/
+#define ES_SPI_CSR_10			0x28	/*PAGE_PROGRAM_TIME*/
+#define ES_SPI_CSR_11			0x2c	/*SECTOR_ERASE_TIME*/
+#define ES_SPI_CSR_12			0x30	/*SMALL_BLOCK_ERASE_TIME*/
+#define ES_SPI_CSR_13			0x34	/*LARGE_BLOCK_ERASE_TIME*/
+#define ES_SPI_CSR_14			0x38	/*CHIP_ERASE_TIME*/
+#define ES_SPI_CSR_15			0x3c	/*CHIP_DESELECT_TIME*/
+#define ES_SPI_CSR_16			0x40	/*POWER_DOWN_TIME*/
+
+#define ES_SYSCSR_SPIMODECFG			0x340
+
+#define ES_CONCSR_SPI_INTSEL			0x3c0
+
+#define SPI_COMMAND_VALID				0x01
+#define SPI_COMMAND_MOVE_VALUE			0x00
+#define SPI_COMMAND_CODE_FIELD_POSITION 0X06
+#define SPI_COMMAND_MOVE_FIELD_POSITION 0X05
+#define SPI_COMMAND_TYPE_FIELD_POSITION 0X01
+
+/* Bit fields in CTRLR0 */
+/*
+ * Only present when SSI_MAX_XFER_SIZE=16. This is the default, and the only
+ * option before version 3.23a.
+ */
+#define SPI_INTSEL_MASK			GENMASK(11, 10)
+#define INT_ROUTED_U84			0x0
+#define INT_ROUTED_LPCPU		0x1
+#define INT_ROUTED_SCPU			0x3u
+
+#define RX_TIMEOUT			5000		/* timeout in ms */
+
+#define SPI_COMMAND_INIT_VALUE       0XFFFFC000
+#define FLASH_PAGE_SIZE      0x100
+
+typedef enum {
+	SPI_FLASH_WR_BYTE  = 1,
+	SPI_FLASH_WR_2BYTE = 2,
+	SPI_FLASH_WR_WORD  = 4,
+} SPI_FLASH_WR_NUM_T;
+
+typedef enum {
+	SPI_FAST_READ_DEFAULT = 0,
+	SPI_FAST_READ_ENABLE  = 3 /*WHEN SPI QUAD0 OR DUAL MODE*/
+} SPI_FAST_READ_CTL_T;
+
+typedef enum { STANDARD_SPI = 0, DUAL_SPI, QUAD_SPI } SPI_BUS_MODE_T;
+
+typedef enum {
+	SPIC_CMD_TYPE_SPI_PROGRAM = 0,
+	SPIC_CMD_TYPE_WRITE_STATUS_REGISTER,
+	SPIC_CMD_TYPE_READ_STATUS_REGISTER,
+	SPIC_CMD_TYPE_SECTOR_ERASE,
+	SPIC_CMD_TYPE_BLOCK_ERASE_TYPE1,
+	SPIC_CMD_TYPE_BLOCK_ERASE_TYPE2,
+	SPIC_CMD_TYPE_CHIP_ERASE,
+	SPIC_CMD_TYPE_POWER_DOWN,
+	SPIC_CMD_TYPE_RELEASE_POWER_DOWM,
+	SPIC_CMD_TYPE_ENTER_OR_EXIT_32BIT_MODE,
+	SPIC_CMD_TYPE_READ_SECURITY_REG,
+	SPIC_CMD_TYPE_ERASE_SECURITY_REG,
+	SPIC_CMD_TYPE_WRITE_SECURITY_REG,
+	SPIC_CMD_TYPE_READ_DATA,
+	SPIC_CMD_TYPE_READ_MANUFACTURED_ID,
+	SPIC_CMD_TYPE_READ_JEDEC_ID
+} SPI_FLASH_COMMAND_TYPE_T;
+
+#define SPIC_CMD_CODE_POWER_DOWN              0xb9
+#define SPIC_CMD_CODE_RELEASE_POWER_DOWN       0xab
+#define SPIC_CMD_CODE_ENABLE_RESET            0x66
+#define SPIC_CMD_CODE_RESET                   0x99
+
+struct es_spi_priv {
+	struct clk *cfg_clk;
+	struct clk *clk;
+	struct reset_control *rstc;
+	struct gpio_desc *cs_gpio;	/* External chip-select gpio */
+
+	void __iomem *regs;
+	void __iomem *sys_regs;
+	void __iomem *flash_base;
+	unsigned int freq;		/* Default frequency */
+	unsigned int mode;
+
+	const void *tx;
+	u32 opcode;
+	u32 cmd_type;
+	u64 addr;
+	void *rx;
+	u32 fifo_len;			/* depth of the FIFO buffer */
+	u32 max_xfer;			/* Maximum transfer size (in bits) */
+
+	int bits_per_word;
+	int len;
+	u8 cs;				/* chip select pin */
+	u8 tmode;			/* TR/TO/RO/EEPROM */
+	u8 type;			/* SPI/SSP/MicroWire */
+	struct spi_controller *master;
+	struct device *dev;
+	int irq;
+};
+
+static inline u32 eswin_bootspi_read(struct es_spi_priv *priv, u32 offset)
+{
+	return readl(priv->regs + offset);
+}
+
+static inline void eswin_bootspi_write(struct es_spi_priv *priv, u32 offset, u32 val)
+{
+	writel(val, priv->regs + offset);
+}
+
+static inline u32 eswin_bootspi_data_read(struct es_spi_priv *priv, u32 offset)
+{
+	return readl(priv->flash_base + offset);
+}
+
+static inline void eswin_bootspi_data_write(struct es_spi_priv *priv, u32 offset, u32 val)
+{
+	writel(val, priv->flash_base + offset);
+}
+
+static int eswin_bootspi_wait_over(struct es_spi_priv *priv)
+{
+	u32 val;
+	struct device *dev = priv->dev;
+
+	if (readl_poll_timeout(priv->regs + ES_SPI_CSR_06, val,
+		(!(val & 0x1)), 10, RX_TIMEOUT * 1000)) {
+			dev_err(dev, "eswin_bootspi_wait_over : timeout!!\n");
+			return -ETIMEDOUT;
+	}
+	return 0;
+}
+
+/**
+ * @brief spi read and write cfg
+ */
+static void eswin_bootspi_read_write_cfg(struct es_spi_priv *priv, u32 byte, u32 addr)
+{
+	eswin_bootspi_write(priv, ES_SPI_CSR_09, addr);
+	eswin_bootspi_write(priv, ES_SPI_CSR_05, byte);
+	eswin_bootspi_write(priv, ES_SPI_CSR_04, SPI_FAST_READ_DEFAULT);
+	eswin_bootspi_write(priv, ES_SPI_CSR_01, STANDARD_SPI);
+}
+
+/**
+ *  @brief write data from dest address to flash
+ */
+static void eswin_bootspi_send_data(struct es_spi_priv *priv,
+	const u8 *dest, u32 size)
+{
+	u32 offset = 0;
+	u8 *buff = (u8 *)dest;
+	u32 data = 0;
+	int i;
+	struct device *dev = priv->dev;
+
+	dev_dbg(dev,"wrtie spi data\n");
+	while (size >= SPI_FLASH_WR_WORD) {
+		data = (buff[0]) | (buff[1] << 8) |(buff[2] << 16) | (buff[3] << 24);
+		for (i = 0; i < 4; i++) {
+			dev_dbg(dev,"0x%x ", buff[i]);
+		}
+		dev_dbg(dev,"0x%x ", data);
+		eswin_bootspi_data_write(priv, offset, data);
+		offset = offset + SPI_FLASH_WR_WORD;
+		size = size - SPI_FLASH_WR_WORD;
+		buff = buff + SPI_FLASH_WR_WORD;
+	}
+	data = 0;
+	if (size != 0) {
+		for (i = 0; i < size; i++) {
+			data |=buff[i] << (8 * i);
+			dev_dbg(dev,"0x%x ", buff[i]);
+		}
+		dev_dbg(dev,"0x%x ", data);
+		eswin_bootspi_data_write(priv, offset, data);
+	}
+}
+
+/**
+ *  @brief Read data from flash to dest address
+ */
+static void eswin_bootspi_recv_data(struct es_spi_priv *priv, u8 *dest, u32 size)
+{
+	u32 offset = 0;
+	u8 *buff = NULL;
+	u32 data = 0xFFFFFFFF;
+	int i;
+	struct device *dev = priv->dev;
+
+	dev_dbg(dev,"read spi data\n");
+	while (size >= SPI_FLASH_WR_WORD) {
+		buff = (u8 *)dest;
+		data = eswin_bootspi_data_read(priv, offset);
+		dev_dbg(dev,"0x%x ", data);
+		for (i = 0; i < SPI_FLASH_WR_WORD; i++) {
+			*buff = (u8)(data >> (8 * i));
+			dev_dbg(dev,"0x%x ", *buff);
+			buff++;
+		}
+		dest = dest + SPI_FLASH_WR_WORD;
+		offset = offset + SPI_FLASH_WR_WORD;
+		size = size - SPI_FLASH_WR_WORD;
+	}
+	if (size != 0) {
+		buff = (u8 *)dest;
+		data = eswin_bootspi_data_read(priv, offset);
+		for (i = 0; i < size; i++) {
+			*buff = (u8)(data >> (8 * i));
+			dev_dbg(dev,"0x%x ", *buff);
+			buff++;
+		}
+	}
+	dev_dbg(dev,"\n");
+}
+
+
+/**
+ * @brief spi send command
+ */
+static void eswin_bootspi_cmd_cfg(struct es_spi_priv *priv, u32 code, u32 type)
+{
+	u32 command = eswin_bootspi_read(priv, ES_SPI_CSR_06);
+	struct device *dev = priv->dev;
+
+	command &= ~((0xFF << 6) | (0x1 << 5) | (0xF << 1) | 0x1);
+	command |= ((code << SPI_COMMAND_CODE_FIELD_POSITION) |
+		(SPI_COMMAND_MOVE_VALUE << SPI_COMMAND_MOVE_FIELD_POSITION) |
+		(type << SPI_COMMAND_TYPE_FIELD_POSITION) | SPI_COMMAND_VALID);
+
+	eswin_bootspi_write(priv, ES_SPI_CSR_06, command);
+	dev_dbg(dev, "[%s %d]: write command 0x%x, read back command 0x%x\n",
+		__func__,__LINE__, command, eswin_bootspi_read(priv, ES_SPI_CSR_06));
+}
+/**
+ * @brief  spi write flash
+ * @param [in]  offset: address of flash to be write
+ * @param [in]  wr_dest: Address of data to be sent
+ * @param [in]  size: size of flash to be write
+ */
+void eswin_bootspi_writer(struct es_spi_priv *priv)
+{
+	u32 write_size = 0, offset, cmd_code;
+	u32 cmd_type = priv->cmd_type;
+	const u8 *wr_dest = priv->tx;
+	int size = priv->len;
+
+	offset = priv->addr;
+	cmd_code = priv->opcode;
+
+	if (size == 0) {
+		// if(SPIC_CMD_TYPE_SECTOR_ERASE == cmd_type)
+		{
+			eswin_bootspi_read_write_cfg(priv, write_size, offset);
+			eswin_bootspi_cmd_cfg(priv, cmd_code, cmd_type);
+			eswin_bootspi_wait_over(priv);
+		}
+	}
+	while (size > 0) {
+		write_size = size;
+		if (write_size > FLASH_PAGE_SIZE) {
+			write_size = FLASH_PAGE_SIZE;
+		}
+		eswin_bootspi_read_write_cfg(priv, write_size, offset);
+		eswin_bootspi_send_data(priv, wr_dest, write_size);
+		eswin_bootspi_cmd_cfg(priv, cmd_code, cmd_type);
+		eswin_bootspi_wait_over(priv);
+		wr_dest += write_size;
+		offset += write_size;
+		size = size - write_size;
+	}
+}
+
+static void eswin_bootspi_reader(struct es_spi_priv *priv)
+{
+	int read_size = 0;
+	u32 offset = priv->addr;
+	u32 cmd_code = priv->opcode;
+	u32 cmd_type = priv->cmd_type;
+	u8 *mem_dest = priv->rx;
+	int size = priv->len;
+
+	while (size > 0) {
+		read_size = size;
+		if (read_size > FLASH_PAGE_SIZE) {
+			read_size = FLASH_PAGE_SIZE;
+		}
+
+		eswin_bootspi_read_write_cfg(priv, read_size, offset);
+		eswin_bootspi_cmd_cfg(priv, cmd_code, cmd_type);
+		eswin_bootspi_wait_over(priv);
+		eswin_bootspi_recv_data(priv, mem_dest, read_size);
+		mem_dest += read_size;
+		offset += read_size;
+		size = size - read_size;
+	}
+}
+
+/*
+ * We define external_cs_manage function as 'weak' as some targets
+ * (like MSCC Ocelot) don't control the external CS pin using a GPIO
+ * controller. These SoCs use specific registers to control by
+ * software the SPI pins (and especially the CS).
+ */
+
+static void external_cs_manage(struct es_spi_priv *priv, bool on)
+{
+	gpiod_set_value(priv->cs_gpio, on ? 1 : 0);
+}
+
+/* The size of ctrl1 limits data transfers to 64K */
+static int eswin_bootspi_adjust_op_size(struct spi_mem *mem,
+					struct spi_mem_op *op)
+{
+	op->data.nbytes = min(op->data.nbytes, (unsigned int)SZ_64K);
+
+	return 0;
+}
+
+/*
+ * The controller only supports Standard SPI mode, Duall mode and
+ * Quad mode. Double sanitize the ops here to avoid OOB access.
+ */
+static bool eswin_bootspi_supports_op(struct spi_mem *mem,
+				      const struct spi_mem_op *op)
+{
+	return spi_mem_default_supports_op(mem, op);
+}
+
+static int eswin_bootspi_exec_op(struct spi_mem *mem,
+				 const struct spi_mem_op *op)
+{
+	bool read = op->data.dir == SPI_MEM_DATA_IN;
+	int ret = 0;
+	struct es_spi_priv *priv = spi_master_get_devdata(mem->spi->master);
+	struct device *dev = priv->dev;
+
+	priv->addr = op->addr.val;
+	priv->opcode = op->cmd.opcode;
+
+	dev_dbg(dev, "\n[%s %d]: addr=0x%llx opcode=0x%x\n", __func__,__LINE__,
+		priv->addr, priv->opcode);
+
+	if ( priv->opcode == SPINOR_OP_WREN
+		|| priv->opcode == SPINOR_OP_WRDI)
+		return 0;
+
+	switch(priv->opcode) {
+		case SPINOR_OP_RDID:
+		case SPINOR_OP_RDSFDP:
+			priv->cmd_type = SPIC_CMD_TYPE_READ_JEDEC_ID;
+			break;
+		case SPINOR_OP_BE_4K:
+		case SPINOR_OP_BE_4K_PMC:
+			priv->opcode = SPINOR_OP_BE_4K;
+			priv->cmd_type = SPIC_CMD_TYPE_SECTOR_ERASE;
+			break;
+		case SPINOR_OP_BE_32K:
+			priv->cmd_type = SPIC_CMD_TYPE_BLOCK_ERASE_TYPE1;
+			break;
+		case SPINOR_OP_SE:
+			priv->cmd_type = SPIC_CMD_TYPE_BLOCK_ERASE_TYPE2;
+			break;
+		case SPINOR_OP_CHIP_ERASE:
+			priv->cmd_type = SPIC_CMD_TYPE_CHIP_ERASE;
+			break;
+		case SPINOR_OP_PP:
+		case SPINOR_OP_PP_1_1_4:
+		case SPINOR_OP_PP_1_4_4:
+		case SPINOR_OP_PP_1_1_8:
+		case SPINOR_OP_PP_1_8_8:
+			priv->opcode = SPINOR_OP_PP;
+			priv->cmd_type = SPIC_CMD_TYPE_SPI_PROGRAM;
+			break;
+		case SPINOR_OP_READ:
+		case SPINOR_OP_READ_FAST:
+		case SPINOR_OP_READ_1_1_2:
+		case SPINOR_OP_READ_1_2_2:
+		case SPINOR_OP_READ_1_1_4:
+		case SPINOR_OP_READ_1_4_4:
+		case SPINOR_OP_READ_1_1_8:
+		case SPINOR_OP_READ_1_8_8:
+			priv->opcode = SPINOR_OP_READ;
+			priv->cmd_type = SPIC_CMD_TYPE_READ_DATA;
+			break;
+		case SPINOR_OP_RDSR:
+		case SPINOR_OP_RDSR2:
+			priv->cmd_type = SPIC_CMD_TYPE_READ_STATUS_REGISTER;
+			break;
+		case SPINOR_OP_WRSR:
+		case SPINOR_OP_WRSR2:
+			priv->cmd_type = SPIC_CMD_TYPE_WRITE_STATUS_REGISTER;
+			break;
+		case SPIC_CMD_CODE_POWER_DOWN:
+			priv->cmd_type = SPIC_CMD_TYPE_POWER_DOWN;
+			break;
+		case SPIC_CMD_CODE_RELEASE_POWER_DOWN:
+			priv->cmd_type = SPIC_CMD_TYPE_RELEASE_POWER_DOWM;
+			break;
+		case SPIC_CMD_CODE_ENABLE_RESET:
+		case SPIC_CMD_CODE_RESET:
+			priv->cmd_type = SPIC_CMD_TYPE_SPI_PROGRAM;
+			break;
+		default:
+			dev_warn(dev, "[%s %d]: unsupport opcode = 0x%x, return sucess directly!\n",
+				__func__,__LINE__, priv->opcode);
+			return 0;
+	}
+
+	dev_dbg(dev, "[%s %d]: data direction=%d, opcode = 0x%x, cmd_type 0x%x\n",
+		__func__,__LINE__, op->data.dir, priv->opcode, priv->cmd_type);
+	external_cs_manage(priv, false);
+
+	if (read) {
+		priv->rx = op->data.buf.in;
+		priv->len = op->data.nbytes;
+		dev_dbg(dev, "[%s %d]: read len = %u\n", __func__,__LINE__, op->data.nbytes);
+		eswin_bootspi_reader(priv);
+	} else {
+		priv->tx = op->data.buf.out;
+		priv->len = op->data.nbytes;
+		/* Fill up the write fifo before starting the transfer */
+		dev_dbg(dev, "[%s %d]: write len = 0x%x  tx_addr 0x%px\n", __func__,__LINE__,
+			op->data.nbytes, priv->tx);
+		eswin_bootspi_writer(priv);
+		if (eswin_bootspi_wait_over(priv) < 0) {
+			dev_err(dev, "eswin_bootspi_wait_over ETIMEDOUT\n");
+			ret = -ETIMEDOUT;
+		}
+	}
+	external_cs_manage(priv, true);
+	dev_dbg(dev, "%u bytes xfered\n", op->data.nbytes);
+	return ret;
+}
+
+static const struct spi_controller_mem_ops eswin_bootspi_mem_ops = {
+	.adjust_op_size = eswin_bootspi_adjust_op_size,
+	.supports_op = eswin_bootspi_supports_op,
+	.exec_op = eswin_bootspi_exec_op,
+};
+
+static int eswin_bootspi_setup(struct spi_device *spi)
+{
+	struct es_spi_priv *priv = spi_master_get_devdata(spi->master);
+	struct device *dev = priv->dev;
+	int vaule = 0;
+	int ret;
+
+	ret = clk_prepare_enable(priv->cfg_clk);
+	if (ret) {
+		dev_err(dev, "could not enable cfg clock: %d\n", ret);
+		goto err_cfg_clk;
+	}
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret) {
+		dev_err(dev, "could not enable clock: %d\n", ret);
+		goto err_clk;
+	}
+	/* set rate to 50M*/
+	ret = clk_set_rate(priv->clk, 50000000);
+	if (ret) {
+		dev_err(dev, "could not enable clock: %d\n", ret);
+		goto err_clk;
+	}
+
+	reset_control_deassert(priv->rstc);
+
+	/* switch bootspi to cpu mode*/
+	vaule = readl(priv->sys_regs + ES_SYSCSR_SPIMODECFG);
+	vaule |= 0x1;
+	writel(vaule, priv->sys_regs + ES_SYSCSR_SPIMODECFG);
+
+	/* Basic HW init */
+	eswin_bootspi_write(priv, ES_SPI_CSR_08, 0x0);
+	return ret;
+
+err_clk:
+	clk_disable(priv->cfg_clk);
+err_cfg_clk:
+	return ret;
+}
+
+static int eswin_bootspi_probe(struct platform_device *pdev)
+{
+	struct es_spi_priv *priv;
+	struct spi_controller *master;
+	int ret = 0;
+	struct device *dev = &pdev->dev;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*priv));
+	if (!master)
+		return -ENOMEM;
+
+	master->mode_bits = SPI_CPOL | SPI_CPHA;
+	master->flags = SPI_MASTER_HALF_DUPLEX;
+	master->setup = eswin_bootspi_setup;
+	master->dev.of_node = pdev->dev.of_node;
+	master->bits_per_word_mask = SPI_BPW_MASK(32) | SPI_BPW_MASK(16) |
+				     SPI_BPW_MASK(8);
+	master->mem_ops = &eswin_bootspi_mem_ops;
+	master->num_chipselect = 1;
+
+	priv = spi_master_get_devdata(master);
+	priv->master = master;
+	priv->dev = &pdev->dev;
+	platform_set_drvdata(pdev, priv);
+
+	priv->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(priv->regs)) {
+		dev_err(dev, "%s %d: failed to map registers\n", __func__,__LINE__);
+		return PTR_ERR(priv->regs);
+	}
+
+	priv->sys_regs = devm_platform_ioremap_resource(pdev, 1);
+	if (IS_ERR(priv->sys_regs)) {
+		dev_err(dev,"%s %d: failed to map sys registers\n", __func__, __LINE__);
+		return PTR_ERR(priv->sys_regs);
+	}
+
+	priv->flash_base = devm_platform_ioremap_resource(pdev, 2);
+	if (IS_ERR(priv->flash_base)) {
+		dev_err(dev,"%s %d: failed to map sys registers\n", __func__, __LINE__);
+		return PTR_ERR(priv->flash_base);
+	}
+
+	priv->cfg_clk = devm_clk_get(dev, "cfg_clk");
+	if (IS_ERR(priv->cfg_clk)) {
+		dev_err(dev, "%s %d:could not get cfg clk: %ld\n", __func__,__LINE__,
+			PTR_ERR(priv->cfg_clk));
+		return PTR_ERR(priv->cfg_clk);
+	}
+
+	priv->clk = devm_clk_get(dev, "clk");
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "%s %d:could not get clk: %ld\n",__func__,__LINE__, PTR_ERR(priv->rstc));
+		return PTR_ERR(priv->clk);
+	}
+	priv->rstc = devm_reset_control_get_optional_exclusive(dev, "rst");
+	if (IS_ERR(priv->rstc)) {
+		dev_err(dev, "%s %d:could not get rst: %ld\n", __func__,__LINE__, PTR_ERR(priv->rstc));
+		return PTR_ERR(priv->rstc);
+	}
+
+	priv->cs_gpio = devm_gpiod_get(dev, "cs", GPIOD_OUT_LOW);
+	if (IS_ERR(priv->cs_gpio)) {
+		dev_err(dev, "%s %d: couldn't request gpio! (error %ld)\n", __func__,__LINE__,
+			PTR_ERR(priv->cs_gpio));
+		return PTR_ERR(priv->cs_gpio);
+	}
+
+	priv->max_xfer = 32;
+	dev_info(dev, "ssi_max_xfer_size=%u\n", priv->max_xfer);
+
+	/* Currently only bits_per_word == 8 supported */
+	priv->bits_per_word = 8;
+	priv->tmode = 0; /* Tx & Rx */
+
+	if (!priv->fifo_len) {
+		priv->fifo_len = 256;
+	}
+	ret = devm_spi_register_controller(dev, master);
+	if (ret)
+		goto err_put_master;
+
+	dev_info(&pdev->dev, "fifo_len %d, %s mode.\n", priv->fifo_len, priv->irq ? "irq" : "polling");
+	return 0;
+
+err_put_master:
+	spi_master_put(master);
+	return ret;
+}
+
+static int eswin_bootspi_remove(struct platform_device *pdev)
+{
+	struct es_spi_priv *priv = platform_get_drvdata(pdev);
+	struct spi_controller *master = priv->master;
+
+	spi_master_put(master);
+	return 0;
+}
+
+static const struct of_device_id eswin_bootspi_of_match[] = {
+	{ .compatible = "eswin,bootspi", .data = NULL},
+	{ /* end of table */}
+};
+MODULE_DEVICE_TABLE(of, eswin_bootspi_of_match);
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id eswin_bootspi_acpi_match[] = {
+	{"eswin,bootspi", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(acpi, eswin_bootspi_acpi_match);
+#endif
+
+static struct platform_driver eswin_bootspi_driver = {
+	.probe		= eswin_bootspi_probe,
+	.remove		= eswin_bootspi_remove,
+	.driver		= {
+		.name	= "eswin-bootspi",
+		.of_match_table = eswin_bootspi_of_match,
+#ifdef CONFIG_ACPI
+		.acpi_match_table = eswin_bootspi_acpi_match,
+#endif
+	},
+};
+module_platform_driver(eswin_bootspi_driver);
+
+MODULE_AUTHOR("Huangyifeng <huangyifeng@eswincomputing.com>");
+MODULE_DESCRIPTION("Eswin Boot SPI Controller Driver for EIC770X SoCs");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/tty/hvc/Kconfig b/drivers/tty/hvc/Kconfig
index 4f9264d005c0..6e05c5c7bca1 100644
--- a/drivers/tty/hvc/Kconfig
+++ b/drivers/tty/hvc/Kconfig
@@ -108,7 +108,7 @@ config HVC_DCC_SERIALIZE_SMP
 
 config HVC_RISCV_SBI
 	bool "RISC-V SBI console support"
-	depends on RISCV_SBI_V01
+	depends on RISCV_SBI
 	select HVC_DRIVER
 	help
 	  This enables support for console output via RISC-V SBI calls, which
diff --git a/drivers/tty/hvc/hvc_riscv_sbi.c b/drivers/tty/hvc/hvc_riscv_sbi.c
index 31f53fa77e4a..dee96c593c83 100644
--- a/drivers/tty/hvc/hvc_riscv_sbi.c
+++ b/drivers/tty/hvc/hvc_riscv_sbi.c
@@ -11,10 +11,12 @@
 #include <linux/moduleparam.h>
 #include <linux/types.h>
 
+#include <asm/cove.h>
 #include <asm/sbi.h>
 
 #include "hvc_console.h"
 
+#ifdef CONFIG_RISCV_SBI_V01
 static int hvc_sbi_tty_put(uint32_t vtermno, const char *buf, int count)
 {
 	int i;
@@ -39,21 +41,90 @@ static int hvc_sbi_tty_get(uint32_t vtermno, char *buf, int count)
 	return i;
 }
 
-static const struct hv_ops hvc_sbi_ops = {
+static const struct hv_ops hvc_sbi_v01_ops = {
 	.get_chars = hvc_sbi_tty_get,
 	.put_chars = hvc_sbi_tty_put,
 };
+#endif
 
-static int __init hvc_sbi_init(void)
+static int hvc_sbi_dbcn_tty_put(uint32_t vtermno, const char *buf, int count)
 {
-	return PTR_ERR_OR_ZERO(hvc_alloc(0, 0, &hvc_sbi_ops, 16));
+	phys_addr_t pa;
+	struct sbiret ret;
+
+	if (is_vmalloc_addr(buf))
+		pa = page_to_phys(vmalloc_to_page(buf)) + offset_in_page(buf);
+	else
+		pa = __pa(buf);
+
+	ret = sbi_ecall(SBI_EXT_DBCN, SBI_EXT_DBCN_CONSOLE_WRITE,
+#ifdef CONFIG_32BIT
+		  count, pa, (u64)pa >> 32,
+#else
+		  count, pa, 0,
+#endif
+		  0, 0, 0);
+
+	if (ret.error)
+		return 0;
+
+	return count;
 }
-device_initcall(hvc_sbi_init);
 
-static int __init hvc_sbi_console_init(void)
+static int hvc_sbi_dbcn_tty_get(uint32_t vtermno, char *buf, int count)
+{
+	phys_addr_t pa;
+	struct sbiret ret;
+
+	if (is_vmalloc_addr(buf))
+		pa = page_to_phys(vmalloc_to_page(buf)) + offset_in_page(buf);
+	else
+		pa = __pa(buf);
+
+	ret = sbi_ecall(SBI_EXT_DBCN, SBI_EXT_DBCN_CONSOLE_READ,
+#ifdef CONFIG_32BIT
+		  count, pa, (u64)pa >> 32,
+#else
+		  count, pa, 0,
+#endif
+		  0, 0, 0);
+
+	if (ret.error)
+		return 0;
+
+	return ret.value;
+}
+
+static const struct hv_ops hvc_sbi_dbcn_ops = {
+	.put_chars = hvc_sbi_dbcn_tty_put,
+	.get_chars = hvc_sbi_dbcn_tty_get,
+};
+
+static int __init hvc_sbi_init(void)
 {
-	hvc_instantiate(0, 0, &hvc_sbi_ops);
+	int err;
+
+	/* Prefer virtio console as hvc console for guests */
+	if (is_cove_guest())
+		return 0;
+
+	if ((sbi_spec_version >= sbi_mk_version(1, 0)) &&
+	    (sbi_probe_extension(SBI_EXT_DBCN) > 0)) {
+		err = PTR_ERR_OR_ZERO(hvc_alloc(0, 0, &hvc_sbi_dbcn_ops, 16));
+		if (err)
+			return err;
+		hvc_instantiate(0, 0, &hvc_sbi_dbcn_ops);
+	} else {
+#ifdef CONFIG_RISCV_SBI_V01
+		err = PTR_ERR_OR_ZERO(hvc_alloc(0, 0, &hvc_sbi_v01_ops, 16));
+		if (err)
+			return err;
+		hvc_instantiate(0, 0, &hvc_sbi_v01_ops);
+#else
+		return -ENODEV;
+#endif
+	}
 
 	return 0;
 }
-console_initcall(hvc_sbi_console_init);
+device_initcall(hvc_sbi_init);
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index bdc568a4ab66..cec46091a716 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -87,7 +87,7 @@ config SERIAL_EARLYCON_SEMIHOST
 
 config SERIAL_EARLYCON_RISCV_SBI
 	bool "Early console using RISC-V SBI"
-	depends on RISCV_SBI_V01
+	depends on RISCV_SBI
 	select SERIAL_CORE
 	select SERIAL_CORE_CONSOLE
 	select SERIAL_EARLYCON
diff --git a/drivers/tty/serial/earlycon-riscv-sbi.c b/drivers/tty/serial/earlycon-riscv-sbi.c
index 27afb0b74ea7..ac4c875f9580 100644
--- a/drivers/tty/serial/earlycon-riscv-sbi.c
+++ b/drivers/tty/serial/earlycon-riscv-sbi.c
@@ -9,23 +9,130 @@
 #include <linux/init.h>
 #include <linux/serial_core.h>
 #include <asm/sbi.h>
+#include <asm/cove.h>
+#include <asm/covg_sbi.h>
+#include <linux/memblock.h>
 
+#ifdef CONFIG_RISCV_COVE_GUEST
+#define DBCN_BOUNCE_BUF_SIZE (PAGE_SIZE)
+static char dbcn_buf[DBCN_BOUNCE_BUF_SIZE] __aligned(PAGE_SIZE);
+#endif
+
+#ifdef CONFIG_RISCV_SBI_V01
 static void sbi_putc(struct uart_port *port, unsigned char c)
 {
 	sbi_console_putchar(c);
 }
 
-static void sbi_console_write(struct console *con,
-			      const char *s, unsigned n)
+static void sbi_0_1_console_write(struct console *con,
+				  const char *s, unsigned n)
 {
 	struct earlycon_device *dev = con->data;
 	uart_console_write(&dev->port, s, n, sbi_putc);
 }
+#endif
+
+#ifdef CONFIG_RISCV_COVE_GUEST
+static void sbi_dbcn_console_write_cove(struct console *con, const char *s,
+					unsigned int n)
+{
+	phys_addr_t pa = __pa(dbcn_buf);
+	unsigned int off = 0;
+
+	pr_warn("ACE %s: sbi_dbcn_console_write_cove\n", __func__);
+
+	while (off < n) {
+		const unsigned int rem = n - off;
+		const unsigned int size =
+			rem > DBCN_BOUNCE_BUF_SIZE ? DBCN_BOUNCE_BUF_SIZE : rem;
+
+		memcpy(dbcn_buf, &s[off], size);
+
+		sbi_ecall(SBI_EXT_DBCN, SBI_EXT_DBCN_CONSOLE_WRITE,
+#ifdef CONFIG_32BIT
+			  size, pa, (u64)pa >> 32,
+#else
+			  size, pa, 0,
+#endif
+			  0, 0, 0);
+
+		off += size;
+	}
+}
+#endif
+
+// static void sbi_dbcn_console_write(struct console *con,
+// 				   const char *s, unsigned n)
+// {
+// 	phys_addr_t pa = __pa(s);
+
+// 	sbi_ecall(SBI_EXT_DBCN, SBI_EXT_DBCN_CONSOLE_WRITE,
+// #ifdef CONFIG_32BIT
+// 		  n, pa, (u64)pa >> 32,
+// #else
+// 		  n, pa, 0,
+// #endif
+// 		  0, 0, 0);
+// }
+
+// ACE possible
+static void sbi_dbcn_console_write(struct console *con,
+				   const char *s, unsigned int n)
+{
+	int ret;
+
+	while (n) {
+		ret = sbi_debug_console_write(s, n);
+		if (ret < 0)
+			break;
+
+		s += ret;
+		n -= ret;
+	}
+}
 
 static int __init early_sbi_setup(struct earlycon_device *device,
 				  const char *opt)
 {
-	device->con->write = sbi_console_write;
-	return 0;
+	int ret = 0;
+
+	/* TODO: Check for SBI debug console (DBCN) extension */
+	pr_warn("ACE %s: early_sbi_setup\n", __func__);
+	if ((sbi_spec_version >= sbi_mk_version(1, 0)) &&
+	    (sbi_probe_extension(SBI_EXT_DBCN) > 0)) {
+#ifdef CONFIG_RISCV_COVE_GUEST
+		pr_warn("ACE %s: early_sbi_setup 2\n", __func__);
+		if (is_cove_guest()) {
+			pr_warn("ACE %s: early_sbi_setup 3\n", __func__);
+			ret = sbi_covg_share_memory(__pa(dbcn_buf),
+						    DBCN_BOUNCE_BUF_SIZE);
+			if (ret)
+				return ret;
+
+			pr_warn("ACE %s: early_sbi_setup 4\n", __func__);
+			device->con->write = sbi_dbcn_console_write_cove;
+			return 0;
+		}
+#endif
+		device->con->write = sbi_dbcn_console_write;
+	} else {
+#ifdef CONFIG_RISCV_SBI_V01
+		device->con->write = sbi_0_1_console_write;
+#else
+		ret = -ENODEV;
+#endif
+	}
+
+	return ret;
+
+	// ACE possible conflict
+	// if (sbi_debug_console_available)
+	// 	device->con->write = sbi_dbcn_console_write;
+	// else if (IS_ENABLED(CONFIG_RISCV_SBI_V01))
+	// 	device->con->write = sbi_0_1_console_write;
+	// else
+	// 	return -ENODEV;
+
+	// return 0;
 }
 EARLYCON_DECLARE(sbi, early_sbi_setup);
diff --git a/drivers/usb/dwc3/Kconfig b/drivers/usb/dwc3/Kconfig
index 98efcbb76c88..3571543e8348 100644
--- a/drivers/usb/dwc3/Kconfig
+++ b/drivers/usb/dwc3/Kconfig
@@ -118,6 +118,15 @@ config USB_DWC3_OF_SIMPLE
 	  Currently supports Xilinx and Qualcomm DWC USB3 IP.
 	  Say 'Y' or 'M' if you have one such device.
 
+config USB_DWC3_ESWIN
+	tristate "Eswin Platforms"
+	depends on OF
+	depends on USB=y || USB=USB_DWC3
+	default USB_DWC3
+	help
+	  Support of USB2/3 functionality in Eswin platforms.
+	  say 'Y' or 'M' if you have one such device.
+
 config USB_DWC3_ST
 	tristate "STMicroelectronics Platforms"
 	depends on (ARCH_STI || COMPILE_TEST) && OF
diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index fe1493d4bbe5..d75a79bb453c 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -55,3 +55,4 @@ obj-$(CONFIG_USB_DWC3_QCOM)		+= dwc3-qcom.o
 obj-$(CONFIG_USB_DWC3_IMX8MP)		+= dwc3-imx8mp.o
 obj-$(CONFIG_USB_DWC3_XILINX)		+= dwc3-xilinx.o
 obj-$(CONFIG_USB_DWC3_OCTEON)		+= dwc3-octeon.o
+obj-$(CONFIG_USB_DWC3_ESWIN)		+= dwc3-eswin.o
diff --git a/drivers/usb/dwc3/dwc3-eswin.c b/drivers/usb/dwc3/dwc3-eswin.c
new file mode 100755
index 000000000000..7536bd282340
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-eswin.c
@@ -0,0 +1,673 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * eswin Specific Glue layer
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: Han Min <hanmin@eswincomputing.com>
+ */
+
+#include <linux/async.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/pm_runtime.h>
+#include <linux/extcon.h>
+#include <linux/freezer.h>
+#include <linux/iopoll.h>
+#include <linux/reset.h>
+#include <linux/usb.h>
+#include <linux/pm.h>
+#include <linux/usb/hcd.h>
+#include <linux/usb/ch9.h>
+#include <linux/extcon-provider.h>
+#include <linux/iommu.h>
+#include <linux/mfd/syscon.h>
+#include <linux/bitfield.h>
+#include <linux/eic7700-sid-cfg.h>
+#include <linux/regmap.h>
+#include <linux/gpio/consumer.h>
+#include "core.h"
+#include "io.h"
+
+#define AWSMMUSID GENMASK(31, 24) // The sid of write operation
+#define AWSMMUSSID GENMASK(23, 16) // The ssid of write operation
+#define ARSMMUSID GENMASK(15, 8) // The sid of read operation
+#define ARSMMUSSID GENMASK(7, 0) // The ssid of read operation
+
+#define HSP_USB_VBUS_FSEL 0x2a
+#define HSP_USB_MPLL_DEFAULT 0x0
+
+#define HSP_USB_BUS_FILTER_EN (0x1 << 0)
+#define HSP_USB_BUS_CLKEN_GM (0x1 << 9)
+#define HSP_USB_BUS_CLKEN_GS (0x1 << 16)
+#define HSP_USB_BUS_SW_RST (0x1 << 24)
+#define HSP_USB_BUS_CLK_EN (0x1 << 28)
+
+#define HSP_USB_AXI_LP_XM_CSYSREQ (0x1 << 0)
+#define HSP_USB_AXI_LP_XS_CSYSREQ (0x1 << 16)
+
+struct dwc3_eswin {
+	int num_clocks;
+	bool connected;
+	bool suspended;
+	bool force_mode;
+	bool is_phy_on;
+	struct device *dev;
+	struct clk **clks;
+	struct dwc3 *dwc;
+	struct extcon_dev *edev;
+	struct usb_hcd *hcd;
+	struct notifier_block device_nb;
+	struct notifier_block host_nb;
+	struct work_struct otg_work;
+	struct mutex lock;
+	struct reset_control *vaux_rst;
+	struct device *child_dev;
+	enum usb_role new_usb_role;
+};
+
+static ssize_t dwc3_mode_show(struct device *device,
+			      struct device_attribute *attr, char *buf)
+{
+	struct dwc3_eswin *eswin = dev_get_drvdata(device);
+	struct dwc3 *dwc = eswin->dwc;
+	int ret;
+
+	switch (dwc->current_dr_role) {
+	case USB_DR_MODE_HOST:
+		ret = sprintf(buf, "host\n");
+		break;
+	case USB_DR_MODE_PERIPHERAL:
+		ret = sprintf(buf, "peripheral\n");
+		break;
+	case USB_DR_MODE_OTG:
+		ret = sprintf(buf, "otg\n");
+		break;
+	default:
+		ret = sprintf(buf, "UNKNOWN\n");
+	}
+
+	return ret;
+}
+
+static ssize_t dwc3_mode_store(struct device *device,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct dwc3_eswin *eswin = dev_get_drvdata(device);
+	struct dwc3 *dwc = eswin->dwc;
+	enum usb_role new_role;
+	struct usb_role_switch *role_sw = dwc->role_sw;
+
+	if (!strncmp(buf, "1", 1) || !strncmp(buf, "host", 4)) {
+		new_role = USB_ROLE_HOST;
+	} else if (!strncmp(buf, "0", 1) || !strncmp(buf, "peripheral", 10)) {
+		new_role = USB_ROLE_DEVICE;
+	} else {
+		dev_info(eswin->dev, "illegal dr_mode\n");
+		return count;
+	}
+	eswin->force_mode = true;
+
+	mutex_lock(&eswin->lock);
+	usb_role_switch_set_role(role_sw, new_role);
+	mutex_unlock(&eswin->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(dwc3_mode);
+
+static struct attribute *dwc3_eswin_attrs[] = {
+	&dev_attr_dwc3_mode.attr,
+	NULL,
+};
+
+static struct attribute_group dwc3_eswin_attr_group = {
+	.name = NULL, /* we want them in the same directory */
+	.attrs = dwc3_eswin_attrs,
+};
+
+static int dwc3_eswin_device_notifier(struct notifier_block *nb,
+					 unsigned long event, void *ptr)
+{
+	struct dwc3_eswin *eswin =
+		container_of(nb, struct dwc3_eswin, device_nb);
+
+	mutex_lock(&eswin->lock);
+	eswin->new_usb_role = USB_ROLE_DEVICE;
+	mutex_unlock(&eswin->lock);
+	if (!eswin->suspended)
+		schedule_work(&eswin->otg_work);
+
+	return NOTIFY_DONE;
+}
+
+static int dwc3_eswin_host_notifier(struct notifier_block *nb,
+				    unsigned long event, void *ptr)
+{
+	struct dwc3_eswin *eswin = container_of(nb, struct dwc3_eswin, host_nb);
+	mutex_lock(&eswin->lock);
+	eswin->new_usb_role = USB_ROLE_HOST;
+	mutex_unlock(&eswin->lock);
+	if (!eswin->suspended)
+		schedule_work(&eswin->otg_work);
+
+	return NOTIFY_DONE;
+}
+
+static void dwc3_eswin_otg_extcon_evt_work(struct work_struct *work)
+{
+	struct dwc3_eswin *eswin =
+		container_of(work, struct dwc3_eswin, otg_work);
+	struct usb_role_switch *role_sw = eswin->dwc->role_sw;
+	if (true == eswin->force_mode) {
+		return;
+	}
+	mutex_lock(&eswin->lock);
+	usb_role_switch_set_role(role_sw, eswin->new_usb_role);
+	mutex_unlock(&eswin->lock);
+}
+
+static int dwc3_eswin_get_extcon_dev(struct dwc3_eswin *eswin)
+{
+	struct device *dev = eswin->dev;
+	struct extcon_dev *edev;
+	s32 ret = 0;
+
+	if (device_property_read_bool(dev, "extcon")) {
+		edev = extcon_get_edev_by_phandle(dev, 0);
+		if (IS_ERR(edev)) {
+			if (PTR_ERR(edev) != -EPROBE_DEFER)
+				dev_err(dev, "couldn't get extcon device\n");
+			return PTR_ERR(edev);
+		}
+		eswin->edev = edev;
+		eswin->device_nb.notifier_call = dwc3_eswin_device_notifier;
+		ret = devm_extcon_register_notifier(dev, edev, EXTCON_USB,
+						    &eswin->device_nb);
+		if (ret < 0)
+			dev_err(dev, "failed to register notifier for USB\n");
+
+		eswin->host_nb.notifier_call = dwc3_eswin_host_notifier;
+		ret = devm_extcon_register_notifier(dev, edev, EXTCON_USB_HOST,
+						    &eswin->host_nb);
+		if (ret < 0)
+			dev_err(dev, "failed to register notifier for USB-HOST\n");
+	}
+
+	return 0;
+}
+
+static int __init dwc3_eswin_deassert(struct dwc3_eswin *eswin)
+{
+	int rc;
+
+	if (eswin->vaux_rst) {
+		rc = reset_control_deassert(eswin->vaux_rst);
+		WARN_ON(0 != rc);
+	}
+
+	return 0;
+}
+
+static int dwc3_eswin_assert(struct dwc3_eswin *eswin)
+{
+	int rc = 0;
+
+	if (eswin->vaux_rst) {
+		rc = reset_control_assert(eswin->vaux_rst);
+		WARN_ON(0 != rc);
+	}
+
+	return 0;
+}
+
+static int dwc_usb_clk_init(struct device *dev)
+{
+	struct regmap *regmap;
+	u32 hsp_usb_bus;
+	u32 hsp_usb_axi_lp;
+	u32 hsp_usb_vbus_freq;
+	u32 hsp_usb_mpll;
+	int ret;
+
+	regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "eswin,hsp_sp_csr");
+	if (IS_ERR(regmap)) {
+		dev_dbg(dev, "No hsp_sp_csr phandle specified\n");
+		return -1;
+	}
+	ret = of_property_read_u32_index(dev->of_node, "eswin,hsp_sp_csr", 1,
+				&hsp_usb_bus);
+	if (ret) {
+		dev_err(dev, "can't get usb sid cfg reg offset (%d)\n", ret);
+		return ret;
+	}
+	ret = of_property_read_u32_index(dev->of_node, "eswin,hsp_sp_csr", 2,
+				&hsp_usb_axi_lp);
+	if (ret) {
+		dev_err(dev, "can't get usb sid cfg reg offset (%d)\n", ret);
+		return ret;
+	}
+	ret = of_property_read_u32_index(dev->of_node, "eswin,hsp_sp_csr", 3,
+				&hsp_usb_vbus_freq);
+	if (ret) {
+		dev_err(dev, "can't get usb sid cfg reg offset (%d)\n", ret);
+		return ret;
+	}
+	ret = of_property_read_u32_index(dev->of_node, "eswin,hsp_sp_csr", 4,
+				&hsp_usb_mpll);
+	if (ret) {
+		dev_err(dev, "can't get usb sid cfg reg offset (%d)\n", ret);
+		return ret;
+	}
+
+	/*
+	 * usb1 clock init
+	 * ref clock is 24M, below need to be set to satisfy usb phy requirement(125M)
+	 */
+	regmap_write(regmap, hsp_usb_vbus_freq, HSP_USB_VBUS_FSEL);
+	regmap_write(regmap, hsp_usb_mpll, HSP_USB_MPLL_DEFAULT);
+
+	/*
+	 * reset usb core and usb phy
+	 */
+	regmap_write(regmap, hsp_usb_bus,
+		     HSP_USB_BUS_FILTER_EN | HSP_USB_BUS_CLKEN_GM |
+			     HSP_USB_BUS_CLKEN_GS | HSP_USB_BUS_SW_RST |
+			     HSP_USB_BUS_CLK_EN);
+	regmap_write(regmap, hsp_usb_axi_lp,
+		     HSP_USB_AXI_LP_XM_CSYSREQ | HSP_USB_AXI_LP_XS_CSYSREQ);
+
+	return 0;
+}
+
+int dwc3_sid_cfg(struct device *dev)
+{
+	int ret;
+	struct regmap *regmap;
+	int hsp_mmu_usb_reg;
+	u32 rdwr_sid_ssid;
+	u32 sid;
+	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+
+	/* not behind smmu, use the default reset value(0x0) of the reg as streamID*/
+	if (fwspec == NULL) {
+		dev_dbg(dev, "dev is not behind smmu, skip configuration of sid\n");
+		return 0;
+	}
+	sid = fwspec->ids[0];
+
+	regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "eswin,hsp_sp_csr");
+	if (IS_ERR(regmap)) {
+		dev_dbg(dev, "No hsp_sp_csr phandle specified\n");
+		return 0;
+	}
+
+	ret = of_property_read_u32_index(dev->of_node, "eswin,hsp_sp_csr", 1,
+				&hsp_mmu_usb_reg);
+	if (ret) {
+		dev_err(dev, "can't get usb sid cfg reg offset (%d)\n", ret);
+		return ret;
+	}
+
+	/* make the reading sid the same as writing sid, ssid is fixed to zero */
+	rdwr_sid_ssid = FIELD_PREP(AWSMMUSID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(ARSMMUSID, sid);
+	rdwr_sid_ssid |= FIELD_PREP(AWSMMUSSID, 0);
+	rdwr_sid_ssid |= FIELD_PREP(ARSMMUSSID, 0);
+	regmap_write(regmap, hsp_mmu_usb_reg, rdwr_sid_ssid);
+
+	ret = eic7700_dynm_sid_enable(dev_to_node(dev));
+	if (ret < 0)
+	{
+		dev_err(dev, "failed to config usb streamID(%d)!\n", sid);
+	}
+	else
+	{
+		dev_dbg(dev, "success to config usb streamID(%d)!\n", sid);
+	}
+
+	return ret;
+}
+
+static int dwc3_eswin_probe(struct platform_device *pdev)
+{
+	struct dwc3_eswin *eswin;
+	struct device *dev = &pdev->dev;
+	struct device_node *np = dev->of_node, *child;
+	struct platform_device *child_pdev;
+	unsigned int count;
+	int ret;
+	int i;
+	int err_desc = 0;
+	struct gpio_desc *hub_gpio;
+
+	hub_gpio = devm_gpiod_get(dev, "hub-rst", GPIOD_OUT_HIGH);
+	err_desc = IS_ERR(hub_gpio);
+
+	if (!err_desc) {
+		gpiod_set_raw_value(hub_gpio, 1);
+	}
+
+	eswin = devm_kzalloc(dev, sizeof(*eswin), GFP_KERNEL);
+	if (!eswin)
+		return -ENOMEM;
+
+	count = of_clk_get_parent_count(np);
+	if (!count)
+		return -ENOENT;
+
+	eswin->num_clocks = count;
+	eswin->force_mode = false;
+	eswin->clks = devm_kcalloc(dev, eswin->num_clocks, sizeof(struct clk *),
+				   GFP_KERNEL);
+	if (!eswin->clks)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, eswin);
+
+	mutex_init(&eswin->lock);
+
+	eswin->dev = dev;
+
+	mutex_lock(&eswin->lock);
+
+	for (i = 0; i < eswin->num_clocks; i++) {
+		struct clk *clk;
+		clk = of_clk_get(np, i);
+		if (IS_ERR(clk)) {
+			ret = PTR_ERR(clk);
+			goto err0;
+		}
+		ret = clk_prepare_enable(clk);
+		if (ret < 0) {
+			clk_put(clk);
+			goto err0;
+		}
+
+		eswin->clks[i] = clk;
+	}
+
+	eswin->vaux_rst = devm_reset_control_get(dev, "vaux");
+	if (IS_ERR_OR_NULL(eswin->vaux_rst)) {
+		dev_err(dev, "Failed to asic0_rst handle\n");
+		return -EFAULT;
+	}
+
+	dwc3_eswin_deassert(eswin);
+	dwc_usb_clk_init(dev);
+
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	ret = pm_runtime_get_sync(dev);
+	if (ret < 0) {
+		dev_err(dev, "get_sync failed with err %d\n", ret);
+		goto err1;
+	}
+
+	child = of_get_child_by_name(np, "dwc3");
+	if (!child) {
+		dev_err(dev, "failed to find dwc3 core node\n");
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	/* Allocate and initialize the core */
+	ret = of_platform_populate(np, NULL, NULL, dev);
+	if (ret) {
+		dev_err(dev, "failed to create dwc3 core\n");
+		goto err1;
+	}
+
+	INIT_WORK(&eswin->otg_work, dwc3_eswin_otg_extcon_evt_work);
+
+	child_pdev = of_find_device_by_node(child);
+	if (!child_pdev) {
+		dev_err(dev, "failed to find dwc3 core device\n");
+		ret = -ENODEV;
+		goto err2;
+	}
+
+	eswin->dwc = platform_get_drvdata(child_pdev);
+	if (!eswin->dwc) {
+		dev_err(dev, "failed to get drvdata dwc3\n");
+		ret = -EPROBE_DEFER;
+		goto err2;
+	}
+	eswin->child_dev = &child_pdev->dev;
+
+	ret = eic7700_tbu_power(eswin->child_dev, true);
+	if (ret)
+	{
+		dev_err(dev, "tbu power on failed %d\n", ret);
+		goto err2;
+	}
+
+	ret = dwc3_sid_cfg(&child_pdev->dev);
+	if (ret)
+		goto err3;
+
+	ret = dwc3_eswin_get_extcon_dev(eswin);
+	if (ret < 0)
+		goto err3;
+
+	mutex_unlock(&eswin->lock);
+	ret = sysfs_create_group(&dev->kobj, &dwc3_eswin_attr_group);
+	if (ret)
+		dev_err(dev, "failed to create sysfs group: %d\n", ret);
+
+	return ret;
+
+err3:
+	ret = eic7700_tbu_power(eswin->child_dev, false);
+	if (ret)
+	{
+		dev_err(dev, "tbu power2 off failed %d\n", ret);
+	}
+
+err2:
+	cancel_work_sync(&eswin->otg_work);
+	of_platform_depopulate(dev);
+
+err1:
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+	dwc3_eswin_assert(eswin);
+
+err0:
+	for (i = 0; i < eswin->num_clocks && eswin->clks[i]; i++) {
+		if (!pm_runtime_status_suspended(dev))
+			clk_disable(eswin->clks[i]);
+		clk_unprepare(eswin->clks[i]);
+		clk_put(eswin->clks[i]);
+	}
+
+	mutex_unlock(&eswin->lock);
+
+	return ret;
+}
+
+static int dwc3_eswin_remove(struct platform_device *pdev)
+{
+	struct dwc3_eswin *eswin = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+	int i = 0;
+	int ret = 0;
+	cancel_work_sync(&eswin->otg_work);
+
+	sysfs_remove_group(&dev->kobj, &dwc3_eswin_attr_group);
+
+	/* Restore hcd state before unregistering xhci */
+	if (eswin->edev && !eswin->connected) {
+		struct usb_hcd *hcd = dev_get_drvdata(&eswin->dwc->xhci->dev);
+
+		pm_runtime_get_sync(dev);
+
+		/*
+		 * The xhci code does not expect that HCDs have been removed.
+		 * It will unconditionally call usb_remove_hcd() when the xhci
+		 * driver is unloaded in of_platform_depopulate(). This results
+		 * in a crash if the HCDs were already removed. To avoid this
+		 * crash, add the HCDs here as dummy operation.
+		 * This code should be removed after pm runtime support
+		 * has been added to xhci.
+		 */
+		if (hcd->state == HC_STATE_HALT) {
+			usb_add_hcd(hcd, hcd->irq, IRQF_SHARED);
+			usb_add_hcd(hcd->shared_hcd, hcd->irq, IRQF_SHARED);
+		}
+	}
+
+	of_platform_depopulate(dev);
+
+	pm_runtime_put_sync(dev);
+	pm_runtime_disable(dev);
+
+	ret = eic7700_tbu_power(eswin->child_dev, false);
+	if (ret)
+	{
+		dev_err(dev, "tbu power off failed %d\n", ret);
+	}
+
+	dwc3_eswin_assert(eswin);
+	for (i = 0; i < eswin->num_clocks; i++) {
+		if (!pm_runtime_status_suspended(dev))
+			clk_disable(eswin->clks[i]);
+		clk_unprepare(eswin->clks[i]);
+		clk_put(eswin->clks[i]);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int dwc3_eswin_runtime_suspend(struct device *dev)
+{
+	struct dwc3_eswin *eswin = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < eswin->num_clocks; i++)
+		clk_disable(eswin->clks[i]);
+
+	device_init_wakeup(dev, false);
+
+	return 0;
+}
+
+static int dwc3_eswin_runtime_resume(struct device *dev)
+{
+	struct dwc3_eswin *eswin = dev_get_drvdata(dev);
+	int i;
+
+	for (i = 0; i < eswin->num_clocks; i++)
+		clk_enable(eswin->clks[i]);
+
+	device_init_wakeup(dev, true);
+
+	return 0;
+}
+
+static int __maybe_unused dwc3_eswin_suspend(struct device *dev)
+{
+	struct dwc3_eswin *eswin = dev_get_drvdata(dev);
+	struct dwc3 *dwc = eswin->dwc;
+
+	eswin->suspended = true;
+	cancel_work_sync(&eswin->otg_work);
+
+	/*
+	 * The flag of is_phy_on is only true if
+	 * the DWC3 is in Host mode.
+	 */
+	if (eswin->is_phy_on) {
+		phy_power_off(dwc->usb2_generic_phy);
+
+		/*
+		 * If link state is Rx.Detect, it means that
+		 * no usb device is connecting with the DWC3
+		 * Host, and need to power off the USB3 PHY.
+		 */
+		dwc->link_state = dwc3_gadget_get_link_state(dwc);
+		if (dwc->link_state == DWC3_LINK_STATE_RX_DET)
+			phy_power_off(dwc->usb3_generic_phy);
+	}
+
+	return 0;
+}
+
+static int __maybe_unused dwc3_eswin_resume(struct device *dev)
+{
+	struct dwc3_eswin *eswin = dev_get_drvdata(dev);
+	struct dwc3 *dwc = eswin->dwc;
+
+	eswin->suspended = false;
+
+	if (eswin->is_phy_on) {
+		phy_power_on(dwc->usb2_generic_phy);
+
+		if (dwc->link_state == DWC3_LINK_STATE_RX_DET)
+			phy_power_on(dwc->usb3_generic_phy);
+	}
+
+	if (eswin->edev)
+		schedule_work(&eswin->otg_work);
+
+	return 0;
+}
+
+static const struct dev_pm_ops dwc3_eswin_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dwc3_eswin_suspend, dwc3_eswin_resume)
+	SET_RUNTIME_PM_OPS(dwc3_eswin_runtime_suspend,
+			   dwc3_eswin_runtime_resume, NULL)
+};
+
+#define DEV_PM_OPS      (&dwc3_eswin_dev_pm_ops)
+#else
+#define DEV_PM_OPS	NULL
+#endif /* CONFIG_PM */
+
+static const struct of_device_id eswin_dwc3_match[] = {
+	{ .compatible = "eswin,eic7700-dwc3" },
+	{ /* Sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, eswin_dwc3_match);
+
+static struct platform_driver dwc3_eswin_driver = {
+	.probe		= dwc3_eswin_probe,
+	.remove		= dwc3_eswin_remove,
+	.driver		= {
+		.name	= "eswin-dwc3",
+		.pm	= DEV_PM_OPS,
+		.of_match_table = eswin_dwc3_match,
+	},
+};
+
+module_platform_driver(dwc3_eswin_driver);
+
+MODULE_ALIAS("platform:eswin-dwc3");
+MODULE_AUTHOR("Han Min <hanmin@eswin.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("DesignWare USB3 ESWIN Glue Layer");
diff --git a/drivers/usb/typec/tcpm/Kconfig b/drivers/usb/typec/tcpm/Kconfig
index 0b2993fef564..760fd03fc751 100644
--- a/drivers/usb/typec/tcpm/Kconfig
+++ b/drivers/usb/typec/tcpm/Kconfig
@@ -63,6 +63,15 @@ config TYPEC_FUSB302
 	  Type-C Port Controller Manager to provide USB PD and USB
 	  Type-C functionalities.
 
+config TYPEC_FUSB303B
+	tristate "Onsemi FUSB303B Type-C chip driver"
+	depends on I2C
+	depends on EXTCON || !EXTCON
+	help
+	  The Onsemi FUSB303B Type-C chip driver that works with
+	  Type-C Port Controller Manager to provide USB
+	  Type-C functionalities.
+
 config TYPEC_WCOVE
 	tristate "Intel WhiskeyCove PMIC USB Type-C PHY driver"
 	depends on ACPI
diff --git a/drivers/usb/typec/tcpm/Makefile b/drivers/usb/typec/tcpm/Makefile
index 7a8cad0c0bdb..d2b501e32012 100644
--- a/drivers/usb/typec/tcpm/Makefile
+++ b/drivers/usb/typec/tcpm/Makefile
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0
 obj-$(CONFIG_TYPEC_TCPM)		+= tcpm.o
 obj-$(CONFIG_TYPEC_FUSB302)		+= fusb302.o
+obj-$(CONFIG_TYPEC_FUSB303B)		+= fusb303b.o
 obj-$(CONFIG_TYPEC_WCOVE)		+= typec_wcove.o
 typec_wcove-y				:= wcove.o
 obj-$(CONFIG_TYPEC_TCPCI)		+= tcpci.o
diff --git a/drivers/usb/typec/tcpm/fusb303b.c b/drivers/usb/typec/tcpm/fusb303b.c
new file mode 100644
index 000000000000..b17c554c2b66
--- /dev/null
+++ b/drivers/usb/typec/tcpm/fusb303b.c
@@ -0,0 +1,643 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Onsemi FUSB303B Type-C Chip Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: Yang Wei <yangwei1@eswincomputing.com>
+ */
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/proc_fs.h>
+#include <linux/regulator/consumer.h>
+#include <linux/sched/clock.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/usb.h>
+#include <linux/usb/typec.h>
+#include <linux/usb/tcpm.h>
+#include <linux/usb/pd.h>
+#include <linux/workqueue.h>
+
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/usb/role.h>
+
+#define FUSB303B_REG_DEVICE_ID 0X1
+#define FUSB303B_REG_DEVICE_TYPE 0X2
+#define FUSB303B_REG_PORTROLE 0X3
+#define FUSB303B_REG_CONTROL 0X4
+#define FUSB303B_REG_CONTROL1 0X5
+#define FUSB303B_REG_RESET 0XA
+#define FUSB303B_REG_MASK 0XE
+#define FUSB303B_REG_MASK1 0XF
+#define FUSB303B_REG_STATUS 0X11
+#define FUSB303B_REG_TYPE 0X13
+#define FUSB303B_REG_INTERRUPT 0X14
+#define FUSB303B_REG_INTERRUPT1 0X15
+
+#define FUSB303B_PORTROLE_DRP BIT(2)
+#define FUSB303B_PORTROLE_SINK BIT(1)
+#define FUSB303B_PORTROLE_SOURCE BIT(0)
+
+#define FUSB303B_CONTROL_DCABLE_EN BIT(3)
+#define FUSB303B_CONTROL_INT_MASK BIT(0)
+
+#define FUSB303B_CONTROL1_REMEDY_EN BIT(7)
+#define FUSB303B_CONTROL1_ENABLE BIT(3)
+
+#define FUSB303B_STATUS_VBUSOK BIT(3)
+#define FUSB303B_STATUS_ATTACH BIT(0)
+
+#define FUSB303B_INT_I_VBUS_CHG BIT(4)
+#define FUSB303B_INT_I_DETACH BIT(1)
+#define FUSB303B_INT_I_ATTACH BIT(0)
+
+#define FUSB303B_TYPE_SINK BIT(4)
+#define FUSB303B_TYPE_SOURCE BIT(3)
+
+#define FUSB_REG_MASK_M_VBUS_CHG BIT(4)
+#define FUSB_REG_MASK_M_DETACH BIT(1)
+#define FUSB_REG_MASK_M_ATTACH BIT(0)
+
+#define LOG_BUFFER_ENTRIES 1024
+#define LOG_BUFFER_ENTRY_SIZE 128
+
+struct fusb303b_chip
+{
+	struct device *dev;
+	struct i2c_client *i2c_client;
+	struct fwnode_handle *fwnode;
+	spinlock_t irq_lock;
+	struct work_struct irq_work;
+	struct gpio_desc *gpio_int_n;
+	int gpio_int_n_irq;
+	struct usb_role_switch *role_sw;
+	/* lock for sharing chip states */
+	struct mutex lock;
+	bool vbus_ok;
+	bool attch_ok;
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *dentry;
+	/* lock for log buffer access */
+	struct mutex logbuffer_lock;
+	int logbuffer_head;
+	int logbuffer_tail;
+	u8 *logbuffer[LOG_BUFFER_ENTRIES];
+#endif
+};
+
+#ifdef CONFIG_DEBUG_FS
+static bool fusb303b_log_full(struct fusb303b_chip *chip)
+{
+	return chip->logbuffer_tail ==
+	       (chip->logbuffer_head + 1) % LOG_BUFFER_ENTRIES;
+}
+
+__printf(2, 0) static void _fusb303b_log(struct fusb303b_chip *chip,
+					 const char *fmt, va_list args)
+{
+	char tmpbuffer[LOG_BUFFER_ENTRY_SIZE];
+	u64 ts_nsec = local_clock();
+	unsigned long rem_nsec;
+
+	if (!chip->logbuffer[chip->logbuffer_head]) {
+		chip->logbuffer[chip->logbuffer_head] =
+			kzalloc(LOG_BUFFER_ENTRY_SIZE, GFP_KERNEL);
+		if (!chip->logbuffer[chip->logbuffer_head])
+			return;
+	}
+
+	vsnprintf(tmpbuffer, sizeof(tmpbuffer), fmt, args);
+
+	mutex_lock(&chip->logbuffer_lock);
+
+	if (fusb303b_log_full(chip)) {
+		chip->logbuffer_head = max(chip->logbuffer_head - 1, 0);
+		strlcpy(tmpbuffer, "overflow", sizeof(tmpbuffer));
+	}
+
+	if (chip->logbuffer_head < 0 ||
+	    chip->logbuffer_head >= LOG_BUFFER_ENTRIES) {
+		dev_warn(chip->dev, "Bad log buffer index %d\n",
+			 chip->logbuffer_head);
+		goto abort;
+	}
+
+	if (!chip->logbuffer[chip->logbuffer_head]) {
+		dev_warn(chip->dev, "Log buffer index %d is NULL\n",
+			 chip->logbuffer_head);
+		goto abort;
+	}
+
+	rem_nsec = do_div(ts_nsec, 1000000000);
+	scnprintf(chip->logbuffer[chip->logbuffer_head], LOG_BUFFER_ENTRY_SIZE,
+		  "[%5lu.%06lu] %s", (unsigned long)ts_nsec, rem_nsec / 1000,
+		  tmpbuffer);
+	chip->logbuffer_head = (chip->logbuffer_head + 1) % LOG_BUFFER_ENTRIES;
+
+abort:
+	mutex_unlock(&chip->logbuffer_lock);
+}
+
+__printf(2, 3) static void fusb303b_log(struct fusb303b_chip *chip,
+					const char *fmt, ...)
+{
+	va_list args;
+
+	va_start(args, fmt);
+	_fusb303b_log(chip, fmt, args);
+	va_end(args);
+}
+
+static int fusb303b_debug_show(struct seq_file *s, void *v)
+{
+	struct fusb303b_chip *chip = (struct fusb303b_chip *)s->private;
+	int tail;
+
+	mutex_lock(&chip->logbuffer_lock);
+	tail = chip->logbuffer_tail;
+	while (tail != chip->logbuffer_head) {
+		seq_printf(s, "%s\n", chip->logbuffer[tail]);
+		tail = (tail + 1) % LOG_BUFFER_ENTRIES;
+	}
+	if (!seq_has_overflowed(s))
+		chip->logbuffer_tail = tail;
+	mutex_unlock(&chip->logbuffer_lock);
+
+	return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(fusb303b_debug);
+
+static void fusb303b_debugfs_init(struct fusb303b_chip *chip)
+{
+	char name[NAME_MAX];
+
+	mutex_init(&chip->logbuffer_lock);
+	snprintf(name, NAME_MAX, "fusb303b-%s", dev_name(chip->dev));
+	chip->dentry = debugfs_create_dir(name, usb_debug_root);
+	debugfs_create_file("log", S_IFREG | 0444, chip->dentry, chip,
+			    &fusb303b_debug_fops);
+}
+
+static void fusb303b_debugfs_exit(struct fusb303b_chip *chip)
+{
+	debugfs_remove(chip->dentry);
+}
+
+#else
+
+static void fusb303b_log(const struct fusb303b_chip *chip, const char *fmt, ...)
+{
+}
+static void fusb303b_debugfs_init(const struct fusb303b_chip *chip)
+{
+}
+static void fusb303b_debugfs_exit(const struct fusb303b_chip *chip)
+{
+}
+
+#endif
+
+static int fusb303b_i2c_write(struct fusb303b_chip *chip, u8 address, u8 data)
+{
+	int ret = 0;
+
+	ret = i2c_smbus_write_byte_data(chip->i2c_client, address, data);
+	if (ret < 0)
+		fusb303b_log(chip, "cannot write 0x%02x to 0x%02x, ret=%d",
+			     data, address, ret);
+
+	return ret;
+}
+
+static int fusb303b_i2c_read(struct fusb303b_chip *chip, u8 address, u8 *data)
+{
+	int ret = 0;
+
+	ret = i2c_smbus_read_byte_data(chip->i2c_client, address);
+	*data = (u8)ret;
+	if (ret < 0)
+		fusb303b_log(chip, "cannot read %02x, ret=%d", address, ret);
+
+	return ret;
+}
+
+static int fusb303b_i2c_mask_write(struct fusb303b_chip *chip, u8 address,
+				   u8 mask, u8 value)
+{
+	int ret = 0;
+	u8 data;
+
+	ret = fusb303b_i2c_read(chip, address, &data);
+	if (ret < 0)
+		return ret;
+	data &= ~mask;
+	data |= value;
+	ret = fusb303b_i2c_write(chip, address, data);
+	if (ret < 0)
+		return ret;
+
+	return ret;
+}
+
+static int fusb303b_i2c_clear_bits(struct fusb303b_chip *chip, u8 address,
+				   u8 clear_bits)
+{
+	return fusb303b_i2c_mask_write(chip, address, clear_bits, 0x00);
+}
+
+static int fusb303b_sw_reset(struct fusb303b_chip *chip)
+{
+	int ret = 0;
+
+	ret = fusb303b_i2c_write(chip, FUSB303B_REG_RESET, 1);
+	if (ret < 0)
+		fusb303b_log(chip, "cannot sw reset the chip, ret=%d", ret);
+	else
+		fusb303b_log(chip, "sw reset");
+
+	return ret;
+}
+
+/*
+ * initialize interrupt on the chip
+ * - unmasked interrupt: VBUS_OK
+ */
+static int fusb303b_init_interrupt(struct fusb303b_chip *chip)
+{
+	int ret = 0;
+	u8 int_unmask = FUSB_REG_MASK_M_VBUS_CHG |
+                        FUSB_REG_MASK_M_DETACH | FUSB_REG_MASK_M_ATTACH;
+	ret = fusb303b_i2c_write(chip, FUSB303B_REG_MASK,
+                                0xFF & ~(int_unmask));
+	if (ret < 0)
+		return ret;
+	ret = fusb303b_i2c_write(chip, FUSB303B_REG_MASK1, 0xFF);
+	if (ret < 0)
+		return ret;
+
+	ret = fusb303b_i2c_clear_bits(chip, FUSB303B_REG_CONTROL,
+                                    FUSB303B_CONTROL_INT_MASK);
+	if (ret < 0)
+		return ret;
+
+	return ret;
+}
+
+static int fusb303b_init(struct fusb303b_chip *chip)
+{
+	int ret = 0;
+	u8 data;
+
+	ret = fusb303b_sw_reset(chip);
+	if (ret < 0)
+		return ret;
+	fusb303b_i2c_read(chip, FUSB303B_REG_STATUS, &data);
+	fusb303b_i2c_mask_write(chip, FUSB303B_REG_CONTROL,
+                                FUSB303B_CONTROL_DCABLE_EN,
+                                FUSB303B_CONTROL_DCABLE_EN);
+	fusb303b_i2c_mask_write(chip, FUSB303B_REG_CONTROL1,
+                                FUSB303B_CONTROL1_ENABLE | FUSB303B_CONTROL1_REMEDY_EN,
+                                FUSB303B_CONTROL1_ENABLE | FUSB303B_CONTROL1_REMEDY_EN);
+	ret = fusb303b_init_interrupt(chip);
+	if (ret < 0)
+		return ret;
+
+	ret = fusb303b_i2c_read(chip, FUSB303B_REG_STATUS, &data);
+	if (ret < 0)
+		return ret;
+	chip->vbus_ok = !!(data & FUSB303B_STATUS_VBUSOK);
+	chip->attch_ok = !!(data & FUSB303B_STATUS_ATTACH);
+	ret = fusb303b_i2c_read(chip, FUSB303B_REG_DEVICE_ID, &data);
+	if (ret < 0)
+		return ret;
+	fusb303b_log(chip, "fusb303b device ID: 0x%02x", data);
+
+	ret = fusb303b_i2c_read(chip, FUSB303B_REG_DEVICE_TYPE, &data);
+	if (ret < 0)
+		return ret;
+	fusb303b_log(chip, "fusb303b type:0x%02x", data);
+
+	return ret;
+}
+
+static s32 fusb303b_set_port_check(struct fusb303b_chip *chip,
+                                    enum typec_port_type port_type)
+{
+	s32 ret = 0;
+
+	fusb303b_log(chip, "%s.%d port_type:%d",
+                    __FUNCTION__, __LINE__, port_type);
+	switch (port_type)
+	{
+            case TYPEC_PORT_DRP:
+                ret = fusb303b_i2c_write(chip, FUSB303B_REG_PORTROLE,
+                                        FUSB303B_PORTROLE_DRP);
+                break;
+            case TYPEC_PORT_SRC:
+                ret = fusb303b_i2c_write(chip, FUSB303B_REG_PORTROLE,
+                                        FUSB303B_PORTROLE_SOURCE);
+                break;
+            default:
+                ret = fusb303b_i2c_write(chip, FUSB303B_REG_PORTROLE,
+                                        FUSB303B_PORTROLE_SINK);
+                break;
+	}
+
+	return ret;
+}
+
+int fusb303b_set_usb_role(struct fusb303b_chip *chip)
+{
+	u8 type = 0;
+	int ret = 0;
+
+	if ((true == chip->attch_ok) && (true == chip->vbus_ok))
+	{
+		ret = fusb303b_i2c_read(chip, FUSB303B_REG_TYPE, &type);
+		if (ret < 0)
+		{
+			fusb303b_log(chip, "read type error:%d", ret);
+			return ret;
+		}
+		fusb303b_log(chip, "%s type: 0x%02x", __func__, type);
+		if (FUSB303B_TYPE_SOURCE == (FUSB303B_TYPE_SOURCE & type))
+		{
+			usb_role_switch_set_role(chip->role_sw, USB_ROLE_HOST);
+			fusb303b_log(chip, "set usb to host");
+		}
+		else
+		{
+			usb_role_switch_set_role(chip->role_sw, USB_ROLE_DEVICE);
+			fusb303b_log(chip, "set usb to device");
+			if (FUSB303B_TYPE_SINK != (FUSB303B_TYPE_SINK & type))
+			{
+				fusb303b_log(chip, "illegel type:0x%02x,set usb to device", type);
+			}
+		}
+	}
+
+	return 0;
+}
+
+static irqreturn_t fusb303b_irq_intn(int irq, void *dev_id)
+{
+	struct fusb303b_chip *chip = dev_id;
+	int ret = 0;
+	u8 interrupt = 0, interrupt1 = 0, status = 0;
+
+	mutex_lock(&chip->lock);
+	ret = fusb303b_i2c_read(chip, FUSB303B_REG_INTERRUPT, &interrupt);
+	if (ret < 0)
+		goto done;
+	ret = fusb303b_i2c_read(chip, FUSB303B_REG_INTERRUPT1, &interrupt1);
+	if (ret < 0)
+		goto done;
+	ret = fusb303b_i2c_read(chip, FUSB303B_REG_STATUS, &status);
+	if (ret < 0)
+		goto done;
+
+	fusb303b_log(chip, "IRQ: 0x%02x,0x%02x status: 0x%02x",
+				 interrupt, interrupt1, status);
+
+	if (interrupt & FUSB303B_INT_I_VBUS_CHG)
+	{
+		chip->vbus_ok = !!(status & FUSB303B_STATUS_VBUSOK);
+		fusb303b_log(chip, "IRQ: VBUS_OK, vbus=%s",
+                    chip->vbus_ok ? "On" : "Off");
+	}
+	if (interrupt & (FUSB303B_INT_I_ATTACH | FUSB303B_INT_I_DETACH))
+	{
+		chip->attch_ok = !!(status & FUSB303B_STATUS_ATTACH);
+		fusb303b_log(chip, "IRQ: attach OK, attach=%s",
+                        chip->attch_ok ? "On" : "Off");
+	}
+	fusb303b_set_usb_role(chip);
+	if (0 != interrupt)
+		fusb303b_i2c_write(chip, FUSB303B_REG_INTERRUPT, interrupt);
+	if (0 != interrupt1)
+		fusb303b_i2c_write(chip, FUSB303B_REG_INTERRUPT1, interrupt1);
+
+done:
+	mutex_unlock(&chip->lock);
+	return IRQ_HANDLED;
+}
+
+static int init_gpio(struct fusb303b_chip *chip)
+{
+	struct device *dev = chip->dev;
+	int ret = 0;
+
+	chip->gpio_int_n = devm_gpiod_get(dev, "int", GPIOD_IN);
+	if (IS_ERR(chip->gpio_int_n))
+	{
+		fusb303b_log(chip, "failed to request gpio_int_n\n");
+		return PTR_ERR(chip->gpio_int_n);
+	}
+	ret = gpiod_to_irq(chip->gpio_int_n);
+	if (ret < 0)
+	{
+		fusb303b_log(chip, "cannot request IRQ for GPIO Int_N, ret=%d", ret);
+		return ret;
+	}
+	chip->gpio_int_n_irq = ret;
+
+	return 0;
+}
+
+static const struct property_entry port_props[] = {
+	PROPERTY_ENTRY_STRING("data-role", "dual"),
+	PROPERTY_ENTRY_STRING("power-role", "dual"),
+	PROPERTY_ENTRY_STRING("try-power-role", "sink"),
+	{}};
+
+static struct fwnode_handle *fusb303b_fwnode_get(struct device *dev)
+{
+	struct fwnode_handle *fwnode;
+	fwnode = device_get_named_child_node(dev, "connector");
+	if (!fwnode)
+		fwnode = fwnode_create_software_node(port_props, NULL);
+
+	return fwnode;
+}
+
+static int fusb303b_probe(struct i2c_client *client)
+{
+	struct fusb303b_chip *chip;
+	struct device *dev = &client->dev;
+	int ret = 0;
+	struct regmap *regmap;
+	int irq_sel_reg;
+	int irq_sel_bit;
+	const char *cap_str;
+	int usb_data_role = 0;
+	regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "eswin,syscfg");
+	if (!IS_ERR(regmap)) {
+		ret = of_property_read_u32_index(dev->of_node, "eswin,syscfg",
+						 1, &irq_sel_reg);
+		if (ret) {
+			dev_err(dev,
+				"can't get irq cfg reg offset in sys_con(errno:%d)\n",
+				ret);
+			return ret;
+		}
+		ret = of_property_read_u32_index(dev->of_node, "eswin,syscfg",
+						 2, &irq_sel_bit);
+		if (ret) {
+			dev_err(dev,
+				"can't get irq cfg bit offset in sys_con(errno:%d)\n",
+				ret);
+			return ret;
+		}
+		regmap_clear_bits(regmap, irq_sel_reg, BIT_ULL(irq_sel_bit));
+	}
+
+	chip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+	chip->i2c_client = client;
+	chip->dev = &client->dev;
+	mutex_init(&chip->lock);
+	spin_lock_init(&chip->irq_lock);
+	fusb303b_init(chip);
+	fusb303b_debugfs_init(chip);
+	if (client->irq)
+	{
+		chip->gpio_int_n_irq = client->irq;
+	}
+	else
+	{
+		ret = init_gpio(chip);
+		if (ret < 0)
+			goto destroy_workqueue;
+	}
+	chip->fwnode = fusb303b_fwnode_get(dev);
+	if (IS_ERR(chip->fwnode))
+	{
+		ret = PTR_ERR(chip->fwnode);
+		goto destroy_workqueue;
+	}
+	/*
+	 * This fwnode has a "compatible" property, but is never populated as a
+	 * struct device. Instead we simply parse it to read the properties.
+	 * This it breaks fw_devlink=on. To maintain backward compatibility
+	 * with existing DT files, we work around this by deleting any
+	 * fwnode_links to/from this fwnode.
+	 */
+	fw_devlink_purge_absent_suppliers(chip->fwnode);
+
+	/* USB data support is optional */
+	ret = fwnode_property_read_string(chip->fwnode, "data-role", &cap_str);
+	if (ret == 0)
+	{
+		ret = typec_find_port_data_role(cap_str);
+		if (ret < 0)
+		{
+			fusb303b_log(chip, "%s is not leage data-role\n", cap_str);
+			goto put_fwnode;
+		}
+		usb_data_role = ret;
+	}
+	else
+	{
+		fusb303b_log(chip, "cannot find data-role in dts\n");
+	}
+	chip->role_sw = usb_role_switch_get(chip->dev);
+	if (IS_ERR(chip->role_sw))
+	{
+		ret = PTR_ERR(chip->role_sw);
+		fusb303b_log(chip, "get role_sw error");
+		goto put_fwnode;
+	}
+
+	ret = devm_request_threaded_irq(dev, chip->gpio_int_n_irq, NULL,
+									fusb303b_irq_intn,
+									IRQF_ONESHOT | IRQF_TRIGGER_LOW,
+									"fusb303b_interrupt_int_n", chip);
+	if (ret < 0)
+	{
+		fusb303b_log(chip, "cannot request IRQ for GPIO Int_N, ret=%d", ret);
+		goto err_put_role;
+	}
+
+	enable_irq_wake(chip->gpio_int_n_irq);
+	fusb303b_set_port_check(chip, usb_data_role);
+
+	i2c_set_clientdata(client, chip);
+	fusb303b_log(chip, "Kernel thread created successfully");
+	return ret;
+err_put_role:
+	usb_role_switch_put(chip->role_sw);
+put_fwnode:
+	fwnode_handle_put(chip->fwnode);
+destroy_workqueue:
+	fusb303b_debugfs_exit(chip);
+
+	return ret;
+}
+
+static void fusb303b_remove(struct i2c_client *client)
+{
+	struct fusb303b_chip *chip = i2c_get_clientdata(client);
+
+	disable_irq_wake(chip->gpio_int_n_irq);
+	free_irq(chip->gpio_int_n_irq, chip);
+	usb_role_switch_put(chip->role_sw);
+	fwnode_handle_put(chip->fwnode);
+	fusb303b_debugfs_exit(chip);
+}
+
+static const struct of_device_id fusb303b_dt_match[] = {
+	{.compatible = "fcs,fusb303b"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, fusb303b_dt_match);
+
+static const struct i2c_device_id fusb303b_i2c_device_id[] = {
+	{"typec_fusb303b", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, fusb303b_i2c_device_id);
+
+static struct i2c_driver fusb303b_driver = {
+	.driver = {
+		.name = "typec_fusb303b",
+		.of_match_table = of_match_ptr(fusb303b_dt_match),
+	},
+	.probe = fusb303b_probe,
+	.remove = fusb303b_remove,
+	.id_table = fusb303b_i2c_device_id,
+};
+module_i2c_driver(fusb303b_driver);
+
+MODULE_AUTHOR("Yang Wei <yangwei1@eswincomputing.com>");
+MODULE_DESCRIPTION("Onsemi FUSB303B Type-C Chip Driver");
+MODULE_LICENSE("GPL");
diff --git a/include/dt-bindings/clock/eic7700-clock.h b/include/dt-bindings/clock/eic7700-clock.h
new file mode 100755
index 000000000000..866507498876
--- /dev/null
+++ b/include/dt-bindings/clock/eic7700-clock.h
@@ -0,0 +1,623 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Clk Provider Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#ifndef __DTS_EIC7700_CLOCK_H
+#define __DTS_EIC7700_CLOCK_H
+
+#define EIC7700_NONE_CLOCK	0
+
+/* fixed rate */
+#define EIC7700_XTAL_24M                        1
+#define EIC7700_XTAL_32K                        2
+#define EIC7700_PLL_CPU                         3	/*for cpu clk*/
+#define EIC7700_SPLL0_FOUT1                     4
+#define EIC7700_SPLL0_FOUT2                     5
+#define EIC7700_SPLL0_FOUT3                     6
+#define EIC7700_SPLL1_FOUT1                     7
+#define EIC7700_SPLL1_FOUT2                     8
+#define EIC7700_SPLL1_FOUT3                     9
+#define EIC7700_SPLL2_FOUT1                     10
+#define EIC7700_SPLL2_FOUT2                     11
+#define EIC7700_SPLL2_FOUT3                     12
+#define EIC7700_VPLL_FOUT1                      13
+#define EIC7700_VPLL_FOUT2                      14
+#define EIC7700_VPLL_FOUT3                      15
+#define EIC7700_APLL_FOUT1                      16
+#define EIC7700_APLL_FOUT2                      17
+#define EIC7700_APLL_FOUT3                      18
+#define EIC7700_EXT_MCLK                        19
+#define EIC7700_PLL_DDR                         20
+#define EIC7700_LPDDR_REF_BAK                   21
+
+
+/* mux clocks */
+#define  EIC7700_MUX_U_CPU_ROOT_3MUX1_GFREE                         30	/*for cpu clk*/
+#define  EIC7700_MUX_U_CPU_ACLK_2MUX1_GFREE                         31	/*for cpu clk*/
+#define  EIC7700_MUX_U_DSP_ACLK_ROOT_2MUX1_GFREE                    32
+#define  EIC7700_MUX_U_D2D_ACLK_ROOT_2MUX1_GFREE                    33
+#define  EIC7700_MUX_U_MSHCORE_ROOT_3MUX1_0                         34
+#define  EIC7700_MUX_U_MSHCORE_ROOT_3MUX1_1                         35
+#define  EIC7700_MUX_U_MSHCORE_ROOT_3MUX1_2                         36
+#define  EIC7700_MUX_U_NPU_LLCLK_3MUX1_GFREE                        37
+#define  EIC7700_MUX_U_NPU_CORE_3MUX1_GFREE                         38
+#define  EIC7700_MUX_U_VI_ACLK_ROOT_2MUX1_GFREE                     39
+#define  EIC7700_MUX_U_VI_DVP_ROOT_2MUX1_GFREE                      40
+#define  EIC7700_MUX_U_VI_DIG_ISP_ROOT_2MUX1_GFREE                  41
+#define  EIC7700_MUX_U_VO_ACLK_ROOT_2MUX1_GFREE                     42
+#define  EIC7700_MUX_U_VO_PIXEL_ROOT_2MUX1                          43
+#define  EIC7700_MUX_U_VO_CEC_2MUX1                                 44
+#define  EIC7700_MUX_U_VCDEC_ROOT_2MUX1_GFREE                       45
+#define  EIC7700_MUX_U_VCACLK_ROOT_2MUX1_GFREE                      46
+#define  EIC7700_MUX_U_RTC_2MUX1                                    47
+#define  EIC7700_MUX_U_SYSCFG_CLK_ROOT_2MUX1_GFREE                  48
+#define  EIC7700_MUX_U_NOCNSP_XTAL_2MUX1                            49
+#define  EIC7700_MUX_U_BOOTSPI_CLK_2MUX1_GFREE                      50
+#define  EIC7700_MUX_U_SCPU_CORE_CLK_2MUX1_GFREE                    51
+#define  EIC7700_MUX_U_LPCPU_CORE_CLK_2MUX1_GFREE                   52
+#define  EIC7700_MUX_GPU_ACLK_XTAL_2MUX1                            53
+#define  EIC7700_MUX_U_DSP_ACLK_XTAL_2MUX1                          54
+#define  EIC7700_MUX_U_D2D_ACLK_XTAL_2MUX1                          55
+#define  EIC7700_MUX_U_HSP_ACLK_XTAL_2MUX1                          56
+#define  EIC7700_MUX_U_PCIE_ACLK_XTAL_2MUX1                         57
+#define  EIC7700_MUX_U_NPU_ACLK_XTAL_2MUX1                          58
+#define  EIC7700_MUX_U_NPU_LLC_XTAL_2MUX1                           59
+#define  EIC7700_MUX_U_NPU_CORE_XTAL_2MUX1                          60
+#define  EIC7700_MUX_U_VI_ACLK_XTAL_2MUX1                           61
+#define  EIC7700_MUX_U_VI_DVP_XTAL_2MUX1                            62
+#define  EIC7700_MUX_U_VI_DIG_ISP_XTAL_2MUX1                        63
+#define  EIC7700_MUX_U_VI_SHUTTER_XTAL_2MUX1_0                      64
+#define  EIC7700_MUX_U_VI_SHUTTER_XTAL_2MUX1_1                      65
+#define  EIC7700_MUX_U_VI_SHUTTER_XTAL_2MUX1_2                      66
+#define  EIC7700_MUX_U_VI_SHUTTER_XTAL_2MUX1_3                      67
+#define  EIC7700_MUX_U_VI_SHUTTER_XTAL_2MUX1_4                      68
+#define  EIC7700_MUX_U_VI_SHUTTER_XTAL_2MUX1_5                      69
+#define  EIC7700_MUX_U_VO_ACLK_XTAL_2MUX1                           70
+#define  EIC7700_MUX_U_IESMCLK_XTAL_2MUX1                           71
+#define  EIC7700_MUX_U_VO_PIXEL_XTAL_2MUX1                          72
+#define  EIC7700_MUX_U_VO_MCLK_2MUX_EXT_MCLK                        73
+#define  EIC7700_MUX_U_VC_ACLK_XTAL_2MUX1                           74
+#define  EIC7700_MUX_U_JD_XTAL_2MUX1                                75
+#define  EIC7700_MUX_U_JE_XTAL_2MUX1                                76
+#define  EIC7700_MUX_U_VE_XTAL_2MUX1                                77
+#define  EIC7700_MUX_U_VD_XTAL_2MUX1                                78
+#define  EIC7700_MUX_U_SATA_PHY_2MUX1                               79
+#define  EIC7700_MUX_U_AONDMA_AXI2MUX1_GFREE                        80
+#define  EIC7700_MUX_U_CRYPTO_XTAL_2MUX1                            81
+#define  EIC7700_MUX_U_RMII_REF_2MUX                                82
+#define  EIC7700_MUX_U_ETH_CORE_2MUX1                               83
+#define  EIC7700_MUX_U_VI_DW_ROOT_2MUX1                             84
+#define  EIC7700_MUX_U_VI_DW_XTAL_2MUX1                             85
+#define  EIC7700_MUX_U_NPU_E31_3MUX1_GFREE                          86
+#define  EIC7700_MUX_U_DDR_ACLK_ROOT_2MUX1_GFREE                    87
+
+/* divider clocks */
+#define EIC7700_DIVDER_U_SYS_CFG_DIV_DYNM                           100
+#define EIC7700_DIVDER_U_NOC_NSP_DIV_DYNM                           101
+#define EIC7700_DIVDER_U_BOOTSPI_DIV_DYNM                           102
+#define EIC7700_DIVDER_U_SCPU_CORE_DIV_DYNM                         103
+#define EIC7700_DIVDER_U_LPCPU_CORE_DIV_DYNM                        104
+#define EIC7700_DIVDER_U_GPU_ACLK_DIV_DYNM                          105
+#define EIC7700_DIVDER_U_DSP_ACLK_DIV_DYNM                          106
+#define EIC7700_DIVDER_U_D2D_ACLK_DIV_DYNM                          107
+#define EIC7700_DIVDER_U_HSP_ACLK_DIV_DYNM                          108
+#define EIC7700_DIVDER_U_ETH_TXCLK_DIV_DYNM_0                       109
+#define EIC7700_DIVDER_U_ETH_TXCLK_DIV_DYNM_1                       110
+#define EIC7700_DIVDER_U_MSHC_CORE_DIV_DYNM_0                       111
+#define EIC7700_DIVDER_U_MSHC_CORE_DIV_DYNM_1                       112
+#define EIC7700_DIVDER_U_MSHC_CORE_DIV_DYNM_2                       113
+#define EIC7700_DIVDER_U_PCIE_ACLK_DIV_DYNM                         114
+#define EIC7700_DIVDER_U_NPU_ACLK_DIV_DYNM                          115
+#define EIC7700_DIVDER_U_NPU_LLC_SRC0_DIV_DYNM                      116
+#define EIC7700_DIVDER_U_NPU_LLC_SRC1_DIV_DYNM                      117
+#define EIC7700_DIVDER_U_NPU_CORECLK_DIV_DYNM                       118
+#define EIC7700_DIVDER_U_VI_ACLK_DIV_DYNM                           119
+#define EIC7700_DIVDER_U_VI_DVP_DIV_DYNM                            120
+#define EIC7700_DIVDER_U_VI_DIG_ISP_DIV_DYNM                        121
+#define EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_0                      122
+#define EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_1                      123
+#define EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_2                      124
+#define EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_3                      125
+#define EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_4                      126
+#define EIC7700_DIVDER_U_VI_SHUTTER_DIV_DYNM_5                      127
+#define EIC7700_DIVDER_U_VO_ACLK_DIV_DYNM                           128
+#define EIC7700_DIVDER_U_IESMCLK_DIV_DYNM                           129
+#define EIC7700_DIVDER_U_VO_PIXEL_DIV_DYNM                          130
+#define EIC7700_DIVDER_U_VO_MCLK_DIV_DYNM                           131
+#define EIC7700_DIVDER_U_VC_ACLK_DIV_DYNM                           132
+#define EIC7700_DIVDER_U_JD_DIV_DYNM                                133
+#define EIC7700_DIVDER_U_JE_DIV_DYNM                                134
+#define EIC7700_DIVDER_U_VE_DIV_DYNM                                135
+#define EIC7700_DIVDER_U_VD_DIV_DYNM                                136
+#define EIC7700_DIVDER_U_G2D_DIV_DYNM                               137
+#define EIC7700_DIVDER_U_AONDMA_AXI_DIV_DYNM                        138
+#define EIC7700_DIVDER_U_CRYPTO_DIV_DYNM                            139
+#define EIC7700_DIVDER_U_VI_DW_DIV_DYNM                             140
+#define EIC7700_DIVDER_U_NPU_E31_DIV_DYNM                           141
+#define EIC7700_DIVDER_U_SATA_PHY_REF_DIV_DYNM                      142
+#define EIC7700_DIVDER_U_DSP_0_ACLK_DIV_DYNM                        143
+#define EIC7700_DIVDER_U_DSP_1_ACLK_DIV_DYNM                        144
+#define EIC7700_DIVDER_U_DSP_2_ACLK_DIV_DYNM                        145
+#define EIC7700_DIVDER_U_DSP_3_ACLK_DIV_DYNM                        146
+#define EIC7700_DIVDER_U_DDR_ACLK_DIV_DYNM                          147
+#define EIC7700_DIVDER_U_AON_RTC_DIV_DYNM                           148
+#define EIC7700_DIVDER_U_U84_RTC_TOGGLE_DIV_DYNM                    149
+#define EIC7700_DIVDER_U_VO_CEC_DIV_DYNM                            150
+
+/* gate clocks */
+#define EIC7700_GATE_CLK_CPU_EXT_SRC_CORE_CLK_0                 200
+#define EIC7700_GATE_CLK_CPU_EXT_SRC_CORE_CLK_1                 201
+#define EIC7700_GATE_CLK_CPU_EXT_SRC_CORE_CLK_2                 202
+#define EIC7700_GATE_CLK_CPU_EXT_SRC_CORE_CLK_3                 203
+#define EIC7700_GATE_CLK_CPU_TRACE_CLK_0                        204
+#define EIC7700_GATE_CLK_CPU_TRACE_CLK_1                        205
+#define EIC7700_GATE_CLK_CPU_TRACE_CLK_2                        206
+#define EIC7700_GATE_CLK_CPU_TRACE_CLK_3                        207
+#define EIC7700_GATE_CLK_CPU_DEBUG_CLK                          208
+#define EIC7700_GATE_CLK_CPU_TRACE_COM_CLK                      209
+#define EIC7700_GATE_CLK_CPU_CLK                                210
+#define EIC7700_GATE_CLK_SPLL0_FOUT2                            211
+#define EIC7700_GATE_CLK_VPLL_FOUT2                             212
+#define EIC7700_GATE_CLK_VPLL_FOUT3                             213
+#define EIC7700_GATE_CLK_APLL_FOUT1                             214
+#define EIC7700_GATE_CLK_APLL_FOUT2                             215
+#define EIC7700_GATE_CLK_APLL_FOUT3                             216
+#define EIC7700_GATE_EXT_MCLK                                   217
+#define EIC7700_GATE_CLK_1M                                     218
+#define EIC7700_GATE_CLK_SYS_CFG                                219
+#define EIC7700_GATE_CLK_MIPI_TXESC                             220
+#define EIC7700_GATE_NOC_CFG_CLK                                221
+#define EIC7700_GATE_NOC_NSP_CLK                                222
+#define EIC7700_GATE_CLK_BOOTSPI                                223
+#define EIC7700_GATE_CLK_BOOTSPI_CFG                            224
+#define EIC7700_GATE_CLK_U84_CORE_LP                            225
+#define EIC7700_GATE_CLK_SCPU_CORE                              226
+#define EIC7700_GATE_CLK_SCPU_BUS                               227
+#define EIC7700_GATE_CLK_LPCPU_CORE                             228
+#define EIC7700_GATE_CLK_LPCPU_BUS                              229
+#define EIC7700_GATE_GPU_ACLK                                   230
+#define EIC7700_GATE_GPU_GRAY_CLK                               231
+#define EIC7700_GATE_GPU_CFG_CLK                                232
+#define EIC7700_GATE_CLK_DSP_ROOT                               233
+#define EIC7700_GATE_DSPT_ACLK                                  234
+#define EIC7700_GATE_DSPT_CFG_CLK                               235
+#define EIC7700_GATE_CLK_D2DDR_ACLK                             236
+#define EIC7700_GATE_D2D_ACLK                                   237
+#define EIC7700_GATE_D2D_CFG_CLK                                238
+#define EIC7700_GATE_CLK_HSP_ACLK                               239
+#define EIC7700_GATE_CLK_HSP_CFGCLK                             240
+#define EIC7700_GATE_TCU_ACLK                                   241
+#define EIC7700_GATE_TCU_CFG_CLK                                242
+#define EIC7700_GATE_DDRT_CFG_CLK                               243
+#define EIC7700_GATE_DDRT1_CFG_CLK                              244
+#define EIC7700_GATE_DDRT0_P0_ACLK                              245
+#define EIC7700_GATE_DDRT0_P1_ACLK                              246
+#define EIC7700_GATE_DDRT0_P2_ACLK                              247
+#define EIC7700_GATE_DDRT0_P3_ACLK                              248
+#define EIC7700_GATE_DDRT0_P4_ACLK                              249
+#define EIC7700_GATE_DDRT1_P0_ACLK                              250
+#define EIC7700_GATE_DDRT1_P1_ACLK                              251
+#define EIC7700_GATE_DDRT1_P2_ACLK                              252
+#define EIC7700_GATE_DDRT1_P3_ACLK                              253
+#define EIC7700_GATE_DDRT1_P4_ACLK                              254
+#define EIC7700_GATE_HSP_ACLK                                   255
+#define EIC7700_GATE_HSP_CFG_CLK                                256
+#define EIC7700_GATE_HSP_SATA_RBC_CLK                           257
+#define EIC7700_GATE_HSP_SATA_OOB_CLK                           258
+#define EIC7700_GATE_HSP_SATA_PMALIVE_CLK                       259
+#define EIC7700_GATE_HSP_ETH_APP_CLK                            260
+#define EIC7700_GATE_HSP_ETH_CSR_CLK                            261
+#define EIC7700_GATE_HSP_ETH0_CORE_CLK                          262
+#define EIC7700_GATE_HSP_ETH1_CORE_CLK                          263
+#define EIC7700_GATE_HSP_MSHC0_CORE_CLK                         264
+#define EIC7700_GATE_HSP_MSHC1_CORE_CLK                         265
+#define EIC7700_GATE_HSP_MSHC2_CORE_CLK                         266
+#define EIC7700_GATE_HSP_MSHC0_TMR_CLK                          267
+#define EIC7700_GATE_HSP_MSHC1_TMR_CLK                          268
+#define EIC7700_GATE_HSP_MSHC2_TMR_CLK                          269
+#define EIC7700_GATE_HSP_USB0_SUSPEND_CLK                       270
+#define EIC7700_GATE_HSP_USB1_SUSPEND_CLK                       271
+#define EIC7700_GATE_PCIET_ACLK                                 272
+#define EIC7700_GATE_PCIET_CFG_CLK                              273
+#define EIC7700_GATE_PCIET_CR_CLK                               274
+#define EIC7700_GATE_PCIET_AUX_CLK                              275
+#define EIC7700_GATE_NPU_ACLK                                   276
+#define EIC7700_GATE_NPU_CFG_CLK                                277
+#define EIC7700_GATE_CLK_NPU_LLC_SRC0                           278
+#define EIC7700_GATE_CLK_NPU_LLC_SRC1                           279
+#define EIC7700_GATE_NPU_LLC_ACLK                               280
+#define EIC7700_GATE_CLK_NPU_CORE_ST1                           281
+#define EIC7700_GATE_NPU_CLK                                    282
+#define EIC7700_GATE_NPU_E31_CLK                                283
+#define EIC7700_GATE_CLK_VI_ACLK_ST1                            284
+#define EIC7700_GATE_VI_ACLK                                    285
+#define EIC7700_GATE_VI_DVP_CLK                                 286
+#define EIC7700_GATE_VI_CFG_CLK                                 287
+#define EIC7700_GATE_VI_DIG_DW_CLK                              288
+#define EIC7700_GATE_VI_DIG_ISP_CLK                             289
+#define EIC7700_GATE_VI_SHUTTER_0                               290
+#define EIC7700_GATE_VI_SHUTTER_1                               291
+#define EIC7700_GATE_VI_SHUTTER_2                               292
+#define EIC7700_GATE_VI_SHUTTER_3                               293
+#define EIC7700_GATE_VI_SHUTTER_4                               294
+#define EIC7700_GATE_VI_SHUTTER_5                               295
+#define EIC7700_GATE_VI_PHY_TXCLKESC                            296
+#define EIC7700_GATE_VI_PHY_CFG                                 297
+#define EIC7700_GATE_VO_ACLK                                    298
+#define EIC7700_GATE_VO_CFG_CLK                                 299
+#define EIC7700_GATE_VO_HDMI_IESMCLK                            300
+#define EIC7700_GATE_VO_PIXEL_CLK                               301
+#define EIC7700_GATE_VO_I2S_MCLK                                302
+#define EIC7700_GATE_VO_CR_CLK                                  303
+#define EIC7700_GATE_VO_CEC_CLK                                 304
+#define EIC7700_GATE_CLK_VC_ROOT                                305
+#define EIC7700_GATE_VC_ACLK                                    306
+#define EIC7700_GATE_VC_CFG_CLK                                 307
+#define EIC7700_GATE_VC_JE_CLK                                  308
+#define EIC7700_GATE_VC_JD_CLK                                  309
+#define EIC7700_GATE_VC_VE_CLK                                  310
+#define EIC7700_GATE_VC_VD_CLK                                  311
+#define EIC7700_GATE_G2D_CFG_CLK                                312
+#define EIC7700_GATE_CLK_G2D_ST2                                313
+#define EIC7700_GATE_G2D_CLK                                    314
+#define EIC7700_GATE_G2D_ACLK                                   315
+#define EIC7700_GATE_CLK_PVT_INNER                              316
+#define EIC7700_GATE_PVT_CLK_0                                  317
+#define EIC7700_GATE_PVT_CLK_1                                  318
+#define EIC7700_GATE_PVT_CLK_2                                  319
+#define EIC7700_GATE_PVT_CLK_3                                  320
+#define EIC7700_GATE_PVT_CLK_4                                  321
+#define EIC7700_GATE_CLK_AONDMA_CFG                             322
+#define EIC7700_GATE_CLK_AONDMA_AXI_ST3                         323
+#define EIC7700_GATE_AONDMA_ACLK                                324
+#define EIC7700_GATE_AON_ACLK                                   325
+#define EIC7700_GATE_TIMER_CLK_0                                326
+#define EIC7700_GATE_TIMER_CLK_1                                327
+#define EIC7700_GATE_TIMER_CLK_2                                328
+#define EIC7700_GATE_TIMER_CLK_3                                329
+#define EIC7700_GATE_TIMER_PCLK_0                               330
+#define EIC7700_GATE_TIMER_PCLK_1                               331
+#define EIC7700_GATE_TIMER_PCLK_2                               332
+#define EIC7700_GATE_TIMER_PCLK_3                               333
+#define EIC7700_GATE_TIMER3_CLK8                                334
+#define EIC7700_GATE_CLK_RTC_CFG                                335
+#define EIC7700_GATE_CLK_RTC                                    336
+#define EIC7700_GATE_HSP_RMII_REF_0                             337
+#define EIC7700_GATE_HSP_RMII_REF_1                             338
+#define EIC7700_GATE_CLK_PKA_CFG                                339
+#define EIC7700_GATE_CLK_SPACC_CFG                              340
+#define EIC7700_GATE_CLK_CRYPTO                                 341
+#define EIC7700_GATE_CLK_TRNG_CFG                               342
+#define EIC7700_GATE_CLK_OTP_CFG                                343
+#define EIC7700_GATE_CLMM_CFG_CLK                               344
+#define EIC7700_GATE_CLMM_DEB_CLK                               345
+#define EIC7700_GATE_CLK_MAILBOX_0                              346
+#define EIC7700_GATE_CLK_MAILBOX_1                              347
+#define EIC7700_GATE_CLK_MAILBOX_2                              348
+#define EIC7700_GATE_CLK_MAILBOX_3                              349
+#define EIC7700_GATE_CLK_MAILBOX_4                              350
+#define EIC7700_GATE_CLK_MAILBOX_5                              351
+#define EIC7700_GATE_CLK_MAILBOX_6                              352
+#define EIC7700_GATE_CLK_MAILBOX_7                              353
+#define EIC7700_GATE_CLK_MAILBOX_8                              354
+#define EIC7700_GATE_CLK_MAILBOX_9                              355
+#define EIC7700_GATE_CLK_MAILBOX_10                             356
+#define EIC7700_GATE_CLK_MAILBOX_11                             357
+#define EIC7700_GATE_CLK_MAILBOX_12                             358
+#define EIC7700_GATE_CLK_MAILBOX_13                             359
+#define EIC7700_GATE_CLK_MAILBOX_14                             360
+#define EIC7700_GATE_CLK_MAILBOX_15                             361
+#define EIC7700_GATE_CLK_APLL_TEST_OUT                          362
+#define EIC7700_GATE_CLK_CPLL_TEST_OUT                          363
+#define EIC7700_GATE_CLK_HSP_DFT150M                            364
+#define EIC7700_GATE_CLK_HSP_DFT300M                            365
+#define EIC7700_GATE_CLK_HSP_DFT600M                            366
+#define EIC7700_GATE_CLK_VI_DFT400M                             367
+#define EIC7700_GATE_CLK_VI_DFT500M                             368
+#define EIC7700_GATE_CLK_VO_DFT300M                             369
+#define EIC7700_GATE_CLK_VO_DFT600M                             370
+#define EIC7700_GATE_CLK_D2D_DFT300M                            371
+#define EIC7700_GATE_CLK_D2D_DFT600M                            372
+#define EIC7700_GATE_CLK_PCIE_DFT125M                           373
+#define EIC7700_GATE_CLK_PCIE_DFT200M                           374
+#define EIC7700_GATE_CLK_DDR_PLL_BYP_CLK                        375
+#define EIC7700_GATE_CLK_DDR_RX_TEST_CLK                        376
+#define EIC7700_GATE_LSP_I2C0_PCLK                              377
+#define EIC7700_GATE_LSP_I2C1_PCLK                              378
+#define EIC7700_GATE_LSP_I2C2_PCLK                              379
+#define EIC7700_GATE_LSP_I2C3_PCLK                              380
+#define EIC7700_GATE_LSP_I2C4_PCLK                              381
+#define EIC7700_GATE_LSP_I2C5_PCLK                              382
+#define EIC7700_GATE_LSP_I2C6_PCLK                              383
+#define EIC7700_GATE_LSP_I2C7_PCLK                              384
+#define EIC7700_GATE_LSP_I2C8_PCLK                              385
+#define EIC7700_GATE_LSP_I2C9_PCLK                              386
+#define EIC7700_GATE_LSP_WDT0_PCLK                              387
+#define EIC7700_GATE_LSP_WDT1_PCLK                              388
+#define EIC7700_GATE_LSP_WDT2_PCLK                              389
+#define EIC7700_GATE_LSP_WDT3_PCLK                              390
+#define EIC7700_GATE_LSP_SSI0_PCLK                              391
+#define EIC7700_GATE_LSP_SSI1_PCLK                              392
+#define EIC7700_GATE_LSP_PVT_PCLK                               393
+#define EIC7700_GATE_AON_I2C0_PCLK                              394
+#define EIC7700_GATE_AON_I2C1_PCLK                              395
+#define EIC7700_GATE_LSP_UART0_PCLK                             396
+#define EIC7700_GATE_LSP_UART1_PCLK                             397
+#define EIC7700_GATE_LSP_UART2_PCLK                             398
+#define EIC7700_GATE_LSP_UART3_PCLK                             399
+#define EIC7700_GATE_LSP_UART4_PCLK                             400
+#define EIC7700_GATE_LSP_TIMER_PCLK                             401
+#define EIC7700_GATE_LSP_FAN_PCLK                               402
+#define EIC7700_GATE_LSP_PVT0_CLK                               403
+#define EIC7700_GATE_LSP_PVT1_CLK                               404
+#define EIC7700_GATE_RESERVED_1                                 405
+#define EIC7700_GATE_RESERVED_2                                 406
+#define EIC7700_GATE_RESERVED_3                                 407
+#define EIC7700_GATE_VC_JE_PCLK                                 408
+#define EIC7700_GATE_VC_JD_PCLK                                 409
+#define EIC7700_GATE_VC_VE_PCLK                                 410
+#define EIC7700_GATE_VC_VD_PCLK                                 411
+#define EIC7700_GATE_VC_MON_PCLK                                412
+#define EIC7700_GATE_HSP_DMA0_CLK                               413
+
+/*fixed factor clocks*/
+#define EIC7700_FIXED_FACTOR_U_CPU_DIV2                         450
+#define EIC7700_FIXED_FACTOR_U_CLK_1M_DIV24                     451
+#define EIC7700_FIXED_FACTOR_U_MIPI_TXESC_DIV10                 452
+#define EIC7700_FIXED_FACTOR_U_U84_CORE_LP_DIV2                 453
+#define EIC7700_FIXED_FACTOR_U_SCPU_BUS_DIV2                    454
+#define EIC7700_FIXED_FACTOR_U_LPCPU_BUS_DIV2                   455
+#define EIC7700_FIXED_FACTOR_U_PCIE_CR_DIV2                     456
+#define EIC7700_FIXED_FACTOR_U_PCIE_AUX_DIV4                    457
+#define EIC7700_FIXED_FACTOR_U_PVT_DIV20                        458
+#define EIC7700_FIXED_FACTOR_U_DFT100M_DIV4                     459
+#define EIC7700_FIXED_FACTOR_U_DFT125M_DIV2                     460
+#define EIC7700_FIXED_FACTOR_U_DFT150M_DIV2                     461
+#define EIC7700_FIXED_FACTOR_U_DFT100M_DIV2                     462
+#define EIC7700_FIXED_FACTOR_U_DFT500M_DIV3                     463
+#define EIC7700_FIXED_FACTOR_U_DFT500M_DIV2                     464
+#define EIC7700_FIXED_FACTOR_SPLL0_TEST_DIV8                    465
+#define EIC7700_FIXED_FACTOR_SPLL1_TEST_DIV6                    466
+#define EIC7700_FIXED_FACTOR_SPLL2_TEST_DIV4                    467
+#define EIC7700_FIXED_FACTOR_U_HSP_RMII_REF_DIV6                468
+#define EIC7700_FIXED_FACTOR_U_DRR_DIV8                         469
+
+
+/*clocks list for consumer*/
+#define EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_0                      500
+#define EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_1                      501
+#define EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_2                      502
+#define EIC7700_CLK_CPU_EXT_SRC_CORE_CLK_3                      503
+#define EIC7700_CLK_CPU_TRACE_CLK_0                             504
+#define EIC7700_CLK_CPU_TRACE_CLK_1                             505
+#define EIC7700_CLK_CPU_TRACE_CLK_2                             506
+#define EIC7700_CLK_CPU_TRACE_CLK_3                             507
+#define EIC7700_CLK_CPU_DEBUG_CLK                               508
+#define EIC7700_CLK_CPU_TRACE_COM_CLK                           509
+#define EIC7700_CLK_CPU_CLK                                     510
+#define EIC7700_CLK_CLK_1M                                      511
+#define EIC7700_CLK_CLK_SYS_CFG                                 512
+#define EIC7700_CLK_CLK_MIPI_TXESC                              513
+#define EIC7700_CLK_NOC_CFG_CLK                                 514
+#define EIC7700_CLK_NOC_NSP_CLK                                 515
+#define EIC7700_CLK_CLK_BOOTSPI                                 516
+#define EIC7700_CLK_CLK_BOOTSPI_CFG                             517
+#define EIC7700_CLK_CLK_U84_CORE_LP                             518
+#define EIC7700_CLK_CLK_SCPU_CORE                               519
+#define EIC7700_CLK_CLK_SCPU_BUS                                520
+#define EIC7700_CLK_CLK_LPCPU_CORE                              521
+#define EIC7700_CLK_CLK_LPCPU_BUS                               522
+#define EIC7700_CLK_GPU_ACLK                                    523
+#define EIC7700_CLK_GPU_GRAY_CLK                                524
+#define EIC7700_CLK_GPU_CFG_CLK                                 525
+#define EIC7700_CLK_CLK_DSP_ROOT                                526
+#define EIC7700_CLK_DSPT_ACLK                                   527
+#define EIC7700_CLK_DSPT_CFG_CLK                                528
+#define EIC7700_CLK_CLK_D2DDR_ACLK                              529
+#define EIC7700_CLK_D2D_ACLK                                    530
+#define EIC7700_CLK_D2D_CFG_CLK                                 531
+#define EIC7700_CLK_TCU_ACLK                                    532
+#define EIC7700_CLK_TCU_CFG_CLK                                 533
+#define EIC7700_CLK_DDRT_CFG_CLK                                534
+#define EIC7700_CLK_DDRT0_P0_ACLK                               535
+#define EIC7700_CLK_DDRT0_P1_ACLK                               536
+#define EIC7700_CLK_DDRT0_P2_ACLK                               537
+#define EIC7700_CLK_DDRT0_P3_ACLK                               538
+#define EIC7700_CLK_DDRT0_P4_ACLK                               539
+#define EIC7700_CLK_DDRT1_P0_ACLK                               540
+#define EIC7700_CLK_DDRT1_P1_ACLK                               541
+#define EIC7700_CLK_DDRT1_P2_ACLK                               542
+#define EIC7700_CLK_DDRT1_P3_ACLK                               543
+#define EIC7700_CLK_DDRT1_P4_ACLK                               544
+#define EIC7700_CLK_HSP_ACLK                                    545
+#define EIC7700_CLK_HSP_CFG_CLK                                 546
+#define EIC7700_CLK_HSP_SATA_RBC_CLK                            547
+#define EIC7700_CLK_HSP_SATA_OOB_CLK                            548
+#define EIC7700_CLK_HSP_SATA_PMALIVE_CLK                        549
+#define EIC7700_CLK_HSP_ETH_APP_CLK                             550
+#define EIC7700_CLK_HSP_ETH_CSR_CLK                             551
+#define EIC7700_CLK_HSP_ETH0_CORE_CLK                           552
+#define EIC7700_CLK_HSP_ETH1_CORE_CLK                           553
+#define EIC7700_CLK_HSP_MSHC0_CORE_CLK                          554
+#define EIC7700_CLK_HSP_MSHC1_CORE_CLK                          555
+#define EIC7700_CLK_HSP_MSHC2_CORE_CLK                          556
+#define EIC7700_CLK_HSP_MSHC0_TMR_CLK                           557
+#define EIC7700_CLK_HSP_MSHC1_TMR_CLK                           558
+#define EIC7700_CLK_HSP_MSHC2_TMR_CLK                           559
+#define EIC7700_CLK_HSP_USB0_SUSPEND_CLK                        560
+#define EIC7700_CLK_HSP_USB1_SUSPEND_CLK                        561
+#define EIC7700_CLK_PCIET_ACLK                                  562
+#define EIC7700_CLK_PCIET_CFG_CLK                               563
+#define EIC7700_CLK_PCIET_CR_CLK                                564
+#define EIC7700_CLK_PCIET_AUX_CLK                               565
+#define EIC7700_CLK_NPU_ACLK                                    566
+#define EIC7700_CLK_NPU_CFG_CLK                                 567
+#define EIC7700_CLK_CLK_NPU_LLC_SRC0                            568
+#define EIC7700_CLK_CLK_NPU_LLC_SRC1                            569
+#define EIC7700_CLK_NPU_LLC_ACLK                                570
+#define EIC7700_CLK_CLK_NPU_CORE_ST1                            571
+#define EIC7700_CLK_NPU_CLK                                     572
+#define EIC7700_CLK_NPU_E31_CLK                                 573
+#define EIC7700_CLK_CLK_VI_ACLK_ST1                             574
+#define EIC7700_CLK_VI_ACLK                                     575
+#define EIC7700_CLK_VI_DVP_CLK                                  576
+#define EIC7700_CLK_VI_CFG_CLK                                  577
+#define EIC7700_CLK_VI_DIG_DW_CLK                               578
+#define EIC7700_CLK_VI_DIG_ISP_CLK                              579
+#define EIC7700_CLK_VI_SHUTTER_0                                580
+#define EIC7700_CLK_VI_SHUTTER_1                                581
+#define EIC7700_CLK_VI_SHUTTER_2                                582
+#define EIC7700_CLK_VI_SHUTTER_3                                583
+#define EIC7700_CLK_VI_SHUTTER_4                                584
+#define EIC7700_CLK_VI_SHUTTER_5                                585
+#define EIC7700_CLK_VI_PHY_TXCLKESC                             586
+#define EIC7700_CLK_VI_PHY_CFG                                  587
+#define EIC7700_CLK_VO_ACLK                                     588
+#define EIC7700_CLK_VO_CFG_CLK                                  589
+#define EIC7700_CLK_VO_HDMI_IESMCLK                             590
+#define EIC7700_CLK_VO_PIXEL_CLK                                591
+#define EIC7700_CLK_VO_I2S_MCLK                                 592
+#define EIC7700_CLK_VO_CR_CLK                                   593
+#define EIC7700_CLK_VO_CEC_CLK                                  594
+#define EIC7700_CLK_CLK_VC_ROOT                                 595
+#define EIC7700_CLK_VC_ACLK                                     596
+#define EIC7700_CLK_VC_CFG_CLK                                  597
+#define EIC7700_CLK_VC_JE_CLK                                   598
+#define EIC7700_CLK_VC_JD_CLK                                   599
+#define EIC7700_CLK_VC_VE_CLK                                   600
+#define EIC7700_CLK_VC_VD_CLK                                   601
+#define EIC7700_CLK_G2D_CFG_CLK                                 602
+#define EIC7700_CLK_CLK_G2D_ST2                                 603
+#define EIC7700_CLK_G2D_CLK                                     604
+#define EIC7700_CLK_G2D_ACLK                                    605
+#define EIC7700_CLK_CLK_RESERVED                                606
+#define EIC7700_CLK_PVT_CLK_0                                   607
+#define EIC7700_CLK_PVT_CLK_1                                   608
+#define EIC7700_CLK_HSP_RMII_REF_0                              609
+#define EIC7700_CLK_HSP_RMII_REF_1                              610
+#define EIC7700_CLK_HSP_SATA_PHY_REF                            611
+#define EIC7700_CLK_AONDMA_CFG                                  612
+#define EIC7700_CLK_CLK_AONDMA_AXI_ST3                          613
+#define EIC7700_CLK_AONDMA_ACLK                                 614
+#define EIC7700_CLK_AON_ACLK                                    615
+#define EIC7700_CLK_TIMER_CLK_0                                 616      //AON timer
+#define EIC7700_CLK_TIMER_CLK_1                                 617
+#define EIC7700_CLK_TIMER_CLK_2                                 618
+#define EIC7700_CLK_TIMER_CLK_3                                 619
+#define EIC7700_CLK_TIMER_PCLK_0                                620
+#define EIC7700_CLK_TIMER_PCLK_1                                621
+#define EIC7700_CLK_TIMER_PCLK_2                                622
+#define EIC7700_CLK_TIMER_PCLK_3                                623
+#define EIC7700_CLK_TIMER3_CLK8                                 624
+#define EIC7700_CLK_CLK_RTC_CFG                                 625  // AON rtc
+#define EIC7700_CLK_CLK_RTC                                     626  // AON rtc
+#define EIC7700_CLK_CLK_U84_RTC_TOGGLE                          627
+#define EIC7700_CLK_UNUSED_1                                    628
+#define EIC7700_CLK_CLK_PKA_CFG                                 629
+#define EIC7700_CLK_CLK_SPACC_CFG                               630
+#define EIC7700_CLK_CLK_CRYPTO                                  631
+#define EIC7700_CLK_CLK_TRNG_CFG                                632
+#define EIC7700_CLK_CLK_OTP_CFG                                 633
+#define EIC7700_CLK_CLMM_CFG_CLK                                634
+#define EIC7700_CLK_CLMM_DEB_CLK                                635
+#define EIC7700_CLK_DDR_PLL_BYP_CLK                             636
+#define EIC7700_CLK_DDR_PLL_REF_AND_DFI_CLK                     637
+#define EIC7700_CLK_DDR_RX_TEST_CLK                             638
+#define EIC7700_CLK_MAILBOX_0                                   638
+#define EIC7700_CLK_MAILBOX_1                                   639
+#define EIC7700_CLK_MAILBOX_2                                   640
+#define EIC7700_CLK_MAILBOX_3                                   641
+#define EIC7700_CLK_MAILBOX_4                                   642
+#define EIC7700_CLK_MAILBOX_5                                   643
+#define EIC7700_CLK_MAILBOX_6                                   644
+#define EIC7700_CLK_MAILBOX_7                                   645
+#define EIC7700_CLK_MAILBOX_8                                   646
+#define EIC7700_CLK_MAILBOX_9                                   647
+#define EIC7700_CLK_MAILBOX_10                                  648
+#define EIC7700_CLK_MAILBOX_11                                  649
+#define EIC7700_CLK_MAILBOX_12                                  650
+#define EIC7700_CLK_MAILBOX_13                                  651
+#define EIC7700_CLK_MAILBOX_14                                  652
+#define EIC7700_CLK_MAILBOX_15                                  653
+#define EIC7700_CLK_LSP_I2C0_PCLK                               654
+#define EIC7700_CLK_LSP_I2C1_PCLK                               655
+#define EIC7700_CLK_LSP_I2C2_PCLK                               656
+#define EIC7700_CLK_LSP_I2C3_PCLK                               657
+#define EIC7700_CLK_LSP_I2C4_PCLK                               658
+#define EIC7700_CLK_LSP_I2C5_PCLK                               659
+#define EIC7700_CLK_LSP_I2C6_PCLK                               660
+#define EIC7700_CLK_LSP_I2C7_PCLK                               661
+#define EIC7700_CLK_LSP_I2C8_PCLK                               662
+#define EIC7700_CLK_LSP_I2C9_PCLK                               663
+#define EIC7700_CLK_LSP_WDT0_PCLK                               664
+#define EIC7700_CLK_LSP_WDT1_PCLK                               665
+#define EIC7700_CLK_LSP_WDT2_PCLK                               666
+#define EIC7700_CLK_LSP_WDT3_PCLK                               667
+#define EIC7700_CLK_LSP_SSI0_PCLK                               668
+#define EIC7700_CLK_LSP_SSI1_PCLK                               669
+#define EIC7700_CLK_LSP_PVT_PCLK                                670
+#define EIC7700_CLK_AON_I2C0_PCLK                               671
+#define EIC7700_CLK_AON_I2C1_PCLK                               672
+#define EIC7700_CLK_LSP_UART0_PCLK                              673
+#define EIC7700_CLK_LSP_UART1_PCLK                              674
+#define EIC7700_CLK_LSP_UART2_PCLK                              675
+#define EIC7700_CLK_LSP_UART3_PCLK                              676
+#define EIC7700_CLK_LSP_UART4_PCLK                              677
+#define EIC7700_CLK_LSP_TIMER_PCLK                              678         //LSP timer
+#define EIC7700_CLK_LSP_FAN_PCLK                                679
+#define EIC7700_CLK_DSP_ACLK_0                                  680
+#define EIC7700_CLK_DSP_ACLK_1                                  681
+#define EIC7700_CLK_DSP_ACLK_2                                  682
+#define EIC7700_CLK_DSP_ACLK_3                                  683
+
+#define EIC7700_CLK_VC_JE_PCLK                                  685
+#define EIC7700_CLK_VC_JD_PCLK                                  686
+#define EIC7700_CLK_VC_VE_PCLK                                  687
+#define EIC7700_CLK_VC_VD_PCLK                                  688
+#define EIC7700_CLK_VC_MON_PCLK                                 689
+
+#define EIC7700_CLK_HSP_DMA0_CLK                                690
+
+#define EIC7700_NR_CLKS                                         700
+
+/* run frquency */
+#define CLK_FREQ_1800M					1800000000
+#define CLK_FREQ_1700M					1700000000
+#define CLK_FREQ_1600M					1600000000
+#define CLK_FREQ_1500M					1500000000
+#define CLK_FREQ_1400M					1400000000
+#define CLK_FREQ_1300M					1300000000
+#define CLK_FREQ_1200M					1200000000
+#define CLK_FREQ_1000M					1000000000
+#define CLK_FREQ_900M					900000000
+#define CLK_FREQ_800M					800000000
+#define CLK_FREQ_700M					700000000
+#define CLK_FREQ_600M					600000000
+#define CLK_FREQ_500M					500000000
+#define CLK_FREQ_400M					400000000
+#define CLK_FREQ_200M					200000000
+#define CLK_FREQ_100M					100000000
+#define CLK_FREQ_24M					24000000
+
+#define APLL_HIGH_FREQ					983040000
+#define APLL_LOW_FREQ 					225792000
+
+#endif /*endif __DTS_EIC7700_CLOCK_H*/
diff --git a/include/dt-bindings/interconnect/eic7700.h b/include/dt-bindings/interconnect/eic7700.h
new file mode 100644
index 000000000000..984b7cc0840f
--- /dev/null
+++ b/include/dt-bindings/interconnect/eic7700.h
@@ -0,0 +1,141 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Interconnect driver for Eswin EIC7700 SoC
+ *
+ * Copyright (C) 2022  Beiging Eswin Co. Ltd
+ * Author: Huangyifeng <huangyifeng@eswincomputing.com>
+ */
+
+#ifndef _DT_BINDINGS_INTERCONNECT_EIC7700_H_
+#define _DT_BINDINGS_INTERCONNECT_EIC7700_H_
+
+#define OFFSET0                              (0)
+#define OFFSET1                              (1)
+#define OFFSET2                              (2)
+#define OFFSET3                              (3)
+#define OFFSET4                              (4)
+#define OFFSET5                              (5)
+#define OFFSET6                              (6)
+#define OFFSET7                              (7)
+#define OFFSET8                              (8)
+#define OFFSET9                              (9)
+#define OFFSET10                             (10)
+#define OFFSET11                             (11)
+#define OFFSET12                             (12)
+#define OFFSET13                             (13)
+#define OFFSET14                             (14)
+#define OFFSET15                             (15)
+#define OFFSET16                             (16)
+#define OFFSET17                             (17)
+#define OFFSET18                             (18)
+#define OFFSET19                             (19)
+#define OFFSET20                             (20)
+#define OFFSET21                             (21)
+#define OFFSET22                             (22)
+#define OFFSET23                             (23)
+
+#define OFFSET31                             (31)
+
+/*sideband manager module id defination*/
+/*sys noc*/
+#define SBM_AON_SNOC_SP0	0
+#define SBM_DSPT_SNOC		1
+#define SBM_JTAG_SNOC		2
+#define SBM_MCPUT_SNOC_D2D	3
+#define SBM_MCPUT_SNOC_MP	4
+#define SBM_MCPUT_SNOC_SP0	5
+#define SBM_MCPUT_SNOC_SP1	6
+#define SBM_NPU_SNOC_SP0	7
+#define SBM_NPU_SNOC_SP1	8
+#define SBM_PCIET_SNOC_P	9
+#define SBM_SPISLV_PCIET_SNOC	10
+#define SBM_TBU4_SNOC		11
+#define SBM_TCU_SNOC		12
+#define SBM_SNOC_AON		13
+#define SBM_SNOC_DDR0_P1	14
+#define SBM_SNOC_DDR0_P2	15
+#define SBM_SNOC_DDR1_P1	16
+#define SBM_SNOC_DDR1_P2	17
+#define SBM_SNOC_DSPT		18
+#define SBM_SNOC_MCPUT_D2D	19
+#define SBM_SNOC_NPU		20
+#define SBM_SNOC_PCIET		21
+
+/*cfg noc*/
+#define SBM_CLMM		30
+#define SBM_CNOC_AON		31
+#define SBM_CNOC_DDRT0_CTRL	32
+#define SBM_CNOC_DDRT0_PHY	33
+#define SBM_CNOC_DDRT1_CTRL	34
+#define SBM_CNOC_DDRT1_PHY	35
+#define SBM_CNOC_DSPT		36
+#define SBM_CNOC_GPU		37
+#define SBM_CNOC_HSP		38
+#define SBM_CNOC_LSP_APB2	39
+#define SBM_CNOC_LSP_APB3	40
+#define SBM_CNOC_LSP_APB4	41
+#define SBM_CNOC_LSP_APB6	42
+#define SBM_CNOC_MCPUT_D2D	43
+#define SBM_CNOC_NPU		44
+#define SBM_CNOC_PCIET_P	45
+#define SBM_CNOC_PCIET_X	46
+#define SBM_CNOC_TCU		47
+#define SBM_CNOC_VC		48
+#define SBM_CNOC_VI		49
+#define SBM_CNOC_VO		50
+
+/*llc noc*/
+#define SBM_LNOC_NPU_LLC0		60
+#define SBM_LNOC_NPU_LLC1		61
+#define SBM_LNOC_DDRT0_P0		62
+#define SBM_LNOC_DDRT1_P0		63
+
+/*media noc*/
+#define SBM_MNOC_GPU			70
+#define SBM_MNOC_TBU2			71
+#define SBM_MNOC_VC			72
+#define SBM_MNOC_DDRT0_P3		73
+#define SBM_MNOC_DDRT1_P3		74
+
+/*realtime noc*/
+#define SBM_RNOC_TBU0			80
+#define SBM_RNOC_VO			81
+#define SBM_RNOC_DDRT0_P4		82
+#define SBM_RNOC_DDRT1_P4		83
+
+/*RouteID defination*/
+#define        aon_snoc_sp0_I_O        0x0
+#define        dspt_snoc_I_O           0x1
+#define        jtag_snoc_I_O           0x2
+#define        mcput_snoc_d2d_I_O      0x3
+#define        mcput_snoc_mp_I_O       0x4
+#define        mcput_snoc_sp0_I_O      0x5
+#define        mcput_snoc_sp1_I_O      0x6
+#define        mnoc_snoc_I_O           0x7
+#define        npu_snoc_sp0_I_O        0x8
+#define        npu_snoc_sp1_I_O        0x9
+#define        pciet_snoc_p_I_O        0xA
+#define        rnoc_snoc_I_O           0xB
+#define        spislv_tbu3_snoc_I_O    0xC
+#define        tbu4_snoc_I_O           0xD
+#define        tcu_snoc_I_O            0xE
+#define        RESERVED0               0xF
+
+#define        snoc_aon_T_O            0x0
+#define        snoc_cnoc_T_O           0x1
+#define        snoc_ddrt0_p1_T_O       0x2
+#define        snoc_ddrt0_p2_T_O       0x3
+#define        snoc_ddrt1_p1_T_O       0x4
+#define        snoc_ddrt1_p2_T_O       0x5
+#define        snoc_dspt_T_O           0x6
+#define        snoc_lnoc_T_O           0x7
+#define        snoc_mcput_d2d_T_O      0x8
+#define        snoc_mnoc_T_O           0x9
+#define        snoc_npu_T_O            0xA
+#define        snoc_pciet_T_O          0xB
+#define        snoc_rnoc_T_O           0xC
+#define        snoc_service_T_O        0xD
+#define        RESERVED1               0xE
+#define        RESERVED2               0xF
+
+#endif /* _DT_BINDINGS_INTERCONNECT_EIC7700_H_ */
diff --git a/include/dt-bindings/mailbox/eswin-mailbox.h b/include/dt-bindings/mailbox/eswin-mailbox.h
new file mode 100755
index 000000000000..1c82418dbadc
--- /dev/null
+++ b/include/dt-bindings/mailbox/eswin-mailbox.h
@@ -0,0 +1,88 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN Mailbox Driver
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#ifndef _DTS_ESWIN_MAILBOX_H_
+#define _DTS_ESWIN_MAILBOX_H_
+
+#define ESWIN_MAILBOX_U84_TO_SCPU_REG_BASE   0x50a00000 /*maibox 0*/
+#define ESWIN_MAILBOX_SCPU_TO_U84_REG_BASE   0x50a10000 /*maibox 1*/
+
+#define ESWIN_MAILBOX_U84_TO_LPCPU_REG_BASE  0x50a20000 /*maibox 2*/
+#define ESWIN_MAILBOX_LPCPU_TO_U84_REG_BASE  0x50a30000 /*maibox 3*/
+
+#define ESWIN_MAILBOX_U84_TO_NPU_0_REG_BASE  0x50a40000 /*maibox 4*/
+#define ESWIN_MAILBOX_NPU_0_TO_U84_REG_BASE  0x50a50000 /*maibox 5*/
+
+#define ESWIN_MAILBOX_U84_TO_NPU_1_REG_BASE  0x50a60000 /*maibox 6*/
+#define ESWIN_MAILBOX_NP1_0_TO_U84_REG_BASE  0x50a70000 /*maibox 7*/
+
+#define ESWIN_MAILBOX_U84_TO_DSP_0_REG_BASE  0x50a80000 /*maibox 8*/
+#define ESWIN_MAILBOX_DSP_0_TO_U84_REG_BASE  0x50a90000 /*maibox 9*/
+
+#define ESWIN_MAILBOX_U84_TO_DSP_1_REG_BASE  0x50aa0000 /*maibox 10*/
+#define ESWIN_MAILBOX_DSP_1_TO_U84_REG_BASE  0x50ab0000 /*maibox 11*/
+
+#define ESWIN_MAILBOX_U84_TO_DSP_2_REG_BASE  0x50ac0000 /*maibox 12*/
+#define ESWIN_MAILBOX_DSP_2_TO_U84_REG_BASE  0x50ad0000 /*maibox 13*/
+
+#define ESWIN_MAILBOX_U84_TO_DSP_3_REG_BASE  0x50ae0000 /*maibox 14*/
+#define ESWIN_MAILBOX_DSP_3_TO_U84_REG_BASE  0x50af0000 /*maibox 15*/
+
+#define BIT0                              (1 << 0)
+#define BIT1                              (1 << 1)
+#define BIT2                              (1 << 2)
+#define BIT3                              (1 << 3)
+#define BIT4                              (1 << 4)
+#define BIT5                              (1 << 5)
+#define BIT6                              (1 << 6)
+#define BIT7                              (1 << 7)
+#define BIT8                              (1 << 8)
+#define BIT9                              (1 << 9)
+#define BIT10                             (1 << 10)
+#define BIT11                             (1 << 11)
+#define BIT12                             (1 << 12)
+#define BIT13                             (1 << 13)
+#define BIT14                             (1 << 14)
+#define BIT31                             (1 << 31)
+
+#define ESWIN_MAILBOX_WR_LOCK_BIT_U84      BIT0
+#define ESWIN_MAILBOX_WR_LOCK_BIT_SCPU     BIT1
+#define ESWIN_MAILBOX_WR_LOCK_BIT_LPCPU    BIT2
+#define ESWIN_MAILBOX_WR_LOCK_BIT_NPU_0    BIT3
+#define ESWIN_MAILBOX_WR_LOCK_BIT_NPU_1    BIT4
+#define ESWIN_MAILBOX_WR_LOCK_BIT_DSP_0    BIT5
+#define ESWIN_MAILBOX_WR_LOCK_BIT_DSP_1    BIT6
+#define ESWIN_MAILBOX_WR_LOCK_BIT_DSP_2    BIT7
+#define ESWIN_MAILBOX_WR_LOCK_BIT_DSP_3    BIT8
+
+
+#define ESWIN_MAIBOX_U84_IRQ_BIT           BIT0
+#define ESWIN_MAIBOX_SCPU_IRQ_BIT          BIT1
+#define ESWIN_MAIBOX_LPCPU_IRQ_BIT         BIT2
+#define ESWIN_MAIBOX_NPU_0_IRQ_BIT         BIT3
+#define ESWIN_MAIBOX_NPU_1_IRQ_BIT         BIT4
+#define ESWIN_MAIBOX_DSP_0_IRQ_BIT         BIT5
+#define ESWIN_MAIBOX_DSP_1_IRQ_BIT         BIT6
+#define ESWIN_MAIBOX_DSP_2_IRQ_BIT         BIT7
+#define ESWIN_MAIBOX_DSP_3_IRQ_BIT         BIT8
+
+#endif /* _DTS_ESWIN_MAILBOX_H_ */
diff --git a/include/dt-bindings/memory/eic7700-sid.h b/include/dt-bindings/memory/eic7700-sid.h
new file mode 100644
index 000000000000..0fa589ec93b1
--- /dev/null
+++ b/include/dt-bindings/memory/eic7700-sid.h
@@ -0,0 +1,138 @@
+#ifndef DT_BINDINGS_MEMORY_EIC7700_SID_H
+#define DT_BINDINGS_MEMORY_EIC7700_SID_H
+
+#define EIC7700_SID_DMA0	1
+
+#define EIC7700_SID_JDEC	2
+
+#define EIC7700_SID_JENC	3
+
+/* NPU DMA*/
+#define EIC7700_SID_NPU_DMA	4
+
+/* NPU-E31 */
+#define EIC7700_SID_NPU_E31	5
+
+/* Video In */
+#define EIC7700_SID_ISP0	6
+
+//#define EIC7700_SID_ISP1	EIC7700_SID_ISP0
+
+#define EIC7700_SID_DW		8
+
+#define EIC7700_SID_DVP		9
+
+/* High Speed */
+#define EIC7700_SID_USB0	10
+
+#define EIC7700_SID_USB1	11
+
+#define EIC7700_SID_ETH0	12
+
+#define EIC7700_SID_ETH1	13
+
+#define EIC7700_SID_SATA	14
+
+#define EIC7700_SID_EMMC0	15
+
+#define EIC7700_SID_SD0		16
+
+#define EIC7700_SID_SD1		17
+
+
+/* DSP */
+#define EIC7700_SID_DSP_0	18
+#define EIC7700_SID_DSP_1	19
+#define EIC7700_SID_DSP_2	20
+#define EIC7700_SID_DSP_3	21
+
+/* CODEC */
+//#define EIC7700_SID_VDEC	EIC7700_SID_JDEC
+
+//#define EIC7700_SID_VENC	EIC7700_SID_JENC
+
+/*** AON subsystem ***/
+/* Secure CPU */
+#define EIC7700_SID_SCPU	24
+#define SCPU_SID_REG_OFFSET	0x1004
+
+/* Low power CPU */
+#define EIC7700_SID_LCPU	25
+#define LCPU_SID_REG_OFFSET	0x2004
+
+/* Always on, DMA1 */
+#define EIC7700_SID_DMA1	26
+#define DMA1_SID_REG_OFFSET	0x3004
+
+/* crypt */
+//#define EIC7700_SID_CRYPT	EIC7700_SID_SCPU
+#define CRYPT_SID_REG_OFFSET	0x4004
+
+///*** for iova mapping test ***/
+//#define EIC7700_SID_DEV_FOO_A        28
+//#define EIC7700_SID_DEV_FOO_B        29
+//#define EIC7700_SID_DEV_FOO_FOR_DIE1	30
+
+
+/*** tbu id ***/
+/* tbu_id: bit[3:0] is for major, bit[7:4] is for minor;
+	For example, tbu of dsp3 is tbu7_3, the bu 0x73. It measn tbu7_3
+*/
+#define	EIC7700_TBUID_0x0	0x0
+
+#define	EIC7700_TBUID_0x10	0x10
+#define	EIC7700_TBUID_0x11	0x11
+#define	EIC7700_TBUID_0x12	0x12
+#define	EIC7700_TBUID_0x13	0x13
+
+#define	EIC7700_TBUID_0x2	0x2
+
+#define	EIC7700_TBUID_0x3	0x3
+
+#define	EIC7700_TBUID_0x4	0x4
+
+#define	EIC7700_TBUID_0x5	0x5
+
+#define	EIC7700_TBUID_0x70	0x70
+#define	EIC7700_TBUID_0x71	0x71
+#define	EIC7700_TBUID_0x72	0x72
+#define	EIC7700_TBUID_0x73	0x73
+
+#define	EIC7700_TBUID_0xF00	0xF00	// simulation for EIC7700_SID_DEV_FOO_A/B, No real tbu attached infact
+
+
+/* For better use by devices in dts, create tbu alias for devices*/
+#define EIC7700_TBUID_ISP	EIC7700_TBUID_0x0
+#define EIC7700_TBUID_DW	EIC7700_TBUID_ISP
+
+#define EIC7700_TBUID_VDEC	EIC7700_TBUID_0x10
+#define EIC7700_TBUID_VENC	EIC7700_TBUID_0x11
+#define EIC7700_TBUID_JENC	EIC7700_TBUID_0x12
+#define EIC7700_TBUID_JDEC	EIC7700_TBUID_0x13
+
+//high speed modules share the same tbu2
+#define EIC7700_TBUID_DMA0	EIC7700_TBUID_0x2
+#define EIC7700_TBUID_USB	EIC7700_TBUID_DMA0
+#define EIC7700_TBUID_ETH	EIC7700_TBUID_DMA0
+#define EIC7700_TBUID_SATA	EIC7700_TBUID_DMA0
+#define EIC7700_TBUID_EMMC	EIC7700_TBUID_DMA0
+#define EIC7700_TBUID_SD	EIC7700_TBUID_DMA0
+
+#define EIC7700_TBUID_PCIE	EIC7700_TBUID_0x3
+
+//scpu, crypto, lpcpu, dma1 share the same tbu4
+#define EIC7700_TBUID_SCPU	EIC7700_TBUID_0x4
+#define EIC7700_TBUID_CRYPT	EIC7700_TBUID_SCPU
+#define EIC7700_TBUID_DMA1	EIC7700_TBUID_SCPU
+#define EIC7700_TBUID_LPCPU	EIC7700_TBUID_SCPU
+
+//npu
+#define EIC7700_TBUID_NPU	EIC7700_TBUID_0x5
+
+//dsp
+#define EIC7700_TBUID_DSP0	EIC7700_TBUID_0x70
+#define EIC7700_TBUID_DSP1	EIC7700_TBUID_0x71
+#define EIC7700_TBUID_DSP2	EIC7700_TBUID_0x72
+#define EIC7700_TBUID_DSP3	EIC7700_TBUID_0x73
+
+#endif
diff --git a/include/dt-bindings/reset/eic7700-syscrg.h b/include/dt-bindings/reset/eic7700-syscrg.h
new file mode 100755
index 000000000000..ea1ff1874a85
--- /dev/null
+++ b/include/dt-bindings/reset/eic7700-syscrg.h
@@ -0,0 +1,693 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ESWIN SysCrg Definition
+ *
+ * Copyright 2024, Beijing ESWIN Computing Technology Co., Ltd.. All rights reserved.
+ * SPDX-License-Identifier: GPL-2.0
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, version 2.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ * Authors: HuangYiFeng<huangyifeng@eswincomputing.com>
+ */
+
+#ifndef __DT_ESWIN_EIC7700_SYSCRG_H__
+#define __DT_ESWIN_EIC7700_SYSCRG_H__
+
+/*REG OFFSET OF SYS-CRG*/
+
+#define EIC7700_REG_OFFSET_SPLL0_CFG_0                          0X0000
+#define EIC7700_REG_OFFSET_SPLL0_CFG_1                          0X0004
+#define EIC7700_REG_OFFSET_SPLL0_CFG_2                          0X0008
+#define EIC7700_REG_OFFSET_SPLL0_DSKEWCAL                       0X000C
+#define EIC7700_REG_OFFSET_SPLL0_SSC                            0X0010
+#define EIC7700_REG_OFFSET_SPLL1_CFG_0                          0X0014
+#define EIC7700_REG_OFFSET_SPLL1_CFG_1                          0X0018
+#define EIC7700_REG_OFFSET_SPLL1_CFG_2                          0X001C
+#define EIC7700_REG_OFFSET_SPLL1_DSKEWCAL                       0X0020
+#define EIC7700_REG_OFFSET_SPLL1_SSC                            0X0024
+#define EIC7700_REG_OFFSET_SPLL2_CFG_0                          0X0028
+#define EIC7700_REG_OFFSET_SPLL2_CFG_1                          0X002C
+#define EIC7700_REG_OFFSET_SPLL2_CFG_2                          0X0030
+#define EIC7700_REG_OFFSET_SPLL2_DSKEWCAL                       0X0034
+#define EIC7700_REG_OFFSET_SPLL2_SSC                            0X0038
+#define EIC7700_REG_OFFSET_VPLL_CFG_0                           0X003C
+#define EIC7700_REG_OFFSET_VPLL_CFG_1                           0X0040
+#define EIC7700_REG_OFFSET_VPLL_CFG_2                           0X0044
+#define EIC7700_REG_OFFSET_VPLL_DSKEWCAL                        0X0048
+#define EIC7700_REG_OFFSET_VPLL_SSC                             0X004C
+#define EIC7700_REG_OFFSET_APLL_CFG_0                           0X0050
+#define EIC7700_REG_OFFSET_APLL_CFG_1                           0X0054
+#define EIC7700_REG_OFFSET_APLL_CFG_2                           0X0058
+#define EIC7700_REG_OFFSET_APLL_DSKEWCAL                        0X005C
+#define EIC7700_REG_OFFSET_APLL_SSC                             0X0060
+#define EIC7700_REG_OFFSET_MCPUT_PLL_CFG_0                      0X0064
+#define EIC7700_REG_OFFSET_MCPUT_PLL_CFG_1                      0X0068
+#define EIC7700_REG_OFFSET_MCPUT_PLL_CFG_2                      0X006C
+#define EIC7700_REG_OFFSET_MCPUT_PLL_DSKEWCAL                   0X0070
+#define EIC7700_REG_OFFSET_MCPUT_PLL_SSC                        0X0074
+#define EIC7700_REG_OFFSET_DDRT_PLL_CFG_0                       0X0078
+#define EIC7700_REG_OFFSET_DDRT_PLL_CFG_1                       0X007C
+#define EIC7700_REG_OFFSET_DDRT_PLL_CFG_2                       0X0080
+#define EIC7700_REG_OFFSET_DDRT_PLL_DSKEWCAL                    0X0084
+#define EIC7700_REG_OFFSET_DDRT_PLL_SSC                         0X0088
+#define EIC7700_REG_OFFSET_PLL_STATUS                           0X00A4
+#define EIC7700_REG_OFFSET_NOC_CLK_CTRL                         0X100
+#define EIC7700_REG_OFFSET_BOOTSPI_CLK_CTRL                     0X104
+#define EIC7700_REG_OFFSET_BOOTSPI_CFGCLK_CTRL                  0X108
+#define EIC7700_REG_OFFSET_SCPU_CORECLK_CTRL                    0X10C
+#define EIC7700_REG_OFFSET_SCPU_BUSCLK_CTRL                     0X110
+#define EIC7700_REG_OFFSET_LPCPU_CORECLK_CTRL                   0X114
+#define EIC7700_REG_OFFSET_LPCPU_BUSCLK_CTRL                    0X118
+#define EIC7700_REG_OFFSET_TCU_ACLK_CTRL                        0X11C
+#define EIC7700_REG_OFFSET_TCU_CFG_CTRL                         0X120
+#define EIC7700_REG_OFFSET_DDR_CLK_CTRL                         0X124
+#define EIC7700_REG_OFFSET_DDR1_CLK_CTRL                        0X128
+#define EIC7700_REG_OFFSET_GPU_ACLK_CTRL                        0X12C
+#define EIC7700_REG_OFFSET_GPU_CFG_CTRL                         0X130
+#define EIC7700_REG_OFFSET_GPU_GRAY_CTRL                        0X134
+#define EIC7700_REG_OFFSET_DSP_ACLK_CTRL                        0X138
+#define EIC7700_REG_OFFSET_DSP_CFG_CTRL                         0X13C
+#define EIC7700_REG_OFFSET_D2D_ACLK_CTRL                        0X140
+#define EIC7700_REG_OFFSET_D2D_CFG_CTRL                         0X144
+#define EIC7700_REG_OFFSET_HSP_ACLK_CTRL                        0X148
+#define EIC7700_REG_OFFSET_HSP_CFG_CTRL                         0X14C
+#define EIC7700_REG_OFFSET_SATA_RBC_CTRL                        0X150
+#define EIC7700_REG_OFFSET_SATA_OOB_CTRL                        0X154
+#define EIC7700_REG_OFFSET_ETH0_CTRL                            0X158
+#define EIC7700_REG_OFFSET_ETH1_CTRL                            0X15C
+#define EIC7700_REG_OFFSET_MSHC0_CORECLK_CTRL                   0X160
+#define EIC7700_REG_OFFSET_MSHC1_CORECLK_CTRL                   0X164
+#define EIC7700_REG_OFFSET_MSHC2_CORECLK_CTRL                   0X168
+#define EIC7700_REG_OFFSET_MSHC_USB_SLWCLK                      0X16C
+#define EIC7700_REG_OFFSET_PCIE_ACLK_CTRL                       0X170
+#define EIC7700_REG_OFFSET_PCIE_CFG_CTRL                        0X174
+#define EIC7700_REG_OFFSET_NPU_ACLK_CTRL                        0X178
+#define EIC7700_REG_OFFSET_NPU_LLC_CTRL                         0X17C
+#define EIC7700_REG_OFFSET_NPU_CORE_CTRL                        0X180
+#define EIC7700_REG_OFFSET_VI_DWCLK_CTRL                        0X184
+#define EIC7700_REG_OFFSET_VI_ACLK_CTRL                         0X188
+#define EIC7700_REG_OFFSET_VI_DIG_ISP_CLK_CTRL                  0X18C
+#define EIC7700_REG_OFFSET_VI_DVP_CLK_CTRL                      0X190
+#define EIC7700_REG_OFFSET_VI_SHUTTER0                          0X194
+#define EIC7700_REG_OFFSET_VI_SHUTTER1                          0X198
+#define EIC7700_REG_OFFSET_VI_SHUTTER2                          0X19C
+#define EIC7700_REG_OFFSET_VI_SHUTTER3                          0X1A0
+#define EIC7700_REG_OFFSET_VI_SHUTTER4                          0X1A4
+#define EIC7700_REG_OFFSET_VI_SHUTTER5                          0X1A8
+#define EIC7700_REG_OFFSET_VI_PHY_CLKCTRL                       0X1AC
+#define EIC7700_REG_OFFSET_VO_ACLK_CTRL                         0X1B0
+#define EIC7700_REG_OFFSET_VO_IESMCLK_CTRL                      0X1B4
+#define EIC7700_REG_OFFSET_VO_PIXEL_CTRL                        0X1B8
+#define EIC7700_REG_OFFSET_VO_MCLK_CTRL                         0X1BC
+#define EIC7700_REG_OFFSET_VO_PHY_CLKCTRL                       0X1C0
+#define EIC7700_REG_OFFSET_VC_ACLK_CTRL                         0X1C4
+#define EIC7700_REG_OFFSET_VCDEC_ROOTCLK_CTRL                   0X1C8
+#define EIC7700_REG_OFFSET_G2D_CTRL                             0X1CC
+#define EIC7700_REG_OFFSET_VC_CLKEN_CTRL                        0X1D0
+#define EIC7700_REG_OFFSET_JE_CLK_CTRL                          0X1D4
+#define EIC7700_REG_OFFSET_JD_CLK_CTRL                          0X1D8
+#define EIC7700_REG_OFFSET_VD_CLK_CTRL                          0X1DC
+#define EIC7700_REG_OFFSET_VE_CLK_CTRL                          0X1E0
+#define EIC7700_REG_OFFSET_AON_DMA_CLK_CTRL                     0X1E4
+#define EIC7700_REG_OFFSET_TIMER_CLK_CTRL                       0X1E8
+#define EIC7700_REG_OFFSET_RTC_CLK_CTRL                         0X1EC
+#define EIC7700_REG_OFFSET_PKA_CLK_CTRL                         0X1F0
+#define EIC7700_REG_OFFSET_SPACC_CLK_CTRL                       0X1F4
+#define EIC7700_REG_OFFSET_TRNG_CLK_CTRL                        0X1F8
+#define EIC7700_REG_OFFSET_OTP_CLK_CTRL                         0X1FC
+#define EIC7700_REG_OFFSET_LSP_CLK_EN0                          0X200
+#define EIC7700_REG_OFFSET_LSP_CLK_EN1                          0X204
+#define EIC7700_REG_OFFSET_U84_CLK_CTRL                         0X208
+#define EIC7700_REG_OFFSET_SYSCFG_CLK_CTRL                      0X20C
+#define EIC7700_REG_OFFSET_I2C0_CLK_CTRL                        0X210
+#define EIC7700_REG_OFFSET_I2C1_CLK_CTRL                        0X214
+#define EIC7700_REG_OFFSET_DFT_CLK_CTRL                         0X280
+#define EIC7700_REG_OFFSET_SYS_SWRST_VALUE                      0X300
+#define EIC7700_REG_OFFSET_CLR_RST_STATUS                       0X304
+#define EIC7700_REG_OFFSET_DIE_STATUS                           0X308
+#define EIC7700_REG_OFFSET_CLR_BOOT_INFO                        0X30C
+#define EIC7700_REG_OFFSET_SCPU_BOOT_ADDRESS                    0X310
+#define EIC7700_REG_OFFSET_LPCPU_BOOT_ADDRESS                   0X314
+#define EIC7700_REG_OFFSET_NPUE31_BOOT_ADDRESS                  0X318
+#define EIC7700_REG_OFFSET_U84_BOOT_ADDRESS0_HI                 0X31C
+#define EIC7700_REG_OFFSET_U84_BOOT_ADDRESS0_LOW                0X320
+#define EIC7700_REG_OFFSET_U84_BOOT_ADDRESS1_HI                 0X324
+#define EIC7700_REG_OFFSET_U84_BOOT_ADDRESS1_LOW                0X328
+#define EIC7700_REG_OFFSET_U84_BOOT_ADDRESS2_HI                 0X32C
+#define EIC7700_REG_OFFSET_U84_BOOT_ADDRESS2_LOW                0X330
+#define EIC7700_REG_OFFSET_U84_BOOT_ADDRESS3_HI                 0X334
+#define EIC7700_REG_OFFSET_U84_BOOT_ADDRESS3_LOW                0X338
+#define EIC7700_REG_OFFSET_BOOT_SEL_STAT                        0X33C
+#define EIC7700_REG_OFFSET_BOOT_SPI_CFG                         0X340
+#define EIC7700_REG_OFFSET_SNOC_RST_CTRL                        0X400
+#define EIC7700_REG_OFFSET_GPU_RST_CTRL                         0X404
+#define EIC7700_REG_OFFSET_DSP_RST_CTRL                         0X408
+#define EIC7700_REG_OFFSET_D2D_RST_CTRL                         0X40C
+#define EIC7700_REG_OFFSET_DDR_RST_CTRL                         0X410
+#define EIC7700_REG_OFFSET_TCU_RST_CTRL                         0X414
+#define EIC7700_REG_OFFSET_NPU_RST_CTRL                         0X418
+#define EIC7700_REG_OFFSET_HSPDMA_RST_CTRL                      0X41C
+#define EIC7700_REG_OFFSET_PCIE_RST_CTRL                        0X420
+#define EIC7700_REG_OFFSET_I2C_RST_CTRL                         0X424
+#define EIC7700_REG_OFFSET_FAN_RST_CTRL                         0X428
+#define EIC7700_REG_OFFSET_PVT_RST_CTRL                         0X42C
+#define EIC7700_REG_OFFSET_MBOX_RST_CTRL                        0X430
+#define EIC7700_REG_OFFSET_UART_RST_CTRL                        0X434
+#define EIC7700_REG_OFFSET_GPIO_RST_CTRL                        0X438
+#define EIC7700_REG_OFFSET_TIMER_RST_CTRL                       0X43C
+#define EIC7700_REG_OFFSET_SSI_RST_CTRL                         0X440
+#define EIC7700_REG_OFFSET_WDT_RST_CTRL                         0X444
+#define EIC7700_REG_OFFSET_LSP_CFGRST_CTRL                      0X448
+#define EIC7700_REG_OFFSET_U84_RST_CTRL                         0X44C
+#define EIC7700_REG_OFFSET_SCPU_RST_CTRL                        0X450
+#define EIC7700_REG_OFFSET_LPCPU_RST_CTRL                       0X454
+#define EIC7700_REG_OFFSET_VC_RST_CTRL                          0X458
+#define EIC7700_REG_OFFSET_JD_RST_CTRL                          0X45C
+#define EIC7700_REG_OFFSET_JE_RST_CTRL                          0X460
+#define EIC7700_REG_OFFSET_VD_RST_CTRL                          0X464
+#define EIC7700_REG_OFFSET_VE_RST_CTRL                          0X468
+#define EIC7700_REG_OFFSET_G2D_RST_CTRL                         0X46C
+#define EIC7700_REG_OFFSET_VI_RST_CTRL                          0X470
+#define EIC7700_REG_OFFSET_DVP_RST_CTRL                         0X474
+#define EIC7700_REG_OFFSET_ISP0_RST_CTRL                        0X478
+#define EIC7700_REG_OFFSET_ISP1_RST_CTRL                        0X47C
+#define EIC7700_REG_OFFSET_SHUTTER_RST_CTRL                     0X480
+#define EIC7700_REG_OFFSET_VO_PHYRST_CTRL                       0X484
+#define EIC7700_REG_OFFSET_VO_I2SRST_CTRL                       0X488
+#define EIC7700_REG_OFFSET_VO_RST_CTRL                          0X48C
+#define EIC7700_REG_OFFSET_BOOTSPI_RST_CTRL                     0X490
+#define EIC7700_REG_OFFSET_I2C1_RST_CTRL                        0X494
+#define EIC7700_REG_OFFSET_I2C0_RST_CTRL                        0X498
+#define EIC7700_REG_OFFSET_DMA1_RST_CTRL                        0X49C
+#define EIC7700_REG_OFFSET_FPRT_RST_CTRL                        0X4A0
+#define EIC7700_REG_OFFSET_HBLOCK_RST_CTRL                      0X4A4
+#define EIC7700_REG_OFFSET_SECSR_RST_CTRL                       0X4A8
+#define EIC7700_REG_OFFSET_OTP_RST_CTRL                         0X4AC
+#define EIC7700_REG_OFFSET_PKA_RST_CTRL                         0X4B0
+#define EIC7700_REG_OFFSET_SPACC_RST_CTRL                       0X4B4
+#define EIC7700_REG_OFFSET_TRNG_RST_CTRL                        0X4B8
+#define EIC7700_REG_OFFSET_TIMER0_RST_CTRL                      0X4C0
+#define EIC7700_REG_OFFSET_TIMER1_RST_CTRL                      0X4C4
+#define EIC7700_REG_OFFSET_TIMER2_RST_CTRL                      0X4C8
+#define EIC7700_REG_OFFSET_TIMER3_RST_CTRL                      0X4CC
+#define EIC7700_REG_OFFSET_RTC_RST_CTRL                         0X4D0
+#define EIC7700_REG_OFFSET_MNOC_RST_CTRL                        0X4D4
+#define EIC7700_REG_OFFSET_RNOC_RST_CTRL                        0X4D8
+#define EIC7700_REG_OFFSET_CNOC_RST_CTRL                        0X4DC
+#define EIC7700_REG_OFFSET_LNOC_RST_CTRL                        0X4E0
+
+/*
+ * RESET DEV ID  FOR EACH RESET CONSUMER
+ *
+ */
+#define		SNOC_RST_CTRL					0X00
+#define		GPU_RST_CTRL					0X01
+#define		DSP_RST_CTRL					0X02
+#define		D2D_RST_CTRL					0X03
+#define		DDR_RST_CTRL					0X04
+#define		TCU_RST_CTRL					0X05
+#define		NPU_RST_CTRL					0X06
+#define		HSPDMA_RST_CTRL					0X07
+#define		PCIE_RST_CTRL					0X08
+#define		I2C_RST_CTRL					0X09
+#define		FAN_RST_CTRL					0X0A
+#define		PVT_RST_CTRL					0X0B
+#define		MBOX_RST_CTRL					0X0C
+#define		UART_RST_CTRL					0X0D
+#define		GPIO_RST_CTRL					0X0E
+#define		TIMER_RST_CTRL					0X0F
+#define		SSI_RST_CTRL					0X10
+#define		WDT_RST_CTRL					0X11
+#define		LSP_CFGRST_CTRL					0X12
+#define		U84_RST_CTRL					0X13
+#define		SCPU_RST_CTRL					0X14
+#define		LPCPU_RST_CTRL					0X15
+#define		VC_RST_CTRL					0X16
+#define		JD_RST_CTRL					0X17
+#define		JE_RST_CTRL					0X18
+#define		VD_RST_CTRL					0X19
+#define		VE_RST_CTRL					0X1A
+#define		G2D_RST_CTRL					0X1B
+#define		VI_RST_CTRL					0X1C
+#define		DVP_RST_CTRL					0X1D
+#define		ISP0_RST_CTRL					0X1E
+#define		ISP1_RST_CTRL					0X1F
+#define		SHUTTER_RST_CTRL				0X20
+#define		VO_PHYRST_CTRL					0X21
+#define		VO_I2SRST_CTRL					0X22
+#define		VO_RST_CTRL					0X23
+#define		BOOTSPI_RST_CTRL				0X24
+#define		I2C1_RST_CTRL					0X25
+#define		I2C0_RST_CTRL					0X26
+#define		DMA1_RST_CTRL					0X27
+#define		FPRT_RST_CTRL					0X28
+#define		HBLOCK_RST_CTRL					0X29
+#define		SECSR_RST_CTRL					0X2A
+#define		OTP_RST_CTRL					0X2B
+#define		PKA_RST_CTRL					0X2C
+#define		SPACC_RST_CTRL					0X2D
+#define		TRNG_RST_CTRL					0X2E
+#define		RESERVED					0X2F
+#define		TIMER0_RST_CTRL					0X30
+#define		TIMER1_RST_CTRL					0X31
+#define		TIMER2_RST_CTRL					0X32
+#define		TIMER3_RST_CTRL					0X33
+#define		RTC_RST_CTRL					0X34
+#define		MNOC_RST_CTRL					0X35
+#define		RNOC_RST_CTRL					0X36
+#define		CNOC_RST_CTRL					0X37
+#define		LNOC_RST_CTRL					0X38
+
+#define BIT0                              (1 << 0)
+#define BIT1                              (1 << 1)
+#define BIT2                              (1 << 2)
+#define BIT3                              (1 << 3)
+#define BIT4                              (1 << 4)
+#define BIT5                              (1 << 5)
+#define BIT6                              (1 << 6)
+#define BIT7                              (1 << 7)
+#define BIT8                              (1 << 8)
+#define BIT9                              (1 << 9)
+#define BIT10                             (1 << 10)
+#define BIT11                             (1 << 11)
+#define BIT12                             (1 << 12)
+#define BIT13                             (1 << 13)
+#define BIT14                             (1 << 14)
+#define BIT15                             (1 << 15)
+#define BIT16                             (1 << 16)
+#define BIT17                             (1 << 17)
+#define BIT18                             (1 << 18)
+#define BIT19                             (1 << 19)
+#define BIT20                             (1 << 20)
+#define BIT21                             (1 << 21)
+#define BIT22                             (1 << 22)
+#define BIT23                             (1 << 23)
+#define BIT24                             (1 << 24)
+#define BIT25                             (1 << 25)
+#define BIT26                             (1 << 26)
+#define BIT27                             (1 << 27)
+#define BIT28                             (1 << 28)
+#define BIT29                             (1 << 29)
+#define BIT30                             (1 << 30)
+#define BIT31                             (1 << 31)
+
+/*
+	CONSUMER RESET CONTROL BIT
+*/
+/*SNOC*/
+#define		SW_NOC_NSP_RSTN						BIT0
+#define		SW_NOC_CFG_RSTN						BIT1
+#define		SW_RNOC_NSP_RSTN					BIT2
+#define		SW_SNOC_TCU_ARSTN					BIT3
+#define		SW_SNOC_U84_ARSTN					BIT4
+#define		SW_SNOC_PCIET_XSRSTN					BIT5
+#define		SW_SNOC_PCIET_XMRSTN					BIT6
+#define		SW_SNOC_PCIET_PRSTN					BIT7
+#define		SW_SNOC_NPU_ARSTN					BIT8
+#define		SW_SNOC_JTAG_ARSTN					BIT9
+#define		SW_SNOC_DSPT_ARSTN					BIT10
+#define		SW_SNOC_DDRC1_P2_ARSTN					BIT11
+#define		SW_SNOC_DDRC1_P1_ARSTN					BIT12
+#define		SW_SNOC_DDRC0_P2_ARSTN					BIT13
+#define		SW_SNOC_DDRC0_P1_ARSTN					BIT14
+#define		SW_SNOC_D2D_ARSTN					BIT15
+#define		SW_SNOC_AON_ARSTN					BIT16
+
+/*GPU*/
+#define		SW_GPU_AXI_RSTN						BIT0
+#define		SW_GPU_CFG_RSTN						BIT1
+#define		SW_GPU_GRAY_RSTN					BIT2
+#define		SW_GPU_JONES_RSTN					BIT3
+#define		SW_GPU_SPU_RSTN						BIT4
+
+/*DSP*/
+#define		SW_DSP_AXI_RSTN						BIT0
+#define		SW_DSP_CFG_RSTN						BIT1
+#define		SW_DSP_DIV4_RSTN					BIT2
+#define		SW_DSP_DIV_RSTN_0					BIT4
+#define		SW_DSP_DIV_RSTN_1					BIT5
+#define		SW_DSP_DIV_RSTN_2					BIT6
+#define		SW_DSP_DIV_RSTN_3					BIT7
+
+/*D2D*/
+#define		SW_D2D_AXI_RSTN						BIT0
+#define		SW_D2D_CFG_RSTN						BIT1
+#define		SW_D2D_PRST_N						BIT2
+#define		SW_D2D_RAW_PCS_RST_N					BIT4
+#define		SW_D2D_RX_RST_N						BIT5
+#define		SW_D2D_TX_RST_N						BIT6
+#define		SW_D2D_CORE_RST_N					BIT7
+
+/*TCU*/
+#define		SW_TCU_AXI_RSTN						BIT0
+#define		SW_TCU_CFG_RSTN						BIT1
+#define		TBU_RSTN_0						BIT4
+#define		TBU_RSTN_1						BIT5
+#define		TBU_RSTN_2						BIT6
+#define		TBU_RSTN_3						BIT7
+#define		TBU_RSTN_4						BIT8
+#define		TBU_RSTN_5						BIT9
+#define		TBU_RSTN_6						BIT10
+#define		TBU_RSTN_7						BIT11
+#define		TBU_RSTN_8						BIT12
+#define		TBU_RSTN_9						BIT13
+#define		TBU_RSTN_10						BIT14
+#define		TBU_RSTN_11						BIT15
+#define		TBU_RSTN_12						BIT16
+#define		TBU_RSTN_13						BIT17
+#define		TBU_RSTN_14						BIT18
+#define		TBU_RSTN_15						BIT19
+#define		TBU_RSTN_16						BIT20
+
+/*NPU*/
+#define		SW_NPU_AXI_RSTN						BIT0
+#define		SW_NPU_CFG_RSTN						BIT1
+#define		SW_NPU_CORE_RSTN					BIT2
+#define		SW_NPU_E31CORE_RSTN					BIT3
+#define		SW_NPU_E31BUS_RSTN					BIT4
+#define		SW_NPU_E31DBG_RSTN					BIT5
+#define		SW_NPU_LLC_RSTN						BIT6
+
+/*HSP DMA*/
+#define		SW_HSP_AXI_RSTN						BIT0
+#define		SW_HSP_CFG_RSTN						BIT1
+#define		SW_HSP_POR_RSTN						BIT2
+#define		SW_MSHC0_PHY_RSTN					BIT3
+#define		SW_MSHC1_PHY_RSTN					BIT4
+#define		SW_MSHC2_PHY_RSTN					BIT5
+#define		SW_MSHC0_TXRX_RSTN					BIT6
+#define		SW_MSHC1_TXRX_RSTN					BIT7
+#define		SW_MSHC2_TXRX_RSTN					BIT8
+#define		SW_SATA_ASIC0_RSTN					BIT9
+#define		SW_SATA_OOB_RSTN					BIT10
+#define		SW_SATA_PMALIVE_RSTN					BIT11
+#define		SW_SATA_RBC_RSTN					BIT12
+#define		SW_DMA0_RST_N						BIT13
+#define		SW_HSP_DMA0_RSTN					BIT14
+#define		SW_USB0_VAUX_RSTN					BIT15
+#define		SW_USB1_VAUX_RSTN					BIT16
+#define		SW_HSP_SD1_PRSTN					BIT17
+#define		SW_HSP_SD0_PRSTN					BIT18
+#define		SW_HSP_EMMC_PRSTN					BIT19
+#define		SW_HSP_DMA_PRSTN					BIT20
+#define		SW_HSP_SD1_ARSTN					BIT21
+#define		SW_HSP_SD0_ARSTN					BIT22
+#define		SW_HSP_EMMC_ARSTN					BIT23
+#define		SW_HSP_DMA_ARSTN					BIT24
+#define		SW_HSP_ETH1_ARSTN					BIT25
+#define		SW_HSP_ETH0_ARSTN					BIT26
+#define		SW_HSP_SATA_ARSTN					BIT27
+
+/*PCIE*/
+#define		SW_PCIE_CFG_RSTN					BIT0
+#define		SW_PCIE_POWERUP_RSTN					BIT1
+#define		SW_PCIE_PERST_N						BIT2
+
+/*I2C*/
+#define		SW_I2C_RST_N_0						BIT0
+#define		SW_I2C_RST_N_1						BIT1
+#define		SW_I2C_RST_N_2						BIT2
+#define		SW_I2C_RST_N_3						BIT3
+#define		SW_I2C_RST_N_4						BIT4
+#define		SW_I2C_RST_N_5						BIT5
+#define		SW_I2C_RST_N_6						BIT6
+#define		SW_I2C_RST_N_7						BIT7
+#define		SW_I2C_RST_N_8						BIT8
+#define		SW_I2C_RST_N_9						BIT9
+
+/*FAN*/
+#define		SW_FAN_RST_N						BIT0
+
+/*PVT*/
+#define		SW_PVT_RST_N_0						BIT0
+#define		SW_PVT_RST_N_1						BIT1
+
+/*MBOX*/
+#define		SW_MBOX_RST_N_0					BIT0
+#define		SW_MBOX_RST_N_1					BIT1
+#define		SW_MBOX_RST_N_2					BIT2
+#define		SW_MBOX_RST_N_3					BIT3
+#define		SW_MBOX_RST_N_4					BIT4
+#define		SW_MBOX_RST_N_5					BIT5
+#define		SW_MBOX_RST_N_6					BIT6
+#define		SW_MBOX_RST_N_7					BIT7
+#define		SW_MBOX_RST_N_8					BIT8
+#define		SW_MBOX_RST_N_9					BIT9
+#define		SW_MBOX_RST_N_10				BIT10
+#define		SW_MBOX_RST_N_11				BIT11
+#define		SW_MBOX_RST_N_12				BIT12
+#define		SW_MBOX_RST_N_13				BIT13
+#define		SW_MBOX_RST_N_14				BIT14
+#define		SW_MBOX_RST_N_15				BIT15
+
+/*UART*/
+#define		SW_UART_RST_N_0					BIT0
+#define		SW_UART_RST_N_1					BIT1
+#define		SW_UART_RST_N_2					BIT2
+#define		SW_UART_RST_N_3					BIT3
+#define		SW_UART_RST_N_4					BIT4
+
+/*GPIO*/
+/*
+#define		SW_GPIO_RST_N_0					BIT0
+#define		SW_GPIO_RST_N_1					BIT1
+*/
+
+/*TIMER*/
+#define		SW_TIMER_RST_N					BIT0
+
+/*SSI*/
+#define		SW_SSI_RST_N_0					BIT0
+#define		SW_SSI_RST_N_1					BIT1
+
+/*WDT*/
+#define		SW_WDT_RST_N_0					BIT0
+#define		SW_WDT_RST_N_1					BIT1
+#define		SW_WDT_RST_N_2					BIT2
+#define		SW_WDT_RST_N_3					BIT3
+
+/*LSP CFG*/
+#define		SW_LSP_CFG_RSTN					BIT0
+
+/*U84 CFG*/
+#define		SW_U84_CORE_RSTN_0				BIT0
+#define		SW_U84_CORE_RSTN_1				BIT1
+#define		SW_U84_CORE_RSTN_2				BIT2
+#define		SW_U84_CORE_RSTN_3				BIT3
+#define		SW_U84_BUS_RSTN					BIT4
+#define		SW_U84_DBG_RSTN					BIT5
+#define		SW_U84_TRACECOM_RSTN				BIT6
+#define		SW_U84_TRACE_RSTN_0				BIT8
+#define		SW_U84_TRACE_RSTN_1				BIT9
+#define		SW_U84_TRACE_RSTN_2				BIT10
+#define		SW_U84_TRACE_RSTN_3				BIT11
+
+/*SCPU*/
+#define		SW_SCPU_CORE_RSTN				BIT0
+#define		SW_SCPU_BUS_RSTN				BIT1
+#define		SW_SCPU_DBG_RSTN				BIT2
+
+/*LPCPU*/
+#define		SW_LPCPU_CORE_RSTN				BIT0
+#define		SW_LPCPU_BUS_RSTN				BIT1
+#define		SW_LPCPU_DBG_RSTN				BIT2
+
+/*VC*/
+#define		SW_VC_CFG_RSTN					BIT0
+#define		SW_VC_AXI_RSTN					BIT1
+#define		SW_VC_MONCFG_RSTN				BIT2
+
+/*JD*/
+#define		SW_JD_CFG_RSTN					BIT0
+#define		SW_JD_AXI_RSTN					BIT1
+
+/*JE*/
+#define		SW_JE_CFG_RSTN					BIT0
+#define		SW_JE_AXI_RSTN					BIT1
+
+/*VD*/
+#define		SW_VD_CFG_RSTN					BIT0
+#define		SW_VD_AXI_RSTN					BIT1
+
+/*VE*/
+#define		SW_VE_AXI_RSTN					BIT0
+#define		SW_VE_CFG_RSTN					BIT1
+
+/*G2D*/
+#define		SW_G2D_CORE_RSTN				BIT0
+#define		SW_G2D_CFG_RSTN					BIT1
+#define		SW_G2D_AXI_RSTN					BIT2
+
+/*VI*/
+#define		SW_VI_AXI_RSTN					BIT0
+#define		SW_VI_CFG_RSTN					BIT1
+#define		SW_VI_DWE_RSTN					BIT2
+
+/*DVP*/
+#define		SW_VI_DVP_RSTN					BIT0
+
+/*ISP0*/
+#define		SW_VI_ISP0_RSTN					BIT0
+
+/*ISP1*/
+#define		SW_VI_ISP1_RSTN					BIT0
+
+/*SHUTTR*/
+#define		SW_VI_SHUTTER_RSTN_0				BIT0
+#define		SW_VI_SHUTTER_RSTN_1				BIT1
+#define		SW_VI_SHUTTER_RSTN_2				BIT2
+#define		SW_VI_SHUTTER_RSTN_3				BIT3
+#define		SW_VI_SHUTTER_RSTN_4				BIT4
+#define		SW_VI_SHUTTER_RSTN_5				BIT5
+
+/*VO PHY*/
+#define		SW_VO_MIPI_PRSTN				BIT0
+#define		SW_VO_PRSTN					BIT1
+#define		SW_VO_HDMI_PRSTN				BIT3
+#define		SW_HDMI_PHYCTRL_RSTN				BIT4
+#define		SW_VO_HDMI_RSTN					BIT5
+
+/*VO I2S*/
+#define		SW_VO_I2S_RSTN					BIT0
+#define		SW_VO_I2S_PRSTN					BIT1
+
+/*VO*/
+#define		SW_VO_AXI_RSTN					BIT0
+#define		SW_VO_CFG_RSTN					BIT1
+#define		SW_VO_DC_RSTN					BIT2
+#define		SW_VO_DC_PRSTN					BIT3
+
+/*BOOTSPI*/
+#define		SW_BOOTSPI_HRSTN				BIT0
+#define		SW_BOOTSPI_RSTN					BIT1
+
+/*I2C1*/
+#define		SW_I2C1_PRSTN					BIT0
+
+/*I2C0*/
+#define		SW_I2C0_PRSTN					BIT0
+
+/*DMA1*/
+#define		SW_DMA1_ARSTN					BIT0
+#define		SW_DMA1_HRSTN					BIT1
+
+/*FPRT*/
+#define		SW_FP_PRT_HRSTN					BIT0
+
+/*HBLOCK*/
+#define		SW_HBLOCK_HRSTN					BIT0
+
+/*SECSR*/
+#define		SW_SECSR_HRSTN					BIT0
+
+/*OTP*/
+#define		SW_OTP_PRSTN					BIT0
+
+/*PKA*/
+#define		SW_PKA_HRSTN					BIT0
+
+/*SPACC*/
+#define		SW_SPACC_RSTN					BIT0
+
+/*TRNG*/
+#define		SW_TRNG_HRSTN					BIT0
+
+/*TIMER0*/
+#define		SW_TIMER0_RSTN_0				BIT0
+#define		SW_TIMER0_RSTN_1				BIT1
+#define		SW_TIMER0_RSTN_2				BIT2
+#define		SW_TIMER0_RSTN_3				BIT3
+#define		SW_TIMER0_RSTN_4				BIT4
+#define		SW_TIMER0_RSTN_5				BIT5
+#define		SW_TIMER0_RSTN_6				BIT6
+#define		SW_TIMER0_RSTN_7				BIT7
+#define		SW_TIMER0_PRSTN					BIT8
+
+/*TIMER1*/
+#define		SW_TIMER1_RSTN_0				BIT0
+#define		SW_TIMER1_RSTN_1				BIT1
+#define		SW_TIMER1_RSTN_2				BIT2
+#define		SW_TIMER1_RSTN_3				BIT3
+#define		SW_TIMER1_RSTN_4				BIT4
+#define		SW_TIMER1_RSTN_5				BIT5
+#define		SW_TIMER1_RSTN_6				BIT6
+#define		SW_TIMER1_RSTN_7				BIT7
+#define		SW_TIMER1_PRSTN					BIT8
+
+/*TIMER2*/
+#define		SW_TIMER2_RSTN_0				BIT0
+#define		SW_TIMER2_RSTN_1				BIT1
+#define		SW_TIMER2_RSTN_2				BIT2
+#define		SW_TIMER2_RSTN_3				BIT3
+#define		SW_TIMER2_RSTN_4				BIT4
+#define		SW_TIMER2_RSTN_5				BIT5
+#define		SW_TIMER2_RSTN_6				BIT6
+#define		SW_TIMER2_RSTN_7				BIT7
+#define		SW_TIMER2_PRSTN					BIT8
+
+/*TIMER3*/
+#define		SW_TIMER3_RSTN_0				BIT0
+#define		SW_TIMER3_RSTN_1				BIT1
+#define		SW_TIMER3_RSTN_2				BIT2
+#define		SW_TIMER3_RSTN_3				BIT3
+#define		SW_TIMER3_RSTN_4				BIT4
+#define		SW_TIMER3_RSTN_5				BIT5
+#define		SW_TIMER3_RSTN_6				BIT6
+#define		SW_TIMER3_RSTN_7				BIT7
+#define		SW_TIMER3_PRSTN					BIT8
+
+/*RTC*/
+#define		SW_RTC_RSTN					BIT0
+
+/*MNOC*/
+#define		SW_MNOC_SNOC_NSP_RSTN				BIT0
+#define		SW_MNOC_VC_ARSTN				BIT1
+#define		SW_MNOC_CFG_RSTN				BIT2
+#define		SW_MNOC_HSP_ARSTN				BIT3
+#define		SW_MNOC_GPU_ARSTN				BIT4
+#define		SW_MNOC_DDRC1_P3_ARSTN				BIT5
+#define		SW_MNOC_DDRC0_P3_ARSTN				BIT6
+
+/*RNOC*/
+#define		SW_RNOC_VO_ARSTN				BIT0
+#define		SW_RNOC_VI_ARSTN				BIT1
+#define		SW_RNOC_SNOC_NSP_RSTN				BIT2
+#define		SW_RNOC_CFG_RSTN				BIT3
+#define		SW_MNOC_DDRC1_P4_ARSTN				BIT4
+#define		SW_MNOC_DDRC0_P4_ARSTN				BIT5
+
+/*CNOC*/
+#define		SW_CNOC_VO_CFG_RSTN				BIT0
+#define		SW_CNOC_VI_CFG_RSTN				BIT1
+#define		SW_CNOC_VC_CFG_RSTN				BIT2
+#define		SW_CNOC_TCU_CFG_RSTN				BIT3
+#define		SW_CNOC_PCIET_CFG_RSTN				BIT4
+#define		SW_CNOC_NPU_CFG_RSTN				BIT5
+#define		SW_CNOC_LSP_CFG_RSTN				BIT6
+#define		SW_CNOC_HSP_CFG_RSTN				BIT7
+#define		SW_CNOC_GPU_CFG_RSTN				BIT8
+#define		SW_CNOC_DSPT_CFG_RSTN				BIT9
+#define		SW_CNOC_DDRT1_CFG_RSTN				BIT10
+#define		SW_CNOC_DDRT0_CFG_RSTN				BIT11
+#define		SW_CNOC_D2D_CFG_RSTN				BIT12
+#define		SW_CNOC_CFG_RSTN				BIT13
+#define		SW_CNOC_CLMM_CFG_RSTN				BIT14
+#define		SW_CNOC_AON_CFG_RSTN				BIT15
+
+/*LNOC*/
+#define		SW_LNOC_CFG_RSTN				BIT0
+#define		SW_LNOC_NPU_LLC_ARSTN				BIT1
+#define		SW_LNOC_DDRC1_P0_ARSTN				BIT2
+#define		SW_LNOC_DDRC0_P0_ARSTN				BIT3
+
+#endif /*endif __DT_ESWIN_EIC7700_SYSCRG_H__*/
diff --git a/include/linux/eic7700-sid-cfg.h b/include/linux/eic7700-sid-cfg.h
new file mode 100644
index 000000000000..60f47630b8c8
--- /dev/null
+++ b/include/linux/eic7700-sid-cfg.h
@@ -0,0 +1,8 @@
+#ifndef EIC7700_SID_CFG_H
+#define EIC7700_SID_CFG_H
+
+int eic7700_dynm_sid_enable(int nid);
+int eic7700_aon_sid_cfg(struct device *dev);
+int eic7700_tbu_power(struct device *dev, bool is_powerUp);
+
+#endif
diff --git a/include/linux/irqchip/riscv-aplic.h b/include/linux/irqchip/riscv-aplic.h
new file mode 100644
index 000000000000..97e198ea0109
--- /dev/null
+++ b/include/linux/irqchip/riscv-aplic.h
@@ -0,0 +1,119 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2021 Western Digital Corporation or its affiliates.
+ * Copyright (C) 2022 Ventana Micro Systems Inc.
+ */
+#ifndef __LINUX_IRQCHIP_RISCV_APLIC_H
+#define __LINUX_IRQCHIP_RISCV_APLIC_H
+
+#include <linux/bitops.h>
+
+#define APLIC_MAX_IDC			BIT(14)
+#define APLIC_MAX_SOURCE		1024
+
+#define APLIC_DOMAINCFG			0x0000
+#define APLIC_DOMAINCFG_RDONLY		0x80000000
+#define APLIC_DOMAINCFG_IE		BIT(8)
+#define APLIC_DOMAINCFG_DM		BIT(2)
+#define APLIC_DOMAINCFG_BE		BIT(0)
+
+#define APLIC_SOURCECFG_BASE		0x0004
+#define APLIC_SOURCECFG_D		BIT(10)
+#define APLIC_SOURCECFG_CHILDIDX_MASK	0x000003ff
+#define APLIC_SOURCECFG_SM_MASK	0x00000007
+#define APLIC_SOURCECFG_SM_INACTIVE	0x0
+#define APLIC_SOURCECFG_SM_DETACH	0x1
+#define APLIC_SOURCECFG_SM_EDGE_RISE	0x4
+#define APLIC_SOURCECFG_SM_EDGE_FALL	0x5
+#define APLIC_SOURCECFG_SM_LEVEL_HIGH	0x6
+#define APLIC_SOURCECFG_SM_LEVEL_LOW	0x7
+
+#define APLIC_MMSICFGADDR		0x1bc0
+#define APLIC_MMSICFGADDRH		0x1bc4
+#define APLIC_SMSICFGADDR		0x1bc8
+#define APLIC_SMSICFGADDRH		0x1bcc
+
+#ifdef CONFIG_RISCV_M_MODE
+#define APLIC_xMSICFGADDR		APLIC_MMSICFGADDR
+#define APLIC_xMSICFGADDRH		APLIC_MMSICFGADDRH
+#else
+#define APLIC_xMSICFGADDR		APLIC_SMSICFGADDR
+#define APLIC_xMSICFGADDRH		APLIC_SMSICFGADDRH
+#endif
+
+#define APLIC_xMSICFGADDRH_L		BIT(31)
+#define APLIC_xMSICFGADDRH_HHXS_MASK	0x1f
+#define APLIC_xMSICFGADDRH_HHXS_SHIFT	24
+#define APLIC_xMSICFGADDRH_LHXS_MASK	0x7
+#define APLIC_xMSICFGADDRH_LHXS_SHIFT	20
+#define APLIC_xMSICFGADDRH_HHXW_MASK	0x7
+#define APLIC_xMSICFGADDRH_HHXW_SHIFT	16
+#define APLIC_xMSICFGADDRH_LHXW_MASK	0xf
+#define APLIC_xMSICFGADDRH_LHXW_SHIFT	12
+#define APLIC_xMSICFGADDRH_BAPPN_MASK	0xfff
+
+#define APLIC_xMSICFGADDR_PPN_SHIFT	12
+
+#define APLIC_xMSICFGADDR_PPN_HART(__lhxs) \
+	(BIT(__lhxs) - 1)
+
+#define APLIC_xMSICFGADDR_PPN_LHX_MASK(__lhxw) \
+	(BIT(__lhxw) - 1)
+#define APLIC_xMSICFGADDR_PPN_LHX_SHIFT(__lhxs) \
+	((__lhxs))
+#define APLIC_xMSICFGADDR_PPN_LHX(__lhxw, __lhxs) \
+	(APLIC_xMSICFGADDR_PPN_LHX_MASK(__lhxw) << \
+	 APLIC_xMSICFGADDR_PPN_LHX_SHIFT(__lhxs))
+
+#define APLIC_xMSICFGADDR_PPN_HHX_MASK(__hhxw) \
+	(BIT(__hhxw) - 1)
+#define APLIC_xMSICFGADDR_PPN_HHX_SHIFT(__hhxs) \
+	((__hhxs) + APLIC_xMSICFGADDR_PPN_SHIFT)
+#define APLIC_xMSICFGADDR_PPN_HHX(__hhxw, __hhxs) \
+	(APLIC_xMSICFGADDR_PPN_HHX_MASK(__hhxw) << \
+	 APLIC_xMSICFGADDR_PPN_HHX_SHIFT(__hhxs))
+
+#define APLIC_IRQBITS_PER_REG		32
+
+#define APLIC_SETIP_BASE		0x1c00
+#define APLIC_SETIPNUM			0x1cdc
+
+#define APLIC_CLRIP_BASE		0x1d00
+#define APLIC_CLRIPNUM			0x1ddc
+
+#define APLIC_SETIE_BASE		0x1e00
+#define APLIC_SETIENUM			0x1edc
+
+#define APLIC_CLRIE_BASE		0x1f00
+#define APLIC_CLRIENUM			0x1fdc
+
+#define APLIC_SETIPNUM_LE		0x2000
+#define APLIC_SETIPNUM_BE		0x2004
+
+#define APLIC_GENMSI			0x3000
+
+#define APLIC_TARGET_BASE		0x3004
+#define APLIC_TARGET_HART_IDX_SHIFT	18
+#define APLIC_TARGET_HART_IDX_MASK	0x3fff
+#define APLIC_TARGET_GUEST_IDX_SHIFT	12
+#define APLIC_TARGET_GUEST_IDX_MASK	0x3f
+#define APLIC_TARGET_IPRIO_MASK	0xff
+#define APLIC_TARGET_EIID_MASK	0x7ff
+
+#define APLIC_IDC_BASE			0x4000
+#define APLIC_IDC_SIZE			32
+
+#define APLIC_IDC_IDELIVERY		0x00
+
+#define APLIC_IDC_IFORCE		0x04
+
+#define APLIC_IDC_ITHRESHOLD		0x08
+
+#define APLIC_IDC_TOPI			0x18
+#define APLIC_IDC_TOPI_ID_SHIFT	16
+#define APLIC_IDC_TOPI_ID_MASK	0x3ff
+#define APLIC_IDC_TOPI_PRIO_MASK	0xff
+
+#define APLIC_IDC_CLAIMI		0x1c
+
+#endif
diff --git a/include/linux/irqchip/riscv-imsic.h b/include/linux/irqchip/riscv-imsic.h
new file mode 100644
index 000000000000..5d1387adc0ba
--- /dev/null
+++ b/include/linux/irqchip/riscv-imsic.h
@@ -0,0 +1,92 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2021 Western Digital Corporation or its affiliates.
+ * Copyright (C) 2022 Ventana Micro Systems Inc.
+ */
+#ifndef __LINUX_IRQCHIP_RISCV_IMSIC_H
+#define __LINUX_IRQCHIP_RISCV_IMSIC_H
+
+#include <linux/types.h>
+#include <asm/csr.h>
+
+#define IMSIC_MMIO_PAGE_SHIFT		12
+#define IMSIC_MMIO_PAGE_SZ		(1UL << IMSIC_MMIO_PAGE_SHIFT)
+#define IMSIC_MMIO_PAGE_LE		0x00
+#define IMSIC_MMIO_PAGE_BE		0x04
+
+#define IMSIC_MIN_ID			63
+#define IMSIC_MAX_ID			2048
+
+#define IMSIC_EIDELIVERY		0x70
+
+#define IMSIC_EITHRESHOLD		0x72
+
+#define IMSIC_EIP0			0x80
+#define IMSIC_EIP63			0xbf
+#define IMSIC_EIPx_BITS			32
+
+#define IMSIC_EIE0			0xc0
+#define IMSIC_EIE63			0xff
+#define IMSIC_EIEx_BITS			32
+
+#define IMSIC_FIRST			IMSIC_EIDELIVERY
+#define IMSIC_LAST			IMSIC_EIE63
+
+#define IMSIC_MMIO_SETIPNUM_LE		0x00
+#define IMSIC_MMIO_SETIPNUM_BE		0x04
+
+struct imsic_global_config {
+	/*
+	 * MSI Target Address Scheme
+	 *
+	 * XLEN-1                                                12     0
+	 * |                                                     |     |
+	 * -------------------------------------------------------------
+	 * |xxxxxx|Group Index|xxxxxxxxxxx|HART Index|Guest Index|  0  |
+	 * -------------------------------------------------------------
+	 */
+
+	/* Bits representing Guest index, HART index, and Group index */
+	u32 guest_index_bits;
+	u32 hart_index_bits;
+	u32 group_index_bits;
+	u32 group_index_shift;
+
+	/* Global base address matching all target MSI addresses */
+	phys_addr_t base_addr;
+
+	/* Number of interrupt identities */
+	u32 nr_ids;
+
+	/* Number of guest interrupt identities */
+	u32 nr_guest_ids;
+};
+
+struct imsic_local_config {
+	phys_addr_t msi_pa;
+	void __iomem *msi_va;
+};
+
+#ifdef CONFIG_RISCV_IMSIC
+
+extern const struct imsic_global_config *imsic_get_global_config(void);
+
+extern const struct imsic_local_config *imsic_get_local_config(
+							unsigned int cpu);
+
+#else
+
+static inline const struct imsic_global_config *imsic_get_global_config(void)
+{
+	return NULL;
+}
+
+static inline const struct imsic_local_config *imsic_get_local_config(
+							unsigned int cpu)
+{
+	return NULL;
+}
+
+#endif
+
+#endif
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index 13065dd96132..a0abc312ca70 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -919,6 +919,14 @@ struct kvm_ppc_resize_hpt {
 #define KVM_VM_TYPE_ARM_IPA_SIZE_MASK	0xffULL
 #define KVM_VM_TYPE_ARM_IPA_SIZE(x)		\
 	((x) & KVM_VM_TYPE_ARM_IPA_SIZE_MASK)
+
+/*
+ * RISCV-V Confidential VM type. The large bit shift is chosen on purpose
+ * to allow other architectures to have their specific VM types if required.
+ */
+#define KVM_VM_TYPE_RISCV_COVE_MULTI_STEP_INIT	(1UL << 9)
+#define KVM_VM_TYPE_RISCV_COVE_SINGLE_STEP_INIT	(1UL << 10)
+
 /*
  * ioctls for /dev/kvm fds:
  */
@@ -1563,6 +1571,8 @@ struct kvm_s390_ucas_mapping {
 /* Available with KVM_CAP_COUNTER_OFFSET */
 #define KVM_ARM_SET_COUNTER_OFFSET _IOW(KVMIO,  0xb5, struct kvm_arm_counter_offset)
 
+#define KVM_RISCV_COVE_MEASURE_REGION  _IOR(KVMIO, 0xb5, struct kvm_riscv_cove_measure_region)
+
 /* ioctl for vm fd */
 #define KVM_CREATE_DEVICE	  _IOWR(KVMIO,  0xe0, struct kvm_create_device)
 
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index a3fedb3ee0db..f1d753d154d9 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -304,6 +304,14 @@ static int vmap_range_noflush(unsigned long addr, unsigned long end,
 	return err;
 }
 
+__weak void ioremap_phys_range_hook(phys_addr_t phys_addr, size_t size, pgprot_t prot)
+{
+}
+
+__weak void iounmap_phys_range_hook(phys_addr_t phys_addr, size_t size)
+{
+}
+
 int ioremap_page_range(unsigned long addr, unsigned long end,
 		phys_addr_t phys_addr, pgprot_t prot)
 {
@@ -313,8 +321,12 @@ int ioremap_page_range(unsigned long addr, unsigned long end,
 				 ioremap_max_page_shift);
 	flush_cache_vmap(addr, end);
 	if (!err)
-		err = kmsan_ioremap_page_range(addr, end, phys_addr, prot,
-					       ioremap_max_page_shift);
+		kmsan_ioremap_page_range(addr, end, phys_addr, prot,
+					 ioremap_max_page_shift);
+
+	if (!err)
+		ioremap_phys_range_hook(phys_addr, end - addr, prot);
+
 	return err;
 }
 
@@ -2872,6 +2884,10 @@ void vunmap(const void *addr)
 				addr);
 		return;
 	}
+
+	if (vm->flags & VM_IOREMAP)
+		iounmap_phys_range_hook(vm->phys_addr, get_vm_area_size(vm));
+
 	kfree(vm);
 }
 EXPORT_SYMBOL(vunmap);
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 439fa631c342..24ee3416d6a6 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -85,6 +85,7 @@ source "sound/soc/au1x/Kconfig"
 source "sound/soc/bcm/Kconfig"
 source "sound/soc/cirrus/Kconfig"
 source "sound/soc/dwc/Kconfig"
+source "sound/soc/eswin/Kconfig"
 source "sound/soc/fsl/Kconfig"
 source "sound/soc/google/Kconfig"
 source "sound/soc/hisilicon/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 8376fdb217ed..d36d824db893 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_SND_SOC)	+= au1x/
 obj-$(CONFIG_SND_SOC)	+= bcm/
 obj-$(CONFIG_SND_SOC)	+= cirrus/
 obj-$(CONFIG_SND_SOC)	+= dwc/
+obj-$(CONFIG_SND_SOC)	+= eswin/
 obj-$(CONFIG_SND_SOC)	+= fsl/
 obj-$(CONFIG_SND_SOC)	+= google/
 obj-$(CONFIG_SND_SOC)	+= hisilicon/
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index f1e1dbc509f6..319d89477279 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -2404,4 +2404,5 @@ config SND_SOC_LPASS_TX_MACRO
 	select SND_SOC_LPASS_MACRO_COMMON
 	tristate "Qualcomm TX Macro in LPASS(Low Power Audio SubSystem)"
 
+source "sound/soc/codecs/eswin/Kconfig"
 endmenu
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index a87e56938ce5..6205558e39fe 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -772,3 +772,4 @@ obj-$(CONFIG_SND_SOC_LPASS_TX_MACRO)	+= snd-soc-lpass-tx-macro.o
 
 # Mux
 obj-$(CONFIG_SND_SOC_SIMPLE_MUX)	+= snd-soc-simple-mux.o
+obj-$(CONFIG_ESWIN_SND_SOC_CODECS)	+= eswin/
diff --git a/sound/soc/codecs/eswin/Kconfig b/sound/soc/codecs/eswin/Kconfig
new file mode 100755
index 000000000000..1c4a45508d64
--- /dev/null
+++ b/sound/soc/codecs/eswin/Kconfig
@@ -0,0 +1,20 @@
+menuconfig ESWIN_SND_SOC_CODECS
+	bool "ESWIN CODEC drivers"
+	default n
+	help
+	  Say Y or M if you want to add support for codecs attached to
+	  the ESWIN Asoc interface. You will also need
+	  to select the audio interfaces to support below.
+
+#if ESWIN_SND_SOC_CODECS
+
+config ESWIN_SND_ES8388_CODEC
+	bool "ESWIN Audio es8388 codec"
+	depends on ESWIN_SND_SOC_CODECS
+	default n
+	help
+	  ESWIN Audio codec,
+	  es8388 codec,
+	  this codec is internal
+
+#endif #ESWIN_SND_SOC_CODECS
diff --git a/sound/soc/codecs/eswin/Makefile b/sound/soc/codecs/eswin/Makefile
new file mode 100755
index 000000000000..ee696d62096c
--- /dev/null
+++ b/sound/soc/codecs/eswin/Makefile
@@ -0,0 +1,3 @@
+esw_es8328_codec-objs := es8328-i2c.o es8328.o
+
+obj-$(CONFIG_ESWIN_SND_ES8388_CODEC) += esw_es8328_codec.o
\ No newline at end of file
diff --git a/sound/soc/codecs/eswin/es8328-i2c.c b/sound/soc/codecs/eswin/es8328-i2c.c
new file mode 100644
index 000000000000..2a59aa9fc168
--- /dev/null
+++ b/sound/soc/codecs/eswin/es8328-i2c.c
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * es8328-i2c.c  --  ES8328 ALSA SoC I2C Audio driver
+ *
+ * Copyright 2014 Sutajio Ko-Usagi PTE LTD
+ *
+ * Author: Sean Cross <xobs@kosagi.com>
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+
+#include <sound/soc.h>
+
+#include "es8328.h"
+
+static const struct i2c_device_id es8328_id[] = {
+	{ "es8328", 0 },
+	{ "es8388", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, es8328_id);
+
+static const struct of_device_id es8328_of_match[] = {
+	{ .compatible = "eswin,es8388", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, es8328_of_match);
+
+static int es8328_i2c_probe(struct i2c_client *i2c)
+{
+	return es8328_probe(&i2c->dev,
+			devm_regmap_init_i2c(i2c, &es8328_regmap_config));
+}
+
+static struct i2c_driver es8328_i2c_driver = {
+	.driver = {
+		.name		= "es8328",
+		.of_match_table = es8328_of_match,
+	},
+	.probe    = es8328_i2c_probe,
+	.id_table = es8328_id,
+};
+
+module_i2c_driver(es8328_i2c_driver);
+
+MODULE_DESCRIPTION("ASoC ES8328 audio CODEC I2C driver");
+MODULE_AUTHOR("Sean Cross <xobs@kosagi.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/eswin/es8328.c b/sound/soc/codecs/eswin/es8328.c
new file mode 100644
index 000000000000..1fcf73f448c2
--- /dev/null
+++ b/sound/soc/codecs/eswin/es8328.c
@@ -0,0 +1,1087 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * es8328.c  --  ES8328 ALSA SoC Audio driver
+ *
+ * Copyright 2014 Sutajio Ko-Usagi PTE LTD
+ *
+ * Author: Sean Cross <xobs@kosagi.com>
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/of_device.h>
+#include <linux/module.h>
+#include <linux/pm.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/regulator/consumer.h>
+#include <linux/gpio/consumer.h>
+
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#include "es8328.h"
+
+#define MIN_CHANNEL_NUM		2
+#define MAX_CHANNEL_NUM		2
+
+static const unsigned int rates_12288[] = {
+	8000, 12000, 16000, 24000, 32000, 48000, 96000,
+};
+
+static const int ratios_12288[] = {
+	10, 7, 6, 4, 3, 2, 0,
+};
+
+static const struct snd_pcm_hw_constraint_list constraints_12288 = {
+	.count	= ARRAY_SIZE(rates_12288),
+	.list	= rates_12288,
+};
+
+static const unsigned int rates_11289[] = {
+	8018, 11025, 22050, 44100, 88200,
+};
+
+static const int ratios_11289[] = {
+	9, 7, 4, 2, 0,
+};
+
+static const struct snd_pcm_hw_constraint_list constraints_11289 = {
+	.count	= ARRAY_SIZE(rates_11289),
+	.list	= rates_11289,
+};
+
+/* regulator supplies for sgtl5000, VDDD is an optional external supply */
+enum sgtl5000_regulator_supplies {
+	DVDD,
+	AVDD,
+	PVDD,
+	HPVDD,
+	ES8328_SUPPLY_NUM
+};
+
+/* vddd is optional supply */
+static const char * const supply_names[ES8328_SUPPLY_NUM] = {
+	"DVDD",
+	"AVDD",
+	"PVDD",
+	"HPVDD",
+};
+
+#define ES8328_RATES (SNDRV_PCM_RATE_192000 | \
+		SNDRV_PCM_RATE_96000 | \
+		SNDRV_PCM_RATE_88200 | \
+		SNDRV_PCM_RATE_8000_48000)
+#define ES8328_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+		SNDRV_PCM_FMTBIT_S18_3LE | \
+		SNDRV_PCM_FMTBIT_S20_3LE | \
+		SNDRV_PCM_FMTBIT_S24_LE | \
+		SNDRV_PCM_FMTBIT_S32_LE)
+
+struct es8328_priv {
+	struct regmap *regmap;
+	struct clk *clk;
+	int playback_fs;
+	bool deemph;
+	int mclkdiv2;
+	const struct snd_pcm_hw_constraint_list *sysclk_constraints;
+	const int *mclk_ratios;
+	bool provider;
+	struct regulator_bulk_data supplies[ES8328_SUPPLY_NUM];
+
+	u32 eswin_plat;
+	struct snd_soc_component *component;
+	struct gpio_desc *front_jack_gpio;
+	struct gpio_desc *back_jack_gpio;
+};
+
+/*
+ * ES8328 Controls
+ */
+
+static const char * const adcpol_txt[] = {"Normal", "L Invert", "R Invert",
+					  "L + R Invert"};
+static SOC_ENUM_SINGLE_DECL(adcpol,
+			    ES8328_ADCCONTROL6, 6, adcpol_txt);
+
+static const DECLARE_TLV_DB_SCALE(play_tlv, -3000, 100, 0);
+static const DECLARE_TLV_DB_SCALE(dac_adc_tlv, -9600, 50, 0);
+static const DECLARE_TLV_DB_SCALE(bypass_tlv, -1500, 300, 0);
+static const DECLARE_TLV_DB_SCALE(mic_tlv, 0, 300, 0);
+
+static const struct {
+	int rate;
+	unsigned int val;
+} deemph_settings[] = {
+	{ 0,     ES8328_DACCONTROL6_DEEMPH_OFF },
+	{ 32000, ES8328_DACCONTROL6_DEEMPH_32k },
+	{ 44100, ES8328_DACCONTROL6_DEEMPH_44_1k },
+	{ 48000, ES8328_DACCONTROL6_DEEMPH_48k },
+};
+
+static int es8328_set_deemph(struct snd_soc_component *component)
+{
+	struct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);
+	int val, i, best;
+
+	/*
+	 * If we're using deemphasis select the nearest available sample
+	 * rate.
+	 */
+	if (es8328->deemph) {
+		best = 0;
+		for (i = 1; i < ARRAY_SIZE(deemph_settings); i++) {
+			if (abs(deemph_settings[i].rate - es8328->playback_fs) <
+			    abs(deemph_settings[best].rate - es8328->playback_fs))
+				best = i;
+		}
+
+		val = deemph_settings[best].val;
+	} else {
+		val = ES8328_DACCONTROL6_DEEMPH_OFF;
+	}
+
+	dev_dbg(component->dev, "Set deemphasis %d\n", val);
+
+	return snd_soc_component_update_bits(component, ES8328_DACCONTROL6,
+			ES8328_DACCONTROL6_DEEMPH_MASK, val);
+}
+
+static int es8328_get_deemph(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = es8328->deemph;
+	return 0;
+}
+
+static int es8328_put_deemph(struct snd_kcontrol *kcontrol,
+			     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
+	struct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);
+	unsigned int deemph = ucontrol->value.integer.value[0];
+	int ret;
+
+	if (deemph > 1)
+		return -EINVAL;
+
+	if (es8328->deemph == deemph)
+		return 0;
+
+	ret = es8328_set_deemph(component);
+	if (ret < 0)
+		return ret;
+
+	es8328->deemph = deemph;
+
+	return 1;
+}
+static int dump_flag = 0;
+static u32 g_reg = 1;
+static u32 g_get_cnt = 0;
+static u32 g_put_cnt = 0;
+
+int esw_codec_dump_get(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = dump_flag;
+	return 0;
+}
+
+int esw_codec_dump_info(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+	return 0;
+}
+
+int esw_codec_dump_put(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
+{
+	int dump_onoff	= ucontrol->value.integer.value[0];
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	u32 reg, ret, i;
+
+	printk("codec dump onoff:%d\n", dump_onoff);
+	dump_flag = dump_onoff;
+	if (dump_onoff == true) {
+		printk("statr codec dump\n");
+		for (i = 0; i < 53; i++) {
+			ret = regmap_read(component->regmap, i, &reg);
+			if (ret != 0) {
+				printk("reag reg[%d] failed!\n", i);
+			}
+			printk("reg[%d]:0x%x\n", i, reg);
+		}
+	}
+	return 0;
+}
+
+int esw_codec_reg_get(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	u32 val;
+	int ret;
+
+	g_get_cnt++;
+
+	if (g_get_cnt == 1) {
+		ucontrol->value.integer.value[0] = g_reg;
+	} else {
+		ret = regmap_read(component->regmap, g_reg, &val);
+		if (ret != 0) {
+			printk("read reg[%d] failed!\n", g_reg);
+		}
+		printk("codec read reg[%d]:0x%x\n", g_reg, val);
+		ucontrol->value.integer.value[1] = val;
+		g_get_cnt = 0;
+	}
+	return 0;
+}
+
+int esw_codec_reg_info(struct snd_kcontrol *kcontrol,
+					    struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 256;
+	return 0;
+}
+
+int esw_codec_reg_put(struct snd_kcontrol *kcontrol,
+					   struct snd_ctl_elem_value *ucontrol)
+{
+	int ret;
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+
+	g_put_cnt++;
+
+	if (g_put_cnt == 1) {
+		g_reg = ucontrol->value.integer.value[0];
+	} else {
+		printk("codec write reg:%d, val:0x%x\n", g_reg, (u32)ucontrol->value.integer.value[1]);
+		ret = regmap_write(component->regmap, g_reg, (u32)ucontrol->value.integer.value[1]);
+		if (ret != 0) {
+			printk("write reg[%d] failed!\n", g_reg);
+		}
+		g_put_cnt = 0;
+	}
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new es8328_snd_controls[] = {
+	SOC_DOUBLE_R_TLV("Capture Digital Volume",
+		ES8328_ADCCONTROL8, ES8328_ADCCONTROL9,
+		 0, 0xc0, 1, dac_adc_tlv),
+	SOC_SINGLE("Capture ZC Switch", ES8328_ADCCONTROL7, 5, 1, 0),
+
+	SOC_SINGLE_BOOL_EXT("DAC Deemphasis Switch", 0,
+		    es8328_get_deemph, es8328_put_deemph),
+
+	SOC_ENUM("Capture Polarity", adcpol),
+
+	SOC_SINGLE_TLV("Left Mixer Left Bypass Volume",
+			ES8328_DACCONTROL17, 3, 7, 1, bypass_tlv),
+	SOC_SINGLE_TLV("Left Mixer Right Bypass Volume",
+			ES8328_DACCONTROL19, 3, 7, 1, bypass_tlv),
+	SOC_SINGLE_TLV("Right Mixer Left Bypass Volume",
+			ES8328_DACCONTROL18, 3, 7, 1, bypass_tlv),
+	SOC_SINGLE_TLV("Right Mixer Right Bypass Volume",
+			ES8328_DACCONTROL20, 3, 7, 1, bypass_tlv),
+
+	SOC_DOUBLE_R_TLV("PCM Volume",
+			ES8328_LDACVOL, ES8328_RDACVOL,
+			0, ES8328_LDACVOL_MAX, 1, dac_adc_tlv),
+
+	SOC_DOUBLE_R_TLV("Output 1 Playback Volume",
+			ES8328_LOUT1VOL, ES8328_ROUT1VOL,
+			0, ES8328_OUT1VOL_MAX, 0, play_tlv),
+
+	SOC_DOUBLE_R_TLV("Output 2 Playback Volume",
+			ES8328_LOUT2VOL, ES8328_ROUT2VOL,
+			0, ES8328_OUT2VOL_MAX, 0, play_tlv),
+
+	SOC_DOUBLE_TLV("Mic PGA Volume", ES8328_ADCCONTROL1,
+			4, 0, 8, 0, mic_tlv),
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+		.name = "Reg Dump",
+		.index = 0,
+		.access = SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info = esw_codec_dump_info,
+		.get = esw_codec_dump_get,
+		.put = esw_codec_dump_put,
+	},
+	{
+		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
+		.name = "Reg Write",
+		.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | SNDRV_CTL_ELEM_ACCESS_READWRITE,
+		.info = esw_codec_reg_info,
+		.get = esw_codec_reg_get,
+		.put = esw_codec_reg_put,
+	}
+};
+
+/*
+ * DAPM Controls
+ */
+
+static const char * const es8328_line_texts[] = {
+	"Line 1", "Line 2", "PGA", "Differential"};
+
+static const struct soc_enum es8328_lline_enum =
+	SOC_ENUM_SINGLE(ES8328_DACCONTROL16, 3,
+			      ARRAY_SIZE(es8328_line_texts),
+			      es8328_line_texts);
+static const struct snd_kcontrol_new es8328_left_line_controls =
+	SOC_DAPM_ENUM("Route", es8328_lline_enum);
+
+static const struct soc_enum es8328_rline_enum =
+	SOC_ENUM_SINGLE(ES8328_DACCONTROL16, 0,
+			      ARRAY_SIZE(es8328_line_texts),
+			      es8328_line_texts);
+static const struct snd_kcontrol_new es8328_right_line_controls =
+	SOC_DAPM_ENUM("Route", es8328_rline_enum);
+
+/* Left Mixer */
+static const struct snd_kcontrol_new es8328_left_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Playback Switch", ES8328_DACCONTROL17, 7, 1, 0),
+	SOC_DAPM_SINGLE("Left Bypass Switch", ES8328_DACCONTROL17, 6, 1, 0),
+	SOC_DAPM_SINGLE("Right Playback Switch", ES8328_DACCONTROL18, 7, 1, 0),
+	SOC_DAPM_SINGLE("Right Bypass Switch", ES8328_DACCONTROL18, 6, 1, 0),
+};
+
+/* Right Mixer */
+static const struct snd_kcontrol_new es8328_right_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Left Playback Switch", ES8328_DACCONTROL19, 7, 1, 0),
+	SOC_DAPM_SINGLE("Left Bypass Switch", ES8328_DACCONTROL19, 6, 1, 0),
+	SOC_DAPM_SINGLE("Playback Switch", ES8328_DACCONTROL20, 7, 1, 0),
+	SOC_DAPM_SINGLE("Right Bypass Switch", ES8328_DACCONTROL20, 6, 1, 0),
+};
+
+static const char * const es8328_pga_sel[] = {
+	"Line 1", "Line 2", "Line 3", "Differential"};
+
+/* Left PGA Mux */
+static const struct soc_enum es8328_lpga_enum =
+	SOC_ENUM_SINGLE(ES8328_ADCCONTROL2, 6,
+			      ARRAY_SIZE(es8328_pga_sel),
+			      es8328_pga_sel);
+static const struct snd_kcontrol_new es8328_left_pga_controls =
+	SOC_DAPM_ENUM("Route", es8328_lpga_enum);
+
+/* Right PGA Mux */
+static const struct soc_enum es8328_rpga_enum =
+	SOC_ENUM_SINGLE(ES8328_ADCCONTROL2, 4,
+			      ARRAY_SIZE(es8328_pga_sel),
+			      es8328_pga_sel);
+static const struct snd_kcontrol_new es8328_right_pga_controls =
+	SOC_DAPM_ENUM("Route", es8328_rpga_enum);
+
+/* Differential Mux */
+static const char * const es8328_diff_sel[] = {"Line 1", "Line 2"};
+static SOC_ENUM_SINGLE_DECL(diffmux,
+			    ES8328_ADCCONTROL3, 7, es8328_diff_sel);
+static const struct snd_kcontrol_new es8328_diffmux_controls =
+	SOC_DAPM_ENUM("Route", diffmux);
+
+/* Mono ADC Mux */
+static const char * const es8328_mono_mux[] = {"Stereo", "Mono (Left)",
+	"Mono (Right)", "Digital Mono"};
+static SOC_ENUM_SINGLE_DECL(monomux,
+			    ES8328_ADCCONTROL3, 3, es8328_mono_mux);
+static const struct snd_kcontrol_new es8328_monomux_controls =
+	SOC_DAPM_ENUM("Route", monomux);
+
+static const struct snd_soc_dapm_widget es8328_dapm_widgets[] = {
+	SND_SOC_DAPM_MUX("Differential Mux", SND_SOC_NOPM, 0, 0,
+		&es8328_diffmux_controls),
+	SND_SOC_DAPM_MUX("Left ADC Mux", SND_SOC_NOPM, 0, 0,
+		&es8328_monomux_controls),
+	SND_SOC_DAPM_MUX("Right ADC Mux", SND_SOC_NOPM, 0, 0,
+		&es8328_monomux_controls),
+
+	SND_SOC_DAPM_MUX("Left PGA Mux", ES8328_ADCPOWER,
+			ES8328_ADCPOWER_AINL_OFF, 1,
+			&es8328_left_pga_controls),
+	SND_SOC_DAPM_MUX("Right PGA Mux", ES8328_ADCPOWER,
+			ES8328_ADCPOWER_AINR_OFF, 1,
+			&es8328_right_pga_controls),
+
+	SND_SOC_DAPM_MUX("Left Line Mux", SND_SOC_NOPM, 0, 0,
+		&es8328_left_line_controls),
+	SND_SOC_DAPM_MUX("Right Line Mux", SND_SOC_NOPM, 0, 0,
+		&es8328_right_line_controls),
+
+	SND_SOC_DAPM_ADC("Right ADC", "Right Capture", ES8328_ADCPOWER,
+			ES8328_ADCPOWER_ADCR_OFF, 1),
+	SND_SOC_DAPM_ADC("Left ADC", "Left Capture", ES8328_ADCPOWER,
+			ES8328_ADCPOWER_ADCL_OFF, 1),
+
+	SND_SOC_DAPM_SUPPLY("Mic Bias", ES8328_ADCPOWER,
+			ES8328_ADCPOWER_MIC_BIAS_OFF, 1, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("Mic Bias Gen", ES8328_ADCPOWER,
+			ES8328_ADCPOWER_ADC_BIAS_GEN_OFF, 1, NULL, 0),
+
+	SND_SOC_DAPM_SUPPLY("DAC STM", ES8328_CHIPPOWER,
+			ES8328_CHIPPOWER_DACSTM_RESET, 1, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("ADC STM", ES8328_CHIPPOWER,
+			ES8328_CHIPPOWER_ADCSTM_RESET, 1, NULL, 0),
+
+	SND_SOC_DAPM_SUPPLY("DAC DIG", ES8328_CHIPPOWER,
+			ES8328_CHIPPOWER_DACDIG_OFF, 1, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("ADC DIG", ES8328_CHIPPOWER,
+			ES8328_CHIPPOWER_ADCDIG_OFF, 1, NULL, 0),
+
+	SND_SOC_DAPM_SUPPLY("DAC DLL", ES8328_CHIPPOWER,
+			ES8328_CHIPPOWER_DACDLL_OFF, 1, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("ADC DLL", ES8328_CHIPPOWER,
+			ES8328_CHIPPOWER_ADCDLL_OFF, 1, NULL, 0),
+
+	SND_SOC_DAPM_SUPPLY("ADC Vref", ES8328_CHIPPOWER,
+			ES8328_CHIPPOWER_ADCVREF_OFF, 1, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("DAC Vref", ES8328_CHIPPOWER,
+			ES8328_CHIPPOWER_DACVREF_OFF, 1, NULL, 0),
+
+	SND_SOC_DAPM_DAC("Right DAC", "Right Playback", ES8328_DACPOWER,
+			ES8328_DACPOWER_RDAC_OFF, 1),
+	SND_SOC_DAPM_DAC("Left DAC", "Left Playback", ES8328_DACPOWER,
+			ES8328_DACPOWER_LDAC_OFF, 1),
+
+	SND_SOC_DAPM_MIXER("Left Mixer", SND_SOC_NOPM, 0, 0,
+		&es8328_left_mixer_controls[0],
+		ARRAY_SIZE(es8328_left_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Mixer", SND_SOC_NOPM, 0, 0,
+		&es8328_right_mixer_controls[0],
+		ARRAY_SIZE(es8328_right_mixer_controls)),
+
+	SND_SOC_DAPM_PGA("Right Out 2", ES8328_DACPOWER,
+			ES8328_DACPOWER_ROUT2_ON, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left Out 2", ES8328_DACPOWER,
+			ES8328_DACPOWER_LOUT2_ON, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Out 1", ES8328_DACPOWER,
+			ES8328_DACPOWER_ROUT1_ON, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Left Out 1", ES8328_DACPOWER,
+			ES8328_DACPOWER_LOUT1_ON, 0, NULL, 0),
+
+	SND_SOC_DAPM_OUTPUT("LOUT1"),
+	SND_SOC_DAPM_OUTPUT("ROUT1"),
+	SND_SOC_DAPM_OUTPUT("LOUT2"),
+	SND_SOC_DAPM_OUTPUT("ROUT2"),
+
+	SND_SOC_DAPM_INPUT("LINPUT1"),
+	SND_SOC_DAPM_INPUT("LINPUT2"),
+	SND_SOC_DAPM_INPUT("RINPUT1"),
+	SND_SOC_DAPM_INPUT("RINPUT2"),
+};
+
+static const struct snd_soc_dapm_route es8328_dapm_routes[] = {
+
+	{ "Left Line Mux", "Line 1", "LINPUT1" },
+	{ "Left Line Mux", "Line 2", "LINPUT2" },
+	{ "Left Line Mux", "PGA", "Left PGA Mux" },
+	{ "Left Line Mux", "Differential", "Differential Mux" },
+
+	{ "Right Line Mux", "Line 1", "RINPUT1" },
+	{ "Right Line Mux", "Line 2", "RINPUT2" },
+	{ "Right Line Mux", "PGA", "Right PGA Mux" },
+	{ "Right Line Mux", "Differential", "Differential Mux" },
+
+	{ "Left PGA Mux", "Line 1", "LINPUT1" },
+	{ "Left PGA Mux", "Line 2", "LINPUT2" },
+	{ "Left PGA Mux", "Differential", "Differential Mux" },
+
+	{ "Right PGA Mux", "Line 1", "RINPUT1" },
+	{ "Right PGA Mux", "Line 2", "RINPUT2" },
+	{ "Right PGA Mux", "Differential", "Differential Mux" },
+
+	{ "Differential Mux", "Line 1", "LINPUT1" },
+	{ "Differential Mux", "Line 1", "RINPUT1" },
+	{ "Differential Mux", "Line 2", "LINPUT2" },
+	{ "Differential Mux", "Line 2", "RINPUT2" },
+
+	{ "Left ADC Mux", "Stereo", "Left PGA Mux" },
+	{ "Left ADC Mux", "Mono (Left)", "Left PGA Mux" },
+	{ "Left ADC Mux", "Digital Mono", "Left PGA Mux" },
+
+	{ "Right ADC Mux", "Stereo", "Right PGA Mux" },
+	{ "Right ADC Mux", "Mono (Right)", "Right PGA Mux" },
+	{ "Right ADC Mux", "Digital Mono", "Right PGA Mux" },
+
+	{ "Left ADC", NULL, "Left ADC Mux" },
+	{ "Right ADC", NULL, "Right ADC Mux" },
+
+	{ "ADC DIG", NULL, "ADC STM" },
+	{ "ADC DIG", NULL, "ADC Vref" },
+	{ "ADC DIG", NULL, "ADC DLL" },
+
+	{ "Left ADC", NULL, "ADC DIG" },
+	{ "Right ADC", NULL, "ADC DIG" },
+
+	{ "Mic Bias", NULL, "Mic Bias Gen" },
+
+	{ "Left ADC", NULL, "Mic Bias" },
+	{ "Right ADC", NULL, "Mic Bias" },
+
+	{ "Left Line Mux", "Line 1", "LINPUT1" },
+	{ "Left Line Mux", "Line 2", "LINPUT2" },
+	{ "Left Line Mux", "PGA", "Left PGA Mux" },
+	{ "Left Line Mux", "Differential", "Differential Mux" },
+
+	{ "Right Line Mux", "Line 1", "RINPUT1" },
+	{ "Right Line Mux", "Line 2", "RINPUT2" },
+	{ "Right Line Mux", "PGA", "Right PGA Mux" },
+	{ "Right Line Mux", "Differential", "Differential Mux" },
+
+	{ "Left Out 1", NULL, "Left DAC" },
+	{ "Right Out 1", NULL, "Right DAC" },
+	{ "Left Out 2", NULL, "Left DAC" },
+	{ "Right Out 2", NULL, "Right DAC" },
+
+	{ "Left Mixer", "Playback Switch", "Left DAC" },
+	{ "Left Mixer", "Left Bypass Switch", "Left Line Mux" },
+	{ "Left Mixer", "Right Playback Switch", "Right DAC" },
+	{ "Left Mixer", "Right Bypass Switch", "Right Line Mux" },
+
+	{ "Right Mixer", "Left Playback Switch", "Left DAC" },
+	{ "Right Mixer", "Left Bypass Switch", "Left Line Mux" },
+	{ "Right Mixer", "Playback Switch", "Right DAC" },
+	{ "Right Mixer", "Right Bypass Switch", "Right Line Mux" },
+
+	{ "DAC DIG", NULL, "DAC STM" },
+	{ "DAC DIG", NULL, "DAC Vref" },
+	{ "DAC DIG", NULL, "DAC DLL" },
+
+	{ "Left DAC", NULL, "DAC DIG" },
+	{ "Right DAC", NULL, "DAC DIG" },
+
+	{ "Left Out 1", NULL, "Left Mixer" },
+	{ "LOUT1", NULL, "Left Out 1" },
+	{ "Right Out 1", NULL, "Right Mixer" },
+	{ "ROUT1", NULL, "Right Out 1" },
+
+	{ "Left Out 2", NULL, "Left Mixer" },
+	{ "LOUT2", NULL, "Left Out 2" },
+	{ "Right Out 2", NULL, "Right Mixer" },
+	{ "ROUT2", NULL, "Right Out 2" },
+};
+
+static int es8328_mute(struct snd_soc_dai *dai, int mute, int direction)
+{
+	return snd_soc_component_update_bits(dai->component, ES8328_DACCONTROL3,
+			ES8328_DACCONTROL3_DACMUTE,
+			mute ? ES8328_DACCONTROL3_DACMUTE : 0);
+}
+
+static int es8328_startup(struct snd_pcm_substream *substream,
+			  struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);
+
+	if (es8328->provider && es8328->sysclk_constraints)
+		snd_pcm_hw_constraint_list(substream->runtime, 0,
+				SNDRV_PCM_HW_PARAM_RATE,
+				es8328->sysclk_constraints);
+
+	return 0;
+}
+
+static int es8328_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params,
+	struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);
+	int i;
+	int reg;
+	int wl;
+	int ratio;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		reg = ES8328_DACCONTROL2;
+	else
+		reg = ES8328_ADCCONTROL5;
+
+	if (es8328->provider) {
+		if (!es8328->sysclk_constraints) {
+			dev_err(component->dev, "No MCLK configured\n");
+			return -EINVAL;
+		}
+
+		for (i = 0; i < es8328->sysclk_constraints->count; i++)
+			if (es8328->sysclk_constraints->list[i] ==
+			    params_rate(params))
+				break;
+
+		if (i == es8328->sysclk_constraints->count) {
+			dev_err(component->dev,
+				"LRCLK %d unsupported with current clock\n",
+				params_rate(params));
+			return -EINVAL;
+		}
+		ratio = es8328->mclk_ratios[i];
+	} else {
+		ratio = 0;
+		es8328->mclkdiv2 = 0;
+	}
+
+	snd_soc_component_update_bits(component, ES8328_MASTERMODE,
+			ES8328_MASTERMODE_MCLKDIV2,
+			es8328->mclkdiv2 ? ES8328_MASTERMODE_MCLKDIV2 : 0);
+
+	switch (params_width(params)) {
+	case 16:
+		wl = 3;
+		break;
+	case 18:
+		wl = 2;
+		break;
+	case 20:
+		wl = 1;
+		break;
+	case 24:
+		wl = 0;
+		break;
+	case 32:
+		wl = 4;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		snd_soc_component_update_bits(component, ES8328_DACCONTROL1,
+				ES8328_DACCONTROL1_DACWL_MASK,
+				wl << ES8328_DACCONTROL1_DACWL_SHIFT);
+
+		es8328->playback_fs = params_rate(params);
+		es8328_set_deemph(component);
+	} else
+		snd_soc_component_update_bits(component, ES8328_ADCCONTROL4,
+				ES8328_ADCCONTROL4_ADCWL_MASK,
+				wl << ES8328_ADCCONTROL4_ADCWL_SHIFT);
+
+	return snd_soc_component_update_bits(component, reg, ES8328_RATEMASK, ratio);
+}
+
+static int es8328_set_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_component *component = codec_dai->component;
+	struct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);
+	int mclkdiv2 = 0;
+
+	switch (freq) {
+	case 0:
+		es8328->sysclk_constraints = NULL;
+		es8328->mclk_ratios = NULL;
+		break;
+	case 22579200:
+		mclkdiv2 = 1;
+		fallthrough;
+	case 11289600:
+		es8328->sysclk_constraints = &constraints_11289;
+		es8328->mclk_ratios = ratios_11289;
+		break;
+	case 24576000:
+		mclkdiv2 = 1;
+		fallthrough;
+	case 12288000:
+		es8328->sysclk_constraints = &constraints_12288;
+		es8328->mclk_ratios = ratios_12288;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	es8328->mclkdiv2 = mclkdiv2;
+	return 0;
+}
+
+static int es8328_set_dai_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct snd_soc_component *component = codec_dai->component;
+	struct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);
+	u8 dac_mode = 0;
+	u8 adc_mode = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {
+	case SND_SOC_DAIFMT_CBP_CFP:
+		/* Master serial port mode, with BCLK generated automatically */
+		snd_soc_component_update_bits(component, ES8328_MASTERMODE,
+				    ES8328_MASTERMODE_MSC,
+				    ES8328_MASTERMODE_MSC);
+		es8328->provider = true;
+		break;
+	case SND_SOC_DAIFMT_CBC_CFC:
+		/* Slave serial port mode */
+		snd_soc_component_update_bits(component, ES8328_MASTERMODE,
+				    ES8328_MASTERMODE_MSC, 0);
+		es8328->provider = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		dac_mode |= ES8328_DACCONTROL1_DACFORMAT_I2S;
+		adc_mode |= ES8328_ADCCONTROL4_ADCFORMAT_I2S;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		dac_mode |= ES8328_DACCONTROL1_DACFORMAT_RJUST;
+		adc_mode |= ES8328_ADCCONTROL4_ADCFORMAT_RJUST;
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		dac_mode |= ES8328_DACCONTROL1_DACFORMAT_LJUST;
+		adc_mode |= ES8328_ADCCONTROL4_ADCFORMAT_LJUST;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	if ((fmt & SND_SOC_DAIFMT_INV_MASK) != SND_SOC_DAIFMT_NB_NF)
+		return -EINVAL;
+
+	snd_soc_component_update_bits(component, ES8328_DACCONTROL1,
+			ES8328_DACCONTROL1_DACFORMAT_MASK, dac_mode);
+	snd_soc_component_update_bits(component, ES8328_ADCCONTROL4,
+			ES8328_ADCCONTROL4_ADCFORMAT_MASK, adc_mode);
+	snd_soc_component_update_bits(component, ES8328_DACCONTROL21,
+			ES8328_DACCONTROL21_SLRCK, ES8328_DACCONTROL21_SLRCK);
+
+	/* Set Capture Digital Volume */
+	snd_soc_component_write(component, ES8328_ADCCONTROL8, 0);
+	snd_soc_component_write(component, ES8328_ADCCONTROL9, 0);
+
+	/* Set PCM Volume */
+	snd_soc_component_write(component, ES8328_LDACVOL, 0);
+	snd_soc_component_write(component, ES8328_RDACVOL, 0);
+
+	/* Set L/R Out Volume */
+	snd_soc_component_write(component, ES8328_LOUT1VOL, 0x1e);
+	snd_soc_component_write(component, ES8328_ROUT1VOL, 0x1e);
+	snd_soc_component_write(component, ES8328_LOUT2VOL, 0x1e);
+	snd_soc_component_write(component, ES8328_ROUT2VOL, 0x1e);
+
+	/* Set MIC PGA Volume */
+	snd_soc_component_write(component, ES8328_ADCCONTROL1, 0x88);
+
+	if (es8328->eswin_plat == 2) {
+		if (gpiod_get_value(es8328->front_jack_gpio) == 1 && gpiod_get_value(es8328->back_jack_gpio) == 0) {
+			/* Select default capture path ---> LIN1 */
+			snd_soc_component_write(component, ES8328_ADCCONTROL2, 0);
+		} else {
+			/* Select default capture path ---> LIN2 */
+			snd_soc_component_write(component, ES8328_ADCCONTROL2, 0x50);
+		}
+	} else {
+		/* Select default capture path ---> phone mic */
+		snd_soc_component_write(component, ES8328_ADCCONTROL2, 0xf0);
+	}
+
+	snd_soc_component_update_bits(component, ES8328_ADCCONTROL3,
+			ES8328_ADCCONTROL3_DS, 0);
+
+	/* Select Playback path */
+	snd_soc_component_update_bits(component, ES8328_DACCONTROL17,
+			ES8328_DACCONTROL17_LD2LO, ES8328_DACCONTROL17_LD2LO);
+	snd_soc_component_update_bits(component, ES8328_DACCONTROL20,
+			ES8328_DACCONTROL20_RD2RO, ES8328_DACCONTROL20_RD2RO);
+
+	return 0;
+}
+
+static int es8328_set_bias_level(struct snd_soc_component *component,
+				 enum snd_soc_bias_level level)
+{
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+		break;
+
+	case SND_SOC_BIAS_PREPARE:
+		/* VREF, VMID=2x50k, digital enabled */
+		snd_soc_component_write(component, ES8328_CHIPPOWER, 0);
+		snd_soc_component_update_bits(component, ES8328_CONTROL1,
+				ES8328_CONTROL1_VMIDSEL_MASK |
+				ES8328_CONTROL1_ENREF,
+				ES8328_CONTROL1_VMIDSEL_50k |
+				ES8328_CONTROL1_ENREF);
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {
+			snd_soc_component_update_bits(component, ES8328_CONTROL1,
+					ES8328_CONTROL1_VMIDSEL_MASK |
+					ES8328_CONTROL1_ENREF,
+					ES8328_CONTROL1_VMIDSEL_5k |
+					ES8328_CONTROL1_ENREF);
+
+			/* Charge caps */
+			msleep(100);
+		}
+
+		snd_soc_component_write(component, ES8328_CONTROL2,
+				ES8328_CONTROL2_OVERCURRENT_ON |
+				ES8328_CONTROL2_THERMAL_SHUTDOWN_ON);
+
+		/* VREF, VMID=2*500k, digital stopped */
+		snd_soc_component_update_bits(component, ES8328_CONTROL1,
+				ES8328_CONTROL1_VMIDSEL_MASK |
+				ES8328_CONTROL1_ENREF,
+				ES8328_CONTROL1_VMIDSEL_500k |
+				ES8328_CONTROL1_ENREF);
+		break;
+
+	case SND_SOC_BIAS_OFF:
+		snd_soc_component_update_bits(component, ES8328_CONTROL1,
+				ES8328_CONTROL1_VMIDSEL_MASK |
+				ES8328_CONTROL1_ENREF,
+				0);
+		break;
+	}
+	return 0;
+}
+
+static const struct snd_soc_dai_ops es8328_dai_ops = {
+	.startup	= es8328_startup,
+	.hw_params	= es8328_hw_params,
+	.mute_stream	= es8328_mute,
+	.set_sysclk	= es8328_set_sysclk,
+	.set_fmt	= es8328_set_dai_fmt,
+	.no_capture_mute = 1,
+};
+
+static struct snd_soc_dai_driver es8328_dai[3] = {
+	{
+		.name = "es8328-0-hifi-analog",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ES8328_RATES,
+			.formats = ES8328_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ES8328_RATES,
+			.formats = ES8328_FORMATS,
+		},
+		.ops = &es8328_dai_ops,
+		.symmetric_rate = 1,
+	},
+	{
+		.name = "es8328-1-hifi-analog",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ES8328_RATES,
+			.formats = ES8328_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ES8328_RATES,
+			.formats = ES8328_FORMATS,
+		},
+		.ops = &es8328_dai_ops,
+		.symmetric_rate = 1,
+	},
+	{
+		.name = "es8328-2-hifi-analog",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ES8328_RATES,
+			.formats = ES8328_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ES8328_RATES,
+			.formats = ES8328_FORMATS,
+		},
+		.ops = &es8328_dai_ops,
+		.symmetric_rate = 1,
+	},
+};
+
+static int es8328_suspend(struct snd_soc_component *component)
+{
+	return 0;
+}
+
+static int es8328_resume(struct snd_soc_component *component)
+{
+	struct regmap *regmap = dev_get_regmap(component->dev, NULL);
+	int ret;
+
+	regcache_mark_dirty(regmap);
+	ret = regcache_sync(regmap);
+	if (ret) {
+		dev_err(component->dev, "unable to sync regcache\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int es8328_component_probe(struct snd_soc_component *component)
+{
+	struct es8328_priv *es8328 = snd_soc_component_get_drvdata(component);
+
+	es8328->component = component;
+
+	return 0;
+}
+
+static void es8328_remove(struct snd_soc_component *component)
+{
+}
+
+const struct regmap_config es8328_regmap_config = {
+	.reg_bits	= 8,
+	.val_bits	= 8,
+	.max_register	= ES8328_REG_MAX,
+	.cache_type	= REGCACHE_MAPLE,
+	.use_single_read = true,
+	.use_single_write = true,
+};
+EXPORT_SYMBOL_GPL(es8328_regmap_config);
+
+static const struct snd_soc_component_driver es8328_component_driver = {
+	.probe			= es8328_component_probe,
+	.remove			= es8328_remove,
+	.suspend		= es8328_suspend,
+	.resume			= es8328_resume,
+	.set_bias_level		= es8328_set_bias_level,
+	.controls		= es8328_snd_controls,
+	.num_controls		= ARRAY_SIZE(es8328_snd_controls),
+	.dapm_widgets		= es8328_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(es8328_dapm_widgets),
+	.dapm_routes		= es8328_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(es8328_dapm_routes),
+	.suspend_bias_off	= 1,
+	.idle_bias_on		= 1,
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+};
+
+static irqreturn_t es8328_jack_irq(int irq, void *data)
+{
+	struct es8328_priv *es8328 = data;
+	struct snd_soc_component *comp = es8328->component;
+	int front_jack_value, back_jack_value;
+
+	if (!es8328->front_jack_gpio || !es8328->back_jack_gpio) {
+		dev_warn(comp->dev, "jack gpio desc is null\n");
+		return IRQ_NONE;
+	}
+
+	front_jack_value = gpiod_get_value(es8328->front_jack_gpio);
+	back_jack_value = gpiod_get_value(es8328->back_jack_gpio);
+
+	dev_dbg(comp->dev, "front jack value:%d, back jack value:%d\n", front_jack_value, back_jack_value);
+
+	if (back_jack_value == 0 && front_jack_value == 1) {
+		/* Select Capture path ---> LIN1 */
+		regmap_write(comp->regmap, ES8328_ADCCONTROL2, 0);
+	} else {
+		/* Select Capture path ---> LIN2 */
+		regmap_write(comp->regmap, ES8328_ADCCONTROL2, 0x50);
+	}
+
+	return IRQ_HANDLED;
+}
+
+int es8328_probe(struct device *dev, struct regmap *regmap)
+{
+	struct es8328_priv *es8328;
+	int ret;
+
+	if (IS_ERR(regmap))
+		return PTR_ERR(regmap);
+
+	es8328 = devm_kzalloc(dev, sizeof(*es8328), GFP_KERNEL);
+	if (es8328 == NULL)
+		return -ENOMEM;
+
+	es8328->regmap = regmap;
+
+	dev_set_drvdata(dev, es8328);
+
+	ret = device_property_read_u32(dev, "eswin-plat", &es8328->eswin_plat);
+	if (0 != ret) {
+		es8328->eswin_plat = 0;
+	}
+	dev_info(dev, "eswin platform:%d\n", es8328->eswin_plat);
+
+	if (es8328->eswin_plat == 2) {
+		es8328->front_jack_gpio = devm_gpiod_get(dev, "front-jack", GPIOD_IN);
+		ret = IS_ERR(es8328->front_jack_gpio);
+		if(ret) {
+			dev_err(dev, "can not get front jack gpio\n");
+		}
+
+		es8328->back_jack_gpio = devm_gpiod_get(dev, "back-jack", GPIOD_IN);
+		ret = IS_ERR(es8328->back_jack_gpio);
+		if(ret) {
+			dev_err(dev, "can not get back jack gpio\n");
+		}
+
+		ret = devm_request_threaded_irq(dev, gpiod_to_irq(es8328->front_jack_gpio), NULL, es8328_jack_irq,
+				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+				"front jack", es8328);
+		if (ret) {
+			dev_err(dev, "Failed to request front irq[%d], ret:%d\n", gpiod_to_irq(es8328->back_jack_gpio), ret);
+		}
+
+		ret = devm_request_threaded_irq(dev, gpiod_to_irq(es8328->back_jack_gpio), NULL, es8328_jack_irq,
+				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+				"back jack", es8328);
+		if (ret) {
+			dev_err(dev, "Failed to request back irq[%d], ret:%d\n", gpiod_to_irq(es8328->back_jack_gpio), ret);
+		}
+	}
+
+	if (of_node_name_prefix(dev->of_node, "es8388-0")) {
+		ret = devm_snd_soc_register_component(dev,
+				&es8328_component_driver, &es8328_dai[0], 1);
+	} else if (of_node_name_prefix(dev->of_node, "es8388-1")) {
+		ret = devm_snd_soc_register_component(dev,
+				&es8328_component_driver, &es8328_dai[1], 1);
+	} else {
+		ret = devm_snd_soc_register_component(dev,
+				&es8328_component_driver, &es8328_dai[2], 1);
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(es8328_probe);
+
+MODULE_DESCRIPTION("ASoC ES8328 driver");
+MODULE_AUTHOR("Sean Cross <xobs@kosagi.com>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/eswin/es8328.h b/sound/soc/codecs/eswin/es8328.h
new file mode 100644
index 000000000000..c47988b5ea1b
--- /dev/null
+++ b/sound/soc/codecs/eswin/es8328.h
@@ -0,0 +1,284 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * es8328.h  --  ES8328 ALSA SoC Audio driver
+ */
+
+#ifndef _ES8328_H
+#define _ES8328_H
+
+#include <linux/regmap.h>
+
+struct device;
+
+extern const struct regmap_config es8328_regmap_config;
+int es8328_probe(struct device *dev, struct regmap *regmap);
+
+#define ES8328_DACLVOL 46
+#define ES8328_DACRVOL 47
+#define ES8328_DACCTL 28
+#define ES8328_RATEMASK (0x1f << 0)
+
+#define ES8328_CONTROL1		0x00
+#define ES8328_CONTROL1_VMIDSEL_OFF (0 << 0)
+#define ES8328_CONTROL1_VMIDSEL_50k (1 << 0)
+#define ES8328_CONTROL1_VMIDSEL_500k (2 << 0)
+#define ES8328_CONTROL1_VMIDSEL_5k (3 << 0)
+#define ES8328_CONTROL1_VMIDSEL_MASK (3 << 0)
+#define ES8328_CONTROL1_ENREF (1 << 2)
+#define ES8328_CONTROL1_SEQEN (1 << 3)
+#define ES8328_CONTROL1_SAMEFS (1 << 4)
+#define ES8328_CONTROL1_DACMCLK_ADC (0 << 5)
+#define ES8328_CONTROL1_DACMCLK_DAC (1 << 5)
+#define ES8328_CONTROL1_LRCM (1 << 6)
+#define ES8328_CONTROL1_SCP_RESET (1 << 7)
+
+#define ES8328_CONTROL2		0x01
+#define ES8328_CONTROL2_VREF_BUF_OFF (1 << 0)
+#define ES8328_CONTROL2_VREF_LOWPOWER (1 << 1)
+#define ES8328_CONTROL2_IBIASGEN_OFF (1 << 2)
+#define ES8328_CONTROL2_ANALOG_OFF (1 << 3)
+#define ES8328_CONTROL2_VREF_BUF_LOWPOWER (1 << 4)
+#define ES8328_CONTROL2_VCM_MOD_LOWPOWER (1 << 5)
+#define ES8328_CONTROL2_OVERCURRENT_ON (1 << 6)
+#define ES8328_CONTROL2_THERMAL_SHUTDOWN_ON (1 << 7)
+
+#define ES8328_CHIPPOWER	0x02
+#define ES8328_CHIPPOWER_DACVREF_OFF 0
+#define ES8328_CHIPPOWER_ADCVREF_OFF 1
+#define ES8328_CHIPPOWER_DACDLL_OFF 2
+#define ES8328_CHIPPOWER_ADCDLL_OFF 3
+#define ES8328_CHIPPOWER_DACSTM_RESET 4
+#define ES8328_CHIPPOWER_ADCSTM_RESET 5
+#define ES8328_CHIPPOWER_DACDIG_OFF 6
+#define ES8328_CHIPPOWER_ADCDIG_OFF 7
+
+#define ES8328_ADCPOWER		0x03
+#define ES8328_ADCPOWER_INT1_LOWPOWER 0
+#define ES8328_ADCPOWER_FLASH_ADC_LOWPOWER 1
+#define ES8328_ADCPOWER_ADC_BIAS_GEN_OFF 2
+#define ES8328_ADCPOWER_MIC_BIAS_OFF 3
+#define ES8328_ADCPOWER_ADCR_OFF 4
+#define ES8328_ADCPOWER_ADCL_OFF 5
+#define ES8328_ADCPOWER_AINR_OFF 6
+#define ES8328_ADCPOWER_AINL_OFF 7
+
+#define ES8328_DACPOWER		0x04
+#define ES8328_DACPOWER_OUT3_ON 0
+#define ES8328_DACPOWER_MONO_ON 1
+#define ES8328_DACPOWER_ROUT2_ON 2
+#define ES8328_DACPOWER_LOUT2_ON 3
+#define ES8328_DACPOWER_ROUT1_ON 4
+#define ES8328_DACPOWER_LOUT1_ON 5
+#define ES8328_DACPOWER_RDAC_OFF 6
+#define ES8328_DACPOWER_LDAC_OFF 7
+
+#define ES8328_CHIPLOPOW1	0x05
+#define ES8328_CHIPLOPOW2	0x06
+#define ES8328_ANAVOLMANAG	0x07
+
+#define ES8328_MASTERMODE	0x08
+#define ES8328_MASTERMODE_BCLKDIV (0 << 0)
+#define ES8328_MASTERMODE_BCLK_INV (1 << 5)
+#define ES8328_MASTERMODE_MCLKDIV2 (1 << 6)
+#define ES8328_MASTERMODE_MSC (1 << 7)
+
+#define ES8328_ADCCONTROL1	0x09
+#define ES8328_ADCCONTROL2	0x0a
+#define ES8328_ADCCONTROL3	0x0b
+#define ES8328_ADCCONTROL3_DS (1 << 7)
+
+#define ES8328_ADCCONTROL4	0x0c
+#define ES8328_ADCCONTROL4_ADCFORMAT_MASK (3 << 0)
+#define ES8328_ADCCONTROL4_ADCFORMAT_I2S (0 << 0)
+#define ES8328_ADCCONTROL4_ADCFORMAT_LJUST (1 << 0)
+#define ES8328_ADCCONTROL4_ADCFORMAT_RJUST (2 << 0)
+#define ES8328_ADCCONTROL4_ADCFORMAT_PCM (3 << 0)
+#define ES8328_ADCCONTROL4_ADCWL_SHIFT 2
+#define ES8328_ADCCONTROL4_ADCWL_MASK (7 << 2)
+#define ES8328_ADCCONTROL4_ADCLRP_I2S_POL_NORMAL (0 << 5)
+#define ES8328_ADCCONTROL4_ADCLRP_I2S_POL_INV (1 << 5)
+#define ES8328_ADCCONTROL4_ADCLRP_PCM_MSB_CLK2 (0 << 5)
+#define ES8328_ADCCONTROL4_ADCLRP_PCM_MSB_CLK1 (1 << 5)
+
+#define ES8328_ADCCONTROL5	0x0d
+#define ES8328_ADCCONTROL5_RATEMASK (0x1f << 0)
+
+#define ES8328_ADCCONTROL6	0x0e
+
+#define ES8328_ADCCONTROL7	0x0f
+#define ES8328_ADCCONTROL7_ADC_MUTE (1 << 2)
+#define ES8328_ADCCONTROL7_ADC_LER (1 << 3)
+#define ES8328_ADCCONTROL7_ADC_ZERO_CROSS (1 << 4)
+#define ES8328_ADCCONTROL7_ADC_SOFT_RAMP (1 << 5)
+#define ES8328_ADCCONTROL7_ADC_RAMP_RATE_4 (0 << 6)
+#define ES8328_ADCCONTROL7_ADC_RAMP_RATE_8 (1 << 6)
+#define ES8328_ADCCONTROL7_ADC_RAMP_RATE_16 (2 << 6)
+#define ES8328_ADCCONTROL7_ADC_RAMP_RATE_32 (3 << 6)
+
+#define ES8328_ADCCONTROL8	0x10
+#define ES8328_ADCCONTROL9	0x11
+#define ES8328_ADCCONTROL10	0x12
+#define ES8328_ADCCONTROL11	0x13
+#define ES8328_ADCCONTROL12	0x14
+#define ES8328_ADCCONTROL13	0x15
+#define ES8328_ADCCONTROL14	0x16
+
+#define ES8328_DACCONTROL1	0x17
+#define ES8328_DACCONTROL1_DACFORMAT_MASK (3 << 1)
+#define ES8328_DACCONTROL1_DACFORMAT_I2S (0 << 1)
+#define ES8328_DACCONTROL1_DACFORMAT_LJUST (1 << 1)
+#define ES8328_DACCONTROL1_DACFORMAT_RJUST (2 << 1)
+#define ES8328_DACCONTROL1_DACFORMAT_PCM (3 << 1)
+#define ES8328_DACCONTROL1_DACWL_SHIFT 3
+#define ES8328_DACCONTROL1_DACWL_MASK (7 << 3)
+#define ES8328_DACCONTROL1_DACLRP_I2S_POL_NORMAL (0 << 6)
+#define ES8328_DACCONTROL1_DACLRP_I2S_POL_INV (1 << 6)
+#define ES8328_DACCONTROL1_DACLRP_PCM_MSB_CLK2 (0 << 6)
+#define ES8328_DACCONTROL1_DACLRP_PCM_MSB_CLK1 (1 << 6)
+#define ES8328_DACCONTROL1_LRSWAP (1 << 7)
+
+#define ES8328_DACCONTROL2	0x18
+#define ES8328_DACCONTROL2_RATEMASK (0x1f << 0)
+#define ES8328_DACCONTROL2_DOUBLESPEED (1 << 5)
+
+#define ES8328_DACCONTROL3	0x19
+#define ES8328_DACCONTROL3_AUTOMUTE (1 << 2)
+#define ES8328_DACCONTROL3_DACMUTE (1 << 2)
+#define ES8328_DACCONTROL3_LEFTGAINVOL (1 << 3)
+#define ES8328_DACCONTROL3_DACZEROCROSS (1 << 4)
+#define ES8328_DACCONTROL3_DACSOFTRAMP (1 << 5)
+#define ES8328_DACCONTROL3_DACRAMPRATE (3 << 6)
+
+#define ES8328_LDACVOL 0x1a
+#define ES8328_LDACVOL_MASK (0 << 0)
+#define ES8328_LDACVOL_MAX (0xc0)
+
+#define ES8328_RDACVOL 0x1b
+#define ES8328_RDACVOL_MASK (0 << 0)
+#define ES8328_RDACVOL_MAX (0xc0)
+
+#define ES8328_DACCONTROL6	0x1c
+#define ES8328_DACCONTROL6_CLICKFREE (1 << 3)
+#define ES8328_DACCONTROL6_DAC_INVR (1 << 4)
+#define ES8328_DACCONTROL6_DAC_INVL (1 << 5)
+#define ES8328_DACCONTROL6_DEEMPH_MASK (3 << 6)
+#define ES8328_DACCONTROL6_DEEMPH_OFF (0 << 6)
+#define ES8328_DACCONTROL6_DEEMPH_32k (1 << 6)
+#define ES8328_DACCONTROL6_DEEMPH_44_1k (2 << 6)
+#define ES8328_DACCONTROL6_DEEMPH_48k (3 << 6)
+
+#define ES8328_DACCONTROL7	0x1d
+#define ES8328_DACCONTROL7_VPP_SCALE_3p5	(0 << 0)
+#define ES8328_DACCONTROL7_VPP_SCALE_4p0	(1 << 0)
+#define ES8328_DACCONTROL7_VPP_SCALE_3p0	(2 << 0)
+#define ES8328_DACCONTROL7_VPP_SCALE_2p5	(3 << 0)
+#define ES8328_DACCONTROL7_SHELVING_STRENGTH (1 << 2) /* In eights */
+#define ES8328_DACCONTROL7_MONO		(1 << 5)
+#define ES8328_DACCONTROL7_ZEROR	(1 << 6)
+#define ES8328_DACCONTROL7_ZEROL	(1 << 7)
+
+/* Shelving filter */
+#define ES8328_DACCONTROL8	0x1e
+#define ES8328_DACCONTROL9	0x1f
+#define ES8328_DACCONTROL10	0x20
+#define ES8328_DACCONTROL11	0x21
+#define ES8328_DACCONTROL12	0x22
+#define ES8328_DACCONTROL13	0x23
+#define ES8328_DACCONTROL14	0x24
+#define ES8328_DACCONTROL15	0x25
+
+#define ES8328_DACCONTROL16	0x26
+#define ES8328_DACCONTROL16_RMIXSEL_RIN1 (0 << 0)
+#define ES8328_DACCONTROL16_RMIXSEL_RIN2 (1 << 0)
+#define ES8328_DACCONTROL16_RMIXSEL_RIN3 (2 << 0)
+#define ES8328_DACCONTROL16_RMIXSEL_RADC (3 << 0)
+#define ES8328_DACCONTROL16_LMIXSEL_LIN1 (0 << 3)
+#define ES8328_DACCONTROL16_LMIXSEL_LIN2 (1 << 3)
+#define ES8328_DACCONTROL16_LMIXSEL_LIN3 (2 << 3)
+#define ES8328_DACCONTROL16_LMIXSEL_LADC (3 << 3)
+
+#define ES8328_DACCONTROL17	0x27
+#define ES8328_DACCONTROL17_LI2LOVOL (7 << 3)
+#define ES8328_DACCONTROL17_LI2LO (1 << 6)
+#define ES8328_DACCONTROL17_LD2LO (1 << 7)
+
+#define ES8328_DACCONTROL18	0x28
+#define ES8328_DACCONTROL18_RI2LOVOL (7 << 3)
+#define ES8328_DACCONTROL18_RI2LO (1 << 6)
+#define ES8328_DACCONTROL18_RD2LO (1 << 7)
+
+#define ES8328_DACCONTROL19	0x29
+#define ES8328_DACCONTROL19_LI2ROVOL (7 << 3)
+#define ES8328_DACCONTROL19_LI2RO (1 << 6)
+#define ES8328_DACCONTROL19_LD2RO (1 << 7)
+
+#define ES8328_DACCONTROL20	0x2a
+#define ES8328_DACCONTROL20_RI2ROVOL (7 << 3)
+#define ES8328_DACCONTROL20_RI2RO (1 << 6)
+#define ES8328_DACCONTROL20_RD2RO (1 << 7)
+
+#define ES8328_DACCONTROL21	0x2b
+#define ES8328_DACCONTROL21_SLRCK (1 << 7)
+
+#define ES8328_DACCONTROL22	0x2c
+#define ES8328_DACCONTROL22_RI2MOVOL (7 << 3)
+#define ES8328_DACCONTROL22_RI2MO (1 << 6)
+#define ES8328_DACCONTROL22_RD2MO (1 << 7)
+
+#define ES8328_DACCONTROL23	0x2d
+#define ES8328_DACCONTROL23_MOUTINV		(1 << 1)
+#define ES8328_DACCONTROL23_HPSWPOL		(1 << 2)
+#define ES8328_DACCONTROL23_HPSWEN		(1 << 3)
+#define ES8328_DACCONTROL23_VROI_1p5k		(0 << 4)
+#define ES8328_DACCONTROL23_VROI_40k		(1 << 4)
+#define ES8328_DACCONTROL23_OUT3_VREF		(0 << 5)
+#define ES8328_DACCONTROL23_OUT3_ROUT1		(1 << 5)
+#define ES8328_DACCONTROL23_OUT3_MONOOUT	(2 << 5)
+#define ES8328_DACCONTROL23_OUT3_RIGHT_MIXER	(3 << 5)
+#define ES8328_DACCONTROL23_ROUT2INV		(1 << 7)
+
+/* LOUT1 Amplifier */
+#define ES8328_LOUT1VOL 0x2e
+#define ES8328_LOUT1VOL_MASK (0 << 5)
+#define ES8328_LOUT1VOL_MAX (0x24)
+
+/* ROUT1 Amplifier */
+#define ES8328_ROUT1VOL 0x2f
+#define ES8328_ROUT1VOL_MASK (0 << 5)
+#define ES8328_ROUT1VOL_MAX (0x24)
+
+#define ES8328_OUT1VOL_MAX (0x24)
+
+/* LOUT2 Amplifier */
+#define ES8328_LOUT2VOL 0x30
+#define ES8328_LOUT2VOL_MASK (0 << 5)
+#define ES8328_LOUT2VOL_MAX (0x24)
+
+/* ROUT2 Amplifier */
+#define ES8328_ROUT2VOL 0x31
+#define ES8328_ROUT2VOL_MASK (0 << 5)
+#define ES8328_ROUT2VOL_MAX (0x24)
+
+#define ES8328_OUT2VOL_MAX (0x24)
+
+/* Mono Out Amplifier */
+#define ES8328_MONOOUTVOL 0x32
+#define ES8328_MONOOUTVOL_MASK (0 << 5)
+#define ES8328_MONOOUTVOL_MAX (0x24)
+
+#define ES8328_DACCONTROL29	0x33
+#define ES8328_DACCONTROL30	0x34
+
+#define ES8328_SYSCLK		0
+
+#define ES8328_REG_MAX		0x35
+
+#define ES8328_1536FS		1536
+#define ES8328_1024FS		1024
+#define ES8328_768FS		768
+#define ES8328_512FS		512
+#define ES8328_384FS		384
+#define ES8328_256FS		256
+#define ES8328_128FS		128
+
+#endif
diff --git a/sound/soc/eswin/Kconfig b/sound/soc/eswin/Kconfig
new file mode 100644
index 000000000000..7eaebda84b6a
--- /dev/null
+++ b/sound/soc/eswin/Kconfig
@@ -0,0 +1,10 @@
+menu "SND ESWIN SOC"
+
+config SND_ESWIN_DW_I2S
+	tristate "Eswin Dw I2S Device Driver"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	 Say Y or M if you want to add support for I2S driver for
+	 Eswin dw I2S device. The device supports up to
+	 a maximum of 8 channels each for play and record.
+endmenu
diff --git a/sound/soc/eswin/Makefile b/sound/soc/eswin/Makefile
new file mode 100644
index 000000000000..2c133c695dbe
--- /dev/null
+++ b/sound/soc/eswin/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0-only
+# ESWIN Platform Support
+snd-soc-i2s-objs := esw-i2s.o esw-audio-proc.o
+
+obj-$(CONFIG_SND_ESWIN_DW_I2S) += snd-soc-i2s.o
\ No newline at end of file
diff --git a/sound/soc/eswin/esw-audio-proc.c b/sound/soc/eswin/esw-audio-proc.c
new file mode 100644
index 000000000000..ff372ff2d93a
--- /dev/null
+++ b/sound/soc/eswin/esw-audio-proc.c
@@ -0,0 +1,484 @@
+/*
+ *
+ * Copyright (C) 2021 ESWIN, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/kernel.h>
+#include <linux/seq_file.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/dma-mapping.h>
+#include <linux/uaccess.h>
+#include <linux/eventfd.h>
+#include <linux/ioctl.h>
+#include <linux/device.h>
+
+// proc data definition
+typedef enum
+{
+	ADEC_CREATE_CHN,
+	ADEC_SEND_STREAM,
+	ADEC_GET_FRAME,
+	ADEC_PARSE_PACKET,
+	ADEC_DECODE_STREAM,
+	AENC_CREATE_CHN,
+	AENC_SEND_FRAME,
+	AENC_GET_STREAM,
+	AENC_ENCODE_FRAME,
+	AGC_PROCESS,
+	ANS_PROCESS,
+	AEC_PROCESS,
+	DRC_PROCESS,
+	EQ_PROCESS,
+	DCBLOCK_PROCESS,
+	VOLUME_PROCESS,
+	SRC_HOST_PROCESS,
+	SRC_DAI_PROCESS,
+	HOST_PROCESS,
+	DAI_PROCESS,
+	AO_START,
+	AO_PROCESS_FRAME,
+	AO_WRITE_FRAME,
+	AO_STOP,
+	AI_START,
+	AI_READ_FRAME,
+	AI_PROCESS_FRAME,
+	AI_STOP,
+} PERF_MARK;
+
+static struct proc_dir_entry *proc_esaudio;
+static int g_switch = 0;
+
+// Device data definition
+#define MAX_PERF_SIZE 1024
+enum DEVICES_ID{
+	INVALID_DEVICE = -1,
+	AO = 0,
+	AI,
+	AENC,
+	ADEC,
+	NUM_DEVICES,
+};
+static const char *device_names[NUM_DEVICES] = {"ao", "ai", "aenc", "adec"};
+static int audio_proc_major[NUM_DEVICES] = {0};
+static struct class *audio_proc_class = NULL;
+static struct device *audio_proc_device[NUM_DEVICES] = {NULL};
+static int32_t *g_perf_data[NUM_DEVICES] = {NULL};
+
+static void show_aenc_data(struct seq_file *m)
+{
+	seq_printf(m,"----------------------------------------------------AENC PERF STATISTIC BEGIN"
+				"----------------------------------------------------\n");
+	seq_printf(m, "\n");
+	seq_printf(m, "------------------------------------------------------------------------"
+				"----------------------------------------------------------\n");
+	seq_printf(m, "audio encoder performance(us):\n");
+	seq_printf(m, "%-14s%-14s%-14s%-14s\n", "create_chn", "send_frame", "get_stream", "encode_frame");
+	seq_printf(m, "----------------------------------------------------------------------------------"
+				"------------------------------------------------\n");
+	seq_printf(m, "%-14d%-14d%-14d%-14d\n", g_perf_data[AENC][AENC_CREATE_CHN], g_perf_data[AENC][AENC_SEND_FRAME],
+				g_perf_data[AENC][AENC_GET_STREAM], g_perf_data[AENC][AENC_ENCODE_FRAME]);
+	seq_printf(m, "\n");
+	seq_printf(m, "-----------------------------------------------------AENC PERF STATISTIC END"
+	"-----------------------------------------------------\n");
+}
+
+static void show_adec_data(struct seq_file *m)
+{
+	seq_printf(m, "----------------------------------------------------ADEC PERF STATISTIC BEGIN"
+					"----------------------------------------------------\n");
+	seq_printf(m, "\n");
+	seq_printf(m, "--------------------------------------------------------------------------"
+				"--------------------------------------------------------\n");
+	seq_printf(m, "audio decoder performance(us):\n");
+	seq_printf(m, "%-14s%-14s%-14s%-14s%-14s\n", "create_chn", "send_stream", "get_frame",
+				"parse_packet", "decode_stream");
+	seq_printf(m, "------------------------------------------------------------------------------------"
+				"----------------------------------------------\n");
+	seq_printf(m, "%-14d%-14d%-14d%-14d%-14d\n", g_perf_data[ADEC][ADEC_CREATE_CHN],
+				g_perf_data[ADEC][ADEC_SEND_STREAM], g_perf_data[ADEC][ADEC_GET_FRAME],
+				g_perf_data[ADEC][ADEC_PARSE_PACKET], g_perf_data[ADEC][ADEC_DECODE_STREAM]);
+	seq_printf(m, "\n");
+	seq_printf(m,"-----------------------------------------------------ADEC PERF STATISTIC END"
+				"-----------------------------------------------------\n");
+}
+
+static void show_ao_data(struct seq_file *m)
+{
+	seq_printf(m,"----------------------------------------------------AO PERF STATISTIC BEGIN"
+	"----------------------------------------------------\n");
+	seq_printf(m, "\n");
+	seq_printf(m, "---------------------------------------------------------------------------"
+				"-------------------------------------------------------\n");
+	seq_printf(m, "audio output performance(us):\n");
+	seq_printf(m, "%-14s%-24s%-24s\n", "ao_start", "ao_process_frame", "ao_write_frame");
+	seq_printf(m, "----------------------------------------------------------------------------"
+				"------------------------------------------------------\n");
+	seq_printf(m, "%-14d%-24d%-24d\n", g_perf_data[AO][AO_START], g_perf_data[AO][AO_PROCESS_FRAME],
+				g_perf_data[AO][AO_WRITE_FRAME]);
+	seq_printf(m, "\n");
+	seq_printf(m, "-----------------------------------------------------------------------------"
+				"-----------------------------------------------------\n");
+	seq_printf(m, "audio argorithm performance(ns/1ms):\n");
+	seq_printf(m, "%-14s%-14s%-14s%-14s%-14s%-14s%-14s%-14s%-14s\n", "agc", "ans", "eq", "hpf",
+				"volume", "src-host","src-dai", "host", "dai");
+	seq_printf(m, "------------------------------------------------------------------------------"
+				"----------------------------------------------------\n");
+	seq_printf(m, "%-14d%-14d%-14d%-14d%-14d%-14d%-14d%-14d%-14d\n", g_perf_data[AO][AGC_PROCESS],
+				g_perf_data[AO][ANS_PROCESS],g_perf_data[AO][EQ_PROCESS],
+				g_perf_data[AO][DCBLOCK_PROCESS],g_perf_data[AO][VOLUME_PROCESS],
+				g_perf_data[AO][SRC_HOST_PROCESS],g_perf_data[AO][SRC_DAI_PROCESS],
+				g_perf_data[AO][HOST_PROCESS], g_perf_data[AO][DAI_PROCESS]);
+	seq_printf(m, "\n");
+	seq_printf(m,"-----------------------------------------------------AO PERF STATISTIC END"
+				"-----------------------------------------------------\n");
+}
+
+static void show_ai_data(struct seq_file *m)
+{
+	seq_printf(m,"----------------------------------------------------AI PERF STATISTIC BEGIN"
+				"----------------------------------------------------\n");
+	seq_printf(m, "\n");
+	seq_printf(m, "---------------------------------------------------------------------------"
+				"-------------------------------------------------------\n");
+	seq_printf(m, "audio input performance(us):\n");
+	seq_printf(m, "%-14s%-24s%-24s\n", "ai_start", "ai_read_frame", "ai_process_frame");
+	seq_printf(m, "----------------------------------------------------------------------------"
+				"------------------------------------------------------\n");
+	seq_printf(m, "%-14d%-24d%-24d\n", g_perf_data[AI][AI_START], g_perf_data[AI][AI_READ_FRAME],
+				g_perf_data[AI][AI_PROCESS_FRAME]);
+	seq_printf(m, "\n");
+	seq_printf(m, "-----------------------------------------------------------------------------"
+				"-----------------------------------------------------\n");
+	seq_printf(m, "audio argorithm performance(ns/1ms):\n");
+	seq_printf(m, "%-14s%-14s%-14s%-14s%-14s%-14s%-14s%-14s%-14s%-14s\n", "agc", "ans", "drc", "eq",
+				"hpf", "volume","src-host", "src-dai", "host", "dai");
+	seq_printf(m, "------------------------------------------------------------------------------"
+				"----------------------------------------------------\n");
+	seq_printf(m, "%-14d%-14d%-14d%-14d%-14d%-14d%-14d%-14d%-14d%-14d\n", g_perf_data[AI][AGC_PROCESS],
+		g_perf_data[AI][ANS_PROCESS],g_perf_data[AI][DRC_PROCESS], g_perf_data[AI][EQ_PROCESS],
+		g_perf_data[AI][DCBLOCK_PROCESS], g_perf_data[AI][VOLUME_PROCESS],g_perf_data[AI][SRC_HOST_PROCESS],
+		g_perf_data[AI][SRC_DAI_PROCESS], g_perf_data[AI][HOST_PROCESS], g_perf_data[AI][DAI_PROCESS]);
+	seq_printf(m, "\n");
+	seq_printf(m,"-----------------------------------------------------AI PERF STATISTIC END"
+				"-----------------------------------------------------\n");
+}
+
+
+static int audio_info_show(struct seq_file *m, void *p)
+{
+	int i;
+	const char *fileName = m->file->f_path.dentry->d_name.name;
+	enum DEVICES_ID deviceID = INVALID_DEVICE;
+
+	pr_info("audio_info_show:%s\n", m->file->f_path.dentry->d_name.name);
+
+	for (i = 0; i < NUM_DEVICES; ++i) {
+		if (strcmp(fileName, device_names[i]) == 0) {
+			deviceID = i;
+			break;
+		}
+	}
+
+	if (deviceID == INVALID_DEVICE) {
+		pr_err("deviceID is INVALID\n");
+		return -EINVAL;
+	}
+
+ 	if (g_switch == 0) {
+		seq_printf(m, "The switch is not turned on, pls first turn on the switch.\n");
+		return 0;
+	}
+
+	switch (deviceID) {
+	case AI:
+		show_ai_data(m);
+		break;
+	case AO:
+		show_ao_data(m);
+		break;
+	case AENC:
+		show_aenc_data(m);
+		break;
+	case ADEC:
+		show_adec_data(m);
+		break;
+	default:
+		pr_err("deviceID is INVALID\n");
+		break;
+		}
+	return 0;
+}
+
+static int info_open(struct inode *inode, struct file *flip)
+{
+	return single_open(flip, audio_info_show, NULL);
+}
+
+static int switch_show(struct seq_file *m, void *p)
+{
+	seq_printf(m, "--------------------AUDIO Performance Switch--------------------\n");
+	seq_printf(m, "\n");
+	seq_printf(m, "AUDIO Performance Switch Status Value:%d\n", g_switch);
+	seq_printf(m, "\n");
+	return 0;
+}
+
+static int switch_open(struct inode *inode, struct file *flip)
+{
+	return single_open(flip, switch_show, NULL);
+}
+
+static ssize_t switch_write(struct file *flip, const char __user *buf, size_t size, loff_t *pos)
+{
+	u16 data;
+	u8 value;
+
+	if (size > 2) {
+		return -EINVAL;
+	}
+	if (copy_from_user(&data, buf, size)) {
+		return -EFAULT;
+	}
+	value = data & 0xff;
+
+	value -= '0';
+	if (!(value == 1 || value == 0)) {
+		printk("%s, %d, data=%d is not correct, pls use 1 or 0.\n", __func__, __LINE__, value);
+		return -EINVAL;
+	}
+
+	g_switch = value ? 1 : 0;
+
+	return size;
+}
+
+static struct proc_ops proc_info_fops = {
+	.proc_open = info_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+};
+
+static struct proc_ops proc_switch_fops = {
+	.proc_open = switch_open,
+	.proc_read = seq_read,
+	.proc_release = single_release,
+	.proc_write = switch_write,
+};
+
+int audio_create_procfs(void)
+{
+	proc_esaudio = proc_mkdir("es_audio", NULL);
+	if (proc_esaudio == NULL) {
+		pr_err("create es_audio dir err.\n");
+		return -ENOMEM;
+	}
+
+	if (!proc_create("ao", 0644, proc_esaudio, &proc_info_fops)) {
+		pr_err("error create proc ao file.\n");
+		goto err_ao;
+	}
+
+	if (!proc_create("ai", 0644, proc_esaudio, &proc_info_fops)) {
+		pr_err("error create proc ai file.\n");
+		goto err_ai;
+	}
+
+	if (!proc_create("aenc", 0644, proc_esaudio, &proc_info_fops)) {
+		pr_err("error create proc aenc file.\n");
+		goto err_aenc;
+	}
+
+	if (!proc_create("adec", 0644, proc_esaudio, &proc_info_fops)) {
+		pr_err("error create proc adec file.\n");
+		goto err_adec;
+	}
+
+	if (!proc_create("switch", 0644, proc_esaudio, &proc_switch_fops)) {
+		pr_err("error create proc switch file.\n");
+		goto err_switch;
+	}
+
+	return 0;
+
+err_switch:
+	remove_proc_entry("adec", proc_esaudio);
+err_adec:
+	remove_proc_entry("aenc", proc_esaudio);
+err_aenc:
+	remove_proc_entry("ai", proc_esaudio);
+err_ai:
+	remove_proc_entry("ao", proc_esaudio);
+err_ao:
+	remove_proc_entry("es_audio", NULL);
+	return -1;
+}
+
+void audio_remove_procfs(void)
+{
+	remove_proc_entry("switch", proc_esaudio);
+
+	remove_proc_entry("adec", proc_esaudio);
+
+	remove_proc_entry("aenc", proc_esaudio);
+
+	remove_proc_entry("ai", proc_esaudio);
+
+	remove_proc_entry("ao", proc_esaudio);
+
+	remove_proc_entry("es_audio", NULL);
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+// audio dev implementation
+static int audio_dev_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int i;
+	const char *fileName = file->f_path.dentry->d_name.name;
+	enum DEVICES_ID deviceID = INVALID_DEVICE;
+	unsigned long size = vma->vm_end - vma->vm_start;
+
+	if (size > (MAX_PERF_SIZE * sizeof(int32_t))) {
+		pr_err("audio_dev_mmap: size:%ld > %ld.\n", size, MAX_PERF_SIZE * sizeof(int32_t));
+		return -EINVAL;
+	}
+
+	for (i = 0; i < NUM_DEVICES; ++i) {
+		if (strcmp(fileName, device_names[i]) == 0) {
+			deviceID = i;
+			break;
+		}
+	}
+
+	if (deviceID == INVALID_DEVICE) {
+		pr_err("deviceID is INVALID\n");
+		return -EINVAL;
+	}
+
+	// Remap the shared memory into the process's address space
+	if (remap_pfn_range(vma, vma->vm_start, virt_to_phys(g_perf_data[deviceID]) >> PAGE_SHIFT,
+						size, vma->vm_page_prot)) {
+		pr_err("Failed to remap shared memory.\n");
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
+static const struct file_operations dev_fops = {
+	.owner = THIS_MODULE,
+	.mmap = audio_dev_mmap,
+};
+
+static bool g_proc_initialized = false;
+
+int audio_proc_module_init(void)
+{
+	int i, ret;
+	struct device *dev;
+
+	if (g_proc_initialized) {
+		return 0;
+	}
+
+	pr_info("audio_proc_module_init enter.\n");
+
+	audio_proc_class = class_create("audio_proc_class");
+	if (IS_ERR(audio_proc_class)) {
+		pr_err("Failed to create audio_proc_class\n");
+		return PTR_ERR(audio_proc_class);
+	}
+
+	for (i = 0; i < NUM_DEVICES; ++i) {
+		g_perf_data[i] = kmalloc(MAX_PERF_SIZE * sizeof(int32_t), GFP_KERNEL);
+		if (!g_perf_data[i]) {
+			pr_err("Failed to allocate shared memory for '%s'\n", device_names[i]);
+			goto cleanup;
+		}
+
+		memset(g_perf_data[i], 0, MAX_PERF_SIZE * sizeof(int32_t));
+
+		ret = register_chrdev(0, device_names[i], &dev_fops);
+		if (ret < 0) {
+			pr_err("Failed to register character device '%s'\n", device_names[i]);
+			goto cleanup;
+		}
+
+		audio_proc_major[i] = ret;
+
+		dev = device_create(audio_proc_class, NULL, MKDEV(audio_proc_major[i], 0), NULL, device_names[i]);
+		if (IS_ERR(dev)) {
+			pr_err("Failed to create device node '%s'\n", device_names[i]);
+			goto cleanup;
+		}
+
+		audio_proc_device[i] = dev;
+	}
+
+	audio_create_procfs();
+
+	g_proc_initialized = true;
+
+	pr_info("es_audio_proc: initialized\n");
+	return 0;
+
+cleanup:
+	for (i = 0; i < NUM_DEVICES; ++i) {
+		if (g_perf_data[i]) {
+			kfree(g_perf_data[i]);
+			g_perf_data[i] = NULL;
+		}
+
+		if (audio_proc_major[i]) {
+			unregister_chrdev(audio_proc_major[i], device_names[i]);
+		}
+
+		if (audio_proc_device[i]) {
+			device_destroy(audio_proc_class, MKDEV(audio_proc_major[i], 0));
+		}
+	}
+
+	class_destroy(audio_proc_class);
+	return ret;
+}
+
+static bool g_proc_uninitialized = false;
+
+void audio_proc_module_exit(void)
+{
+	int i;
+
+	if (g_proc_uninitialized) {
+		return;
+	}
+
+	audio_remove_procfs();
+	for (i = 0; i < NUM_DEVICES; ++i) {
+		device_destroy(audio_proc_class, MKDEV(audio_proc_major[i], 0));
+		unregister_chrdev(audio_proc_major[i], device_names[i]);
+		kfree(g_perf_data[i]);
+		g_perf_data[i] = NULL;
+	}
+
+	class_destroy(audio_proc_class);
+
+	g_proc_uninitialized = true;
+
+	pr_info("es_audio_proc: uninitialized\n");
+}
diff --git a/sound/soc/eswin/esw-audio-proc.h b/sound/soc/eswin/esw-audio-proc.h
new file mode 100644
index 000000000000..1fd3f377671d
--- /dev/null
+++ b/sound/soc/eswin/esw-audio-proc.h
@@ -0,0 +1,23 @@
+/*
+ *
+ * Copyright (C) 2021 ESWIN, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef _ES_AUDIO_PROC_H_
+#define _ES_AUDIO_PROC_H_
+
+int audio_proc_module_init(void);
+void audio_proc_module_exit(void);
+
+#endif
diff --git a/sound/soc/eswin/esw-i2s.c b/sound/soc/eswin/esw-i2s.c
new file mode 100755
index 000000000000..fb032ebd085e
--- /dev/null
+++ b/sound/soc/eswin/esw-i2s.c
@@ -0,0 +1,922 @@
+/*
+ * ALSA SoC Synopsys I2S Audio Layer
+ *
+ * sound/soc/dwc/designware_i2s.c
+ *
+ * Copyright (C) 2010 ST Microelectronics
+ * Rajeev Kumar <rajeevkumar.linux@gmail.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ */
+
+/*
+ * Copyright (C) 2021 ESWIN, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <sound/pcm.h>
+#include <linux/device.h>
+#include <sound/soc.h>
+#include <linux/pm_runtime.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <sound/pcm_params.h>
+#include <asm/io.h>
+#include <sound/asound.h>
+#include <sound/designware_i2s.h>
+#include <linux/irqreturn.h>
+#include <linux/clk.h>
+#include <sound/soc-dai.h>
+#include <linux/ioport.h>
+#include <linux/err.h>
+#include <linux/pm.h>
+#include <linux/mfd/syscon.h>
+#include <linux/reset.h>
+#include <linux/dma-map-ops.h>
+#include "esw-i2s.h"
+#include "esw-audio-proc.h"
+
+#define VO_MCLK_DIVSOR_MASK    0xff0
+#define VO_MCLK_DIVSOR_OFFSET  4
+
+#define MAX_SAMPLE_RATE_SUPPORT (192000UL)
+#define MAX_SAMPLE_RATE_CLK (MAX_SAMPLE_RATE_SUPPORT * 32 * 2) // 32 bits, 2channels
+
+#define VO_TOP_CSR             0x50280000UL
+#define VO_I2S0_DIV_NUM        0x2000
+#define VO_I2S1_DIV_NUM        0x2004
+#define VO_I2S2_DIV_NUM        0x2008
+#define DIV_NUM_MASK           0x1f
+
+#define ESW_I2S_RATES (SNDRV_PCM_RATE_192000 | \
+			SNDRV_PCM_RATE_96000 | \
+			SNDRV_PCM_RATE_48000 | \
+			SNDRV_PCM_RATE_32000 | \
+			SNDRV_PCM_RATE_16000 | \
+			SNDRV_PCM_RATE_8000)
+#define ESW_I2S_FORMATS (SNDRV_PCM_FMTBIT_S32_LE)
+
+#define I2S0_IO_ADDR 0x51600124
+
+static struct clk *g_mclk;
+
+static u32 dmaen_txch[] = {
+	DMAEN_TXCH_0,
+	DMAEN_TXCH_1,
+	DMAEN_TXCH_2,
+	DMAEN_TXCH_3
+};
+
+static u32 dmaen_rxch[] = {
+	DMAEN_RXCH_0,
+	DMAEN_RXCH_1,
+	DMAEN_RXCH_2,
+	DMAEN_RXCH_3
+};
+
+/* Maximum bit resolution of a channel - not uniformly spaced */
+static const u32 fifo_width[COMP_MAX_WORDSIZE] = {
+	12, 16, 20, 24, 32, 0, 0, 0
+};
+
+/* Width of (DMA) bus */
+static const u32 bus_widths[COMP_MAX_DATA_WIDTH] = {
+	DMA_SLAVE_BUSWIDTH_1_BYTE,
+	DMA_SLAVE_BUSWIDTH_2_BYTES,
+	DMA_SLAVE_BUSWIDTH_4_BYTES,
+	DMA_SLAVE_BUSWIDTH_UNDEFINED
+};
+
+static inline u32 i2s_read_reg(void *io_base, int reg)
+{
+	return readl((char *)io_base + reg);
+}
+
+static inline void i2s_write_reg(void *io_base, int reg, u32 val)
+{
+	writel(val, (char *)io_base + reg);
+}
+
+static inline void i2s_disable_channels(struct i2s_dev *i2s_drvdata, u32 stream)
+{
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		i2s_write_reg(i2s_drvdata->i2s_base, TER(0), 0);
+	} else {
+		i2s_write_reg(i2s_drvdata->i2s_base, RER(0), 0);
+	}
+}
+
+static void i2s_config(struct i2s_dev *i2s_drvdata, int stream)
+{
+	u32 ch_reg;
+	struct i2s_clk_config_data *config = &i2s_drvdata->config;
+	i2s_disable_channels(i2s_drvdata, stream);
+	for (ch_reg = 0; ch_reg < (config->chan_nr / 2); ch_reg++) {
+		if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			i2s_write_reg(i2s_drvdata->i2s_base, TCR(ch_reg),
+				      i2s_drvdata->xfer_resolution);
+			i2s_write_reg(i2s_drvdata->i2s_base, TFCR(ch_reg),
+				      i2s_drvdata->fifo_th - 1);
+			i2s_write_reg(i2s_drvdata->i2s_base, TER(ch_reg), 1);
+		} else {
+			i2s_write_reg(i2s_drvdata->i2s_base, RCR(ch_reg),
+				      i2s_drvdata->xfer_resolution);
+			i2s_write_reg(i2s_drvdata->i2s_base, RFCR(ch_reg),
+				      i2s_drvdata->fifo_th - 1);
+			i2s_write_reg(i2s_drvdata->i2s_base, RER(ch_reg), 1);
+		}
+    }
+}
+
+static inline void i2s_enable_irqs(struct i2s_dev *i2s_drvdata, u32 stream,
+				   int chan_nr)
+{
+	u32 i, irq;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(i2s_drvdata->i2s_base, IMR(i));
+			i2s_write_reg(i2s_drvdata->i2s_base, IMR(i), irq & ~0x30);
+		}
+	} else {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(i2s_drvdata->i2s_base, IMR(i));
+			i2s_write_reg(i2s_drvdata->i2s_base, IMR(i), irq & ~0x03);
+		}
+    }
+}
+
+static inline void i2s_enable_dedicated_dma(struct i2s_dev *i2s_drvdata, u32 stream,
+				   int chan_nr)
+{
+	u32 i, dmacr;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			dmacr = i2s_read_reg(i2s_drvdata->i2s_base, DMACR);
+			i2s_write_reg(i2s_drvdata->i2s_base, DMACR, dmacr | dmaen_txch[i]);
+		}
+	} else {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			dmacr = i2s_read_reg(i2s_drvdata->i2s_base, DMACR);
+			i2s_write_reg(i2s_drvdata->i2s_base, DMACR, dmacr | dmaen_rxch[i]);
+		}
+    }
+}
+
+static inline void i2s_disable_dedicated_dma(struct i2s_dev *i2s_drvdata, u32 stream,
+				   int chan_nr)
+{
+	u32 i, dmacr;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			dmacr = i2s_read_reg(i2s_drvdata->i2s_base, DMACR);
+			i2s_write_reg(i2s_drvdata->i2s_base, DMACR, dmacr & ~dmaen_txch[i]);
+		}
+	} else {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			dmacr = i2s_read_reg(i2s_drvdata->i2s_base, DMACR);
+			i2s_write_reg(i2s_drvdata->i2s_base, DMACR, dmacr & ~dmaen_rxch[i]);
+		}
+    }
+}
+
+static inline void i2s_enable_combined_dma(struct i2s_dev *i2s_drvdata, u32 stream)
+{
+	u32 dmacr;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dmacr = i2s_read_reg(i2s_drvdata->i2s_base, DMACR);
+		i2s_write_reg(i2s_drvdata->i2s_base, DMACR, dmacr | DMAEN_TXBLOCK);
+
+	} else {
+		dmacr = i2s_read_reg(i2s_drvdata->i2s_base, DMACR);
+		i2s_write_reg(i2s_drvdata->i2s_base, DMACR, dmacr | DMAEN_RXBLOCK);
+    }
+}
+
+static inline void i2s_disable_combined_dma(struct i2s_dev *i2s_drvdata, u32 stream)
+{
+	u32 dmacr;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dmacr = i2s_read_reg(i2s_drvdata->i2s_base, DMACR);
+		i2s_write_reg(i2s_drvdata->i2s_base, DMACR, dmacr & ~DMAEN_TXBLOCK);
+
+	} else {
+		dmacr = i2s_read_reg(i2s_drvdata->i2s_base, DMACR);
+		i2s_write_reg(i2s_drvdata->i2s_base, DMACR, dmacr & ~DMAEN_RXBLOCK);
+    }
+}
+
+static void i2s_start(struct i2s_dev *i2s_drvdata,
+		      struct snd_pcm_substream *substream)
+{
+	struct i2s_clk_config_data *config = &i2s_drvdata->config;
+	i2s_write_reg(i2s_drvdata->i2s_base, IER, 1);
+	if (i2s_drvdata->use_pio) {
+		i2s_enable_irqs(i2s_drvdata, substream->stream, config->chan_nr);
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		i2s_write_reg(i2s_drvdata->i2s_base, ITER, 1);
+	} else {
+		i2s_write_reg(i2s_drvdata->i2s_base, IRER, 1);
+	}
+	if (!i2s_drvdata->use_pio) {
+		i2s_enable_dedicated_dma(i2s_drvdata, substream->stream, config->chan_nr);
+	}
+	i2s_write_reg(i2s_drvdata->i2s_base, CER, 1);
+}
+
+static inline void i2s_clear_irqs(struct i2s_dev *i2s_drvdata, u32 stream)
+{
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		i2s_read_reg(i2s_drvdata->i2s_base, TOR(0));
+	} else {
+		i2s_read_reg(i2s_drvdata->i2s_base, ROR(0));
+	}
+}
+
+static inline void i2s_disable_irqs(struct i2s_dev *i2s_drvdata, u32 stream,
+				    int chan_nr)
+{
+	u32 i, irq;
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(i2s_drvdata->i2s_base, IMR(i));
+			i2s_write_reg(i2s_drvdata->i2s_base, IMR(i), irq | 0x30);
+		}
+	} else {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(i2s_drvdata->i2s_base, IMR(i));
+			i2s_write_reg(i2s_drvdata->i2s_base, IMR(i), irq | 0x03);
+		}
+	}
+}
+
+static void i2s_stop(struct i2s_dev *i2s_drvdata,
+		struct snd_pcm_substream *substream)
+{
+	if (i2s_drvdata->use_pio) {
+		i2s_clear_irqs(i2s_drvdata, substream->stream);
+	}
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		i2s_write_reg(i2s_drvdata->i2s_base, ITER, 0);
+	} else {
+		i2s_write_reg(i2s_drvdata->i2s_base, IRER, 0);
+	}
+	if (i2s_drvdata->use_pio) {
+		i2s_disable_irqs(i2s_drvdata, substream->stream, 2);
+	} else {
+		i2s_disable_dedicated_dma(i2s_drvdata, substream->stream, 2);
+	}
+	if (!i2s_drvdata->active) {
+		i2s_write_reg(i2s_drvdata->i2s_base, CER, 0);
+		i2s_write_reg(i2s_drvdata->i2s_base, IER, 0);
+	}
+}
+
+static int i2s_configure_res_by_dt(struct i2s_dev *dev,
+								   struct resource *res)
+{
+	struct snd_soc_component *component;
+	struct dmaengine_pcm *pcm;
+	u32 comp1 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_1);
+	u32 comp2 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_2);
+	u32 fifo_depth;
+	u32 idx;
+	u32 idx2;
+
+	dev_info(dev->dev, "comp1:0x%x, comp2:0x%x\n", comp1, comp2);
+	fifo_depth = 1 << (1 + COMP1_FIFO_DEPTH_GLOBAL(comp1));
+	idx = COMP1_APB_DATA_WIDTH(comp1);
+
+	if (WARN_ON(idx >= ARRAY_SIZE(bus_widths))) {
+		dev_err(dev->dev, "idx:%d inval\n", idx);
+		return -EINVAL;
+	}
+
+	if (COMP1_MODE_EN(comp1)) {
+		dev_dbg(dev->dev, "eswin: i2s master mode supported\n");
+		dev->capability |= DW_I2S_MASTER;
+	} else {
+		dev_dbg(dev->dev, "eswin: i2s slave mode supported\n");
+		dev->capability |= DW_I2S_SLAVE;
+	}
+	dev->fifo_th = fifo_depth / 2;
+
+	component = snd_soc_lookup_component(dev->dev, SND_DMAENGINE_PCM_DRV_NAME);
+	if (!component) {
+		dev_err(dev->dev, "Can not find snd_soc_component\n");
+		return -1;
+	}
+
+	pcm = soc_component_to_pcm(component);
+	if (COMP1_TX_ENABLED(comp1)) {
+		idx2 = COMP1_TX_WORDSIZE_0(comp1);
+		dev->capability |= DWC_I2S_PLAY;
+		/* only  configure Combined DMA addr, Our scenario is not Dedicated DMA case */
+		dev->play_dma_data.addr_width = bus_widths[idx];
+		dev->play_dma_data.fifo_size = fifo_depth *
+			(fifo_width[idx2]) >> 3;
+		if (of_node_name_prefix(pcm->chan[SNDRV_PCM_STREAM_PLAYBACK]->device->dev->of_node,
+								"dma-controller-hsp")) {
+			dev->play_dma_data.addr = dma_map_resource(
+						pcm->chan[SNDRV_PCM_STREAM_PLAYBACK]->device->dev,
+						res->start + TXDMA_CH(0),
+						dev->play_dma_data.fifo_size,
+						DMA_BIDIRECTIONAL,
+						DMA_ATTR_SKIP_CPU_SYNC);
+		} else {
+			dev->play_dma_data.addr = res->start + TXDMA_CH(0);
+		}
+		dev->play_dma_data.maxburst = 16;
+	}
+	if (COMP1_RX_ENABLED(comp1)) {
+		idx2 = COMP2_RX_WORDSIZE_0(comp2);
+		dev->capability |= DWC_I2S_RECORD;
+		/* only  configure Combined DMA addr, Our scenario is not Dedicated DMA case */
+		dev->capture_dma_data.addr_width = bus_widths[idx];
+		dev->capture_dma_data.fifo_size = fifo_depth *
+			(fifo_width[idx2]) >> 3;
+		if (of_node_name_prefix(pcm->chan[SNDRV_PCM_STREAM_CAPTURE]->device->dev->of_node,
+								"dma-controller-hsp")) {
+			dev->capture_dma_data.addr = dma_map_resource(
+						pcm->chan[SNDRV_PCM_STREAM_CAPTURE]->device->dev,
+						res->start + RXDMA_CH(0),
+						dev->capture_dma_data.fifo_size,
+						DMA_BIDIRECTIONAL,
+						DMA_ATTR_SKIP_CPU_SYNC);
+		} else {
+			dev->capture_dma_data.addr = res->start + RXDMA_CH(0);
+		}
+		dev->capture_dma_data.maxburst = 16;
+	}
+	return 0;
+}
+
+static int i2s_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+
+	dai_link->trigger_stop = SND_SOC_TRIGGER_ORDER_LDC;
+	return 0;
+}
+
+
+static int i2s_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct i2s_dev *i2s_drvdata = snd_soc_dai_get_drvdata(dai);
+	struct i2s_clk_config_data *config = &i2s_drvdata->config;
+	uint32_t div_num = 0;
+	uint32_t div_num_reg;
+
+	dev_dbg(i2s_drvdata->dev, "sample rate:%d, chan:%d, width:%d\n",
+			 params_rate(params), params_channels(params), params_width(params));
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		config->data_width = 16;
+		i2s_drvdata->ccr = CLOCK_CYCLES_32 << CCR_WSS_POS |
+					NO_CLOCK_GATING;
+		i2s_drvdata->xfer_resolution = RESOLUTION_16_BIT;
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		config->data_width = 24;
+		i2s_drvdata->ccr = CLOCK_CYCLES_32 << CCR_WSS_POS |
+					NO_CLOCK_GATING;
+		i2s_drvdata->xfer_resolution = RESOLUTION_24_BIT;
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		config->data_width = 32;
+		i2s_drvdata->ccr = CLOCK_CYCLES_32 << CCR_WSS_POS |
+					NO_CLOCK_GATING;
+		i2s_drvdata->xfer_resolution = RESOLUTION_32_BIT;
+		break;
+	default:
+		dev_err(i2s_drvdata->dev, "eswin-i2s: unsupported PCM fmt");
+		return -EINVAL;
+	}
+	config->chan_nr = MAX_CHANNEL_NUM;
+	switch (config->chan_nr) {
+	case TWO_CHANNEL_SUPPORT:
+		break;
+	default:
+		dev_err(i2s_drvdata->dev, "channel not supported\n");
+		return -EINVAL;
+	}
+	i2s_config(i2s_drvdata, substream->stream);
+	i2s_write_reg(i2s_drvdata->i2s_base, CCR, i2s_drvdata->ccr);
+	config->sample_rate = params_rate(params);
+	if (i2s_drvdata->capability & DW_I2S_MASTER) {
+		if (MAX_SAMPLE_RATE_SUPPORT % config->sample_rate != 0) {
+			dev_err(i2s_drvdata->dev, "Not support sample rate: %d\n", config->sample_rate);
+			return -EINVAL;
+		}
+
+		div_num = MAX_SAMPLE_RATE_SUPPORT / config->sample_rate - 1;
+
+		if (i2s_drvdata->active) {
+			if (i2s_drvdata->i2s_div_num != div_num) {
+				dev_err(i2s_drvdata->dev, "Not support the playback and capture clocks are different\n");
+				return -EINVAL;
+			}
+		} else {
+			div_num_reg = i2s_read_reg(i2s_drvdata->i2s_div_base, 0) & ~DIV_NUM_MASK;
+			div_num_reg |= div_num;
+
+			dev_dbg(i2s_drvdata->dev, "div num:0x%x\n", div_num);
+			i2s_drvdata->i2s_div_num = div_num;
+			i2s_write_reg(i2s_drvdata->i2s_div_base, 0, div_num_reg);
+		}
+	}
+
+	return 0;
+}
+
+static int i2s_prepare(struct snd_pcm_substream *substream,
+			  struct snd_soc_dai *dai)
+{
+	struct i2s_dev *i2s_drvdata = snd_soc_dai_get_drvdata(dai);
+	 if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(i2s_drvdata->i2s_base, TXFFR, 1);
+	else
+		i2s_write_reg(i2s_drvdata->i2s_base, RXFFR, 1);
+
+	return 0;
+}
+
+static int i2s_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *dai)
+{
+	struct i2s_dev *i2s_drvdata = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		i2s_drvdata->active++;
+		i2s_start(i2s_drvdata, substream);
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			i2s_drvdata->playback_active = true;
+		} else {
+			i2s_drvdata->capture_active = true;
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		i2s_drvdata->active--;
+		i2s_stop(i2s_drvdata, substream);
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			i2s_drvdata->playback_active = false;
+		} else {
+			i2s_drvdata->capture_active = false;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+	switch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {
+	case SND_SOC_DAIFMT_BC_FC:
+		if (dev->capability & DW_I2S_SLAVE)
+			ret = 0;
+		else
+			ret = -EINVAL;
+		break;
+	case SND_SOC_DAIFMT_BP_FP:
+		if (dev->capability & DW_I2S_MASTER)
+			ret = 0;
+		else
+			ret = -EINVAL;
+		break;
+	case SND_SOC_DAIFMT_BC_FP:
+	case SND_SOC_DAIFMT_BP_FC:
+		ret = -EINVAL;
+		break;
+	default:
+		dev_dbg(dev->dev, "dwc : Invalid clock provider format\n");
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int i2s_pcm_dai_probe(struct snd_soc_dai *dai)
+{
+	struct i2s_dev *i2s_drvdata = snd_soc_dai_get_drvdata(dai);
+
+	snd_soc_dai_init_dma_data(dai, &i2s_drvdata->play_dma_data, &i2s_drvdata->capture_dma_data);
+	return 0;
+}
+
+static const struct snd_soc_dai_ops i2s_dai_ops = {
+	.probe		= i2s_pcm_dai_probe,
+	.startup	= i2s_startup,
+	.hw_params	= i2s_hw_params,
+	.prepare	= i2s_prepare,
+	.trigger	= i2s_trigger,
+	.set_fmt	= i2s_set_fmt,
+};
+
+#ifdef CONFIG_PM
+static int i2s_runtime_suspend(struct device *dev)
+{
+	struct i2s_dev *i2s_drvdata = dev_get_drvdata(dev);
+
+	dev_dbg(i2s_drvdata->dev, "%s\n", __func__);
+
+	clk_disable(g_mclk);
+
+	return 0;
+}
+
+static int i2s_runtime_resume(struct device *dev)
+{
+	struct i2s_dev *i2s_drvdata = dev_get_drvdata(dev);
+
+	dev_dbg(i2s_drvdata->dev, "%s\n", __func__);
+	clk_enable(g_mclk);
+
+	return 0;
+}
+
+static int i2s_suspend(struct snd_soc_component *component)
+{
+	struct i2s_dev *i2s_drvdata = snd_soc_component_get_drvdata(component);
+
+	dev_dbg(i2s_drvdata->dev, "%s\n", __func__);
+	if(!pm_runtime_suspended(i2s_drvdata->dev)) {
+		dev_dbg(i2s_drvdata->dev, "disable clk\n");
+		clk_disable(g_mclk);
+	}
+
+	return 0;
+}
+
+static int i2s_resume(struct snd_soc_component *component)
+{
+	struct i2s_dev *i2s_drvdata = snd_soc_component_get_drvdata(component);
+	struct snd_soc_dai *dai = NULL;
+	int stream;
+
+	dev_dbg(i2s_drvdata->dev, "%s\n", __func__);
+	if(!pm_runtime_suspended(i2s_drvdata->dev)) {
+		dev_dbg(i2s_drvdata->dev, "enable clk\n");
+		clk_enable(g_mclk);
+		for_each_component_dais(component, dai) {
+			for_each_pcm_streams(stream)
+				if (snd_soc_dai_stream_active(dai, stream))
+					i2s_config(i2s_drvdata, stream);
+		}
+	}
+
+	return 0;
+}
+#else
+#define i2s_suspend NULL
+#define i2s_resume NULL
+#endif
+
+static int i2s_reset(struct platform_device *pdev, struct i2s_dev *i2s)
+{
+	struct reset_control *rst;
+	struct reset_control *prst;
+	struct reset_control *voprst;
+	int ret;
+
+	rst = devm_reset_control_get_optional_exclusive(&pdev->dev, "i2srst");
+	if (IS_ERR(rst)) {
+		return PTR_ERR(rst);
+	}
+
+	prst = devm_reset_control_get_optional_exclusive(&pdev->dev, "i2sprst");
+	if (IS_ERR(prst)) {
+		return PTR_ERR(prst);
+	}
+
+	voprst = devm_reset_control_get_optional_exclusive(&pdev->dev, "voprst");
+	if (IS_ERR(prst)) {
+		return PTR_ERR(prst);
+	}
+
+	ret = reset_control_assert(rst);
+	WARN_ON(0 != ret);
+	ret = reset_control_assert(prst);
+	WARN_ON(0 != ret);
+	ret = reset_control_deassert(rst);
+	WARN_ON(0 != ret);
+	ret = reset_control_deassert(prst);
+	WARN_ON(0 != ret);
+	ret = reset_control_deassert(voprst);
+	WARN_ON(0 != ret);
+
+	return 0;
+}
+
+static int i2s_open(struct snd_soc_component *component,
+			      struct snd_pcm_substream *substream)
+{
+	struct i2s_dev *i2s_drvdata = snd_soc_component_get_drvdata(component);
+
+	if ((substream->stream == SNDRV_PCM_STREAM_PLAYBACK && i2s_drvdata->playback_active == true) ||
+		(substream->stream == SNDRV_PCM_STREAM_CAPTURE && i2s_drvdata->capture_active == true)) {
+		dev_err(i2s_drvdata->dev, "i2s is busying\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver i2s_component = {
+	.name         = "i2s0",
+	.open         = i2s_open,
+	.suspend      = i2s_suspend,
+	.resume       = i2s_resume,
+};
+
+static struct snd_soc_dai_driver i2s_dai[4] = {
+	{
+		.name = "i2s0-hdmi",
+		.id = 0,
+		.ops = &i2s_dai_ops,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ESW_I2S_RATES,
+			.formats = ESW_I2S_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ESW_I2S_RATES,
+			.formats = ESW_I2S_FORMATS,
+		},
+	},
+	{
+		.name = "i2s0",
+		.id = 1,
+		.ops = &i2s_dai_ops,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ESW_I2S_RATES,
+			.formats = ESW_I2S_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ESW_I2S_RATES,
+			.formats = ESW_I2S_FORMATS,
+		},
+	},
+	{
+		.name = "i2s1",
+		.id = 0,
+		.ops = &i2s_dai_ops,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ESW_I2S_RATES,
+			.formats = ESW_I2S_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ESW_I2S_RATES,
+			.formats = ESW_I2S_FORMATS,
+		},
+	},
+	{
+		.name = "i2s2",
+		.id = 0,
+		.ops = &i2s_dai_ops,
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ESW_I2S_RATES,
+			.formats = ESW_I2S_FORMATS,
+		},
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = MIN_CHANNEL_NUM,
+			.channels_max = MAX_CHANNEL_NUM,
+			.rates = ESW_I2S_RATES,
+			.formats = ESW_I2S_FORMATS,
+		},
+	},
+};
+
+static int i2s_probe(struct platform_device *pdev)
+{
+	struct i2s_dev *i2s_drvdata;
+	struct resource *res;
+	int ret;
+	const char *clk_id;
+	struct snd_dmaengine_pcm_config *config;
+	void __iomem *i2s0_io_base;
+	int reg_val;
+
+	dev_info(&pdev->dev, "dev name:%s\n", pdev->dev.of_node->name);
+	i2s_drvdata = devm_kzalloc(&pdev->dev, sizeof(*i2s_drvdata), GFP_KERNEL);
+	if (!i2s_drvdata)
+		return -ENOMEM;
+
+	config = devm_kzalloc(&pdev->dev,
+			sizeof(struct snd_dmaengine_pcm_config), GFP_KERNEL);
+	if (!config)
+		return -ENOMEM;
+	config->chan_names[SNDRV_PCM_STREAM_PLAYBACK] = "tx";
+	config->chan_names[SNDRV_PCM_STREAM_CAPTURE] = "rx";
+	config->prepare_slave_config = snd_dmaengine_pcm_prepare_slave_config;
+
+	res = platform_get_resource(pdev,IORESOURCE_MEM, 0);
+	i2s_drvdata->i2s_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(i2s_drvdata->i2s_base)) {
+		dev_err(&pdev->dev, "devm_ioremap_resource failed\n");
+		return PTR_ERR(i2s_drvdata->i2s_base);
+	}
+	i2s_drvdata->dev = &pdev->dev;
+
+	if (of_node_name_prefix(pdev->dev.of_node, "i2s0")) {
+		clk_id = "mclk";
+		g_mclk = devm_clk_get(&pdev->dev, clk_id);
+		if (IS_ERR(g_mclk))
+			return PTR_ERR(g_mclk);
+		ret = clk_prepare_enable(g_mclk);
+		if (ret < 0)
+			return ret;
+		i2s_drvdata->clk = g_mclk;
+		ret = clk_set_rate(g_mclk, MAX_SAMPLE_RATE_CLK);
+		if (ret) {
+			dev_err(i2s_drvdata->dev, "Can't set I2S clock rate: %d\n", ret);
+		}
+
+		ret = i2s_reset(pdev, i2s_drvdata);
+		if (ret != 0) {
+			dev_err(&pdev->dev, "i2s_reset failed\n");
+			goto err_probe;
+		}
+
+		if (!of_property_read_bool(pdev->dev.of_node, "io_reuse_enable")) {
+			i2s0_io_base = devm_ioremap(&pdev->dev, I2S0_IO_ADDR, 12);
+			if (!i2s0_io_base) {
+				dev_err(i2s_drvdata->dev, "failed to remap i2s0 io ctl\n");
+				return -ENOMEM;
+			}
+
+			/* set the i2s0 WCLK io to GPIO func */
+			reg_val = readl((char *)i2s0_io_base);
+			reg_val &= 0xfff8ffff;
+			reg_val |= 0x20000;
+			writel(reg_val, (char *)i2s0_io_base);
+
+			/* set the i2s0 SDI io to GPIO func */
+			reg_val = readl((char *)i2s0_io_base + 4);
+			reg_val &= 0xfff8ffff;
+			reg_val |= 0x20000;
+			writel(reg_val, (char *)i2s0_io_base + 4);
+
+			/* set the i2s0 SDO io to GPIO func */
+			reg_val = readl((char *)i2s0_io_base + 8);
+			reg_val &= 0xfff8ffff;
+			reg_val |= 0x20000;
+			writel(reg_val, (char *)i2s0_io_base + 8);
+		}
+	}
+
+	dev_set_drvdata(&pdev->dev, i2s_drvdata);
+
+	if (of_node_name_prefix(pdev->dev.of_node, "i2s0")) {
+		i2s_drvdata->i2s_div_base = devm_ioremap(i2s_drvdata->dev, VO_TOP_CSR + VO_I2S0_DIV_NUM, 4);
+		if (!i2s_drvdata->i2s_div_base) {
+			dev_err(&pdev->dev, "failed to remap i2s0 div config\n");
+			ret = -ENOMEM;
+			goto err_probe;
+		}
+		ret = devm_snd_soc_register_component(&pdev->dev, &i2s_component,
+					&i2s_dai[0], 2);
+	} else if (of_node_name_prefix(pdev->dev.of_node, "i2s1")) {
+		i2s_drvdata->i2s_div_base = devm_ioremap(i2s_drvdata->dev, VO_TOP_CSR + VO_I2S1_DIV_NUM, 4);
+		if (!i2s_drvdata->i2s_div_base) {
+			dev_err(&pdev->dev, "failed to remap i2s1 div config\n");
+			ret = -ENOMEM;
+			goto err_probe;
+		}
+		ret = devm_snd_soc_register_component(&pdev->dev, &i2s_component,
+					&i2s_dai[2], 1);
+	} else {
+		i2s_drvdata->i2s_div_base = devm_ioremap(i2s_drvdata->dev, VO_TOP_CSR + VO_I2S2_DIV_NUM, 4);
+		if (!i2s_drvdata->i2s_div_base) {
+			dev_err(&pdev->dev, "failed to remap i2s2 div config\n");
+			ret = -ENOMEM;
+			goto err_probe;
+		}
+		ret = devm_snd_soc_register_component(&pdev->dev, &i2s_component,
+					&i2s_dai[3], 1);
+	}
+	if (ret != 0) {
+		dev_err(&pdev->dev, "not able to register dai\n");
+		goto err_probe;
+	}
+
+	i2s_drvdata->use_pio = false;
+	ret = devm_snd_dmaengine_pcm_register(&pdev->dev, config, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "could not register pcm: %d\n", ret);
+		goto err_probe;
+	}
+
+	i2s_drvdata->i2s_reg_comp1 = I2S_COMP_PARAM_1;
+	i2s_drvdata->i2s_reg_comp2 = I2S_COMP_PARAM_2;
+	ret = i2s_configure_res_by_dt(i2s_drvdata, res);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "i2s_configure_res_by_dt failed\n");
+		goto err_probe;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	audio_proc_module_init();
+
+#ifdef CONFIG_PM
+	clk_disable(i2s_drvdata->clk);
+#endif
+	return 0;
+err_probe:
+	clk_disable_unprepare(i2s_drvdata->clk);
+
+	return ret;
+}
+
+static int i2s_remove(struct platform_device *pdev)
+{
+	struct i2s_dev *i2s_drvdata = dev_get_drvdata(&pdev->dev);
+
+	clk_disable_unprepare(i2s_drvdata->clk);
+
+	pm_runtime_disable(&pdev->dev);
+
+	audio_proc_module_exit();
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id i2s_of_match[] = {
+	{ .compatible = "snps,i2s", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, i2s_of_match);
+#endif
+
+static const struct dev_pm_ops i2s_pm_ops = {
+	SET_RUNTIME_PM_OPS(i2s_runtime_suspend, i2s_runtime_resume, NULL)
+};
+
+static struct platform_driver i2s_driver = {
+	.probe		= i2s_probe,
+	.remove		= i2s_remove,
+	.driver		= {
+		.name	= "i2s",
+		.of_match_table = of_match_ptr(i2s_of_match),
+		.pm = &i2s_pm_ops,
+	},
+};
+
+module_platform_driver(i2s_driver);
+
+MODULE_AUTHOR("ESWIN, INC.");
+MODULE_DESCRIPTION("I2S driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/eswin/esw-i2s.h b/sound/soc/eswin/esw-i2s.h
new file mode 100644
index 000000000000..6c1a243223a4
--- /dev/null
+++ b/sound/soc/eswin/esw-i2s.h
@@ -0,0 +1,180 @@
+/*
+ * Copyright (ST) 2012 Rajeev Kumar (rajeevkumar.linux@gmail.com)
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+/*
+ *
+ * Copyright (C) 2021 ESWIN, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __I2S_H
+#define __I2S_H
+
+#include <linux/device.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <linux/clk.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/designware_i2s.h>
+
+
+/* common register for all channel */
+#define IER		0x000
+#define IRER		0x004
+#define ITER		0x008
+#define CER		0x00C
+#define CCR		0x010
+#define RXFFR		0x014
+#define TXFFR		0x018
+
+/* DMA Control Register Offset */
+#define DMACR       	0x200
+/* DMA Control Register fields */
+#define DMAEN_TXBLOCK	BIT(17)
+#define DMAEN_RXBLOCK   BIT(16)
+#define DMAEN_TXCH_3    BIT(11)
+#define DMAEN_TXCH_2    BIT(10)
+#define DMAEN_TXCH_1	BIT(9)
+#define DMAEN_TXCH_0    BIT(8)
+#define DMAEN_RXCH_3	BIT(3)
+#define DMAEN_RXCH_2    BIT(2)
+#define DMAEN_RXCH_1	BIT(1)
+#define DMAEN_RXCH_0    BIT(0)
+
+/* Interrupt status register fields */
+#define ISR_TXFO	BIT(5)
+#define ISR_TXFE	BIT(4)
+#define ISR_RXFO	BIT(1)
+#define ISR_RXDA	BIT(0)
+
+/* I2STxRxRegisters for all channels */
+#define LRBR_LTHR(x)	(0x40 * x + 0x020)
+#define RRBR_RTHR(x)	(0x40 * x + 0x024)
+#define RER(x)		(0x40 * x + 0x028)
+#define TER(x)		(0x40 * x + 0x02C)
+#define RCR(x)		(0x40 * x + 0x030)
+#define TCR(x)		(0x40 * x + 0x034)
+#define ISR(x)		(0x40 * x + 0x038)
+#define IMR(x)		(0x40 * x + 0x03C)
+#define ROR(x)		(0x40 * x + 0x040)
+#define TOR(x)		(0x40 * x + 0x044)
+#define RFCR(x)		(0x40 * x + 0x048)
+#define TFCR(x)		(0x40 * x + 0x04C)
+#define RFF(x)		(0x40 * x + 0x050)
+#define TFF(x)		(0x40 * x + 0x054)
+
+/* I2SCOMPRegisters */
+#define I2S_COMP_PARAM_2	0x01F0
+#define I2S_COMP_PARAM_1	0x01F4
+#define I2S_COMP_VERSION	0x01F8
+#define I2S_COMP_TYPE		0x01FC
+
+/* I2S DMA registers */
+#define RXDMA_CH(x)		(0x4 * x + 0x204)
+#define TXDMA_CH(x)		(0x4 * x + 0x214)
+
+/*
+ * Component parameter register fields - define the I2S block's
+ * configuration.
+ */
+#define	COMP1_TX_WORDSIZE_3(r)	(((r) & GENMASK(27, 25)) >> 25)
+#define	COMP1_TX_WORDSIZE_2(r)	(((r) & GENMASK(24, 22)) >> 22)
+#define	COMP1_TX_WORDSIZE_1(r)	(((r) & GENMASK(21, 19)) >> 19)
+#define	COMP1_TX_WORDSIZE_0(r)	(((r) & GENMASK(18, 16)) >> 16)
+#define	COMP1_TX_CHANNELS(r)	(((r) & GENMASK(10, 9)) >> 9)
+#define	COMP1_RX_CHANNELS(r)	(((r) & GENMASK(8, 7)) >> 7)
+#define	COMP1_RX_ENABLED(r)	(((r) & BIT(6)) >> 6)
+#define	COMP1_TX_ENABLED(r)	(((r) & BIT(5)) >> 5)
+#define	COMP1_MODE_EN(r)	(((r) & BIT(4)) >> 4)
+#define	COMP1_FIFO_DEPTH_GLOBAL(r)	(((r) & GENMASK(3, 2)) >> 2)
+#define	COMP1_APB_DATA_WIDTH(r)	(((r) & GENMASK(1, 0)) >> 0)
+#define	COMP2_RX_WORDSIZE_3(r)	(((r) & GENMASK(12, 10)) >> 10)
+#define	COMP2_RX_WORDSIZE_2(r)	(((r) & GENMASK(9, 7)) >> 7)
+#define	COMP2_RX_WORDSIZE_1(r)	(((r) & GENMASK(5, 3)) >> 3)
+#define	COMP2_RX_WORDSIZE_0(r)	(((r) & GENMASK(2, 0)) >> 0)
+
+/* Number of entries in WORDSIZE and DATA_WIDTH parameter registers */
+#define	COMP_MAX_WORDSIZE	(1 << 3)
+#define	COMP_MAX_DATA_WIDTH	(1 << 2)
+#define MAX_CHANNEL_NUM		2
+#define MIN_CHANNEL_NUM		2
+#define STEREO		0
+#define TDM		1
+
+#define CCR_SCLKG_POS 0
+#define CCR_WSS_POS   3
+
+enum {
+	CLOCK_CYCLES_16,
+	CLOCK_CYCLES_24,
+	CLOCK_CYCLES_32
+};
+
+enum {
+	NO_CLOCK_GATING,
+	GATE_CLOCK_CYCLES_12,
+	GATE_CLOCK_CYCLES_16,
+	GATE_CLOCK_CYCLES_20,
+	GATE_CLOCK_CYCLES_24
+};
+
+enum {
+	IGNORE_WORD_LENGTH,
+	RESOLUTION_12_BIT,
+	RESOLUTION_16_BIT,
+	RESOLUTION_20_BIT,
+	RESOLUTION_24_BIT,
+	RESOLUTION_32_BIT
+};
+
+struct i2s_dev {
+	void __iomem *i2s_base;
+	struct clk *clk;
+	struct device *dev;
+	unsigned int i2s_reg_comp1;
+	unsigned int i2s_reg_comp2;
+	unsigned int capability;
+	u32 fifo_th;
+	bool use_pio;
+	/* data related to DMA transfers b/w i2s and DMAC */
+	struct snd_dmaengine_dai_dma_data play_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+	struct i2s_clk_config_data config;
+	struct snd_pcm_substream __rcu *tx_substream;
+	struct snd_pcm_substream __rcu *rx_substream;
+	unsigned int (*tx_fn)(struct i2s_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+			bool *period_elapsed,int type);
+	unsigned int (*rx_fn)(struct i2s_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int rx_ptr,
+			bool *period_elapsed,int type);
+	unsigned int tx_ptr;
+	unsigned int rx_ptr;
+	u32 xfer_resolution;
+	int active;
+	u32 ccr;
+	void __iomem *i2s_div_base;
+	u32 i2s_div_num;
+	bool playback_active;
+	bool capture_active;
+};
+
+#endif /* __I2S_H */
diff --git a/tools/perf/pmu-events/arch/riscv/mapfile.csv b/tools/perf/pmu-events/arch/riscv/mapfile.csv
index c61b3d6ef616..6328fd3f45ee 100644
--- a/tools/perf/pmu-events/arch/riscv/mapfile.csv
+++ b/tools/perf/pmu-events/arch/riscv/mapfile.csv
@@ -15,3 +15,4 @@
 #
 #MVENDORID-MARCHID-MIMPID,Version,Filename,EventType
 0x489-0x8000000000000007-0x[[:xdigit:]]+,v1,sifive/u74,core
+0x489-0x8000000000000008-0x[[:xdigit:]]+,v1,sifive/p550,core
diff --git a/tools/perf/pmu-events/arch/riscv/sifive/p550/cycle-and-instruction-count.json b/tools/perf/pmu-events/arch/riscv/sifive/p550/cycle-and-instruction-count.json
new file mode 100644
index 000000000000..b530032994d9
--- /dev/null
+++ b/tools/perf/pmu-events/arch/riscv/sifive/p550/cycle-and-instruction-count.json
@@ -0,0 +1,12 @@
+[
+	{
+		"EventName": "CORE_CLOCK_CYCLES",
+		"EventCode": "0x165",
+		"BriefDescription": "Counts core clock cycles"
+	},
+	{
+		"EventName": "INSTRUCTIONS_RETIRED",
+		"EventCode": "0x265",
+		"BriefDescription": "Counts instructions retired"
+	}
+]
diff --git a/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json b/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json
new file mode 100644
index 000000000000..9b4a032186a7
--- /dev/null
+++ b/tools/perf/pmu-events/arch/riscv/sifive/p550/firmware.json
@@ -0,0 +1,68 @@
+[
+  {
+    "ArchStdEvent": "FW_MISALIGNED_LOAD"
+  },
+  {
+    "ArchStdEvent": "FW_MISALIGNED_STORE"
+  },
+  {
+    "ArchStdEvent": "FW_ACCESS_LOAD"
+  },
+  {
+    "ArchStdEvent": "FW_ACCESS_STORE"
+  },
+  {
+    "ArchStdEvent": "FW_ILLEGAL_INSN"
+  },
+  {
+    "ArchStdEvent": "FW_SET_TIMER"
+  },
+  {
+    "ArchStdEvent": "FW_IPI_SENT"
+  },
+  {
+    "ArchStdEvent": "FW_IPI_RECEIVED"
+  },
+  {
+    "ArchStdEvent": "FW_FENCE_I_SENT"
+  },
+  {
+    "ArchStdEvent": "FW_FENCE_I_RECEIVED"
+  },
+  {
+    "ArchStdEvent": "FW_SFENCE_VMA_SENT"
+  },
+  {
+    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
+  },
+  {
+    "ArchStdEvent": "FW_SFENCE_VMA_RECEIVED"
+  },
+  {
+    "ArchStdEvent": "FW_SFENCE_VMA_ASID_RECEIVED"
+  },
+  {
+    "ArchStdEvent": "FW_HFENCE_GVMA_SENT"
+  },
+  {
+    "ArchStdEvent": "FW_HFENCE_GVMA_RECEIVED"
+  },
+  {
+    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_SENT"
+  },
+  {
+    "ArchStdEvent": "FW_HFENCE_GVMA_VMID_RECEIVED"
+  },
+  {
+    "ArchStdEvent": "FW_HFENCE_VVMA_SENT"
+  },
+  {
+    "ArchStdEvent": "FW_HFENCE_VVMA_RECEIVED"
+  },
+  {
+    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_SENT"
+  },
+  {
+    "ArchStdEvent": "FW_HFENCE_VVMA_ASID_RECEIVED"
+  }
+]
diff --git a/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json b/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json
new file mode 100644
index 000000000000..284e4c1566e0
--- /dev/null
+++ b/tools/perf/pmu-events/arch/riscv/sifive/p550/instruction.json
@@ -0,0 +1,92 @@
+[
+  {
+    "EventName": "EXCEPTION_TAKEN",
+    "EventCode": "0x100",
+    "BriefDescription": "Counts exceptions taken"
+  },
+  {
+    "EventName": "INTEGER_LOAD_RETIRED",
+    "EventCode": "0x200",
+    "BriefDescription": "Counts integer load instructions retired"
+  },
+  {
+    "EventName": "INTEGER_STORE_RETIRED",
+    "EventCode": "0x400",
+    "BriefDescription": "Counts integer store instructions retired"
+  },
+  {
+    "EventName": "ATOMIC_MEMORY_RETIRED",
+    "EventCode": "0x800",
+    "BriefDescription": "Counts atomic memory instructions retired"
+  },
+  {
+    "EventName": "SYSTEM_INSTRUCTION_RETIRED",
+    "EventCode": "0x1000",
+    "BriefDescription": "Counts system instructions retired (CSR, WFI, MRET, etc.)"
+  },
+  {
+    "EventName": "INTEGER_ARITHMETIC_RETIRED",
+    "EventCode": "0x2000",
+    "BriefDescription": "Counts integer arithmetic instructions retired"
+  },
+  {
+    "EventName": "CONDITIONAL_BRANCH_RETIRED",
+    "EventCode": "0x4000",
+    "BriefDescription": "Counts conditional branch instructions retired"
+  },
+  {
+    "EventName": "JAL_INSTRUCTION_RETIRED",
+    "EventCode": "0x8000",
+    "BriefDescription": "Counts jump-and-link instructions retired"
+  },
+  {
+    "EventName": "JALR_INSTRUCTION_RETIRED",
+    "EventCode": "0x10000",
+    "BriefDescription": "Counts indirect jump instructions (JALR) retired"
+  },
+  {
+    "EventName": "INTEGER_MULTIPLICATION_RETIRED",
+    "EventCode": "0x20000",
+    "BriefDescription": "Counts integer multiplication instructions retired"
+  },
+  {
+    "EventName": "INTEGER_DIVISION_RETIRED",
+    "EventCode": "0x40000",
+    "BriefDescription": "Counts integer division instructions retired"
+  },
+  {
+    "EventName": "FP_LOAD_RETIRED",
+    "EventCode": "0x80000",
+    "BriefDescription": "Counts floating-point load instructions retired"
+  },
+  {
+    "EventName": "FP_STORE_RETIRED",
+    "EventCode": "0x100000",
+    "BriefDescription": "Counts floating-point store instructions retired"
+  },
+  {
+    "EventName": "FP_ADD_RETIRED",
+    "EventCode": "0x200000",
+    "BriefDescription": "Counts floating-point add instructions retired"
+  },
+  {
+    "EventName": "FP_MUL_RETIRED",
+    "EventCode": "0x400000",
+    "BriefDescription": "Counts floating-point multiply instructions retired"
+  },
+  {
+    "EventName": "FP_MULADD_RETIRED",
+    "EventCode": "0x800000",
+    "BriefDescription": "Counts floating-point fused multiply-add instructions retired"
+  },
+  {
+    "EventName": "FP_DIV_SQRT_RETIRED",
+    "EventCode": "0x1000000",
+    "BriefDescription": "Counts floating point divide or square root instructions retired"
+  },
+  {
+    "EventName": "OTHER_FP_RETIRED",
+    "EventCode": "0x2000000",
+    "BriefDescription": "Counts other floating-point instructions retired"
+  }
+]
diff --git a/tools/perf/pmu-events/arch/riscv/sifive/p550/memory.json b/tools/perf/pmu-events/arch/riscv/sifive/p550/memory.json
new file mode 100644
index 000000000000..9351c9074ed7
--- /dev/null
+++ b/tools/perf/pmu-events/arch/riscv/sifive/p550/memory.json
@@ -0,0 +1,47 @@
+[
+	{
+		"EventName": "ICACHE_MISS",
+		"EventCode": "0x102",
+		"BriefDescription": "Counts instruction cache misses"
+	},
+	{
+		"EventName": "DCACHE_MISS",
+		"EventCode": "0x202",
+		"BriefDescription": "Counts data cache misses"
+	},
+	{
+		"EventName": "DCACHE_RELEASE",
+		"EventCode": "0x402",
+		"BriefDescription": "Counts writeback requests from the data cache"
+	},
+	{
+		"EventName": "ITLB_MISS",
+		"EventCode": "0x802",
+		"BriefDescription": "Counts Instruction TLB misses caused by instruction address translation requests"
+	},
+	{
+		"EventName": "DTLB_MISS",
+		"EventCode": "0x1002",
+		"BriefDescription": "Counts Data TLB misses caused by data address translation requests"
+	},
+	{
+		"EventName": "UTLB_MISS",
+		"EventCode": "0x2002",
+		"BriefDescription": "Counts Unified TLB misses caused by address translation requests"
+	},
+	{
+		"EventName": "UTLB_HIT",
+		"EventCode": "0x4002",
+		"BriefDescription": "Counts Unified TLB hits for address translation requests"
+	},
+	{
+		"EventName": "PTE_CACHE_MISS",
+		"EventCode": "0x8002",
+		"BriefDescription": "Counts Page Table Entry cache misses"
+	},
+	{
+		"EventName": "PTE_CACHE_HIT",
+		"EventCode": "0x10002",
+		"BriefDescription": "Counts Page Table Entry cache hits"
+	}
+]
diff --git a/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json b/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json
new file mode 100644
index 000000000000..d9cdb7d747ee
--- /dev/null
+++ b/tools/perf/pmu-events/arch/riscv/sifive/p550/microarch.json
@@ -0,0 +1,57 @@
+[
+  {
+    "EventName": "ADDRESSGEN_INTERLOCK",
+    "EventCode": "0x101",
+    "BriefDescription": "Counts cycles with an address-generation interlock"
+  },
+  {
+    "EventName": "LONGLATENCY_INTERLOCK",
+    "EventCode": "0x201",
+    "BriefDescription": "Counts cycles with a long-latency interlock"
+  },
+  {
+    "EventName": "CSR_INTERLOCK",
+    "EventCode": "0x401",
+    "BriefDescription": "Counts cycles with a CSR interlock"
+  },
+  {
+    "EventName": "ICACHE_BLOCKED",
+    "EventCode": "0x801",
+    "BriefDescription": "Counts cycles in which the instruction cache was not able to provide an instruction"
+  },
+  {
+    "EventName": "DCACHE_BLOCKED",
+    "EventCode": "0x1001",
+    "BriefDescription": "Counts cycles in which the data cache blocked an instruction"
+  },
+  {
+    "EventName": "BRANCH_DIRECTION_MISPREDICTION",
+    "EventCode": "0x2001",
+    "BriefDescription": "Counts mispredictions of conditional branch direction (taken/not taken)"
+  },
+  {
+    "EventName": "BRANCH_TARGET_MISPREDICTION",
+    "EventCode": "0x4001",
+    "BriefDescription": "Counts mispredictions of the target PC of control-flow instructions"
+  },
+  {
+    "EventName": "PIPELINE_FLUSH",
+    "EventCode": "0x8001",
+    "BriefDescription": "Counts flushes of the core pipeline. Common causes include fence.i and CSR accesses"
+  },
+  {
+    "EventName": "REPLAY",
+    "EventCode": "0x10001",
+    "BriefDescription": "Counts instruction replays"
+  },
+  {
+    "EventName": "INTEGER_MUL_DIV_INTERLOCK",
+    "EventCode": "0x20001",
+    "BriefDescription": "Counts cycles with a multiply or divide interlock"
+  },
+  {
+    "EventName": "FP_INTERLOCK",
+    "EventCode": "0x40001",
+    "BriefDescription": "Counts cycles with a floating-point interlock"
+  }
+]
